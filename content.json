{"meta":{"title":"GageShan's blog","subtitle":null,"description":"谨言慎行，勤思能动","author":"John Doe","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2018-08-14T12:45:56.000Z","updated":"2018-08-14T13:31:09.123Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"以前不知道喜欢什么所以来到这里现在明白了想要什么未来会去哪里 ————SGZ"}],"posts":[{"title":"验证回文字符串（c#实现）","slug":"验证回文字符串","date":"2018-09-07T04:34:18.465Z","updated":"2018-09-07T06:50:11.396Z","comments":true,"path":"2018/09/07/验证回文字符串/","link":"","permalink":"http://yoursite.com/2018/09/07/验证回文字符串/","excerpt":"最近在学习c#语言，为提高c#熟练度，特意到leetcode上写题，现写下代码 回文字符串概念：一个字符串从左往右数和从右往左数是一样的。","text":"最近在学习c#语言，为提高c#熟练度，特意到leetcode上写题，现写下代码 回文字符串概念：一个字符串从左往右数和从右往左数是一样的。 12345678910111213141516171819202122232425262728293031using System;namespace 验证回文字符串__leetcode&#123; class Program &#123; static void Main(string[] args) &#123; string s = &quot;A man, a plan, a canal: Panama&quot;; bool result = IsPalindrome(s); Console.WriteLine(result); Console.ReadLine(); &#125; public static bool IsPalindrome(string s) &#123; string s1 = &quot;&quot;; s = s.ToUpper(); for (int i = 0; i &lt; s.Length; i++) &#123; if ((s[i] &gt;= &apos;A&apos; &amp;&amp; s[i] &lt;= &apos;Z&apos;) || (s[i] &gt;= &apos;0&apos; &amp;&amp; s[i] &lt;= &apos;9&apos;)) s1 += s[i]; &#125; Console.WriteLine(s1); char[] arr = s1.ToCharArray(); Array.Reverse(arr); string str = new string(arr); return str == s1; &#125; &#125;&#125;","categories":[{"name":"c#","slug":"c","permalink":"http://yoursite.com/categories/c/"}],"tags":[{"name":"基础算法","slug":"基础算法","permalink":"http://yoursite.com/tags/基础算法/"}]},{"title":"NYOJ63 小猴子下落（二叉树）","slug":"NYOJ63小猴子下落","date":"2018-08-14T12:06:28.320Z","updated":"2018-08-14T12:28:19.439Z","comments":true,"path":"2018/08/14/NYOJ63小猴子下落/","link":"","permalink":"http://yoursite.com/2018/08/14/NYOJ63小猴子下落/","excerpt":"一、题目描述小猴子下落时间限制：3000 ms | 内存限制：65535 KB难度：3描述 有一颗二叉树，最大深度为D,且所有叶子的深度都相同。所有结点从左到右从上到下的编号为1,2,3，·····，2的D次方减1。在结点1处放一个小猴子，它会往下跑。每个内结点上都有一个开关，初始全部关闭，当每次有小猴子跑到一个开关上时，它的状态都会改变，当到达一个内结点时，如果开关关闭，小猴子往左走，否则往右走，直到走到叶子结点。一些小猴子从结点1处开始往下跑，最后一个小猴儿会跑到哪里呢？","text":"一、题目描述小猴子下落时间限制：3000 ms | 内存限制：65535 KB难度：3描述 有一颗二叉树，最大深度为D,且所有叶子的深度都相同。所有结点从左到右从上到下的编号为1,2,3，·····，2的D次方减1。在结点1处放一个小猴子，它会往下跑。每个内结点上都有一个开关，初始全部关闭，当每次有小猴子跑到一个开关上时，它的状态都会改变，当到达一个内结点时，如果开关关闭，小猴子往左走，否则往右走，直到走到叶子结点。一些小猴子从结点1处开始往下跑，最后一个小猴儿会跑到哪里呢？输入输入二叉树叶子的深度D,和小猴子数目I，假设I不超过整棵树的叶子个数，D&lt;=20.最终以 0 0 结尾 输出 输出第I个小猴子所在的叶子编号。 样例输入1234 23 40 0 样例输出12127 来源[张洁烽]原创上传者张洁烽 二、题解思路如下 1、首先可以明确当节点值为0时，往左走，然后节点值变为1，反之往右走，节点值变为0；2、定义一个大数组用来存放节点状态值，将数组看成满二叉树存储值的状态；3、左节点的序号为上一节点的2倍，右节点的序号为上一节点的2倍加1。 123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;memory.h&gt;#define MAXSIZE 40000+10int flag[MAXSIZE]=&#123;0&#125;; int main()&#123; int N,M; while(scanf(&quot;%d%d&quot;,&amp;N,&amp;M)!=EOF)&#123; memset(flag,0,MAXSIZE); if(N==0&amp;&amp;M==0) break; int temp=1; for(int i=1;i&lt;=M;i++)&#123; int depth=1; temp=1; while(depth&lt;N)&#123; if(flag[temp]==0)&#123; flag[temp]=1; temp=temp*2; &#125;else&#123; flag[temp]=0; temp=temp*2+1; &#125; depth++; &#125; &#125; printf(&quot;%d\\n&quot;,temp); &#125; return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://yoursite.com/tags/ACM/"}]},{"title":"hexo小配置","slug":"hexo小配置","date":"2018-08-10T12:00:32.068Z","updated":"2018-08-10T12:18:09.594Z","comments":true,"path":"2018/08/10/hexo小配置/","link":"","permalink":"http://yoursite.com/2018/08/10/hexo小配置/","excerpt":"","text":"一、hexo部署本地图片把图片在hexo/blog/public/css/images目录下，其中(hexo/blog)是你博客所在文件夹。使用/css/images/at.png的方式进行链接。 二、在首页只显示摘要信息12345这里写文章的简介&lt;!-- more --&gt;这里写文章的正文 未完待续……","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"http://yoursite.com/tags/小技巧/"}]},{"title":"二叉树的创建及其遍历","slug":"二叉树的创建及其遍历","date":"2018-08-09T15:37:26.625Z","updated":"2018-08-15T11:07:47.593Z","comments":true,"path":"2018/08/09/二叉树的创建及其遍历/","link":"","permalink":"http://yoursite.com/2018/08/09/二叉树的创建及其遍历/","excerpt":"二叉树是一种非常重要的数据结构，","text":"二叉树是一种非常重要的数据结构，许多其他的数据结构都是基于二叉树发展推演过来的。用递归定义树的结构非常简洁，同样，递归遍历也非常简洁。在学习过程中，我发现递归算法往往只是一个简单的语句，虽然简洁的语句实现了功能，但在算法具体过程方面没有很好的阐述，我也很纠结为什么可以这么用，一次次调式试图弄明白内在机理，总是达不到预期效果，所以我转而写非递归的算法以此希望能够理解树的节点的构造、遍历。在这里，我写下这些天学习二叉树的历程。 一、树的创建利用递归创建二叉树。123456789101112131415struct Btree *inputTree()//创建二叉树 &#123; int number; struct Btree *tree; scanf(&quot;%d&quot;,&amp;number); if(number==0)&#123; //当输入0时，表示左孩子或右孩子为空 tree=NULL; &#125;else&#123; tree=(struct Btree *)malloc(LEN); tree-&gt;data=number; tree-&gt;lchild=inputTree(); //递归左孩子 tree-&gt;rchild=inputTree(); //递归右孩子 &#125; return tree;&#125; 二、三种遍历递归实现1、先序遍历递归算法规则：先根节点，再左子树，后右子树，简记NLR。具体，可将整棵树分为左子树和右子树，然后再将左子树分为次左子树、次右子树123456789void preTraversal(struct Btree *tree)&#123; if(tree!=NULL)&#123; printf(&quot;%d &quot;,tree-&gt;data); //打印根节点 preTraversal(tree-&gt;lchild); //遍历左孩子树 preTraversal(tree-&gt;rchild); //遍历右孩子树 &#125; return;&#125; 2、中序遍历递归算法规则：先左子树，再根节点，后右子树，简记LNR。具体同先序。123456789void inTraversal(struct Btree *tree)&#123; if(tree!=NULL)&#123; preTraversal(tree-&gt;lchild); //遍历左孩子树 printf(&quot;%d&quot;,tree-&gt;data); //打印根节点 preTraversal(tree-&gt;rchild); //遍历右孩子树 &#125; return;&#125; 3、后序遍历递归算法规则：先左子树，再右子树，后根节点，简记LRN。具体同先序。12345678void postTraversal(struct Btree *tree)&#123; if(tree!=NULL)&#123; postTraversal(tree-&gt;lchild); //遍历左孩子树 postTraversal(tree-&gt;rchild); //遍历右孩子树 printf(&quot;%d &quot;,tree-&gt;data); //打印根节点 &#125;&#125; 三、三种遍历非递归实现1、先序遍历非递归算法算法主要步骤：1、当树不为空时，将根节点压入栈中；2、当栈不为空时，说明需要此时访问当前节点，退栈访问；3、查看该节点的右孩子(这里先查看右孩子是因为这是先序遍历，先遍历根节点其次左孩子最后右孩子，这里用到栈也是因为栈的特点，先进后出，后进先出)，若右孩子存在，则压入栈中；4、查看该节点的左孩子，同3；5、若栈不为空，转2，循环。12345678910111213141516171819202122232425void preTraversal(struct Btree *tree)&#123; struct Btree *stack[MAXSIZE]; struct Btree *temp; int top=-1; if(tree!=NULL)&#123; top++; stack[top]=tree; //将根节点进栈 while(top!=-1)&#123; temp=stack[top]; top--; printf(&quot;%d &quot;,temp-&gt;data); if(temp-&gt;rchild!=NULL)&#123; //右孩子不为空，进栈 top++; stack[top]=temp-&gt;rchild; &#125; if(temp-&gt;lchild!=NULL)&#123; //左孩子不为空，进栈 top++; stack[top]=temp-&gt;lchild; &#125; &#125; &#125; printf(&quot;\\n&quot;); return;&#125; 2、中序遍历非递归算法算法主要步骤：1、首先查看根节点，若根节点不为空，将其进栈；2、查看根节点的左孩子，若左孩子存在，将其进栈，继续访问以左孩子为根节点的次树；3、 若次树无左孩子，访问当前次树的根节点，然后查看该根节点的右孩子；4、循环。12345678910111213141516171819202122void inTraversal(struct Btree *tree)&#123; struct Btree *stack[MAXSIZE],*temp; int top=-1; if(tree!=NULL)&#123; temp=tree; while(top&gt;-1||temp!=NULL)&#123; if(temp!=NULL)&#123; top++; stack[top]=temp; temp=temp-&gt;lchild; &#125;else&#123; //此时说明当前次树已无左孩子，则访问该节点 temp=stack[top]; top--; printf(&quot;%d &quot;,temp-&gt;data); temp=temp-&gt;rchild; //查看该节点的右孩子 &#125; &#125; &#125; printf(&quot;\\n&quot;); return; &#125; 3、后序遍历非递归算法算法主要步骤：1、首先将根节点进栈，若栈不为空，循环；2、查看栈顶元素，若其有左孩子或右孩子并且左右孩子没有被访问，将其左孩子或右孩子入栈，否则，访问该节点；3、 在2步骤中，若访问完一节点，则用pre指针记录下来 。1234567891011121314151617181920212223242526void postTraversal(struct Btree *tree)&#123; struct Btree *stack[MAXSIZE],*temp,*pre=NULL; int top=-1; top++; stack[top]=tree; while(top!=-1)&#123; temp=stack[top]; if((temp-&gt;lchild==NULL&amp;&amp;temp-&gt;rchild==NULL)||\\ (pre!=NULL&amp;&amp;(temp-&gt;lchild==pre||temp-&gt;rchild==pre)))&#123; printf(&quot;%d &quot;,temp-&gt;data);//到此表明该节点无左右孩子 top--; //或者有左右孩子但已被访问输出，访问该节点 pre=temp; //pre指针用来记录上一访问过的节点 &#125;else&#123; if(temp-&gt;rchild!=NULL)&#123; //若右孩子存在，将其入栈 top++; stack[top]=temp-&gt;rchild; &#125; if(temp-&gt;lchild!=NULL)&#123; //若左孩子存在，将其入栈 top++; stack[top]=temp-&gt;lchild; &#125; &#125; &#125; printf(&quot;\\n&quot;); &#125; 四、源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define LEN sizeof(struct Btree)#define MAXSIZE 1000+10struct Btree&#123; int data; struct Btree *lchild,*rchild;&#125;;void preTraversal(struct Btree *tree);void inTraversal(struct Btree *tree);void postTraversal(struct Btree *tree);struct Btree *inputTree();int main()&#123; struct Btree *tree; tree=inputTree(); printf(&quot;先序遍历:\\n&quot;); preTraversal(tree); printf(&quot;中序遍历:\\n&quot;); inTraversal(tree); printf(&quot;后序遍历:\\n&quot;); postTraversal(tree); return 0;&#125;struct Btree *inputTree()//创建二叉树 &#123; int number; struct Btree *tree; scanf(&quot;%d&quot;,&amp;number); if(number==0)&#123; //当输入0时，表示左孩子或右孩子 为空 tree=NULL; &#125;else&#123; tree=(struct Btree *)malloc(LEN); tree-&gt;data=number; tree-&gt;lchild=inputTree(); //递归左孩子 tree-&gt;rchild=inputTree(); //递归右孩子 &#125; return tree;&#125;void preTraversal(struct Btree *tree)//先序递归&#123; if(tree!=NULL)&#123; printf(&quot;%d &quot;,tree-&gt;data); //打印根节点 preTraversal(tree-&gt;lchild); //遍历左孩子树 preTraversal(tree-&gt;rchild); //遍历右孩子树 &#125; return;&#125;void preTraversal(struct Btree *tree)//先序非递归&#123; struct Btree *stack[MAXSIZE]; struct Btree *temp; int top=-1; if(tree!=NULL)&#123; top++; stack[top]=tree; //将根节点进栈 while(top!=-1)&#123; temp=stack[top]; top--; printf(&quot;%d &quot;,temp-&gt;data); if(temp-&gt;rchild!=NULL)&#123; //右孩子不为空，进栈 top++; stack[top]=temp-&gt;rchild; &#125; if(temp-&gt;lchild!=NULL)&#123; //左孩子不为空，进栈 top++; stack[top]=temp-&gt;lchild; &#125; &#125; &#125; printf(&quot;\\n&quot;); return; &#125;void inTraversal(struct Btree *tree)//中序递归&#123; if(tree!=NULL)&#123; preTraversal(tree-&gt;lchild); //遍历左孩子树 printf(&quot;%d&quot;,tree-&gt;data); //打印根节点 preTraversal(tree-&gt;rchild); //遍历右孩子树 &#125; return;&#125;void inTraversal(struct Btree *tree)//中序非递归&#123; struct Btree *stack[MAXSIZE],*temp; int top=-1; if(tree!=NULL)&#123; temp=tree; while(top&gt;-1||temp!=NULL)&#123; if(temp!=NULL)&#123; top++; stack[top]=temp; temp=temp-&gt;lchild; &#125;else&#123; //此时说明当前次树已无左孩子，则访问该节点 temp=stack[top]; top--; printf(&quot;%d &quot;,temp-&gt;data); temp=temp-&gt;rchild; //查看该节点的右孩子 &#125; &#125; &#125; printf(&quot;\\n&quot;); return; &#125; void postTraversal(struct Btree *tree)//后序递归&#123; if(tree!=NULL)&#123; postTraversal(tree-&gt;lchild); //遍历左孩子树 postTraversal(tree-&gt;rchild); //遍历右孩子树 printf(&quot;%d &quot;,tree-&gt;data); //打印根节点 &#125; return;&#125;void postTraversal(struct Btree *tree)&#123; struct Btree *stack[MAXSIZE],*temp,*pre=NULL; int top=-1; top++; stack[top]=tree; while(top!=-1)&#123; temp=stack[top]; if((temp-&gt;lchild==NULL&amp;&amp;temp-&gt;rchild==NULL)||\\ (pre!=NULL&amp;&amp;(temp-&gt;lchild==pre||temp-&gt;rchild==pre)))&#123; printf(&quot;%d &quot;,temp-&gt;data);//到此表明该节点无左右孩子 top--; //或者有左右孩子但已被访问输出，访问该节点 pre=temp;//pre指针用来记录上一访问过的节点 &#125;else&#123; if(temp-&gt;rchild!=NULL)&#123;//若右孩子存在，将其入栈 top++; stack[top]=temp-&gt;rchild; &#125; if(temp-&gt;lchild!=NULL)&#123;//若左孩子存在，将其入栈 top++; stack[top]=temp-&gt;lchild; &#125; &#125; &#125; printf(&quot;\\n&quot;); return;&#125; 五、后记在用递归遍历二叉树时，总想搞明白递归遍历的过程是怎么样的，但每次都以头昏脑涨结尾。说实话，递归说它难，也就那样，说它简单，但……总之，用递归求解时，不要深究细节，逻辑对，递归一定对。最后若有什么想法，欢迎在评论区留言。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"http://yoursite.com/tags/c-c/"}]},{"title":"I am coming","slug":"hello-world","date":"2018-08-02T01:30:58.139Z","updated":"2018-08-10T09:32:48.802Z","comments":true,"path":"2018/08/02/hello-world/","link":"","permalink":"http://yoursite.com/2018/08/02/hello-world/","excerpt":"","text":"ONE 将学习and工作中遇到的问题记录下来，小白成长为大佬，若干年后，相必值得回味。 这是我的第一篇博客。想写博客，但会不会变成为了写博客而写博客呢，不知道。认真地想，以往遇到问题，求助知乎、csdn、博客园，大部分问题都能得到很好的解决，感慨众多大神and大佬的无私分享，遂生出想法，记录问题，待知识丰富后，再来看看这些，希望能够得到些许乐趣吧。 ——GageShan 于2018.08.02 夜","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}],"tags":[]}]}