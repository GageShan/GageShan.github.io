<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[中矿大-G-毕业生的纪念礼物(map+priority_queue)]]></title>
    <url>%2F2019%2F07%2F06%2F%E6%AF%94%E8%B5%9B%2F%E5%8D%8E%E4%B8%BA%E6%9D%AF-%E4%B8%AD%E7%9F%BF%E5%A4%A7%E7%AB%9E%E8%B5%9B-G%2F</url>
    <content type="text"><![CDATA[题目链接：https://ac.nowcoder.com/acm/contest/948/G来源：牛客网 现在有n个纪念品，每个纪念品都有一个种类r[i]，现在要求对每个毕业生分发三个种类不同的纪念品，现在需要你来计算下共可以发给多少个毕业生？输入描述:第一行一个整数n，1≤n≤100000，代表纪念品的个数；第二行包含n个整数，分别是r[1], r[2], r[3]……r[n]，1≤r[i]≤1e9，表示每个纪念品所属的种类。输出描述:输出一个整数，代表最多能够分发给的毕业生人数。示例1输入12141 1 2 2 3 3 4 4 4 4 5 5 5 5 输出14 示例2输入1271 2 3 4 5 6 7 输出12 思路每个毕业生需要发三种不同纪念品，问最多能发的人数。首先需要明确的是，数量少的纪念品一旦发完就没有了，三种不同的数量少的纪念品组合在一起发下去，反而没有一种数量少组合两种数量多的可发给毕业生的人数多。（样例一侧正了这一猜想）想到这，既然数量少的可以与任意数量的组合，到最后数量多的可能会有剩余，那么就让数量多得组合数量多的。 一开始没想到的：对数量多的组合，我一开始是取数量最多的三个，取它们中的最小值，也就是这三种物品组合在一起可发给毕业生的数量。但实际上这是有缺陷的，因为前面已经提到，要让数量最多的组合在一起，而当取三者最小值，各物品数量再减去最小数量时（此时，那个三者最小数量的物品已经耗尽），可能会有其他物品的数量已经大于前三者数量了，正确的做法是，每取三个数，让他们减1，ans加1，接着在继续取最大的三者。这样就可以保证，每次取得的物品数都是已有的物品中数量最多的。 错误代码1234567891011121314151617ll res(ll a,ll b,ll c) &#123; ll tmp=min(min(a,b),c); ans+=tmp; return tmp;&#125;void solve() &#123; while(qu.size()&gt;=3) &#123; int t1=qu.top();qu.pop(); int t2=qu.top();qu.pop(); int t3=qu.top();qu.pop(); int tmp=res(t1,t2,t3); t1-=tmp,t2-=tmp,t3-=tmp; if(t1) qu.push(t1); if(t2) qu.push(t2); if(t3) qu.push(t3); &#125;&#125; 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN=1e5+10;map&lt;ll,ll&gt; mp;priority_queue&lt;int&gt; qu;ll n;ll ans;void read() &#123; scanf("%lld",&amp;n); for(ll i=1;i&lt;=n;i++) &#123; ll a; scanf("%lld",&amp;a); mp[a]++; &#125;&#125;void init() &#123; map&lt;ll,ll&gt;::iterator it; for(it=mp.begin();it!=mp.end();it++) qu.push(it-&gt;second);&#125;ll res(ll a,ll b,ll c) &#123; ll tmp=min(min(a,b),c); ans+=tmp; return tmp; &#125;void solve() &#123; while(qu.size()&gt;=3) &#123; int t1=qu.top();qu.pop(); int t2=qu.top();qu.pop(); int t3=qu.top();qu.pop(); int tmp=1; t1-=tmp,t2-=tmp,t3-=tmp; ans++; if(t1) qu.push(t1); if(t2) qu.push(t2); if(t3) qu.push(t3); &#125;&#125;int main() &#123; read(); init(); solve(); printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown一些常用语法]]></title>
    <url>%2F2019%2F07%2F02%2F%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%8A%80%E5%B7%A7%2Fmarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[上标、下标12&lt;sup&gt;上标&lt;/sup&gt;&lt;sub&gt;下标&lt;/sub&gt;]]></content>
      <tags>
        <tag>小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux课设-用gcc实现Linux简单命令]]></title>
    <url>%2F2019%2F07%2F01%2F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%2FLinux%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[说明利用gcc实现 ls , cp, pwd, cd 常用的linux命令功能用gcc实现一些常用的linux命令功能，具体实现如下如下命令： mkdir 创建目录 rm 删除文件或目录 cp 复制文件 cd 更改路径 exit 退出系统 pwd 打印当前路径 ll 列出当前路径的所有文件或目录 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;math.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;#include &lt;dirent.h&gt;#include &lt;fcntl.h&gt;#define MAXN 1024void mkdirs(char dir[]) &#123; char str[MAXN]; strcpy(str,dir); int len = strlen(str); for(int i = 0;i &lt; len; i++) &#123; if(str[i] == '/') &#123; str[i] = '\0'; if(access(str,0) != 0) mkdir(str,0777); str[i] = '/'; &#125; &#125; if(len &gt; 0 &amp;&amp; access(str,0) != 0) mkdir(str,07770); return;&#125;void rmdirs(char dir[]) &#123; char dirname[MAXN]; strcpy(dirname,dir); int ans = rmdir(dirname); if(ans) printf("rm:can't remove %s: No such file or directory\n",dirname); return;&#125;void exits() &#123; exit(0);&#125;char pwds(int op) &#123; char buf[MAXN]; getcwd(buf,sizeof(buf)); if(op == 1) printf("[%s]$ ",buf); else printf("%s\n",buf);&#125;void cps(char file1[],char file2[]) &#123; int f1 = open(file1,O_RDWR|O_CREAT,0777); int f2 = open(file2,O_RDWR|O_CREAT,0777); char buff[MAXN]; read(f1,buff,MAXN); int len = strlen(buff); write(f2,buff,len); close(f1); close(f2);&#125;void cds(char dirname[]) &#123; char name[MAXN]; strcpy(name,dirname); if(chdir(name) != 0) &#123; printf("cd: %s :No such directory\n",dirname); &#125; return;&#125;void lists(char dirname[]) &#123; char name[MAXN]; strcpy(name,dirname);// if(strcmp(dirname,"test") == 0) // printf("Hello world"); //strcpy(name,"test"); DIR *dirp = NULL; struct dirent *entry; dirp = opendir(name); if(dirp == NULL) &#123; printf("ll: %s: No such directory\n",name); return; &#125; else &#123; int i = 1; while(entry = readdir(dirp)) &#123; printf("filename %d = %s\n",i,entry-&gt;d_name); i++; &#125; closedir(dirp); &#125;&#125;void menu() &#123; bool running = true; while(running) &#123; pwds(1); char fun[MAXN]; scanf("%s",fun); if(strcmp(fun,"exit") == 0) exits(); else if(strcmp(fun,"mkdir") == 0) &#123; char filename[MAXN]; scanf("%s",filename); int len = strlen(filename); if(len &gt; 512) &#123; printf("filename is too long\n"); &#125; else &#123; mkdirs(filename); &#125; &#125; else if(strcmp(fun,"pwd") == 0) pwds(0); else if(strcmp(fun,"rm") == 0) &#123; char dirname[MAXN]; scanf("%s",dirname); int len = strlen(dirname); if(len &gt; 512) printf("dirname is too long\n"); else rmdirs(dirname); &#125; else if(strcmp(fun,"cd") == 0) &#123; char dirname[MAXN]; scanf("%s",dirname); int len = strlen(dirname); if(len &gt; 512) printf("dirname is too long\n"); else cds(dirname); &#125; else if(strcmp(fun,"ll") == 0) &#123; char dirname[MAXN]; scanf("%s",dirname); int len = strlen(dirname); if(len &gt; 512) printf("dirname is too long\n"); else lists(dirname); &#125; else if(strcmp(fun,"cp") == 0) &#123; char file1[MAXN],file2[MAXN]; scanf("%s%s",file1,file2); int len1 = strlen(file1); int len2 = strlen(file2); if(len1 &gt; 512) &#123; printf("%s filename is too long\n",file1); continue; &#125; else if(len2 &gt; 512) &#123; printf("%s filename is too long\n",file2); continue; &#125; else cps(file1,file2); &#125; else printf("Instruction error\n"); &#125;&#125;int main() &#123; menu(); return 0;&#125; 体会写代码就是为了快乐呀。 在刚开始学linux时，基本是对着那个小黑框发呆，把书上的命令一个字符一个字符的敲进去，看着路径转换，列出所有目录或文件名，感觉大不同于之前接触到的windows的图形界面，以前在Windows上看到什么点击就可以了，而在命令行上，基本上用不到鼠标。用cd命令改变路径时，也在想这是怎么实现的，可能跟做C语言课设有点类似，在一个死循环内不断地输入字符，这些字符又被拿去匹配，看是执行什么命令。也有过疑惑，这么多的命令，这么多次的匹配，执行的速度感觉还不算太慢，是用到了什么算法，疑是字典树，哈哈，可能这就是只搞了ACM的通病吧。其实，也在网上找过，在百度上搜索了一些命令的实现源码，也幻想过能有一天自己写的代码能够被加到Linux系统里面，哈哈。这次课程设计刚好就有一个实现Linux一些简单命令的任务，所以不用思考就选了这个了，模仿了Linux系统的输入格式界面，让当前路径在最前面显示，还抄了Linux系统的\$符号，囧rz。首先模仿的命令就是pwd命令，打印当前文件路径，往实现pwd命令的函数里传入一个用于选择的参数，分别为在$前打印路径名和就单纯的pwd命令。在重现这些命令过程中，最疑惑的就是ll命令了，输出当前路径下所有目录和文件，刚开始写的时候，一直把传入的目录名用“”括起来当成字符串处理了，这就造成了“dirname”这样一种情况，而实际上应该是dirname就可以了，在这里浪费了好多时间！最终还是完成了啊，看着在Linux系统上运行的仿Linux命令，莫名的喜感。]]></content>
      <categories>
        <category>课程设计</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[北信科第十一届程序设计竞赛（重现赛）F kotori和n皇后]]></title>
    <url>%2F2019%2F06%2F30%2F%E6%AF%94%E8%B5%9B%2F%E5%8C%97%E4%BF%A1%E7%A7%91%E5%8D%81%E4%B8%80%E5%B1%8A%E7%AB%9E%E8%B5%9B-F%2F</url>
    <content type="text"><![CDATA[题目链接：https://ac.nowcoder.com/acm/contest/940/F来源：牛客网 kotori最近在研究n皇后的问题。 所谓n皇后问题是这样的：一个n*n的地图，上面一共放n个皇后，保证任意两个皇后都不能互相攻击（每个皇后可以攻击同一行、同一列以及同一45度角斜线和135度角斜线上的所有其他皇后）。 kotori思考了很久都无法得出答案，整个人都变成琴梨了。她于是拿了一堆皇后在一个无穷大的棋盘上模拟，按照次序一共放了k个皇后。 但是，皇后的站位太复杂了，kotori甚至不知道是否存在两个皇后会互相攻击。于是她想问问聪明的你，在第i个皇后放置在棋盘上之后，是否存在两个皇后可以互相攻击？ 输入描述:第一行输入一个正整数k，代表总共放置的皇后的个数。（1&lt;=k&lt;=1e5） 接下来的k行，每行两个正整数xi和yi，代表每个皇后的坐标。（1&lt;=xi,yi&lt;=1e9） 之后输入一个正整数t，代表t次询问。（1&lt;=t&lt;=1e5） 接下来的t行，每行一个正整数i，代表询问第i个皇后放置后，是否存在互相攻击的情况。（1&lt;=i&lt;=k） 保证不存在两个皇后放置的位置相同。输出描述:共t行。每行对应当前的询问是否存在两个皇后可以互相攻击，若是则输出“Yes”，否则输出“No”示例1输入12345678951 22 53 16 74 8224 输出12NoYes 说明第四个皇后放置后，第四个和第一个皇后可以互相攻击。 思路这道题我一开始没看清题意，我认成，每当放置一个皇后后，这个皇后是否会跟其他皇后相互攻击，而实际上是，每放置一个皇后，询问这个棋盘是否会有两个皇后相互攻击。所以当放置一个皇后后，如果这个皇后与其他皇后相互工作，那么此后整个棋盘都存在相互攻击的皇后。 判断两个皇后能否相互攻击，只需要记录横、纵、45$^。$对角线、135$^。$对角线即可。也就分别是x、y、x+y、x-y+MAXN。 代码123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXM=1e5+10;map&lt;ll,bool&gt; mp[6];int judge[MAXM]=&#123;0&#125;;ll a[MAXM],b[MAXM];int main()&#123;// freopen("in.txt","r",stdin); int T; scanf("%d",&amp;T); int ans=0x3f3f3f3f; for(int i=1;i&lt;=T;i++) &#123; scanf("%lld%lld",&amp;a[i],&amp;b[i]); if(mp[0][a[i]]||mp[1][b[i]]||mp[2][a[i]+b[i]]||mp[3][a[i]-b[i]]) &#123; ans=min(ans,i); &#125; mp[0][a[i]]=true; mp[1][b[i]]=true; mp[2][a[i]+b[i]]=true; mp[3][a[i]-b[i]]=true;; &#125; int n; scanf("%d",&amp;n); while(n--) &#123; int i; scanf("%d",&amp;i); if(i&gt;=ans) printf("Yes\n"); else printf("No\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北信科第十一届程序设计竞赛（重现赛）H andy和购物]]></title>
    <url>%2F2019%2F06%2F30%2F%E6%AF%94%E8%B5%9B%2F%E5%8C%97%E4%BF%A1%E7%A7%91%E5%8D%81%E4%B8%80%E5%B1%8A%E7%AB%9E%E8%B5%9B-H%2F</url>
    <content type="text"><![CDATA[题目链接：https://ac.nowcoder.com/acm/contest/940/H来源：牛客网 andy要去市场买n件货物，每件货物的价格为ai。商家为了吸引顾客，给每个买N件货物的顾客一个折扣清单，清单上有N个小于1的小数bj表示折扣。对于每个折扣bj，由用户自行决定用它使哪个货物的价格变成bj * ai，并且只能用一次。andy想让你帮他算一下他最少的花费。 输入描述:先输入一个正整数t，代表样例的组数。（1≤t≤10） 对于每个样例： 第一行，输入一个正整数n（1≤n≤1000）。 第二行包含n个整数，第i个整数a[i]代表第i个商品的原价。（1≤a[i]≤1e9） 第三行包含n个小数b[i]，含义如题目描述。（0≤b[i]≤1）输出描述:对于每个样例，输出一个实数s，保留3位小数，表示最小的花费。示例1输入1234151 2 3 4 50.1 0.2 0.3 0.4 0.5 输出13.500 思路简单贪心。拿最高价格对应最大折扣即可。 代码1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;typedef long double lb;const int MAXN=1e3+10;lb arr[MAXN];lb brr[MAXN];int main()&#123; int t; scanf("%d",&amp;t); while(t--) &#123; int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%Lf",&amp;arr[i]); for(int i=1;i&lt;=n;i++) scanf("%Lf",&amp;brr[i]); sort(arr+1,arr+n+1); sort(brr+1,brr+n+1); lb ans=0; for(int i=1,j=n;i&lt;=n;i++,j--) ans+=arr[i]*brr[j]; printf("%.3Lf\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北信科第十一届程序设计竞赛（重现赛）J andy的树被砍了]]></title>
    <url>%2F2019%2F06%2F30%2F%E6%AF%94%E8%B5%9B%2F%E5%8C%97%E4%BF%A1%E7%A7%91%E5%8D%81%E4%B8%80%E5%B1%8A%E7%AB%9E%E8%B5%9B-J%2F</url>
    <content type="text"><![CDATA[题目链接：https://ac.nowcoder.com/acm/contest/940/J来源：牛客网 andy又开始种树了，他觉得老用魔法不太好，这次他决定老老实实地每天种一棵树，第i天种一颗高度为hi的树，按理说老老实实种树就完事了，哪有那么多问题呢？但是他们学校有个叫kotori的人，非常爱砍树，每天都会把所有andy已经种下的树砍掉ci，如果第i天的时候某棵树的高度已经小于等于ci了，那么这棵树就会死亡，以后再也不会被砍了。并且如果到了第n天，有一些树还没被砍，那么kotori就会在第n + 1天把这些树全部砍死。 输入描述:第一行输入一个整数n，表示andy会种n天的树。 第二行含有n个数hi，表示andy在第i天种的树的高度为hi米。 第三行含有n个ci，表示kotori在第i天把所有andy已经种下的树砍掉ci。1 &lt;= n, hi, ci &lt;= 105输出描述:输出一行n个数di，每个数后面有一个空格(包括最后一个数)，最后需要换行。 表示andy第i天种的树会在第di天死亡，如果第n天这棵树还没有死亡，则输出n + 1。 示例1输入123105 7 5 4 1 7 4 3 10 6 6 4 2 4 1 8 5 7 3 5 输出11 4 4 4 5 6 7 8 11 11 说明第1天andy种的树高度为5，这天kotori要把andy已经种下的所有树砍掉6，所以第1棵树在第1天就死掉了。 第2天andy种的树高度为7，第2天被kotori砍掉了4，还剩3，第3天被kotori砍掉了2，还剩1。第4天被砍掉4，所以它在第4天死亡。 第10天andy种下的数高度为6，第10天被kotori砍掉了5，还剩1，也就是说它在第10天还没有死亡，所以它会在第11天被kotori砍死（参见题目描述最后一句）。 思路首先求下砍树高度的前缀和，那么对于前缀数组的每个数就是每天所要砍掉树的长度总和。就可以将问题转化为：对于每棵树来讲，它的总长度就是前一天所要砍掉的长度加上现存的长度，然后就是求出总长度在哪一天能全部砍完了。 代码1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN=1e6+10;ll arr[MAXN];ll brr[MAXN];int main()&#123;// freopen("in.txt","r",stdin); int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;arr[i]); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;brr[i]); for(int i=1;i&lt;=n;i++) brr[i]+=brr[i-1]; for(int i=1;i&lt;=n;i++) &#123; ll tmp=arr[i]+brr[i-1]; ll pos=lower_bound(brr+1,brr+n+1,tmp)-brr; if(pos&gt;=1&amp;&amp;pos&lt;=n) printf("%lld ",pos); else printf("%lld ",n+1); &#125; printf("\n"); return 0;&#125;]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北信科第十一届程序设计竞赛（重现赛）I andy种树]]></title>
    <url>%2F2019%2F06%2F30%2F%E6%AF%94%E8%B5%9B%2F%E5%8C%97%E4%BF%A1%E7%A7%91%E5%8D%81%E4%B8%80%E5%B1%8A%E7%AB%9E%E8%B5%9B-I%2F</url>
    <content type="text"><![CDATA[题目链接：https://ac.nowcoder.com/acm/contest/940/I来源：牛客网 题目描述andy在他的庄园里种了n棵树，排列成一排，标号为1到n。最开始的时候n棵树的高度都是0，也就是种子刚刚被埋下，树还没有长出来。 andy会一种魔法，他每使用一次魔法，就可以让树标号落在连续区间[l, r]里的树的高度增加1。他可以使用q次这种魔法，然后他很好奇，在使用了q次魔法之后，他的所有树的高度分别是多少呢？ 输入描述:第一行输入两个整数n，q。(1&lt;= n, q &lt;= 1e5) 接下来q行，每行输入两个整数l, r(l &lt;= r)，表示andy让标号落在区间[l, r]里的数高度都加1输出描述:输出有一行n个整数，每个整数后面有空格。输出末尾没有换行 第i个数表示第i棵树的高度示例1输入123410 31 32 43 3 输出11 2 3 1 0 0 0 0 0 0 说明12345678910111213141516171819andy种了10棵树第一次使用魔法使得1、2、3棵树的高度增加1,所有树的高度为1 1 1 0 0 0 0 0 0 0第二次使用魔法使得2、3、4棵树的高度增加1，所有树的高度为1 2 2 1 0 0 0 0 0 0第三次使用魔法使得第3棵树的高度增加1所有树的高度为1 2 3 1 0 0 0 0 0 0 思路前缀和。每次使用魔法对区间[l,r]内的数加1，那么可以让[l,n]中的数都加1，同时让[r+1,n]内的数减1，这样就相当于区间[l,r]内的数加1了。 代码1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN=1e6+10;ll arr[MAXN];ll brr[MAXN];int main() &#123;// freopen("in.txt","r",stdin); int n,q; scanf("%d%d",&amp;n,&amp;q); memset(arr,0,sizeof(arr)); memset(brr,0,sizeof(brr)); while(q--) &#123; int l,r; scanf("%d%d",&amp;l,&amp;r); arr[l]++; brr[r+1]--; &#125; for(int i=1;i&lt;=n;i++) arr[i]+=arr[i-1]; for(int i=1;i&lt;=n;i++) brr[i]+=brr[i-1]; for(int i=1;i&lt;=n;i++) printf("%lld ",arr[i]+brr[i]); return 0;&#125;]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北信科第十一届程序设计竞赛（重现赛）E kotori和素因子]]></title>
    <url>%2F2019%2F06%2F30%2F%E6%AF%94%E8%B5%9B%2F%E5%8C%97%E4%BF%A1%E7%A7%91%E5%8D%81%E4%B8%80%E5%B1%8A%E7%AB%9E%E8%B5%9B-E%2F</url>
    <content type="text"><![CDATA[题目链接：https://ac.nowcoder.com/acm/contest/940/E来源：牛客网 kotori拿到了一些正整数。她决定从每个正整数取出一个素因子。但是，kotori有强迫症，她不允许两个不同的正整数取出相同的素因子。 她想知道，最终所有取出的数的和的最小值是多少？ 注：若a%k==0，则称k是a的因子。若一个数有且仅有两个因子，则称其是素数。显然1只有一个因子，不是素数。 输入描述:第一行一个正整数n，代表kotori拿到正整数的个数。 第二行共有n个数ai，表示每个正整数的值。 保证不存在两个相等的正整数。 1&lt;=n&lt;=10 2&lt;=ai&lt;=1000输出描述:一个正整数，代表取出的素因子之和的最小值。若不存在合法的取法，则输出-1。示例1输入12412 15 28 22 输出117 说明分别取3，5，7，2，可保证取出的数之和最小示例2输入1254 5 6 7 8 输出1-1 备注:1231&lt;=n&lt;=102&lt;=ai&lt;=1000 思路简单DFS。把每个数的质因子求出来后，把所有答案搜一遍即可，注意不能从两个不同的数取相同的质因子。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=2e3+10;vector&lt;int&gt; vt[12];int arr[12];int n;int ans;int qu[12];bool isprime(int t) &#123; int p=sqrt(t); for(int i=2;i&lt;=p;i++) if(t%i==0) return false; return true;&#125;void init() &#123; for(int i=1;i&lt;=n;i++) &#123; int tmp=sqrt(arr[i]); for(int j=2;j&lt;=arr[i];j++) &#123; if(arr[i]%j==0&amp;&amp;isprime(j)) vt[i].push_back(j); &#125; &#125; // for(int i=1;i&lt;=n;i++) &#123;// cout&lt;&lt;arr[i]&lt;&lt;": ";// for(int j=0;j&lt;vt[i].size();j++)// cout&lt;&lt;vt[i][j]&lt;&lt;' ';// cout&lt;&lt;endl;// &#125;&#125;bool judge(int cnt,int x) &#123; for(int i=0;i&lt;cnt;i++) if(qu[i]==x) return false; return true;&#125; void DFS(int cnt,int sum,int p) &#123; if(cnt&gt;=n) &#123; ans=min(ans,sum); return; &#125; for(int i=0;i&lt;vt[p].size();i++) &#123; if(judge(cnt,vt[p][i])) &#123; qu[cnt]=vt[p][i]; DFS(cnt+1,sum+vt[p][i],p+1); &#125; &#125;&#125;int main() &#123;// freopen("in.txt","r",stdin); scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;arr[i]); init(); ans=0x3f3f3f3f; DFS(0,0,1); if(ans==0x3f3f3f3f) ans=-1; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北信科第十一届程序设计竞赛（重现赛）D kotori和迷宫]]></title>
    <url>%2F2019%2F06%2F30%2F%E6%AF%94%E8%B5%9B%2F%E5%8C%97%E4%BF%A1%E7%A7%91%E5%8D%81%E4%B8%80%E5%B1%8A%E7%AB%9E%E8%B5%9B-D%2F</url>
    <content type="text"><![CDATA[题目链接：https://ac.nowcoder.com/acm/contest/940/D来源：牛客网 kotori在一个n*m迷宫里，迷宫的最外层被岩浆淹没，无法涉足，迷宫内有k个出口。kotori只能上下左右四个方向移动。她想知道有多少出口是她能到达的，最近的出口离她有多远？ 输入描述:第一行为两个整数n和m，代表迷宫的行和列数 (1≤n,m≤30) 后面紧跟着n行长度为m的字符串来描述迷宫。’k’代表kotori开始的位置，’.’代表道路，’*’代表墙壁，’e’代表出口。保证输入合法。输出描述:若有出口可以抵达，则输出2个整数，第一个代表kotori可选择的出口的数量，第二个代表kotori到最近的出口的步数。（注意，kotori到达出口一定会离开迷宫） 若没有出口可以抵达，则输出-1。示例1输入12345676 8e.*.*e.*.**.*.*e..*k**..***.*.e*.**.*.***......e 输出12 7 说明可供选择坐标为[4,7]和[6,8]，到kotori的距离分别是8和7步。 思路简单BFS，需要注意的是，一遇到出口就离开迷宫了，所以出口不能当作通道走，不能以此走到其他位置。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=40;struct node &#123; int x,y,dep; node(int x,int y,int dep):x(x),y(y),dep(dep)&#123;&#125;&#125;;int n,m;int cnt;int ans;char str[MAXN][MAXN];bool visit[MAXN][MAXN];int dx[]=&#123;1,-1,0,0&#125;;int dy[]=&#123;0,0,1,-1&#125;;bool flag;void BFS(int x,int y) &#123; queue&lt;node&gt; qu; qu.push(node(x,y,0)); memset(visit,false,sizeof(visit)); while(!qu.empty()) &#123; node t=qu.front();qu.pop(); if(str[t.x][t.y]=='e') &#123; cnt++; ans=min(ans,t.dep); return; &#125; visit[t.x][t.y]=true; for(int i=0;i&lt;4;i++) &#123; int tx=t.x+dx[i]; int ty=t.y+dy[i]; if(tx&gt;=0&amp;&amp;tx&lt;n&amp;&amp;ty&gt;=0&amp;&amp;ty&lt;m&amp;&amp;!visit[tx][ty]&amp;&amp;str[tx][ty]!='*') qu.push(node(tx,ty,t.dep+1)); &#125; &#125; flag=true; &#125;int main() &#123;// freopen("in.txt","r",stdin); scanf("%d%d",&amp;n,&amp;m); int sx,sy; for(int i=0;i&lt;n;i++) &#123; scanf("%s",str[i]); for(int j=0;j&lt;m;j++) if(str[i][j]=='k') &#123; sx=i; sy=j; &#125; &#125; flag=false; cnt=0; ans=0x3f3f3f3f; while(!flag) &#123; BFS(sx,sy); &#125; if(ans==0x3f3f3f3f) printf("-1\n"); else printf("%d %d\n",cnt,ans); return 0; &#125;]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北信科第十一届程序设计竞赛（重现赛）B kotori和气球]]></title>
    <url>%2F2019%2F06%2F30%2F%E6%AF%94%E8%B5%9B%2F%E5%8C%97%E4%BF%A1%E7%A7%91%E5%8D%81%E4%B8%80%E5%B1%8A%E7%AB%9E%E8%B5%9B-B%2F</url>
    <content type="text"><![CDATA[题目链接：https://ac.nowcoder.com/acm/contest/940/B来源：牛客网 题目描述kotori最近迷上了摆气球的游戏。她一共有n种气球，每种气球有无数个。她要拿出若干个气球摆成一排。 但是，由于气球被施放了魔法，同样种类的气球如果相邻会发生爆炸，因此若两个相邻的气球种类相同被视为不合法的。 kotori想知道，摆成一排m个一共有多少种不同的方案？ 由于该数可能过大，只需要输出其对109取模的结果。 输入描述:输入仅有一行，为两个整数n和m(1≤n,m≤100)输出描述:输出一个整数，为方案数对109取模的结果。 示例1 输入13 2 输出16 说明 假设3种气球标记为1、2、3，那么共有以下6种方案：[1,2] [1,3] [2,1] [2,3] [3,1] [3,2]。 思路相邻的位置不能放置相同的气球，易得这是各排列组合问题，也就是第一个位置有n种摆法，剩下的就是n-1种了。其实，这道题还是数据规模太小了，稍微大点就要用到快速幂了。 代码123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main()&#123; ll n,m; scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m); ll ans=n; for(int i=2;i&lt;=m;i++) ans=ans*(n-1)%109; printf(&quot;%lld\n&quot;,ans); return 0;&#125;]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[See your voice]]></title>
    <url>%2F2019%2F06%2F30%2F%E9%9A%8F%E7%AC%94%E6%9D%82%E6%83%B3%2FSee%20your%20voice%2F</url>
    <content type="text"><![CDATA[不知不觉已经两年没听到你的声音了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[牛客练习赛48-小w的a=b问题]]></title>
    <url>%2F2019%2F06%2F25%2F%E6%95%B0%E5%AD%A6%2F%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B48-C%2F</url>
    <content type="text"><![CDATA[题目https://ac.nowcoder.com/acm/contest/923/C 思路分析发糖的情况： 第一个人发糖，从位置pos开始向右每个人发一个糖，可以知道左右位置发糖数量是独立的，也就是说跟前面一个发多少个糖是没有关系的。那么每次前后发糖数量的递推公式为d[i-1]=d[i]。 第二个人发糖，从位置pos开始向右发糖，遇到的第一个人发一个糖遇到的第二个人发两个糖……以此类推，遇到的第K个人发K个糖。假如在pos位置一共发了三次糖，那么d[i-1]=d1+d2+d3，d[i]=(d1+1)+(d2+2)+(d3+3)，可推导得d[i-1]=d[i]+3，推广到在pos位置发了n次糖，则d[i-1]+n=d[i]。 第三个人发糖，从位置pos开始向右发糖，遇到的第一个人发一个，第二个发2$^2$，第三个发3$^2$个，第K个人发第K$^2$个糖。假如在pos位置一共发了三次糖，那么d[i-1]=d1$^2$+d2$^2$+d3$^2$，d[i]=(d1+1)$^2$+(d2+1)$^2$+(d3+1)$^2$，推导得d[i-1]+2(d1+d2+d2)+3=d[i],推广到发n次糖，那么d[i-1]+2(d1+d2+d2)+n=d[i]。还有一个问题，通过前后发糖得位置，可以知道(d1$^2$+d2$^2$+d3$^2$)的数量，但是却无法得知(d1+d2+d3)的值，实际上从前面发d1、d2、d3次糖可以知道，(d1+d2+d3)就是在当前位置发糖的次数，用一个数组sum表示就是sum[i]=sum[i-1]+n。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN=1e5+100;const ll MOD=1e9+7;ll d1[MAXN];ll d2[MAXN];ll d3[MAXN];ll sum[MAXN];ll cnt[4][MAXN];int main()&#123; //freopen("in.txt","r",stdin); ll T; scanf("%d",&amp;T); while(T--) &#123; memset(d1,0,sizeof(d1)); memset(d2,0,sizeof(d2)); memset(d3,0,sizeof(d3)); memset(sum,0,sizeof(sum)); memset(cnt,0,sizeof(cnt)); ll n,m; scanf("%lld%lld",&amp;n,&amp;m); while(m--) &#123; ll type,pos; scanf("%lld%lld",&amp;type,&amp;pos); if(type==1) d1[pos]++; else if(type==2) cnt[2][pos]++; else &#123; cnt[3][pos]++; &#125; &#125; for(ll i=1;i&lt;=n;i++) cnt[2][i]=(cnt[2][i]+cnt[2][i-1])%MOD; for(ll i=1;i&lt;=n;i++) cnt[3][i]=(cnt[3][i]+cnt[3][i-1])%MOD; for(ll i=1;i&lt;=n;i++) sum[i]=(sum[i-1]+cnt[3][i])%MOD; for(ll i=1;i&lt;=n;i++) d1[i]=(d1[i]+d1[i-1])%MOD; for(ll i=1;i&lt;=n;i++) d2[i]=(d2[i-1]+cnt[2][i])%MOD; for(ll i=1;i&lt;=n;i++) d3[i]=(d3[i-1]+2*sum[i-1]+cnt[3][i])%MOD; for(ll i=1;i&lt;=n;i++) printf("%lld ",(d1[i]+d2[i]+d3[i])%MOD); printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客练习赛48-小w的a=b问题]]></title>
    <url>%2F2019%2F06%2F22%2F%E6%95%B0%E5%AD%A6%2F%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B48-B%2F</url>
    <content type="text"><![CDATA[题目https://ac.nowcoder.com/acm/contest/923/B 思路说实话，感觉还是做题做得少了，刚开始看到这个题时，脑子里想的全是暴力模拟，想着如何把阶乘转化为另外可以解决的形式。 先前的想法：假如现在有两个数组，一个数组中的元素对另一个数组中的数求相差，如，a[1]=4，b[1]=2，那么a数组比b数组多一个4和一个3，计算数组间的相差，那么可以得到另外两个数组记录了不同的元素，这样就把阶乘转化为了连乘，最后将分别将两个数组的元素乘起来，再比较。但实际上，在计算相差时，可能得到的数据量特别的大。 官方题解：先预处理每一个数的阶乘在不同模系下的结果求出来，保证结果不超longlong。那么对两个数组的元素，就已经求出了阶乘结果，就下来就只需要求连乘，同样，对连乘的结果在与对阶乘取模的相同模下取模，比较两个数组的答案是否相同即可。 但这样并不严谨，因为不管你取的模系有多大（longlong范围内），总会有两个不相同的数对两个不同的数取模后的结果相同。在牛客的讨论群里问过出题人，得到的解答是能取到的这两个数的概率太低了。orz。 所以，老老实实用质因数分解吧。 这道题学到了，在所求结果可能超longlong的情况下，要借助取模公式化简结果，不同一昧的死暴力模拟。 代码对不同模系取模代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll MAXN=1e5+10;const ll MOD[]=&#123;1000000000+7,1000000+7,100000000+7,20000000+7,10000000+7&#125;;ll arr[MAXN];ll brr[MAXN];ll pre[MAXN][5];int main()&#123; //cout&lt;&lt;MOD[4]&lt;&lt;endl; for(ll i=0;i&lt;5;i++) &#123; pre[0][i]=1; for(ll j=1;j&lt;=MAXN;j++) pre[j][i]=pre[j-1][i]*j%MOD[i]; &#125; int T; scanf("%d",&amp;T); while(T--) &#123; ll n,m; scanf("%lld%lld",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;arr[i]); for(int i=1;i&lt;=m;i++) scanf("%lld",&amp;brr[i]); bool flag=false; for(ll i=0;i&lt;5;i++) &#123; ll tmpa=1; for(ll j=1;j&lt;=n;j++) tmpa=pre[arr[j]][i]*tmpa%MOD[i]; ll tmpb=1; for(ll j=1;j&lt;=m;j++) tmpb=pre[brr[j]][i]*tmpb%MOD[i]; if(tmpa!=tmpb) &#123; flag=true; break; &#125; &#125; if(flag) printf("unequal\n"); else printf("equal\n"); &#125; return 0;&#125; 质因数分解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=1e5+100;int prime[MAXN]=&#123;0&#125;;int primes[MAXN];int arr[MAXN];int brr[MAXN];int cnt[2][MAXN];int pt;int number[2][MAXN];void judgePrime()&#123; for(int i=2;i&lt;=MAXN;i++) &#123; if(!prime[i]) primes[pt++]=i; for(int j=0;j&lt;pt&amp;&amp;(i*primes[j])&lt;=MAXN;j++) &#123; prime[i*primes[j]]=1; if(!(i%primes[j])) break; &#125; &#125;&#125;void divi(int op,int x,int time)&#123; int tmpx=x; for(int j=0;primes[j]*primes[j]&lt;=tmpx;j++) &#123; int cnta=0; if(x%primes[j]==0) &#123; while(x&gt;1&amp;&amp;x%primes[j]==0) &#123; cnta++; x/=primes[j]; cnt[op][primes[j]]+=time; &#125; &#125; &#125; if(x&gt;1) cnt[op][x]+=time;&#125;int main()&#123; freopen("in.txt","r",stdin); pt=0; judgePrime(); int T; scanf("%d",&amp;T); while(T--) &#123; int n,m; scanf("%d%d",&amp;n,&amp;m); for(int i=max(m,n);i&gt;=0;i--) &#123; cnt[0][i]=cnt[1][i]=0; number[0][i]=number[1][i]=0; &#125; int maxa=0,maxb=0; for(int i=1;i&lt;=n;i++) &#123; int a; scanf("%d",&amp;a); number[0][a]++; maxa=max(maxa,a); &#125; for(int i=1;i&lt;=m;i++) &#123; int a; scanf("%d",&amp;a); number[1][a]++; maxb=max(maxb,a); &#125; int maxaa=max(maxa,maxb); for(int i=maxaa;i&gt;=1;i--) &#123; number[0][i-1]+=number[0][i]; number[1][i-1]+=number[1][i]; &#125; for(int i=2;i&lt;=maxaa;i++) &#123; if(number[0][i]&gt;=1) &#123; divi(0,i,number[0][i]); &#125; if(number[1][i]&gt;=1) &#123; divi(1,i,number[1][i]); &#125; &#125; bool flag=true; for(int i=0;i&lt;pt;i++) &#123; if(cnt[0][primes[i]]!=cnt[1][primes[i]]) &#123; flag=false;// cout&lt;&lt;primes[i]&lt;&lt;endl;// cout&lt;&lt;cnt[0][primes[i]]&lt;&lt;' '&lt;&lt;cnt[1][primes[i]]&lt;&lt;endl; break; &#125; &#125; if(flag) printf("equal\n"); else printf("unequal\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[P1019 单词接龙]]></title>
    <url>%2F2019%2F06%2F20%2F%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2%2F%E6%B4%9B%E8%B0%B7P1019%20%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99%2F</url>
    <content type="text"><![CDATA[题目https://www.luogu.org/problemnew/show/P1019 思路单词接龙，如果一个单词的末尾与另一个单词的开头有重叠的部分，那么这两个单词就可以连接起来。这道题要求，在给定单词“龙头”的情况下求最长的“龙”的长度。对于这样的题目，很容易地可以想到全局搜一遍，记录最长地即可。但在做这道题过程中，有3个我没有注意到地地方： 题目中说每个单词可以被使用两次，我的处理方法是，将给的所有的单词复制一份，这样对每个单词去搜就行了，但交上去却RE了，可能是递归层次太深，而每次递归都要申请空间造成内存超限。解决方法是用个计数数组统计访问次数。 题中说“相邻的两部分不能存在包含关系，例如atat 和 atideatide 间不能相连。”，在这个地方，我一直在想该怎么判断它们是否有包含关系，但实际上是不要的，因为如果前一个单词能被后一个单词包含，那么直接与后一个单词相连就好了；再者，如果后一个单词被前一个单词包含，那么在连接后可以发现前一个单词的长度是不会发生改变的，这样就可以把这条递归线剪掉。 在两个单词相连时，其重合部分合为一部分。这句话我理解的意思是将最长的重合部分求出来，但实际上是不对的，求的应该是最小的重叠部分。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/*https://www.luogu.org/problemnew/show/P1019AC*/#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=1e5+10;int visit[100];char str[100][MAXN];int n;int ans;void DFS(char t[]) &#123; for(int i=1;i&lt;=n;i++) &#123; if(visit[i]==2) continue; int j=0; int len1=strlen(t); int len2=strlen(str[i]); ans=max(ans,len1); bool flag=false; for(int key=1;key&lt;len2;key++) &#123;// cout&lt;&lt;"KKK"&lt;&lt;endl; char tmpx[1000],tmpy[1000]; int x,y; for(x=0;x&lt;key;x++) tmpx[x]=str[i][x]; tmpx[x]='\0'; int cnt=0; for(y=len1-key;y&lt;len1;y++) tmpy[cnt++]=t[y]; tmpy[cnt]='\0'; if(strcmp(tmpx,tmpy)==0) &#123; char p[MAXN]; strcpy(p,t); int tmpLen=len1; for(int q=key;q&lt;len2;q++) p[len1++]=str[i][q]; p[len1]='\0';// printf("%s %d\n",t,len1);// if(tmpLen==len1) // continue; ans=max(ans,len1); visit[i]++; flag=true; DFS(p); visit[i]--; &#125;// if(flag) break; &#125; &#125;&#125;int main() &#123;// freopen("in.txt","r",stdin); scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%s",str[i]); char head[3]; scanf("%s",head); ans=0; memset(visit,0,sizeof(visit)); DFS(head); printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>简单搜索</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客小白月赛15-H-数据结构题(upper_bound/lower_bound)]]></title>
    <url>%2F2019%2F06%2F18%2FSTL%2F%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B15-H%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目链接：https://ac.nowcoder.com/acm/contest/917/H来源：牛客网 思路题目要求在给定区间内x出现的次数，如果单纯的对于每一次询问都从头到尾遍历区间，结果肯定会超时。可以看到给出x的数据范围是小于100000，不妨这样想，对每个1-100000的数字，用一个容器把它出现的下标位置存起来，这样，对于每次询问x，只需要到存x的下标的容器里去找就可以了。 对上面提到的容器可以用vector存位置下标，因为出现的顺序肯定是从小到大的，存到vector中的顺序也是排好序的，那么只需要查找区间就可以了。 说一下upper_bound和lower_bound,第一次用。12lower_bound(begin,end,x);upper_bound(begin,end,x); 其中，lower_bound是在有序数组中查找第一个大于或等于x的地址，将其减去begin就得到在数组中的位置，不存在就返回end；upper_bound则是查找第一个大于x的地址，同理得到数组中的位置，不存在返回end。 这个题还有一个要注意的地方就是r可能会小于l。 代码123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=1e5+10;const int MOD=20180623;int n,m;vector&lt;int&gt; vt[MAXN];int main() &#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) &#123; int a; scanf("%d",&amp;a); vt[a].push_back(i); &#125; while(m--) &#123; int l,r,l1,r1,x; scanf("%d%d%d%d%d",&amp;l,&amp;r,&amp;l1,&amp;r1,&amp;x); if(l&gt;r) swap(l,r); if(l1&gt;r1) swap(l1,r1); int q=(upper_bound(vt[x].begin(),vt[x].end(),r)-lower_bound(vt[x].begin(),vt[x].end(),l))%MOD; int p=(upper_bound(vt[x].begin(),vt[x].end(),r1)-lower_bound(vt[x].begin(),vt[x].end(),l1))%MOD; printf("%d\n%d\n%d\n",q%MOD,p%MOD,(q*p)%MOD); &#125; return 0;&#125;]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第五届新疆省ACM-ICPC程序设计竞赛（重现赛）D - O(n!）（贪心）]]></title>
    <url>%2F2019%2F06%2F18%2F%E8%B4%AA%E5%BF%83%2F%E7%AC%AC%E4%BA%94%E5%B1%8A%E6%96%B0%E7%96%86%E7%9C%81ACM-ICPC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B-D%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目链接：https://ac.nowcoder.com/acm/contest/911/D来源：牛客网 有 n件商品，第 i件商品价格为 a[i]，购买后，其它所有未购买的商品价格乘上 p[i]，现在要买下所有商品，输出最小耗费。输入描述:第一行一个整数 n(n≤105)，接下来 n 行，第 i 行两个数字a[i],p[i]，其中 a[i] 为整数，p[i] 为浮点数，1≤a[i]≤105,0≤p[i]≤1。输出描述:保留六位小数输出。示例1输入12321 0.510 1 输出16.000000 示例2输入1234327545 0.7977924 0.164441 0.66 输出185769.339000 备注: 样例 1：先买 1 号商品，再买 2 号商品。 样例 2：先买 2 号商品，再买 1 号，最后买 3 号。 思路首先对于两个物品，有物品1(v1,p1),物品2(v2,p2)；先取第一个物品：ans1=v1+p1v2；先取第二个物品：ans2=v2+p2v1； 要使得ans1&lt;ans2,则有v1+p1v2&lt;v2+p2v1,化简后：v1/(1-p1)&lt;v2/(1-p2) 对于两个物品是如此，三个乃至更多的物品就是从局部解推及到最优解。 代码123456789101112131415161718192021222324252627282930313233343536373839404142/*https://ac.nowcoder.com/acm/contest/911/DAC*/#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=1e5+10;struct node &#123; double value; double price; double x;&#125;;node arr[MAXN];bool cmp(node a,node b)&#123; return a.x&lt;b.x;&#125;int main() &#123; int N; scanf("%d",&amp;N); for(int i=1;i&lt;=N;i++) &#123; scanf("%lf%lf",&amp;arr[i].value,&amp;arr[i].price); arr[i].x=arr[i].value/(1-arr[i].price); &#125; sort(arr+1,arr+N+1,cmp); // for(int i=1;i&lt;=N;i++)// cout&lt;&lt;arr[i].value&lt;&lt;' '&lt;&lt;arr[i].price&lt;&lt;' '&lt;&lt;arr[i].x&lt;&lt;endl; long double sum=0; long double p=1.0; for(int i=1;i&lt;=N;i++) &#123; sum+=arr[i].value*p; p*=arr[i].price; &#125; printf("%.6Lf\n",sum); return 0;&#125;]]></content>
      <categories>
        <category>贪心算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小新整数]]></title>
    <url>%2F2019%2F06%2F15%2F%E8%B4%AA%E5%BF%83%2F%E6%9C%80%E5%B0%8F%E6%96%B0%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目给定一个十进制正整数n(0 &lt; n &lt; 1000000000)，每个数位上数字均不为0。n的位数为m。现在从m位中删除k位(0&lt;k &lt; m)，求生成的新整数最小为多少？例如: n = 9128456, k = 2, 则生成的新整数最小为12456Input第一行t, 表示有t组数据；接下来t行，每一行表示一组测试数据，每组测试数据包含两个数字n, k。Outputt行，每行一个数字，表示从n中删除k位后得到的最小整数。Sample Input12329128456 21444 3 Sample Output12124561 题解前一位数与后一位数比较，若大于后一位就删掉它。 代码123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int main()&#123; int Case; cin&gt;&gt;Case; while(Case--)&#123; char str[20]; int k; cin&gt;&gt;str&gt;&gt;k; while(k--)&#123; for(int i=0;i&lt;strlen(str);i++)&#123; if(str[i]&gt;str[i+1])&#123; for(int j=i;j&lt;strlen(str);j++) str[j]=str[j+1]; break; &#125; &#125; &#125; cout&lt;&lt;str&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>贪心算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jungle Roads HDU - 1301]]></title>
    <url>%2F2019%2F06%2F15%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2FJungle%20Roads%20HDU%20-%201301%2F</url>
    <content type="text"><![CDATA[题目The Head Elder of the tropical island of Lagrishan has a problem. A burst of foreign aid money was spent on extra roads between villages some years ago. But the jungle overtakes roads relentlessly, so the large road network is too expensive to maintain. The Council of Elders must choose to stop maintaining some roads. The map above on the left shows all the roads in use now and the cost in aacms per month to maintain them. Of course there needs to be some way to get between all the villages on maintained roads, even if the route is not as short as before. The Chief Elder would like to tell the Council of Elders what would be the smallest amount they could spend in aacms per month to maintain roads that would connect all the villages. The villages are labeled A through I in the maps above. The map on the right shows the roads that could be maintained most cheaply, for 216 aacms per month. Your task is to write a program that will solve such problems.The input consists of one to 100 data sets, followed by a final line containing only 0. Each data set starts with a line containing only a number n, which is the number of villages, 1 &lt; n &lt; 27, and the villages are labeled with the first n letters of the alphabet, capitalized. Each data set is completed with n-1 lines that start with village labels in alphabetical order. There is no line for the last village. Each line for a village starts with the village label followed by a number, k, of roads from this village to villages with labels later in the alphabet. If k is greater than 0, the line continues with data for each of the k roads. The data for each road is the village label for the other end of the road followed by the monthly maintenance cost in aacms for the road. Maintenance costs will be positive integers less than 100. All data fields in the row are separated by single blanks. The road network will always allow travel between all the villages. The network will never have more than 75 roads. No village will have more than 15 roads going to other villages (before or after in the alphabet). In the sample input below, the first data set goes with the map above. The output is one integer per line for each data set: the minimum cost in aacms per month to maintain a road system that connect all the villages. Caution: A brute force solution that examines every possible set of roads will not finish within the one minute time limit.Input123456789101112139A 2 B 12 I 25B 3 C 10 H 40 I 8C 2 D 18 G 55D 1 E 44E 2 F 60 G 38F 0G 1 H 35H 1 I 353A 2 B 10 C 40B 1 C 200 Output1221630 思路求最小生成树的模板题。利用kruskal算法来求解，首先将各节点的关系表示出来，对路径权值排序。当判断两节点是否可以相连（不会出现回路的情况）时，可以用并查集来判断。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=1000;const string str=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;int n;struct node&#123; int x,y,cost;&#125;;struct node arr[MAXN];int parent[MAXN];int judge(char ch)&#123; for(int i=0;i&lt;26;i++) if(ch==str[i]) return i+1;&#125;bool cmp(node a,node b)&#123;return a.cost&lt;b.cost;&#125;int find(int x)&#123; int r=x; while(r!=parent[r])r=parent[r]; int i=x,j; while(i!=r)&#123; //路径压缩 j=parent[i]; parent[i]=r; i=j; &#125; return r;&#125;int main()&#123; while(cin&gt;&gt;n&amp;&amp;n!=0)&#123; int k=0; for(int i=1;i&lt;n;i++)&#123; string s1; cin&gt;&gt;s1; int start=judge(s1[0]); int a; cin&gt;&gt;a; while(a--)&#123; string st; int cost; cin&gt;&gt;st&gt;&gt;cost; arr[k].x=start;arr[k].y=judge(st[0]);arr[k++].cost=cost; &#125; &#125; for(int i=1;i&lt;=n;i++)parent[i]=i; sort(arr,arr+k,cmp); int ans=0; for(int i=0;i&lt;k;i++)&#123; int x=find(arr[i].x); int y=find(arr[i].y); if(x!=y)&#123; ans+=arr[i].cost; parent[x]=y; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>最小生成树-kruskal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新建 Microsoft Office Word 文档]]></title>
    <url>%2F2019%2F06%2F15%2FSTL%2F%E6%96%B0%E5%BB%BAms%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[描述链接：https://ac.nowcoder.com/acm/contest/190/I来源：牛客网 CSL正在学习《计算机办公自动化》文件的建立与删除。 CSL发现，当他新建一个word文档时，会得到一个名为”新建 Microsoft Office Word 文档.doc”的文件，再新建一个，则名为”新建 Microsoft Office Word 文档(2).doc”，再新建，便是”新建 Microsoft Office Word 文档(3).doc”。不断新建，编号不断递增。倘若他已经新建了三个文档，然后删除了”新建 Microsoft Office Word 文档(2).doc”，再新建一个就又会得到一个”新建 Microsoft Office Word 文档(2).doc”。严格来说，Windows在每次新建文档时，都会选取一个与已有文件编号不重复的最小正整数作为新文档的编号。 现在，请你编程模拟以上过程，支持以下两种操作： New：新建一个word文档，反馈新建的文档的编号； Delete id：删除一个编号为id的word文档，反馈删除是否成功。 初始时一个文件都没有，”新建 Microsoft Office Word 文档.doc”的编号算作1。输入描述:第一行一个正整数n表示操作次数，接下来n行，每行表示一个操作。若该行为”New”，则表示新建，为:Delete id”则表示要删除编号为id的文档，其中id为一个正整数。操作按输入顺序依次进行。操作次数不超过100000，删除编号的数值不超过100000。输出描述:对于输入的每一个操作，输出其反馈结果。对于新建操作，输出新建的文档的编号；对于删除操作，反馈删除是否成功：如果删除的文件存在，则删除成功，输出”Successful”，否则输出”Failed”。示例1输入1234567891011121312NewNewNewDelete 2NewDelete 4Delete 3Delete 1NewNewNewDelete 4 输出123456789101112123Successful2FailedSuccessfulSuccessful134Successful 题解学到set，好开心。用set&lt;int&gt;来维护可以创建的队列，然后模拟。 代码1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;const int MAXSIZE=100000+5;int main()&#123; int Case; cin&gt;&gt;Case; set&lt;int&gt; st; set&lt;int&gt;::iterator it; for(int i=1;i&lt;=MAXSIZE;i++) st.insert(i); while(Case--)&#123; string str; cin&gt;&gt;str; if(str==&quot;New&quot;)&#123; it=st.begin(); cout&lt;&lt;*it&lt;&lt;endl; st.erase(it); &#125; else&#123; int a; cin&gt;&gt;a; if(!st.count(a))&#123; cout&lt;&lt;&quot;Successful&quot;&lt;&lt;endl; st.insert(a); &#125; else cout&lt;&lt;&quot;Failed&quot;&lt;&lt;endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>简单题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu14.04mysql卸载与重装]]></title>
    <url>%2F2019%2F06%2F15%2FLinux%2FMySQL%E5%8D%B8%E8%BD%BD%E9%87%8D%E8%A3%85%2F</url>
    <content type="text"><![CDATA[搭环境的遇到的问题，记录下来 安装MySQL1sudo apt-get install mysql-server mysql-client 卸载查看MySQL版本1mysql -V 选择MySQL的版本然后卸载1sudo apt-get autoremove --purge mysql-server-5.5 以下依次进行1sudo apt-get remove mysql-server 1sudo apt-get autoremove mysql-server 1sudo apt-get remove mysql-common 清理残留数据1dpkg -l |grep ^rc|awk &apos;&#123;print $2&#125;&apos; |sudo xargs dpkg -P 参考博文：Ubuntu彻底卸载MySQL、Apache2和Php的方法教程]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu14.04mysql常用命令]]></title>
    <url>%2F2019%2F06%2F15%2FLinux%2Fmysql%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[记录折腾阿里云服务器的求知经历 状态启动1sudo service mysql start 重启1sudo service mysql restart 关闭1sudo service mysql stop 使用创建数据库1mysql&gt; create database 数据库名称; 删除数据库（慎用）1mysql&gt; drop database 数据库名称; 查看数据库1mysql&gt; show databases; 对某数据库加入元素或者删除元素1mysql&gt; use 数据库名称; 数据表创建数据表1mysql&gt; create table 数据表名称 (字段参数); 如1mysql&gt; create table youtable (x int ,y int , z int); 删除数据表1mysql&gt; drop table 数据表名称; 查看某一数据库中有多少表1mysql&gt; show tables; 查看表中的字段1mysql&gt; select * from 数据表;]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSU-2331-向右看（优先队列）]]></title>
    <url>%2F2019%2F05%2F02%2FSTL%2FCSU-2331-%E5%90%91%E5%8F%B3%E7%9C%8B%EF%BC%88%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目http://acm.csu.edu.cn:20080/csuoj/problemset/problem?pid=2331大一新生（又）开始军训了。现在教官让一行萌新向右看齐。 每位萌新看齐的对象是在他右边、比他高（不能同样高）且离他最近的人。 请问每个人分别向谁看齐了？Input单组数据。 第一行是一个整数n，表示人数。 下面一行是n个整数a1, a2, …, an，表示从左至右萌新的身高。 数据范围：1 ≤ n ≤ 105，1 ≤ ai ≤ 109。 Output输出n行整数，第i行表示第i个人看齐的对象编号。如果他没有向任何人看齐，则输出0。 Sample Input1283 5 1 2 5 7 8 6 Sample Output1234567826456700 思路从右到左遍历，用一个优先队列来维护最高身高的萌新。每次遍历到萌新时，就查询该萌新到最高身高的萌新区间内比他高的就可以了。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/*http://acm.csu.edu.cn:20080/csuoj/user/userinfo?user_id=1489438788*/#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=1e5+10;struct node&#123; int value; int index; node(int value,int index):value(value),index(index)&#123;&#125; bool operator &lt; (const node &amp;a) const &#123;return value&lt;a.value;&#125;&#125;;int n;int arr[MAXN];int brr[MAXN];priority_queue&lt;node&gt; qu;int main() &#123; int cnt=0; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;arr[i]); brr[cnt++]=0; qu.push(node(arr[n],n)); for(int i=n-1;i&gt;=1;i--) &#123; node t=qu.top(); int j; for(j=i+1;j&lt;=t.index;j++) &#123; if(arr[j]&gt;arr[i]) &#123; brr[cnt++]=j; break; &#125; &#125; if(j&gt;t.index) brr[cnt++]=0; qu.push(node(arr[i],i)); &#125; for(int i=cnt-1;i&gt;=0;i--) printf("%d\n",brr[i]); return 0;&#125;]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSU-2324-Do You Like XOR?]]></title>
    <url>%2F2019%2F05%2F02%2F%E4%BD%8D%E8%BF%90%E7%AE%97%2FCSU-2324-Do%20You%20Like%20XOR%2F</url>
    <content type="text"><![CDATA[题目http://acm.csu.edu.cn:20080/csuoj/problemset/problem?pid=2324Do you like XOR? Whatever your answer is, Backlight like XOR very much. Thus, he uses a XOR problem as an encryption algorithm, and apply it to his personal computer. The algorithm is as follow:1.choose 3 integers a,b,c and a,b (1 &lt;= a &lt; b&lt;= 10^18),c (1 &lt;= c &lt;= 10^18) .2.calculate password forpi = i ⊕ i ⊕ i⋯i(a total of c times) password=⊕[a,b] (p[i]) here, ⊕ means XOR(exclusive OR). One day, Backlight forget his password. But he remember the 3 integers he use to encrypt. Given the 3 integers, could you help him to calculate out his password? InputInput contains multiple test cases. Each test case consists of a pair of integers a, b and c , separated by a space, one pair of integers per line. OutputFor each test case, print a single integer on its own line denoting the password. Sample Input121 2 36 66 666 Sample Output1230 Hint1⊕1⊕1=1,2⊕2⊕2=2,1⊕2=3 思路首先知道，偶数个相同的数异或最后等于0，奇数个相同的数异或最后结果等于该数本身。所以容易得到：当c等于偶数时，最终的结果为0。那么当c为奇数的情况呢？来看这里，偶数的二进制表示最后一个都为0，当这个偶数加1后，最后一位就变成了1，可推得偶数与与它加1得到得奇数异或结果等于1。该情况就转化为区间[a,b]内有多少个偶奇对了。 代码12345678910111213141516171819202122232425262728293031323334353637/*http://acm.csu.edu.cn:20080/csuoj/problemset/problem?pid=2324*/#include&lt;bits/stdc++.h&gt;using namespace std;unsigned long long a,b,c;int main() &#123; while(cin&gt;&gt;a&gt;&gt;b&gt;&gt;c) &#123; if(c%2==0) cout&lt;&lt;0&lt;&lt;endl; else &#123; unsigned long long d=0; unsigned long long tmpa=0,tmpb=0; if(a%2==1) &#123; tmpa=a; a++; &#125; if(b%2==0) &#123; tmpb=b; b--; &#125; unsigned long long cnt=(b-a+1)/2; if(cnt%2==0) d=0; else d=1; cout&lt;&lt;(tmpa^tmpb^d)&lt;&lt;endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>位运算</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The 16th Zhejiang Provincial Collegiate Programming]]></title>
    <url>%2F2019%2F05%2F01%2F%E6%AF%94%E8%B5%9B%2FThe%2016th%20Zhejiang%20Provincial%20Collegiate%20Programming%2F</url>
    <content type="text"><![CDATA[A - Sequence in the Pocket ZOJ - 4104题目https://cn.vjudge.net/problem/ZOJ-4104DreamGrid has just found an integer sequence in his right pocket. As DreamGrid is bored, he decides to play with the sequence. He can perform the following operation any number of times (including zero time): select an element and move it to the beginning of the sequence. What’s the minimum number of operations needed to make the sequence non-decreasing?InputThere are multiple test cases. The first line of the input contains an integer , indicating the number of test cases. For each test case: The first line contains an integer (), indicating the length of the sequence. The second line contains integers (), indicating the given sequence. It’s guaranteed that the sum of of all test cases will not exceed . OutputFor each test case output one line containing one integer, indicating the answer. Sample Input12345241 3 2 452 3 3 5 5 Sample Output1220 HintFor the first sample test case, move the 3rd element to the front (so the sequence become {2, 1, 3, 4}), then move the 2nd element to the front (so the sequence become {1, 2, 3, 4}). Now the sequence is non-decreasing. For the second sample test case, as the sequence is already sorted, no operation is needed. 思路将一个数移到最左端，使得最终数组元素为单调递增，问最少要移动多少次。初次碰到这种问题，不免都要在脑海中模拟一遍过程，在数据量较少时可能还好说，当数据非常大时，脑子都是晕乎乎的。其实可以发现，最终结果都是要求数组元素单调递增，那么就只需要观察，一个已经是单调递增状态的数组对于原数组来说，哪些数的位置发生了变化，统计这些位置变化的元素即可。当然这里需要注意到，当一个数移动到最左边时，那么这个数原先位置的左边的数的位置都要往右边移一位。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/*https://cn.vjudge.net/problem/ZOJ-4104*/#include&lt;bits/stdc++.h&gt;using namespace std;/*misson 使命，任务，使团 occur 发生 attain 获得 magnificent 壮丽的，华丽的，极好的 adverse 不利的，有害的 stray 走失，迷路，分心，走神，离题 remedy 补救办法，纠正办法，补救，纠正 potential 潜力，潜能，潜在的，可能的 mob 暴民，乌合之众 cane 手杖，藤、竹的茎 */const int misson=1e6+10;int occur[misson];int remedy[misson];int main() &#123; ios::sync_with_stdio(false); int attain; cin&gt;&gt;attain; while(attain--) &#123; int magnificent; cin&gt;&gt;magnificent; for(int stray=1;stray&lt;=magnificent;stray++) &#123; cin&gt;&gt;occur[stray]; remedy[stray]=occur[stray]; &#125; sort(remedy+1,remedy+magnificent+1); int potential=0; for(int stray=magnificent;stray&gt;=1;stray--) &#123; if(occur[stray]!=remedy[potential+stray]) potential++; &#125; cout&lt;&lt;potential&lt;&lt;endl; &#125; return 0;&#125; B - Abbreviation ZOJ - 4105题目In the Test of English as a Foreign Language (TOEFL), the listening part is very important but also very hard for most students since it is usually quite hard for them to remember the whole passage. To help themselves memorize the content, students can write down some necessary details. However, it is not easy to write down the complete word because of its length. That’s why we decide to use the abbreviation to express the whole word. It is very easy to get the abbreviation, all we have to do is to keep the consonant letters and erase the vowel. In the English alphabet, we regard ‘a’, ‘e’, ‘i’, ‘y’, ‘o’, ‘u’ as the vowels and the other letters as the consonants. For example, “subconscious” will be expressed as “sbcnscs”. However, there is one exception: if the vowel appears as the first letter, they should be kept instead of thrown away. For example, “oipotato” should be expressed as “optt”. Since you have learned how to use the abbreviation method, it’s time for some exercises. We now present you words in total, it’s your task to express them in their abbreviation form. InputThere are multiple test cases. The first line of the input contains an integer (about 100), indicating the number of test cases. For each test case: The only line contains a string () consisting of lowercase English letters, indicating the word which needs to be abbreviated. OutputFor each test case output one line containing one string, which is the correct abbreviation of the given word. Sample Input1234565subconsciousoipotatowordsymbolapple Sample Output12345sbcnscsopttwrdsmblappl 思路水题 代码123456789101112131415161718192021222324252627282930313233/*https://cn.vjudge.net/problem/ZOJ-4105*/#include&lt;bits/stdc++.h&gt;using namespace std;set&lt;char&gt; st;int main() &#123; int t;// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); st.insert(&apos;a&apos;); st.insert(&apos;i&apos;); st.insert(&apos;e&apos;); st.insert(&apos;y&apos;); st.insert(&apos;o&apos;); st.insert(&apos;u&apos;); cin&gt;&gt;t; while(t--) &#123; string str; cin&gt;&gt;str; string t=&quot;&quot;; t+=str[0]; for(int i=1;i&lt;str.size();i++) &#123; if(!st.count(str[i])) t+=str[i]; &#125; cout&lt;&lt;t&lt;&lt;endl; &#125; return 0;&#125; C - Lucky 7 in the Pocket ZOJ - 4106题目BaoBao loves number 7 but hates number 4, so he refers to an integer as a “lucky integer” if is divisible by 7 but not divisible by 4. For example, 7, 14 and 21 are lucky integers, but 1, 4 and 28 are not. Today BaoBao has just found an integer in his left pocket. As BaoBao dislikes large integers, he decides to find a lucky integer such that and is as small as possible. Please help BaoBao calculate the value of . InputThere are multiple test cases. The first line of the input is an integer (about 100), indicating the number of test cases. For each test case: The first and only line contains an integer (), indicating the integer in BaoBao’s left pocket. OutputFor each test case output one line containing one integer, indicating the value of . Sample Input123454172028 Sample Output1234772135 思路水题 代码12345678910111213141516171819202122/*https://cn.vjudge.net/problem/ZOJ-4106*/#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=1e9;int main() &#123; int t; cin&gt;&gt;t; while(t--) &#123; int n; cin&gt;&gt;n; for(int i=n;i&lt;=MAXN;i++) if(i%7==0&amp;&amp;i%4!=0) &#123; cout&lt;&lt;i&lt;&lt;endl; break; &#125; &#125; return 0;&#125; D - Singing Everywhere ZOJ - 4107题目Baobao loves singing very much and he really enjoys a game called Singing Everywhere, which allows players to sing and scores the players according to their performance. Consider the song performed by Baobao as an integer sequence , where indicates the -th note in the song. We say a note is a “voice crack” if , and . The more voice cracks BaoBao sings, the lower score he gets. To get a higher score, BaoBao decides to delete at most one note in the song. What’s the minimum number of times BaoBao sings a voice crack after this operation? InputThere are multiple test cases. The first line of the input contains an integer (about 100), indicating the number of test cases. For each test case: The first line contains one integer (), indicating the length of the song. The second line contains integers (), indicating the song performed by BaoBao. It’s guaranteed that at most 5 test cases have . OutputFor each test case output one line containing one integer, indicating the answer. Sample Input1234567361 1 4 5 1 471 9 1 9 8 1 0102 1 4 7 4 8 3 6 4 7 Sample Output123102 HintFor the first sample test case, BaoBao does not need to delete a note. Because if he deletes no note, he will sing 1 voice crack (the 4th note), and no matter which note he deletes, he will also always sing 1 voice crack. For the second sample test case, BaoBao can delete the 3rd note, and no voice cracks will be performed. Yay! For the third sample test case, BaoBao can delete the 4th note, so that only 2 voice cracks will be performed (4 8 3 and 3 6 4). 思路首先可以确定是，每一个位置的状态都会影响它左右两个相邻位置的状态（假设左右两边有元素）。那么只需要枚举每一个位置当它消失时，对左右相邻的元素的影响，求出最大的影响即可。 ##1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/*https://cn.vjudge.net/problem/ZOJ-4107*/#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=1e5+10;int arr[MAXN];int visit[MAXN];int main() &#123; ios::sync_with_stdio(false);// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); int t; cin&gt;&gt;t; while(t--) &#123; int n; cin&gt;&gt;n; memset(visit,0,sizeof(visit)); for(int i=1;i&lt;=n;i++) cin&gt;&gt;arr[i]; int ans=0; for(int i=2;i&lt;n;i++) if(arr[i]&gt;arr[i-1]&amp;&amp;arr[i]&gt;arr[i+1]) &#123; ans++; visit[i]=1; &#125; int sum=0; for(int i=1;i&lt;=n;i++) &#123; int cnt=0; if(i-1&gt;=1&amp;&amp;i+1&lt;=n) &#123; if(i+2&lt;=n&amp;&amp;arr[i+1]&gt;arr[i+2]&amp;&amp;arr[i+1]&gt;arr[i-1]) &#123; cnt++; &#125; if(i-2&gt;=1&amp;&amp;arr[i-1]&gt;arr[i+1]&amp;&amp;arr[i-1]&gt;arr[i-2]) &#123; cnt++; &#125; if(arr[i-1]+arr[i]+arr[i+1]&gt;cnt) &#123; sum=max(sum,visit[i-1]+visit[i]+visit[i+1]-cnt); &#125; &#125; &#125;// cout&lt;&lt;ans&lt;&lt;&apos; &apos;&lt;&lt;sum&lt;&lt;endl; ans=ans-sum; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; E - Fibonacci in the Pocket ZOJ - 4108题目https://cn.vjudge.net/problem/ZOJ-4108 思路求斐波那契数列第a项到第b项的和是奇数还是偶数。通过对斐波那契数列的观察可以发现数列奇偶性有这样的规律奇奇偶奇奇偶奇奇偶奇奇偶奇奇偶奇奇偶奇奇偶奇奇偶奇奇偶奇奇偶，可以看到以3为基准，奇奇偶相加一定为偶数，那么问题就转化为区间[a,b]内有多少个不成对的奇数。将a，b的数位加起来mod3，可以得到在第a项是奇数还是偶数，同理，可以得到第b项。也转化为在第a项的右边有多少不成对的奇数，在第b项左边有多少不成对的奇数，将他们加起来判断是奇还是偶。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/*https://cn.vjudge.net/problem/ZOJ-4108*/#include&lt;bits/stdc++.h&gt;using namespace std;string str1,str2;int solve(string str) &#123; int ans=0; for(int i=0;i&lt;str.size();i++) &#123; ans+=str[i]-48; ans%=3; &#125; return ans;&#125;int main() &#123; ios::sync_with_stdio(false); int t;// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;str1&gt;&gt;str2; int len1=solve(str1); int len2=solve(str2);// cout&lt;&lt;len1&lt;&lt;&apos; &apos;&lt;&lt;len2&lt;&lt;endl; int odd=0,even=0; if(len1==1) odd=2; else if(len1==2) odd=1; else if(len1==0) odd=0; if(len2==1) even=1; else if(len2==2) even=2; else if(len2==0) even=0; if((odd+even)%2==0) cout&lt;&lt;0&lt;&lt;endl; else cout&lt;&lt;1&lt;&lt;endl; &#125; return 0;&#125; F - Welcome Party ZOJ - 4109 (并查集+优先队列)题目https://cn.vjudge.net/problem/ZOJ-4109 思路本场我能解决的问题中最有价值的题目。求进入party的最少不开心人数同时使得进入次序字典序最小。虽然题目中说朋友的朋友不能算作朋友，如果相信这句话就不太好解了。虽然不能算作朋友，但却可以通过一个共同的朋友进入party从而不会不开心。所以通过并查集来分析哪些人会被其他人影响，例如，如果有两个集合没有任何关系，那么这两个集合的人任意谁先进去都可以，只不过考虑下字典序就行了。要让字典序最小，用一个优先队列来维护出队顺序即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include&lt;bits/stdc++.h&gt;using namespace std;//WAconst int MAXN=1e6+10;struct node &#123; int to; int next; &#125;edge[MAXN*4];priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; qu;int parent[MAXN];int visit[MAXN];int n,m;int head[MAXN];int tol;void init() &#123; tol=0; memset(head,-1,sizeof(head)); &#125;inline void add(int v,int u) &#123; tol++; edge[tol].to=u; edge[tol].next=head[v]; head[v]=tol++;&#125;inline int find(int x) &#123; if(x==parent[x]) return x; return parent[x]=find(parent[x]);&#125; inline void join(int x,int y) &#123; x=find(x); y=find(y); if(x!=y) if(x&lt;y) parent[y]=x; else parent[x]=y;&#125;inline void BFS() &#123; int ans=0;// memset(visit,0,sizeof(visit)); for(int i=1;i&lt;=n;i++) if(parent[i]==i) &#123; qu.push(i); visit[i]=1; ans++; &#125; printf(&quot;%d\n&quot;,ans); int cnt=0; while(!qu.empty()) &#123; int t=qu.top();qu.pop(); cnt++; if(cnt!=n) printf(&quot;%d &quot;,t); else &#123; printf(&quot;%d\n&quot;,t); break; &#125; for(int i=head[t];i!=-1;i=edge[i].next) &#123; int v=edge[i].to; if(!visit[v]) &#123; qu.push(v); visit[v]=1; &#125; &#125; &#125;&#125;int main() &#123; ios::sync_with_stdio(false);// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m);// init(); tol=0; while(!qu.empty()) qu.pop(); for(int i=1;i&lt;=n;i++) &#123; visit[i]=0; parent[i]=i; head[i]=-1; &#125; for(int i=1;i&lt;=m;i++) &#123; int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); add(a,b); add(b,a); join(a,b); &#125; BFS(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KATHTHI SPOJ - KATHTHI （BFS+deque）]]></title>
    <url>%2F2019%2F04%2F25%2F%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2%2FKATHTHI%20SPOJ%20-%20KATHTHI%20%EF%BC%88BFS%2Bdeque%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目Kathiresan is initially locked at cell (0,0) in a highly guarded rectangular prison of order RxC. He must reach the gate at (R-1,C-1) in order to escape from the prison. Kathiresan can move from any cell, to any of it’s 4 adjacent cells (North, East, West and South). If Kathiresan is currently at (x1,y1), then he can move to (x2,y2) if and only if abs(x2-x1)+abs(y2-y1) == 1 and 0&lt;=x2&lt;R and 0&lt;=y2&lt;C Kathiresan somehow manages to get the map of the prison.If map[x1][y1] == map[x2][y2] then Kathiresan can move from (x1,y1) to (x2,y2) without killing any guards.If map[x1][y1] != map[x2][y2], then Kathiresan can move from (x1,y1) to (x2,y2) by killing a guard.Given the map of the prison, find the minimum number of guards Kathiresan must kill in order to escape from the prison.Input: The first line consists of an integer t, the number of test cases. For each test case, the first line consists of two integers R and C representing the order of the rectangular prison followed by R strings representing the map of the rectangular prison. Output: For each test case find the minimum number of guards Kathiresan must kill in order to escape from the prison. Input Constraints: 1 &lt;= t &lt;= 10 2 &lt;= R &lt;= 1000 2 &lt;= C &lt;= 1000 ‘a’ &lt;= map[i][j] &lt;= ‘z’ Sample Input:123456789101112131415161718192042 2aaaa2 3abcdef6 6akacccaaacfcamdfccaokhddzyxwdpzyxwdd5 5abbbcabaccaaaccaefcicdgdd Sample Output: 12340322 思路题意为求最少杀人数，如果周围的字母与当前所在位置字母相同，则可以直接走过去，如果不相同就需要杀掉一个守卫。那么可以用一个双端队列来维护当前所走路径。如果周围字母与当前字母相同，就推到队头，否则推到队尾。不过在写这个题目时，发现有个地方跟以前我写搜索时有点不一样。那就是visit数组的应用，以前写搜索在将位置推入队列时直接将这个位置变为已访问状态，而这个题是当这个位置被拿出来使用时才变成已访问状态。这样做的好处在于，可能在某种情况下，其他位置先访问到终点时将终点变为不可访问后，最优位置就无法访问了，从而无法求得最优解，又学到一招qwq。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=1e3+10;struct node&#123; int x,y,dep; node(int x,int y,int dep):x(x),y(y),dep(dep)&#123;&#125;&#125;;deque&lt;node&gt; qu;int visit[MAXN][MAXN];string str[MAXN];int n,m;int ans;int dx[]=&#123;0,0,1,-1&#125;;int dy[]=&#123;1,-1,0,0&#125;;void BFS() &#123; memset(visit,0,sizeof(visit)); while(!qu.empty()) qu.pop_front(); qu.push_front(node(0,0,0));// visit[0][0]=1; int cnt=0; while(!qu.empty()) &#123; node t=qu.front();qu.pop_front(); if(t.x==n-1&amp;&amp;t.y==m-1) ans=min(ans,t.dep); if(visit[t.x][t.y])continue; visit[t.x][t.y]=1; for(int i=0;i&lt;4;i++) &#123; int tx=t.x+dx[i]; int ty=t.y+dy[i]; if(tx&gt;=0&amp;&amp;tx&lt;n&amp;&amp;ty&gt;=0&amp;&amp;ty&lt;m&amp;&amp;!visit[tx][ty]) &#123; if(str[tx][ty]==str[t.x][t.y]) qu.push_front(node(tx,ty,t.dep)); else qu.push_back(node(tx,ty,t.dep+1)); &#125; &#125; &#125;&#125;int main() &#123;// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); ios::sync_with_stdio(false); int T; cin&gt;&gt;T; while(T--) &#123; cin&gt;&gt;n&gt;&gt;m; ans=0x3f3f3f3f; for(int i=0;i&lt;n;i++) cin&gt;&gt;str[i]; BFS(); cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>简单搜索</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[划水日常]]></title>
    <url>%2F2019%2F04%2F23%2F%E5%88%92%E6%B0%B4%E6%97%A5%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[记录学习训练中的日常，时刻提醒自己哪些事情不能做。 时间 a题数量 算法学习 杂 心情 2019.4.22 1 字符串 总结上周末比赛题目 (。・∀・)ノ 2019.4.23 1 双端队列解BFS 湘大谢神来讲座 qwq 2019.4.24 1 马拉车算法求回文字符串 如此巧妙的算法，神往 (￣y▽￣)╭ Ohohoho….. 2019.4.25 3 双端队列解BFS/DFS随机解 果不其然，cf又掉分了 ┗( T﹏T )┛ 2019.4.26 3 温习KMP算法 打了一把div3，果不其然，又掉分了 qwq 2019.4.27 3 字符串（kuangbin专题KMP，Manacher） 还是要继续啊 qwq 2019.4.28 3 周日集训 签了三个水题，手速还是太慢了。看来要刻意练一下敲代码的速度了 qwq 2019.4.29 5 补题加div2 div2掉1分。对于那个本应该在赛场上写出来的却没有写出来赛后一眼就看出来的规律题，我这方面的训练还是不太够啊。 qwq 2019.4.30 3 补题 把以前没写出来的题目都看了一遍，发现有的题是真的水，当初怎么这么菜啊。另外，发下一个问题，对于double类型，用printf输出时一定要用%f，而不是%lf，%lf好像是long double的输出？ qwq 补题加div2 div2掉1分。对于那个本应该在赛场上写出来的却没有写出来赛后一眼就看出来的规律题，我这方面的训练还是不太够啊。 qwq 2019.4.30 3 补题 把以前没写出来的题目都看了一遍，发现有的题是真的水，当初怎么这么菜啊。另外，发下一个问题，对于double类型，用printf输出时一定要用%f，而不是%lf，%lf好像是long double的输出？ qwq 2019.5.1 2 日常划水 日常划水 qwq 2019.5.2 3 位运算技巧 “中途夭折，轻易放弃，多次失败，多次重头再来” qwq 2019.5.3 4 字符串 KMP中的Next数组怎么这么强？ qwq 停止划水，专心训练。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Codeforces-516-Div.2]]></title>
    <url>%2F2019%2F04%2F22%2F%E6%AF%94%E8%B5%9B%2FCodeforces-516-Div.%202%2F</url>
    <content type="text"><![CDATA[A Make a triangle!题目Masha has three sticks of length a, b and c centimeters respectively. In one minute Masha can pick one arbitrary stick and increase its length by one centimeter. She is not allowed to break sticks. What is the minimum number of minutes she needs to spend increasing the stick’s length in order to be able to assemble a triangle of positive area. Sticks should be used as triangle’s sides (one stick for one side) and their endpoints should be located at triangle’s vertices.InputThe only line contains tree integers a, b and c (1≤a,b,c≤100) — the lengths of sticks Masha possesses. OutputPrint a single integer — the minimum number of minutes that Masha needs to spend in order to be able to make the triangle of positive area from her sticks. ExamplesInput13 4 5 Output10 Input12 5 3 Output11 Input1100 10 10 Output181 NoteIn the first example, Masha can make a triangle from the sticks without increasing the length of any of them. In the second example, Masha can’t make a triangle of positive area from the sticks she has at the beginning, but she can spend one minute to increase the length 2 centimeter stick by one and after that form a triangle with sides 3, 3 and 5 centimeters. In the third example, Masha can take 33 minutes to increase one of the 10 centimeters sticks by 33 centimeters, and after that take 48 minutes to increase another 10 centimeters stick by 48 centimeters. This way she can form a triangle with lengths 43, 58 and 100 centimeters in 81 minutes. One can show that it is impossible to get a valid triangle faster. 思路题意为求让两条小边最少增加多少才能够与第三条边构成三角形。而三条边能够构成三角形的条件很简单，那么让最大的边加1减去两条小边长即可。当然，如果直接就满足构成三角形的条件直接输出0就行了。 代码12345678910111213141516#include&lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int arr[3]; cin&gt;&gt;arr[0]&gt;&gt;arr[1]&gt;&gt;arr[2]; sort(arr,arr+3); if((arr[0]+arr[1]&gt;arr[2])&amp;&amp;(arr[1]+arr[2]&gt;arr[0])&amp;&amp;(arr[0]+arr[2]&gt;arr[1]))&#123; cout&lt;&lt;0&lt;&lt;endl; return 0; &#125; int ans=arr[2]+1-(arr[0]+arr[1]); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; B Equations of Mathematical Magic题目Colossal! — exclaimed Hawk-nose. — A programmer! That’s exactly what we are looking for.Arkadi and Boris Strugatsky. Monday starts on SaturdayReading the book “Equations of Mathematical Magic” Roman Oira-Oira and Cristobal Junta found an interesting equation: a−(a⊕x)−x=0 for some given a, where ⊕ stands for a bitwise exclusive or (XOR) of two integers (this operation is denoted as ^ or xor in many modern programming languages). Oira-Oira quickly found some x, which is the solution of the equation, but Cristobal Junta decided that Oira-Oira’s result is not interesting enough, so he asked his colleague how many non-negative solutions of this equation exist. This task turned out to be too difficult for Oira-Oira, so he asks you to help. InputEach test contains several possible values of a and your task is to find the number of equation’s solution for each of them. The first line contains an integer t (1≤t≤1000) — the number of these values. The following t lines contain the values of parameter a, each value is an integer from 0 to 2^30−1 inclusive. OutputFor each value of a print exactly one integer — the number of non-negative solutions of the equation for the given value of the parameter. Print answers in the same order as values of a appear in the input. One can show that the number of solutions is always finite. ExampleInput12343021073741823 Output123121073741824 NoteLet’s define the bitwise exclusive OR (XOR) operation. Given two integers x and y, consider their binary representations (possibly with leading zeroes): xk…x2x1x0 and yk…y2y1y0. Here, xi is the i-th bit of the number x and yi is the i-th bit of the number y. Let r=x⊕y be the result of the XOR operation of x and y. Then r is defined as rk…r2r1r0 where: 12ri=&#123;1, if xi≠yi；0, if xi=yi For the first value of the parameter, only x=0 is a solution of the equation. For the second value of the parameter, solutions are x=0 and x=2. 思路转换一下公式a−(a⊕x)−x=0 =&gt;a-x=a⊕x。假设a的二进制表示为1011011011，a减去一个数x（x&gt;=0）必然会使得a减小，那么就要看a与哪些数异或会使得a会减小相同数的值。异或为不进位的加法，比如1101^0001，结果为1100；让1101-0001，结果为1100。可以发现，只要x的二进制串上的1与a的二进制串上的1有对应的（x的1不与a上的0对应），那么就满足a-x=a⊕x。举例子，a=1011011011，x可为1，11，1011，11011……。所以只需统计a的二进制串有多少位是1，又对于每一位的1选择是取还是不取，答案为2^n。 代码123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;long long fast_pow(int a,int b) &#123; long long ans=1; while(b) &#123; if(b&amp;1) ans=ans*a; a*=a; b&gt;&gt;=1; &#125; return ans;&#125;int main() &#123; int t; cin&gt;&gt;t; while(t--) &#123; long long n; cin&gt;&gt;n; int sum=0; while(n) &#123; if(n&amp;1) sum++; n&gt;&gt;=1; &#125; cout&lt;&lt;fast_pow(2,sum)&lt;&lt;endl; &#125; return 0;&#125; C Oh Those Palindromes题目A non-empty string is called palindrome, if it reads the same from the left to the right and from the right to the left. For example, “abcba”, “a”, and “abba” are palindromes, while “abab” and “xy” are not. A string is called a substring of another string, if it can be obtained from that string by dropping some (possibly zero) number of characters from the beginning and from the end of it. For example, “abc”, “ab”, and “c” are substrings of the string “abc”, while “ac” and “d” are not. Let’s define a palindromic count of the string as the number of its substrings that are palindromes. For example, the palindromic count of the string “aaa” is 6 because all its substrings are palindromes, and the palindromic count of the string “abc” is 3 because only its substrings of length 1 are palindromes. You are given a string s. You can arbitrarily rearrange its characters. You goal is to obtain a string with the maximum possible value of palindromic count. InputThe first line contains an integer n (1≤n≤100000) — the length of string s. The second line contains string s that consists of exactly n lowercase characters of Latin alphabet. OutputPrint string t, which consists of the same set of characters (and each characters appears exactly the same number of times) as string s. Moreover, t should have the maximum possible value of palindromic count among all such strings strings. If there are multiple such strings, print any of them. ExamplesInput125oolol Output1ololo Input1216gagadbcgghhchbdf Output1abccbaghghghgdfd NoteIn the first example, string “ololo” has 9 palindromic substrings: “o”, “l”, “o”, “l”, “o”, “olo”, “lol”, “olo”, “ololo”. Note, that even though some substrings coincide, they are counted as many times as they appear in the resulting string. In the second example, the palindromic count of string “abccbaghghghgdfd” is 29. 思路给定一个字符串，求能组回文子串的最多种数。其实这个题目考思维。对于字符串abccba，如果能看到aabbcc所组成的回文子串的数量一样多的话，就简洁明了了。 代码12345678910111213#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=100000+10;char str[MAXN]; int main() &#123; int n; cin&gt;&gt;n; cin&gt;&gt;str; sort(str,str+n); cout&lt;&lt;str&lt;&lt;endl; return 0;&#125; D Labyrinth CodeForces题目You are playing some computer game. One of its levels puts you in a maze consisting of n lines, each of which contains m cells. Each cell either is free or is occupied by an obstacle. The starting cell is in the row r and column c. In one step you can move one square up, left, down or right, if the target cell is not occupied by an obstacle. You can’t move beyond the boundaries of the labyrinth. Unfortunately, your keyboard is about to break, so you can move left no more than x times and move right no more than y times. There are no restrictions on the number of moves up and down since the keys used to move up and down are in perfect condition. Now you would like to determine for each cell whether there exists a sequence of moves that will put you from the starting cell to this particular one. How many cells of the board have this property? InputThe first line contains two integers n, m (1 ≤ n, m ≤ 2000) — the number of rows and the number columns in the labyrinth respectively. The second line contains two integers r, c (1 ≤ r ≤ n, 1 ≤ c ≤ m) — index of the row and index of the column that define the starting cell. The third line contains two integers x, y (0 ≤ x, y ≤ 109) — the maximum allowed number of movements to the left and to the right respectively. The next n lines describe the labyrinth. Each of them has length of m and consists only of symbols ‘.’ and ‘“.The j-th character of the i-th line corresponds to the cell of labyrinth at row i and column j. Symbol ‘.’ denotes the free cell, while symbol ““ denotes the cell with an obstacle. It is guaranteed, that the starting cell contains no obstacles. OutputPrint exactly one integer — the number of cells in the labyrinth, which are reachable from starting cell, including the starting cell itself. ExamplesInput12345674 53 21 2......***....***.... Output110 Input12345674 42 20 1......*......... Output17 NoteCells, reachable in the corresponding example, are marked with ‘+’. First example:1234+++..+***.+++***+++. Second example:1234.++..+*..++..++. 思路由起点出发，在向左向右转有次数限制的条件下问能到达最大的位置。先是用传统的BFS写了一遍，WA，后来发现某个位置可由不同的位置到达，这些位置带来的状态转变也不一定相同。例如，12345678910...*******.*.*******.*.*******.*.*******.*.*******.*.*.......*.*@*****.*.........********........... 在某个关键位置@，假如由位置1带来的状态是左右转次数都为0，就导致这个点无法向左或向右转造成的结果是后面可能会有更多可达到的位置但是由于这个点@已经无法访问，使得就算有另外的位置达到这里的左右转次数不为零也没有用。所以需要定义一种谁先访问谁后访问的顺序来避免这种情况。 双端队列解法由题知，上下移动不消耗次数，左右移动消耗次数，那么就可以只要能向上或向下就向上或向下移动，当无法上下移动时才左右移动。使用双端队列，将能上下移动的位置放在队头，左右移动的位置放在队尾。 优先队列解法其实优先队列解法与双端队列解法思想是一样的，那就是能上下移动就上下移动，而上下移动不会消耗左右移动次数，也就是说左移动次数加上右移动次数大的优先访问。 代码（deque）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=2e3+10;struct node&#123; int x,y,dep; int left,right; node(int x,int y,int dep,int left,int right):x(x),y(y),dep(dep),left(left),right(right)&#123;&#125;// bool operator &lt; (const node &amp;a) const &#123;return (right)&gt;(a.right);&#125;&#125;; deque&lt;node&gt; qu;int n,m;int r,c;int leftCount,rightCount;int visit[MAXN][MAXN];string str[MAXN]; int ans;int dx[]=&#123;1,-1,0,0&#125;;int dy[]=&#123;0,0,1,-1&#125;;void BFS(int x,int y,int left,int right) &#123; while(!qu.empty()) qu.pop_back(); memset(visit,0,sizeof(visit)); qu.push_front(node(x,y,0,left,right)); visit[x][y]=1; while(!qu.empty()) &#123; node t=qu.front();qu.pop_front(); for(int i=0;i&lt;4;i++) &#123; int tx=t.x+dx[i]; int ty=t.y+dy[i]; if(tx&gt;=0&amp;&amp;tx&lt;n&amp;&amp;ty&gt;=0&amp;&amp;ty&lt;m&amp;&amp;!visit[tx][ty]&amp;&amp;str[tx][ty]==&apos;.&apos;) &#123; // visit[t.x][t.y]=0; if(0==i||1==i) &#123; qu.push_front(node(tx,ty,t.dep+1,t.left,t.right)); visit[tx][ty]=1; ans++; &#125; else if(2==i) &#123; if(t.right&gt;0) &#123; qu.push_back(node(tx,ty,t.dep+1,t.left,t.right-1)); visit[tx][ty]=1; ans++; &#125; &#125; else if(3==i) &#123; if(t.left&gt;0) &#123; qu.push_back(node(tx,ty,t.dep+1,t.left-1,t.right)); visit[tx][ty]=1; ans++; &#125; &#125; &#125; &#125; &#125;&#125;int main() &#123; ios::sync_with_stdio(false); ans=1; cin&gt;&gt;n&gt;&gt;m; cin&gt;&gt;r&gt;&gt;c; cin&gt;&gt;leftCount&gt;&gt;rightCount; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;str[i]; &#125; BFS(r-1,c-1,leftCount,rightCount); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 代码（priority_queue）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=2e3+10;struct node&#123; int x,y,dep; int left,right; node(int x,int y,int dep,int left,int right):x(x),y(y),dep(dep),left(left),right(right)&#123;&#125; bool operator &lt; (const node &amp;a) const &#123;return (left+right)&lt;(a.left+a.right);&#125;&#125;; priority_queue&lt;node&gt; qu;int n,m;int r,c;int leftCount,rightCount;int visit[MAXN][MAXN];string str[MAXN]; int ans;int dx[]=&#123;1,-1,0,0&#125;;int dy[]=&#123;0,0,1,-1&#125;;void BFS(int x,int y,int left,int right) &#123; while(!qu.empty()) qu.pop(); memset(visit,0,sizeof(visit)); qu.push(node(x,y,0,left,right)); visit[x][y]=1; while(!qu.empty()) &#123; node t=qu.top();qu.pop(); for(int i=0;i&lt;4;i++) &#123; int tx=t.x+dx[i]; int ty=t.y+dy[i]; if(tx&gt;=0&amp;&amp;tx&lt;n&amp;&amp;ty&gt;=0&amp;&amp;ty&lt;m&amp;&amp;!visit[tx][ty]&amp;&amp;str[tx][ty]==&apos;.&apos;) &#123; // visit[t.x][t.y]=0; if(0==i||1==i) &#123; qu.push(node(tx,ty,t.dep+1,t.left,t.right)); visit[tx][ty]=1; ans++; &#125; else if(2==i) &#123; if(t.right&gt;0) &#123; qu.push(node(tx,ty,t.dep+1,t.left,t.right-1)); visit[tx][ty]=1; ans++; &#125; &#125; else if(3==i) &#123; if(t.left&gt;0) &#123; qu.push(node(tx,ty,t.dep+1,t.left-1,t.right)); visit[tx][ty]=1; ans++; &#125; &#125; &#125; &#125; &#125;&#125;int main() &#123; ios::sync_with_stdio(false); ans=1; cin&gt;&gt;n&gt;&gt;m; cin&gt;&gt;r&gt;&gt;c; cin&gt;&gt;leftCount&gt;&gt;rightCount; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;str[i]; &#125; BFS(r-1,c-1,leftCount,rightCount); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCPC2018-湖南全国邀请赛-重现赛]]></title>
    <url>%2F2019%2F04%2F19%2F%E6%AF%94%E8%B5%9B%2FCCPC2018-%E6%B9%96%E5%8D%97%E5%85%A8%E5%9B%BD%E9%82%80%E8%AF%B7%E8%B5%9B-%E9%87%8D%E7%8E%B0%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[A - Easy $h$-index HDU - 6276题目：比赛题目：http://acm.hdu.edu.cn/downloads/2018ccpc_hn.pdf The h-index of an author is the largest h where he has at least h papers with citations not less than h. Bobo has published many papers.Given a0,a1,a2,…,an which means Bobo has published ai papers with citations exactly i, find the h-index of Bobo.InputThe input consists of several test cases and is terminated by end-of-file. The first line of each test case contains an integer n.The second line contains (n+1) integers a0,a1,…,an.OutputFor each test case, print an integer which denotes the result. Constraint 1≤n≤2⋅105 0≤ai≤109 The sum of n does not exceed 250,000. Sample Input12345611 221 2 330 0 0 0 Sample Output123120 思路题目意思有点绕，大意是，发表了h篇文章索引量不少于h，然后求最大的h那么只需要将索引量多的文章数加到索引量少的文章数就可以了。 代码12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=1e6+10;int n;int arr[MAXN];int main() &#123; ios::sync_with_stdio(false); while(~scanf(&quot;%d&quot;,&amp;n)) &#123; for(int i=0;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;arr[i]); for(int i=n-1;i&gt;=0;i--) arr[i]+=arr[i+1]; int ans=0; for(int i=1;i&lt;=n+1;i++) if(i&lt;=arr[i]) ans=max(ans,i); cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; F - Sorting HDU - 6281题目Bobo has n tuples (a1,b1,c1),(a2,b2,c2),…,(an,bn,cn).He would like to find the lexicographically smallest permutation p1,p2,…,pn of 1,2,…,n such that for i∈{2,3,…,n} it holds that(a[pi−1]+b[pi−1])/(a[pi−1]+b[pi−1]+c[pi−1])≤(a[pi]+b[pi])/(a[pi]+b[pi]+c[pi]). InputThe input consists of several test cases and is terminated by end-of-file. The first line of each test case contains an integer n.The i-th of the following n lines contains 3 integers ai, bi and ci.OutputFor each test case, print n integers p1,p2,…,pn seperated by spaces.DO NOT print trailing spaces. Constraint 1≤n≤103 1≤ai,bi,ci≤2×109 The sum of n does not exceed 104. Sample Input1234567891021 1 11 1 221 1 21 1 131 3 12 2 13 1 1 Sample Output1232 11 21 2 3 思路求p1-pn间最小的字典序使其满足上面那个不等式。关键在于进行long long 型整数除法时，long double可能都无法保证浮点数精度，所以最好要交换下，但很奇怪的是long double就过了，数据挺弱的吧。 代码12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=3e4+10;struct node&#123; long double a,b,c; int index; long double cost;&#125;;node arr[MAXN];node value[MAXN];int n;bool cmp(node a,node b) &#123; if(a.cost==b.cost) return a.index&lt;b.index; return a.cost&lt;b.cost;&#125;int main() &#123;// cout&lt;&lt;10/3*30&lt;&lt;endl; ios::sync_with_stdio(false); while(cin&gt;&gt;n) &#123; for(int i=1;i&lt;=n;i++) cin&gt;&gt;arr[i].a&gt;&gt;arr[i].b&gt;&gt;arr[i].c; for(int i=1;i&lt;=n;i++) &#123; value[i].cost=(arr[i].a+arr[i].b)*1.0/(arr[i].a+arr[i].b+arr[i].c)*1.0; value[i].index=i; &#125; sort(value+1,value+n+1,cmp); for(int i=1;i&lt;n;i++) cout&lt;&lt;value[i].index&lt;&lt;&apos; &apos;; cout&lt;&lt;value[n].index&lt;&lt;endl; &#125; return 0;&#125; G - String Transformation HDU - 6282题目Bobo has a string S=s1s2…sn consists of letter a, b and c.He can transform the string by inserting or deleting substrings aa, bb and abab. Formally, A=u∘w∘v (∘’’ denotes string concatenation) can be transformed into A′=u∘v and vice versa where u, v are (possibly empty) strings and w∈{aa,bb,abab}. Given the target string T=t1t2…tm, determine if Bobo can transform the string S into T.InputThe input consists of several test cases and is terminated by end-of-file. The first line of each test case contains a string s1s2…sn.The second line contains a string t1t2…tm.OutputFor each test case, print Yes if Bobo can. Print No otherwise. Constraint 1≤n,m≤104 s1,s2,…,sn,t1,t2,…,tm∈{a,b,c} The sum of n and m does not exceed 250,000. Sample Input123456abbaaccaaab Sample Output123YesNoNo Hint For the first sample, Bobo can transform as ab =&gt; aababb =&gt; babb =&gt; ba. 思路题意为第一个字符串能不能变成第二个字符串。首先由第一个样列看到ab经过一系列变化可以转变为ba，同理ba也能转变为ab，得ab与ba能相互转换。再者，经过转换，最后可得到的字符串可以是：a的个数为奇数得到a，b的个数为奇数b，a的个数与b的个数同奇得到ab或ba，a的个数与b的个数同偶得到空串；利用这几点统计两个串的a、b个数的奇偶性即可。其次，对于任何一个串，如果a与a相邻，b与b相邻，那么可以直接删去相邻得相同得字符；如果有abab之类，由ab=&gt;ba得abba可直接删去。对于字符c，无法删除或转化，所以c是一个分隔符，将ab组成的字符串分隔开即c左边的不会影响右边的，得出结论：如果两个串的c不相等，即无法转换。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=1e4+10;struct node&#123; int Counta,Countb; &#125;;int main() &#123; string str1,str2; while(cin&gt;&gt;str1&gt;&gt;str2) &#123; node arr[MAXN]; node brr[MAXN]; memset(arr,0,sizeof(arr)); memset(brr,0,sizeof(brr)); // for(int i=0;i&lt;=10;i++)// cout&lt;&lt;arr[i].Counta&lt;&lt;&apos; &apos;&lt;&lt;arr[i].Countb&lt;&lt;endl;// cout&lt;&lt;endl; int cnt1=0; int cnt2=0; for(int i=0;i&lt;str1.size();i++) &#123; if(&apos;a&apos;==str1[i]) arr[cnt1].Counta++; if(&apos;b&apos;==str1[i]) arr[cnt1].Countb++; if(&apos;c&apos;==str1[i]) cnt1++; &#125; for(int i=0;i&lt;str2.size();i++) &#123; if(&apos;a&apos;==str2[i]) brr[cnt2].Counta++; if(&apos;b&apos;==str2[i]) brr[cnt2].Countb++; if(&apos;c&apos;==str2[i]) cnt2++; &#125; if(cnt1!=cnt2) &#123; cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; continue; &#125; bool flag=true; while(cnt1!=-1) &#123; if((arr[cnt1].Counta+arr[cnt1].Countb)%2!=(brr[cnt2].Counta+brr[cnt2].Countb)%2) &#123; flag=false; break; &#125; if((arr[cnt1].Counta%2!=brr[cnt2].Counta%2)||(arr[cnt1].Countb%2!=brr[cnt2].Countb%2)) &#123; flag=false; break; &#125; cnt1--; cnt2--; &#125; if(flag) cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; &#125; return 0; &#125; K - 2018 HDU - 6286题目Given a,b,c,d, find out the number of pairs of integers (x,y) where a≤x≤b,c≤y≤d and x⋅y is a multiple of 2018.InputThe input consists of several test cases and is terminated by end-of-file. Each test case contains four integers a,b,c,d.OutputFor each test case, print an integer which denotes the result. Constraint 1≤a≤b≤109,1≤c≤d≤109 The number of tests cases does not exceed 104. Sample Input1231 2 1 20181 2018 1 20181 1000000000 1 1000000000 Sample Output123360511485883320325200 思路给定两个区间，问在这两个区间内各取一个数，使其乘积是2018的倍数的取法有多少种。首先想到，要得到2018的倍数，只能通过两种方法得到，1、2018乘以大于0的任意数2、1009乘以大于0的偶数分别统计[a,b]，[c,d]区间内1009的倍数的个数，2018的倍数的个数，2的倍数的个数，总元素个数。拿[a,b]区间1009的倍数个数乘以[c,d]区间内偶数的个数，2018的倍数的个数乘以[c,d]区间内所有元素的个数。[c,d]区间对[a,b]区间也是如此。到这里，可以发现，在统计1009的倍数时会统计到一部分2018的倍数方案，这里需要借助到容斥原理来去重。即1009的倍数加上2018的倍数减去既是2018的倍数又是2的倍数。[c,d]区间也是如此。 代码123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;long long a,b,c,d;long long ans;int main() &#123; while(cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d) &#123; ans=0; long long Counta=b-a+1; long long Countb=d-c+1; long long tmpa=b/2018-(a-1)/2018;//a-b 2018 long long tmpb=d/2018-(c-1)/2018;//c-d 2018 long long tmpx=b/1009-(a-1)/1009;//a-b 1009 long long tmpy=d/1009-(c-1)/1009;//c-d 1009 long long tmpq=b/2-(a-1)/2;//a-b 2 long long tmpp=d/2-(c-1)/2;//c-d 2 // cout&lt;&lt;Counta&lt;&lt;&apos; &apos;&lt;&lt;Countb&lt;&lt;&apos; &apos;&lt;&lt;tmpa&lt;&lt;&apos; &apos;&lt;&lt;tmpb&lt;&lt;&apos; &apos;&lt;&lt;tmpx&lt;&lt;&apos; &apos;&lt;&lt;tmpy&lt;&lt;&apos; &apos;&lt;&lt;tmpq&lt;&lt;&apos; &apos;&lt;&lt;tmpp&lt;&lt;endl; ans=tmpa*Countb+tmpb*Counta-tmpa*tmpb; ans+=(tmpx-tmpa)*(tmpp-tmpb); ans+=(tmpy-tmpb)*(tmpq-tmpa); cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;//AC]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Crossing River POJ - 1700 （经典题）]]></title>
    <url>%2F2019%2F04%2F07%2F%E8%B4%AA%E5%BF%83%2FCrossing%20River%20POJ%20-%201700%20%EF%BC%88%E7%BB%8F%E5%85%B8%E9%A2%98%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目A group of N people wishes to go across a river with only one boat, which can at most carry two persons. Therefore some sort of shuttle arrangement must be arranged in order to row the boat back and forth so that all people may cross. Each person has a different rowing speed; the speed of a couple is determined by the speed of the slower one. Your job is to determine a strategy that minimizes the time for these people to get across.InputThe first line of the input contains a single integer T (1 &lt;= T &lt;= 20), the number of test cases. Then T cases follow. The first line of each case contains N, and the second line contains N integers giving the time for each people to cross the river. Each case is preceded by a blank line. There won’t be more than 1000 people and nobody takes more than 100 seconds to cross.OutputFor each test case, print a line containing the total number of seconds required for all the N people to cross the river.Sample Input123141 2 5 10 Sample Output117 思路刚开始看到这题时，脑海里首先想到的是让速度最快的的人一趟趟地来回接送，这样就可以使得回来的时间最少，从而总时间最少。然而，却发现这种方法连样列都过不了，那么这种方法肯定是有问题。接着忽然想到，如果先把最快和次快的先运过去，让最快的回来，再让最慢和次慢的过去，让次快的回来，这样子，就把最慢和次慢的运过去，其中运最慢和次慢的时间为{最慢}，而不是像第一段中的为{最慢+次慢}。再一次写好，交上去，WA。。。。又想到，这不是贪心吗！贪心肯定是每次着眼于当前最有利的吗？明白了。1、最快和最慢运过去，最快回来；再，最快和次慢过去，最快回来。2、最快和次快运过去，最快回来；再，最慢和次慢过去，次快回来。这两种方案都可以把最慢和次慢运过去，即取两者所花时间最少方案。 代码12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=1e6;int n;int arr[MAXN];bool cmp(int a,int b) &#123; return a&lt;b;&#125;int main() &#123; // freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); int Case; cin&gt;&gt;Case; while(Case--) &#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;arr[i]; sort(arr+1,arr+n+1,cmp); int ans=0; int i; for(i=n;i&gt;3;i-=2) &#123; int MIN=min(arr[i]+arr[i-1]+2*arr[1],arr[1]+2*arr[2]+arr[i]); ans+=MIN; &#125; if(i==3) ans+=arr[1]+arr[2]+arr[3]; else if(i==2) ans+=arr[2]; else ans+=arr[1]; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>贪心算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速幂(个人加深理解)]]></title>
    <url>%2F2019%2F03%2F10%2F%E6%95%B0%E5%AD%A6%2F%E5%BF%AB%E9%80%9F%E5%B9%82%2F</url>
    <content type="text"><![CDATA[12345678910111213typedef long long ll;const int mod=100000007;ll fast_pow(ll a,ll b) &#123; ll ans=1; a%=mod; while(b) &#123; if(b&amp;1) ans=ans%mod*a%mod%mod; a=a%mod*a%mod%mod; b&gt;&gt;=1; &#125; return ans%mod;&#125; 理解：对于一个十进制数都可以化成二进制，即1010==10102，1010也可以写成这样23+21。那么现在要求计算1010%mod，就可以转化为10(23+21)%mod，观察到在10的二进制数表示上当某位为1时，才与ans相乘，其余只是不断地由21累乘到22再到24，而不用一个个去计算22\2了。]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[int，long，long long范围]]></title>
    <url>%2F2019%2F03%2F10%2F%E6%A8%A1%E6%9D%BF%2Flong%20long%E8%8C%83%E5%9B%B4%2F</url>
    <content type="text"><![CDATA[原文地址：ACM博客_kuangbin unsigned int 0～4294967295 int 2147483648～2147483647 unsigned long 0～4294967295 long 2147483648～2147483647 long long的最大值：9223372036854775807 long long的最小值：-9223372036854775808 unsigned long long的最大值：18446744073709551615 __int64的最大值：9223372036854775807 __int64的最小值：-9223372036854775808 unsigned __int64的最大值：18446744073709551615]]></content>
  </entry>
  <entry>
    <title><![CDATA[gcd(个人加深理解)]]></title>
    <url>%2F2019%2F03%2F09%2F%E6%95%B0%E5%AD%A6%2Fgcd%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[12345int gcd(int a,int b)&#123; return b==0?a:gcd(b,a%b);&#125;最大公约数val=gcd(a,b);最小公倍数val=a/gcd(a,b)*b;//防止a*b溢出 证明：a和b的最大公约数与b和a%b的最大公约数相同。设a和b的公约数为d，那么 a=nd ① b=md ②(n,m为自然数) 记a%b=r，可得a=bp+r ③将①、②代入③中，化简得(n-mp)d=r ④，d是r得约数，由②可知，d也是b得约数，所以d是b和r的公约数，即d是b和a%b的公约数，联立①②，d是a和b的公约数。 同理设d$’$是b和a%b的公约数，可求得d$’$也是a和b的公约数。 结论：a和b与b和a%b的公约数相同，那么它们的最大公约数也相同。]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>gcd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搞ACM的你伤不起]]></title>
    <url>%2F2019%2F03%2F05%2F%E9%9A%8F%E7%AC%94%E6%9D%82%E6%83%B3%2F%E6%90%9EACM%E7%9A%84%E4%BD%A0%E4%BC%A4%E4%B8%8D%E8%B5%B7%2F</url>
    <content type="text"><![CDATA[这是原作者，我只是个搬运工 RoBa原创，转载请注明出处 劳资六年前开始搞ACM啊！！！！！！！！！！从此踏上了尼玛不归路啊！！！！！！！！！！！！谁特么跟劳资讲算法是程序设计的核心啊！！！！！！尼玛除了面试题就没见过用算法的地方啊！！！！！！谁再跟劳资讲算法之美算法的力量，劳资一本算法导论拍死你啊！！！！！！！！ ！那是搞ACM的入门书啊！！！！特么的入门书就一千多页啊！！！！！！！还没有习题答案啊，学完了你特么都不知道自己到底会不会啊有木有！！！！！！然后你就得看lrj的黑书啊！！！！！！还是特么的没有习题答案啊！！！！那书难的一B啊！！！！人家一个“显然”得出的结论够你想一礼拜啊有木有！！！！一个课后题够你想几个月啊有木有！！！！然后还有一堆堆的书啊！！！！每一类算法都足够写一本书啊！！！！每本都是砖头一样啊！！！！还都特么是英文的啊！！！！也有中文翻译版啊！！！！！！翻译得跟屎一样啊！！！！你看的时候得把它再变回英文才能懂啊！！！！！！有木有！！！！！！ACM的题目类型是没有范围的啊！！！！！！动态规划有木有！！！！数据结构有木有！！！！图论有木有！！！！！！计算几何有木有！！！！！！数论有木有！！！！！！要写两三百行的模拟题有木有！！！！！！ 特么连物理题化学题都有啊！！！！！！ 还有理论上就不可做的NP难问题啊！！！！！！ 特么理论上不可做的题也有人能AC啊！！！！ 坑爹啊！！！！ 课本上学的东西完全不给力啊！！！！！！ 你以为学过一个最长公共子串就是懂动态规划了啊！！！！！！ 树型的有木有！！！！ 状态压缩的有木有！！！！ 插头的有木有！！！！ 而且特么写出来就超时啊！！！！！！ 你得四边形优化啊！！！！ 你得斜率优化啊！！！！ 你得队列优化啊！！！！ 特么恨不得把要算十年的程序优化到一秒啊！！！！ 你以为学过一个二叉搜索树就是懂数据结构了啊！！！！！！ 平衡啊旋转啊红啊黑啊有木有！！！！ 伸展啊随机权重啊合并啊拆分啊有木有！！！！！！ 你以为学过一个Dijkstra最短路就是懂图算法了啊！！！！！！ 特么的图里有几百万个点啊！！！！！！ 得用堆来优化啊！！！！ 而且边权要是负的就不对了啊！！！！ 还有环啊！！！！ 而且特么的你根本看不出是最短路问题啊！！！！！！ 为神马最短路算法可以用来解不等式啊！！！！ 还有网络流啊！！！！ 特么的课本上的算法铁定超时啊！！！！！！ 你得看论文去研究神马Dinic啊SAP啊！！！！！！ 而且你还是根本看不出是网络流啊！！！！！！ 网络流是在图上来求啊！！！！ 特么的图在哪里啊！！！！ 特么的八竿子打不着的问题都能变成网络流啊！！！！！！ 这些你都学会了啊！！！！ 想参加比赛了啊！！！！ 发现想拿个成绩非常难啊！！！！！ ！ 校内选拔赛就好几百人报名啊有木有！！！！！！ 最后只能剩下十几个啊！！！！ 人家都是竞赛保送的啊！！！！！！ 中学就学了好几年了有木有！！！！ 怎么比的过啊！ ！！！！！ 进了校队以后你就不要想寒暑假了啊！！！！！！ 夏天劳资全身脱光了涂满花露水半夜刷题有木有！！！！！！ 冬天劳资跑遍校园找不到一个开门的食堂有木有！！！！！！ 而且特么老外的在线比赛都在半夜啊！！！！！！！！ 在机房通宵是常事啊有木有！！！ ！！！ 比赛是三个人啊！！！！ 但是只有一台电脑啊！！！！！！ 特么的ACM组委会连多买几台电脑都不肯啊！！！！！！ 队友占着机器你就只能干着急啊！！！！！！ 想把他踹一边儿去啊！！！！！！ 没机器你就得在纸上调试啊！！！！！！ 你的脑子就是个CPU啊有木有！！！！ 你要是摊上一个啥都不会，连读题都误导你的队友，你就死定了啊！！！！！！ 不怕神一样的对手就怕猪一样的队友啊！！！！ 你终于参加区域赛了啊！！！！ 一百多个队啊！！！！！！还有一大堆打星号的高中生们啊！！！！！！都是全国前几名级别的有木有！！！！还有一大堆打星号的老不死们啊！！！！！！毕业了还要来诈尸啊！！！！一开场那气球呼呼地挂啊！！！！你还没读完题人家已经AC了啊！！！！而且最先过的不一定是最简单的啊！！！！人家故意在误导你啊有木有！！！！！！比赛要五个小时啊！！！！结束了以后脑子都抽筋了啊！！！！人家做七八道题，你连一半都不到啊！！！！！！拿个毛的奖啊！！！！去个毛的总决赛啊！！！！！！去了总决赛也是被虐啊！！！！！！老毛子们更尼玛不是人啊有木有！！！！！！连清华都被虐啊有木有！！！！！！你拿着一堆Honorable Mention毕业了啊！！！！想找工作啊！！！！谁说懂算法很容易找到好工作啊！！！！都特么要项目经验有木有！！！！劳资成天盯着一个黑乎乎的控制台窗口！！！！哪有时间做项目啊！！！！！！同学们都是网站啊桌面程序啊做过一堆啊！！！！人家对面试官侃侃而谈啊！！！劳资只好说劳资除了算法啥也不会啊！！而且其实算法也没学会啊！！！！！坑爹啊！！！！终于工作了啊！！！！发现算法神马的完全用不上啊！！！！稍微复杂点的算法都有现成的库可以用啊！！！！！！要懂Shell编程有木有！！！！要懂多线程有木有！！！！要懂Socket有木有！！！！要懂分布式有木有！！！！要懂J2EE有木有！！！！要懂设计模式有木有！！！！要懂以下省略三千字有木有！！！！！！！！！！！！！！！！！！！！！！！！！！！ ！！！！！！！总之搞ACM的上辈子都是脑细胞死光钻到牛角尖里出不来的天使啊！！！！！！你伤不起啊 ！！！！！！]]></content>
      <categories>
        <category>随笔杂想</category>
      </categories>
      <tags>
        <tag>搞笑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆优化prim模板]]></title>
    <url>%2F2019%2F03%2F05%2F%E6%A8%A1%E6%9D%BF%2F%E5%A0%86%E4%BC%98%E5%8C%96prim%E6%A8%A1%E6%9D%BF%20%20%2F</url>
    <content type="text"><![CDATA[数据过大导致开大数组不实际时，用vector。123456789101112131415161718192021222324252627282930313233343536373839const int MAXN=100000+10;const int inf=10e7;struct Node&#123; int x,cost; Node(int x,int cost):x(x),cost(cost)&#123;&#125; friend bool operator &lt; (const Node &amp;a,const Node &amp;b) &#123;return a.cost&gt;b.cost;&#125;&#125;;priority_queue&lt;Node&gt; qu;int n,m;vector&lt;Node&gt; mp[MAXN];int visit[MAXN];int ans=0;void prim(int v) &#123; memset(visit,0,sizeof(visit)); visit[v]=1; int k=v; for(int i=0;i&lt;mp[k].size();i++) &#123; Node tmp=mp[k][i]; if(!visit[tmp.x]) qu.push(Node(tmp.x,tmp.cost)); &#125; while(!qu.empty()) &#123; Node tmp=qu.top(); qu.pop(); if(visit[tmp.x]) continue; ans+=tmp.cost; k=tmp.x; visit[k]=1; for(int i=0;i&lt;mp[k].size();i++) &#123; tmp=mp[k][i]; if(!visit[tmp.x]) qu.push(Node(tmp.x,tmp.cost)); &#125; &#125;&#125; 较小数据量时12345678910111213141516171819202122232425262728293031323334353637const int inf=1000000;const int MAXN=500+5;struct Node&#123; int x,y,cost; Node(int x,int y,int cost):x(x),y(y),cost(cost)&#123;&#125; friend bool operator &lt; (const Node &amp;a,const Node &amp;b) &#123;return a.cost&gt;b.cost;&#125;&#125;;int ans=0; int n,m;int mp[MAXN][MAXN];priority_queue&lt;Node&gt; qu;int visit[MAXN*MAXN];void prim(int v) &#123; memset(visit,0,sizeof(visit)); while(!qu.empty())qu.pop(); visit[v]=1; int k=v; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=n;j++) if(!visit[j]) qu.push(Node(i,j,mp[k][j])); while(!qu.empty()&amp;&amp;visit[qu.top().y]) qu.pop(); if(qu.empty()) break; Node now=qu.top(); ans+=now.cost; k=now.y; visit[k]=1; qu.pop(); &#125; &#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>堆优化prim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rumor CodeForces - 893C]]></title>
    <url>%2F2019%2F03%2F01%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%2FRumor%20CodeForces%20-%20893C%2F</url>
    <content type="text"><![CDATA[题目Vova promised himself that he would never play computer games… But recently Firestorm — a well-known game developing company — published their newest game, World of Farcraft, and it became really popular. Of course, Vova started playing it. Now he tries to solve a quest. The task is to come to a settlement named Overcity and spread a rumor in it. Vova knows that there are n characters in Overcity. Some characters are friends to each other, and they share information they got. Also Vova knows that he can bribe each character so he or she starts spreading the rumor; i-th character wants ci gold in exchange for spreading the rumor. When a character hears the rumor, he tells it to all his friends, and they start spreading the rumor to their friends (for free), and so on.The quest is finished when all n characters know the rumor. What is the minimum amount of gold Vova needs to spend in order to finish the quest? Take a look at the notes if you think you haven’t understood the problem completely. InputThe first line contains two integer numbers n and m (1 ≤ n ≤ 105, 0 ≤ m ≤ 105) — the number of characters in Overcity and the number of pairs of friends. The second line contains n integer numbers ci (0 ≤ ci ≤ 109) — the amount of gold i-th character asks to start spreading the rumor. Then m lines follow, each containing a pair of numbers (xi, yi) which represent that characters xi and yi are friends (1 ≤ xi, yi ≤ n, xi ≠ yi). It is guaranteed that each pair is listed at most once. OutputPrint one number — the minimum amount of gold Vova has to spend in order to finish the quest. ExamplesInput12345 22 5 3 4 81 44 5 Output110 Input1210 01 2 3 4 5 6 7 8 9 10 Output155 Input123456710 51 6 2 7 3 8 4 9 5 101 23 45 67 89 10 Output115 NoteIn the first example the best decision is to bribe the first character (he will spread the rumor to fourth character, and the fourth one will spread it to fifth). Also Vova has to bribe the second and the third characters, so they know the rumor. In the second example Vova has to bribe everyone. In the third example the optimal decision is to bribe the first, the third, the fifth, the seventh and the ninth characters. 思路用并查集的思想把朋友关系合并在一起。在查找父节点的时候，把所有子节点的值赋0，合并的时候注意判断两者的父节点是否相同，若相同则会造成重复计算从而出错，在这个地方WA了n次，qwq。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int MAXN=10e5+5;int n,m;long long arr[MAXN];int parent[MAXN];int find(int x)&#123; int r=x; while(r!=parent[r])&#123; arr[r]=0; r=parent[r]; &#125; int i=x,j; while(i!=r)&#123; j=parent[i]; arr[i]=0; parent[i]=r; i=j; &#125; return r;&#125;void join(int x,int y)&#123; x=find(x); y=find(y); if(x!=y) //千万要注意 if(arr[x]&lt;=arr[y])&#123; parent[y]=x; arr[y]=0; &#125;else&#123; parent[x]=y; arr[x]=0; &#125;&#125;int main()&#123; while(cin&gt;&gt;n&gt;&gt;m)&#123; for(int i=1;i&lt;=n;i++)&#123; parent[i]=i; arr[i]=0; cin&gt;&gt;arr[i]; &#125; for(int i=1;i&lt;=m;i++)&#123; int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); join(a,b); &#125; long long ans=0; for(int i=1;i&lt;=n;i++) if(parent[i]==i) ans+=arr[i]; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[for fun]]></title>
    <url>%2F2019%2F02%2F19%2F%E9%9A%8F%E7%AC%94%E6%9D%82%E6%83%B3%2Ffor%20fun%2F</url>
    <content type="text"><![CDATA[我的建议只有一点:不要假勤奋 大学有太多后知后觉的事了 你每天都去图书馆，认真看书写作业，然后逐渐掌握了大学考试的技巧，你有了好的成绩，成了别人眼里的学霸。 然后你发现只学习老师给的重点对付考试已经足够了，你慢慢学会了偷懒，但你为了当别人眼中的学霸还是每天去图书馆，你不再专注，不再锱铢必较，因为你知道考试之前努力几天还是可以拿A。那你到底用剩下的时间干了什么？ 你在假勤奋，你在培养自己的不专注，你越来越分不清轻重缓急，当你快毕业了，看到周围的人在各种比赛中拿奖也参加了很多社会活动，你才猛然发现，去他妈的学霸。 你也不是没有尝试参加比赛，但你早就培养了自己的侥幸心理，学会了假勤奋，嗯，考试之前看看重点也能考好，所以比赛之前稍稍准备就好，社交活动参加一点就好。结果不言而喻，你没有任何奖状，甚至没有什么交心朋友。 你的假勤奋会毁了你的四年，如果你意识不到，它会成为你的习惯，成为你面对问题的第一方式，这个时候不勤奋甚至比假勤奋更好。 高质量地走完大学四年太难了，但是我至少建议你，时刻注意什么才是重要的，做一件事就拼尽全力，不要有侥幸心理，不要假装勤奋。]]></content>
      <categories>
        <category>随笔杂想</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Rescue HDU - 1242]]></title>
    <url>%2F2019%2F02%2F16%2F%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2%2FRescue%20HDU%20-%201242%20%2F</url>
    <content type="text"><![CDATA[题目Angel was caught by the MOLIGPY! He was put in prison by Moligpy. The prison is described as a N * M (N, M &lt;= 200) matrix. There are WALLs, ROADs, and GUARDs in the prison.Angel’s friends want to save Angel. Their task is: approach Angel. We assume that “approach Angel” is to get to the position where Angel stays. When there’s a guard in the grid, we must kill him (or her?) to move into the grid. We assume that we moving up, down, right, left takes us 1 unit time, and killing a guard takes 1 unit time, too. And we are strong enough to kill all the guards. You have to calculate the minimal time to approach Angel. (We can move only UP, DOWN, LEFT and RIGHT, to the neighbor grid within bound, of course.)InputFirst line contains two integers stand for N and M. Then N lines follows, every line has M characters. “.” stands for road, “a” stands for Angel, and “r” stands for each of Angel’s friend. Process to the end of the file.OutputFor each test case, your program should output a single integer, standing for the minimal time needed. If such a number does no exist, you should output a line containing “Poor ANGEL has to stay in the prison all his life.”Sample Input123456787 8#.#####.#.a#..r.#..#x.....#..#.##...##...#.............. Sample Output113 思路这道题有几个需要注意的地方。1、有多个朋友，也就是说有多个起点，需要进行多次bfs，最后求最短路径。2、在路上，有守卫的地方，所花费的时间为2（击杀守卫通过路径），需要利用一个优先队列，先遍历花费时间为1的再遍历花费时间为2的。优先队列比较算子定义方法，tql。1234567#include&lt;queue&gt;struct node&#123; int x,y,dep; node(int x,int y,int dep):x(x),y(y),dep(dep)&#123;&#125; bool operator &lt; (const node &amp;a) const &#123;return dep&gt;a.dep;&#125;&#125;;priority_queue&lt;node&gt; qu; 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;const int MAXSIZE=210;int visit[MAXSIZE][MAXSIZE];int sx[MAXSIZE]=&#123;0&#125;,sy[MAXSIZE]=&#123;0&#125;,ex=0,ey=0;string str[MAXSIZE];int dx[]=&#123;1,0,0,-1&#125;;int dy[]=&#123;0,1,-1,0&#125;;int N,M;int ans=0x3f3f3f3f;struct node&#123; int x,y,dep; node(int x,int y,int dep):x(x),y(y),dep(dep)&#123;&#125; bool operator &lt; (const node &amp;a) const &#123;return dep&gt;a.dep;&#125;&#125;;void BFS(int x,int y)&#123; memset(visit,0,sizeof(visit)); priority_queue&lt;node&gt; qu; qu.push(node(x,y,0)); visit[x][y]=1; while(!qu.empty())&#123; node t=qu.top();qu.pop(); for(int i=0;i&lt;4;i++)&#123; int tx=t.x+dx[i]; int ty=t.y+dy[i]; if(tx&lt;0||tx&gt;=N||ty&lt;0||ty&gt;=M||visit[tx][ty]==1||str[tx][ty]==&apos;#&apos;)continue; visit[tx][ty]=1; if(tx==ex&amp;&amp;ty==ey)&#123;ans=min(t.dep+1,ans);return;&#125; if(str[tx][ty]==&apos;x&apos;) qu.push(node(tx,ty,t.dep+2)); else qu.push(node(tx,ty,t.dep+1)); &#125; &#125;&#125;int main()&#123; while(cin&gt;&gt;N&gt;&gt;M)&#123; ans=0x3f3f3f3f; vector&lt;node&gt; vc; for(int i=0;i&lt;N;i++) cin&gt;&gt;str[i]; for(int i=0;i&lt;N;i++)&#123; for(int j=0;j&lt;M;j++)&#123; if(str[i][j]==&apos;r&apos;)&#123;vc.push_back(node(i,j,0));&#125; if(str[i][j]==&apos;a&apos;)&#123;ex=i;ey=j;&#125; &#125; &#125; for(int i=0;i&lt;vc.size();i++) BFS(vc[i].x,vc[i].y); //cout&lt;&lt;sx&lt;&lt;&apos; &apos;&lt;&lt;sy&lt;&lt;&apos; &apos;&lt;&lt;ex&lt;&lt;&apos; &apos;&lt;&lt;ey&lt;&lt;endl; if(ans==0x3f3f3f3f) cout&lt;&lt;&quot;Poor ANGEL has to stay in the prison all his life.&quot;&lt;&lt;endl; else cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>简单搜索</category>
      </categories>
      <tags>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Knight Moves ZOJ - 1091]]></title>
    <url>%2F2019%2F02%2F15%2F%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2%2FKnight%20Moves%20ZOJ%20-%201091%2F</url>
    <content type="text"><![CDATA[题目A friend of you is doing research on the Traveling Knight Problem (TKP) where you are to find the shortest closed tour of knight moves that visits each square of a given set of n squares on a chessboard exactly once. He thinks that the most difficult part of the problem is determining the smallest number of knight moves between two given squares and that, once you have accomplished this, finding the tour would be easy.Of course you know that it is vice versa. So you offer him to write a program that solves the “difficult” part.Your job is to write a program that takes two squares a and b as input and then determines the number of knight moves on a shortest route from a to b. Input SpecificationThe input file will contain one or more test cases. Each test case consists of one line containing two squares separated by one space. A square is a string consisting of a letter (a-h) representing the column and a digit (1-8) representing the row on the chessboard.Output SpecificationFor each test case, print one line saying “To get from xx to yy takes n knight moves.”.Sample Input12345678e2 e4a1 b2b2 c3a1 h8a1 h7h8 a1b1 c3f6 f6 Sample Output12345678To get from e2 to e4 takes 2 knight moves.To get from a1 to b2 takes 4 knight moves.To get from b2 to c3 takes 2 knight moves.To get from a1 to h8 takes 6 knight moves.To get from a1 to h7 takes 5 knight moves.To get from h8 to a1 takes 6 knight moves.To get from b1 to c3 takes 1 knight moves.To get from f6 to f6 takes 0 knight moves. 思路简单bfs，从出发点开始到结束点搜索最短路径。用map算出出发点容易点吧。马走日字形。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;int mp[9][9];int visit[9][9];map&lt;char,int&gt; map1;map&lt;char,int&gt; map2;int sx=0,sy=0,ex=0,ey=0;int dx[]=&#123;-1,-2,-2,-1,1,2,2,1&#125;;int dy[]=&#123;-2,-1,1,2,2,1,-1,-2&#125;; struct node&#123; int x,y,dep; node(int x,int y,int dep):x(x),y(y),dep(dep)&#123;&#125;&#125;;int ans=0;void BFS(int x,int y)&#123; memset(visit,0,sizeof(visit)); queue&lt;node&gt; qu; qu.push(node(x,y,0)); visit[x][y]=1; while(!qu.empty())&#123; node t=qu.front();qu.pop(); for(int i=0;i&lt;8;i++)&#123; int tx=t.x+dx[i]; int ty=t.y+dy[i]; if(tx&lt;1||tx&gt;8||ty&lt;1||ty&gt;8||visit[tx][ty]==1) continue; qu.push(node(tx,ty,t.dep+1)); if(tx==ex&amp;&amp;ty==ey) &#123;ans=t.dep+1;return;&#125; visit[tx][ty]=1; &#125; &#125;&#125;int main()&#123; string str1=&quot; abcdefgh&quot;; string str2=&quot; 12345678&quot;; for(int i=1;i&lt;9;i++)&#123; map1[str1[i]]=i; map2[str2[i]]=i; &#125;// for(map&lt;char,int&gt;::iterator it=map2.begin();it!=map2.end();it++)// cout&lt;&lt;it-&gt;first&lt;&lt;&apos; &apos;&lt;&lt;it-&gt;second&lt;&lt;endl; while(cin&gt;&gt;str1&gt;&gt;str2)&#123; ans=0; sx=map1[str1[0]]; sy=map2[str1[1]]; ex=map1[str2[0]]; ey=map2[str2[1]];// cout&lt;&lt;sx&lt;&lt;&apos; &apos;&lt;&lt;sy&lt;&lt;&apos; &apos;&lt;&lt;ex&lt;&lt;&apos; &apos;&lt;&lt;ey&lt;&lt;endl; BFS(sx,sy); cout&lt;&lt;&quot;To get from &quot;&lt;&lt;str1&lt;&lt;&quot; to &quot;&lt;&lt;str2&lt;&lt;&quot; takes &quot;&lt;&lt;ans&lt;&lt;&quot; knight moves.&quot;&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>简单搜索</category>
      </categories>
      <tags>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STL常用技巧]]></title>
    <url>%2F2019%2F02%2F15%2FSTL%2FSTL%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[总结一下近些时间写题用到的stl容器骚操作写法。 STL容器 queue12345678910#include&lt;queue&gt;struct node&#123; int x; int y; int dis; node(int x,int y,int dis):x(x),y(y),dis(dis)&#123;&#125;&#125;;queue&lt;node&gt; qu;qu.push(x);qu.pop(); priority_queue定义方法优先队列比较算子定义方法，tql。1234567#include&lt;queue&gt;struct node&#123; int x,y,dep; node(int x,int y,int dep):x(x),y(y),dep(dep)&#123;&#125; bool operator &lt; (const node &amp;a) const &#123;return dep&gt;a.dep;&#125;&#125;;priority_queue&lt;node&gt; qu; 各类操作12345qu.size();//返回qu里元素个数qu.empty();//返回qu是否为空，空则返回1，否则返回0qu.push(k);//在qu的末尾插入kqu.pop();//删掉qu的第一个元素qu.top();//返回qu的第一个元素 mapvalue值为queue容器12345678910111213141516#include&lt;map&gt;#include&lt;queue&gt;map&lt;int,queue &gt; mp;int a;for(int i=1;i&lt;=n;i++)&#123; scanf(“%d”,&amp;a); mp[a].push(i);&#125;for(int i=0;i&lt;m;i++)&#123; scanf(“%d”,&amp;a); if(mp[a].size()==0) cout&lt;&lt;”-1”; else&#123; cout&lt;&lt;mp[a].front(); mp[a].pop();&#125; Map的按Key排序123456789#include&lt;map&gt;struct cmp&#123; bool operator()(string s1,string s2)&#123; return s1.length()&gt;s1.length(); &#125;&#125;;map&lt;string,int,cmp&gt; mp;//#include &lt;functional&gt;//map&lt;string,int,greater&lt;string&gt; &gt;mp; vectorvector数组表示邻接表。12#include&lt;vector&gt;vector&lt;int &gt; edge[MAXSIZE]; algorithmsort函数123#include&lt;algorithm&gt;bool cmp(int a,int b)&#123;return a&gt;b;&#125;sort(arr,arr+n,cmp); STL-lower_bound-upper_bound简介lower_bound和upper_bound是STL中实现二分查找的函数。 用法12lower_bound(begin,end,x);upper_bound(begin,end,x); 其中，lower_bound是在有序数组中查找第一个大于或等于x的地址，将其减去begin就得到在数组中的位置，不存在就返回end；upper_bound则是查找第一个大于x的地址，同理得到数组中的位置，不存在返回end。 代码123456789101112#include&lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int arr[]=&#123;0,1,2,4,6,8,9,10,23,45&#125;; cout&lt;&lt;lower_bound(arr,arr+10,5)-arr&lt;&lt;' '&lt;&lt;arr[lower_bound(arr,arr+10,5)-arr]&lt;&lt;endl; cout&lt;&lt;upper_bound(arr,arr+10,6)-arr&lt;&lt;' '&lt;&lt;arr[upper_bound(arr,arr+10,6)-arr]&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>STL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Find a way HDU - 2612]]></title>
    <url>%2F2019%2F02%2F15%2F%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2%2FFind%20a%20way%20HDU%20-%202612%20%20%2F</url>
    <content type="text"><![CDATA[题目Pass a year learning in Hangzhou, yifenfei arrival hometown Ningbo at finally. Leave Ningbo one year, yifenfei have many people to meet. Especially a good friend Merceki.Yifenfei’s home is at the countryside, but Merceki’s home is in the center of city. So yifenfei made arrangements with Merceki to meet at a KFC. There are many KFC in Ningbo, they want to choose one that let the total time to it be most smallest.Now give you a Ningbo map, Both yifenfei and Merceki can move up, down ,left, right to the adjacent road by cost 11 minutes.InputThe input contains multiple test cases.Each test case include, first two integers n, m. (2&lt;=n,m&lt;=200).Next n lines, each line included m character.‘Y’ express yifenfei initial position.‘M’ express Merceki initial position.‘#’ forbid road;‘.’ Road.‘@’ KCFOutputFor each test case output the minimum total time that both yifenfei and Merceki to arrival one of KFC.You may sure there is always have a KFC that can let them meet.Sample Input123456789101112131415164 4Y.#@.....#..@..M4 4Y.#@.....#..@#.M5 5Y..@..#....#...@..M.#...# Sample Output123668866 思路对于Y和M，以其坐标为起点，用BFS对每一kfc搜索，记录最短距离，最后相加取最少的。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;const int MAXSIZE=200+5;int N,M;string str[MAXSIZE];int visit[MAXSIZE][MAXSIZE]=&#123;0&#125;;int dx[]=&#123;1,0,0,-1&#125;;int dy[]=&#123;0,1,-1,0&#125;;struct node&#123; int x; int y; int dis; node(int x,int y,int dis):x(x),y(y),dis(dis)&#123;&#125;&#125;;int kfc[MAXSIZE][MAXSIZE];int time[2][MAXSIZE*200];void BFS(int x,int y,int flag)&#123; memset(visit,0,sizeof(visit)); queue&lt;node&gt; qu; qu.push(node(x,y,0)); visit[x][y]=1; while(!qu.empty())&#123; node t=qu.front(); qu.pop(); for(int i=0;i&lt;4;i++)&#123; int tx=t.x+dx[i]; int ty=t.y+dy[i]; if(tx&lt;0||tx&gt;=N||ty&lt;0||ty&gt;=M||visit[tx][ty]==1||str[tx][ty]==&apos;#&apos;) continue; if(str[tx][ty]==&apos;@&apos;) time[flag][kfc[tx][ty]]=t.dis+1; visit[tx][ty]=1; qu.push(node(tx,ty,t.dis+1)); &#125; &#125; &#125;int main()&#123; while(cin&gt;&gt;N&gt;&gt;M)&#123; int sx=0,sy=0,ex=0,ey=0; int cnt=0; for(int i=0;i&lt;N;i++)cin&gt;&gt;str[i]; for(int i=0;i&lt;N;i++) for(int j=0;j&lt;M;j++)&#123;// cin&gt;&gt;str[i][j]; if(str[i][j]==&apos;Y&apos;)&#123; sx=i;sy=j; &#125; if(str[i][j]==&apos;M&apos;)&#123; ex=i;ey=j; &#125; if(str[i][j]==&apos;@&apos;) kfc[i][j]=cnt++; &#125; int ans=0x3f3f3f3f; memset(time,0x3f,sizeof(time)); BFS(sx,sy,0); BFS(ex,ey,1); for(int i=0;i&lt;cnt;i++) ans=min(ans,time[0][i]+time[1][i]); cout&lt;&lt;ans*11&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>简单搜索</category>
      </categories>
      <tags>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Common Subsequence POJ - 1458]]></title>
    <url>%2F2019%2F02%2F13%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2FCommon%20Subsequence%20POJ%20-%201458%2F</url>
    <content type="text"><![CDATA[题目A subsequence of a given sequence is the given sequence with some elements (possible none) left out. Given a sequence X = &lt; x1, x2, …, xm &gt; another sequence Z = &lt; z1, z2, …, zk &gt; is a subsequence of X if there exists a strictly increasing sequence &lt; i1, i2, …, ik &gt; of indices of X such that for all j = 1,2,…,k, x ij = zj. For example, Z = &lt; a, b, f, c &gt; is a subsequence of X = &lt; a, b, c, f, b, c &gt; with index sequence &lt; 1, 2, 4, 6 &gt;. Given two sequences X and Y the problem is to find the length of the maximum-length common subsequence of X and Y.InputThe program input is from the std input. Each data set in the input contains two strings representing the given sequences. The sequences are separated by any number of white spaces. The input data are correct.OutputFor each set of data the program prints on the standard output the length of the maximum-length common subsequence from the beginning of a separate line.Sample Input123abcfbc abfcabprogramming contest abcd mnp Sample Output123420 思路dp简单应用题。 dp[i][j]=0，{i=0或者j=0} dp[i-1][j-1]+1，{str1[i]==str2[j]，x&gt;0&amp;&amp;y&gt;0} max{dp[i-1][j],dp[i][j-1]}，{str1[i]!=str2[j]，x&gt;0&amp;&amp;y&gt;0} 代码123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;cstring&gt;using namespace std;const int MAXSIZE=1000;int dp[MAXSIZE][MAXSIZE];int main()&#123; string str1=&quot;&quot;,str2=&quot;&quot;; while(cin&gt;&gt;str1&gt;&gt;str2)&#123; memset(dp,0,sizeof(dp)); int len1=str1.length(); int len2=str2.length(); for(int i=0;i&lt;len1;i++) dp[i][0]=0; for(int i=0;i&lt;len2;i++) dp[0][i]=0; for(int i=1;i&lt;=len1;i++) for(int j=1;j&lt;=len2;j++)&#123; if(str1[i-1]==str2[j-1]) dp[i][j]=dp[i-1][j-1]+1; else dp[i][j]=max(dp[i-1][j],dp[i][j-1]); &#125; cout&lt;&lt;dp[len1][len2]&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>简单题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tempter of the Bone HDU - 1010]]></title>
    <url>%2F2019%2F02%2F13%2F%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2%2FTempter%20of%20the%20Bone%20HDU%20-%201010%2F</url>
    <content type="text"><![CDATA[题目The doggie found a bone in an ancient maze, which fascinated him a lot. However, when he picked it up, the maze began to shake, and the doggie could feel the ground sinking. He realized that the bone was a trap, and he tried desperately to get out of this maze.The maze was a rectangle with sizes N by M. There was a door in the maze. At the beginning, the door was closed and it would open at the T-th second for a short period of time (less than 1 second). Therefore the doggie had to arrive at the door on exactly the T-th second. In every second, he could move one block to one of the upper, lower, left and right neighboring blocks. Once he entered a block, the ground of this block would start to sink and disappear in the next second. He could not stay at one block for more than one second, nor could he move into a visited block. Can the poor doggie survive? Please help him.InputThe input consists of multiple test cases. The first line of each test case contains three integers N, M, and T (1 &lt; N, M &lt; 7; 0 &lt; T &lt; 50), which denote the sizes of the maze and the time at which the door will open, respectively. The next N lines give the maze layout, with each line containing M characters. A character is one of the following: ‘X’: a block of wall, which the doggie cannot enter;‘S’: the start point of the doggie;‘D’: the Door; or‘.’: an empty block. The input is terminated with three 0’s. This test case is not to be processed.OutputFor each test case, print in one line “YES” if the doggie can survive, or “NO” otherwise.Sample Input123456789104 4 5S.X...X...XD....3 4 5S.X...X....D0 0 0 Sample Output12NOYES 思路这道题原先每看清题意，以为是在规定的时间内到门那里就行了，一直用BFS求最短路径，WA到自闭~实际上是要准时在门那里出现才有一线生机。用DFS写就要考虑时间复杂度了。到网上查了别人的题解，用奇偶减枝来优化代码。剪枝是关键,奇偶剪枝.奇偶剪枝原理: 要理解奇偶剪枝,先了解一下曼哈顿距离,从一个点到达另外一个点的最短路径长度(时间)可以根据两点坐标求出,路径长度(非最短)与最短路径的长度同奇偶,它们的差一定是偶数!举个例子,就像两个偶数的差差是偶数,两个个数的差也是偶数. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cmath&gt;using namespace std;const int MAXSIZE=7;string str[MAXSIZE];int N,M,K;int dx[]=&#123;1,0,0,-1&#125;;int dy[]=&#123;0,1,-1,0&#125;;bool flag=false;int ex,ey;int visit[MAXSIZE][MAXSIZE]=&#123;0&#125;;void DFS(int x,int y,int cnt)&#123; if(flag==true) return; if(ex==x&amp;&amp;ey==y) if(cnt==K)&#123; flag=true; return; &#125; int temp=(K-cnt)-(fabs(x-ex)+fabs(y-ey)); //奇偶减枝判断 if(temp&lt;0||temp%2!=0) return; for(int i=0;i&lt;4;i++)&#123; int tx=x+dx[i]; int ty=y+dy[i]; if(tx&gt;=0&amp;&amp;tx&lt;N&amp;&amp;ty&gt;=0&amp;&amp;ty&lt;M&amp;&amp;visit[tx][ty]==0&amp;&amp;str[tx][ty]!=&apos;X&apos;)&#123; visit[tx][ty]=1; DFS(tx,ty,cnt+1); visit[tx][ty]=0; &#125; &#125;&#125;int main()&#123; while(cin&gt;&gt;N&gt;&gt;M&gt;&gt;K)&#123; if(N==0&amp;&amp;M==0&amp;&amp;K==0) break; int startX=0; int startY=0; flag=false; int sum=0; for(int i=0;i&lt;N;i++) for(int j=0;j&lt;M;j++)&#123; cin&gt;&gt;str[i][j]; visit[i][j]=0; if(str[i][j]==&apos;X&apos;) sum++; if(str[i][j]==&apos;S&apos;)&#123; startX=i; startY=j; str[i][j]=&apos;X&apos;; &#125; if(str[i][j]==&apos;D&apos;)&#123; ex=i; ey=j; &#125; &#125; if(N*M-sum&lt;=K)&#123; cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; continue; &#125; DFS(startX,startY,0); if(flag)cout&lt;&lt;&quot;YES&quot;; else cout&lt;&lt;&quot;NO&quot;; cout&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>简单搜索</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[棋盘问题 POJ - 1321]]></title>
    <url>%2F2019%2F02%2F12%2F%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2%2F%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98%20POJ%20-%201321%2F</url>
    <content type="text"><![CDATA[题目在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。Input输入含有多组测试数据。每组数据的第一行是两个正整数，n k，用一个空格隔开，表示了将在一个n*n的矩阵内描述棋盘，以及摆放棋子的数目。 n &lt;= 8 , k &lt;= n当为-1 -1时表示输入结束。随后的n行描述了棋盘的形状：每行有n个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。Output对于每一组数据，给出一行输出，输出摆放的方案数目C （数据保证C&lt;2^31）。Sample Input1234567892 1#..#4 4...#..#..#..#...-1 -1 Sample Output1221 思路遇到 # 时，检查该位置是否可以放置棋子，若可以则以这个位置为递归的起始点搜索下一行，同时将这个位置状态改为 @ ，表明这个位置已经放置了棋子。当摆放的棋子数满足要求时，就回溯到上一个棋子的位置，将状态改回来。方案数加一 代码1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;const int M=9;string str[M];int n,k;int ans=0;int cnt=0;bool check(int x,int y)&#123; for(int i=0;i&lt;x;i++) if(str[i][y]==&apos;@&apos;) return false; for(int j=0;j&lt;y;j++) if(str[x][j]==&apos;@&apos;) return false; return true;&#125;void DFS(int x,int y)&#123; if(cnt==k) ans++; if(cnt&gt;=k) return; for(int i=x;i&lt;n;i++) for(int j=0;j&lt;n;j++)&#123; if(str[i][j]==&apos;#&apos;&amp;&amp;check(i,j))&#123; cnt++; str[i][j]=&apos;@&apos;; DFS(i+1,j); cnt--; str[i][j]=&apos;#&apos;; &#125; &#125; &#125;int main()&#123; while(cin&gt;&gt;n&gt;&gt;k)&#123; if(n==-1&amp;&amp;k==-1) break; ans=cnt=0; for(int i=0;i&lt;n;i++) cin&gt;&gt;str[i]; DFS(0,0); cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>简单搜索</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Red and Black HDU - 1312]]></title>
    <url>%2F2019%2F02%2F11%2F%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2%2FRed%20and%20Black%20HDU%20-%201312%2F</url>
    <content type="text"><![CDATA[题目There is a rectangular room, covered with square tiles. Each tile is colored either red or black. A man is standing on a black tile. From a tile, he can move to one of four adjacent tiles. But he can’t move on red tiles, he can move only on black tiles.Write a program to count the number of black tiles which he can reach by repeating the moves described above.InputThe input consists of multiple data sets. A data set starts with a line containing two positive integers W and H; W and H are the numbers of tiles in the x- and y- directions, respectively. W and H are not more than 20. There are H more lines in the data set, each of which includes W characters. Each character represents the color of a tile as follows. ‘.’ - a black tile‘#’ - a red tile‘@’ - a man on a black tile(appears exactly once in a data set)OutputFor each data set, your program should output a line which contains the number of tiles he can reach from the initial tile (including itself).Sample Input1234567891011121314151617181920212223242526272829303132333435366 9....#......#..............................#@...#.#..#.11 9.#..........#.#######..#.#.....#..#.#.###.#..#.#..@#.#..#.#####.#..#.......#..#########............11 6..#..#..#....#..#..#....#..#..###..#..#..#@...#..#..#....#..#..#..7 7..#.#....#.#..###.###...@...###.###..#.#....#.#..0 0 Sample Output12344559613 思路dfs简单应用。从起点出发，搜索上下左右可走的位置。当找到位置后，又以该元素为起点来搜索。 代码123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;const int MAXSIZE=20+4;string str[MAXSIZE];int ans=0;int N,M;void DFS(int x,int y)&#123; ans++; str[x][y]=&apos;#&apos;; //cout&lt;&lt;x&lt;&lt;&apos; &apos;&lt;&lt;y&lt;&lt;endl; for(int i=x-1;i&lt;=x+1;i++)&#123; if(i&gt;=0&amp;&amp;i&lt;M&amp;&amp;str[i][y]==&apos;.&apos;) DFS(i,y); &#125; for(int j=y-1;j&lt;=y+1;j++) if(j&gt;=0&amp;&amp;j&lt;N&amp;&amp;str[x][j]==&apos;.&apos;) DFS(x,j);&#125;int main()&#123; while(cin&gt;&gt;N&gt;&gt;M)&#123; if(N==0&amp;&amp;M==0) break; ans=0; int startX=0; int startY=0; for(int i=0;i&lt;M;i++) for(int j=0;j&lt;N;j++)&#123; cin&gt;&gt;str[i][j]; if(str[i][j]==&apos;@&apos;)&#123; startX=i; startY=j; &#125; &#125; DFS(startX,startY); cout&lt;&lt;ans&lt;&lt;endl; // cout&lt;&lt;startX&lt;&lt;&apos; &apos;&lt;&lt;startY&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>简单搜索</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lake Counting POJ - 2386]]></title>
    <url>%2F2019%2F02%2F11%2F%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2%2FLake%20Counting%20POJ%20-%202386%2F</url>
    <content type="text"><![CDATA[题目Due to recent rains, water has pooled in various places in Farmer John’s field, which is represented by a rectangle of N x M (1 &lt;= N &lt;= 100; 1 &lt;= M &lt;= 100) squares. Each square contains either water (‘W’) or dry land (‘.’). Farmer John would like to figure out how many ponds have formed in his field. A pond is a connected set of squares with water in them, where a square is considered adjacent to all eight of its neighbors.Given a diagram of Farmer John’s field, determine how many ponds he has.Input Line 1: Two space-separated integers: N and M Lines 2..N+1: M characters per line representing one row of Farmer John’s field. Each character is either ‘W’ or ‘.’. The characters do not have spaces between them.Output Line 1: The number of ponds in Farmer John’s field.Sample Input123456789101110 12W........WW..WWW.....WWW....WW...WW..........WW..........W....W......W...W.W.....WW.W.W.W.....W..W.W......W...W.......W. Sample Output13 HintOUTPUT DETAILS:There are three ponds: one in the upper left, one in the lower left,and one along the right side. 思路dfs算法的简单应用。对整张图来说 遍历整个图 每遇到一个W，这水池数加1，同时将它改为. 以上一步遇到的W为起点，搜索与它相连的位置，若发现W，则将它改为.，然后又搜索这个点周围的位置 代码1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;const int MAXSIZE=100+5;string str[MAXSIZE];int N,M;void DFS(int x,int y)&#123; str[x][y]=&apos;.&apos;; for(int i=x-1;i&lt;=x+1;i++) for(int j=y-1;j&lt;=y+1;j++)&#123; if(i&gt;=0&amp;&amp;i&lt;N&amp;&amp;j&gt;=0&amp;&amp;j&lt;M&amp;&amp;str[i][j]==&apos;W&apos;) DFS(i,j); &#125;&#125;int main()&#123; while(cin&gt;&gt;N&gt;&gt;M)&#123; for(int i=0;i&lt;N;i++) cin&gt;&gt;str[i]; int ans=0; for(int i=0;i&lt;N;i++)&#123; for(int j=0;j&lt;M;j++)&#123; if(str[i][j]==&apos;W&apos;)&#123; ans++; DFS(i,j); &#125; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>简单搜索</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Max Sum HDU - 1003]]></title>
    <url>%2F2019%2F02%2F09%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2FMax%20Sum%20HDU%20-%201003%20%2F</url>
    <content type="text"><![CDATA[题目Given a sequence a[1],a[2],a[3]……a[n], your job is to calculate the max sum of a sub-sequence. For example, given (6,-1,5,4,-7), the max sum in this sequence is 6 + (-1) + 5 + 4 = 14.InputThe first line of the input contains an integer T(1&lt;=T&lt;=20) which means the number of test cases. Then T lines follow, each line starts with a number N(1&lt;=N&lt;=100000), then N integers followed(all the integers are between -1000 and 1000).OutputFor each test case, you should output two lines. The first line is “Case #:”, # means the number of the test case. The second line contains three integers, the Max Sum in the sequence, the start position of the sub-sequence, the end position of the sub-sequence. If there are more than one result, output the first one. Output a blank line between two cases.Sample Input12325 6 -1 5 4 -77 0 6 -1 1 -6 7 -5 Sample Output12345Case 1:14 1 4Case 2:7 1 6 思路dp[i]=max{dp[i-1]+arr[i],arr[i]},0&lt;=i&lt;n 代码1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int MAXSIZE=100000+5;int arr[MAXSIZE]; int main()&#123; int T; cin&gt;&gt;T; int t=1; while(T--)&#123; int N; cin&gt;&gt;N; for(int i=1;i&lt;=N;i++) scanf("%d",&amp;arr[i]); int besti=1,bestj=1,tempi=1; int ans=arr[1],sum=arr[1]; for(int i=2;i&lt;=N;i++)&#123; if(sum&lt;0) &#123; sum=0; tempi=i; &#125; sum+=arr[i]; if(ans&lt;sum)&#123;ans=sum;besti=tempi;bestj=i;&#125; &#125; // printf("Case ");// cout&lt;&lt;t++&lt;&lt;":"&lt;&lt;endl&lt;&lt;ans&lt;&lt;" "&lt;&lt;besti&lt;&lt;" "&lt;&lt;bestj&lt;&lt;" "&lt;&lt;endl; printf("Case %d:\n%d %d %d\n",t++,ans,besti,bestj); if(T) printf("\n");// if(T)cout&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Longest Ordered Subsequence POJ - 2533]]></title>
    <url>%2F2019%2F02%2F09%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2FLongest%20Ordered%20Subsequence%20POJ%20-%202533%2F</url>
    <content type="text"><![CDATA[题目A numeric sequence of ai is ordered if a1 &lt; a2 &lt; … &lt; aN. Let the subsequence of the given numeric sequence ( a1, a2, …, aN) be any sequence ( ai1, ai2, …, aiK), where 1 &lt;= i1 &lt; i2 &lt; … &lt; iK &lt;= N. For example, sequence (1, 7, 3, 5, 9, 4, 8) has ordered subsequences, e. g., (1, 7), (3, 4, 8) and many others. All longest ordered subsequences are of length 4, e. g., (1, 3, 5, 8).Your program, when given the numeric sequence, must find the length of its longest ordered subsequence.InputThe first line of input file contains the length of sequence N. The second line contains the elements of sequence - N integers in the range from 0 to 10000 each, separated by spaces. 1 &lt;= N &lt;= 1000OutputOutput file must contain a single integer - the length of the longest ordered subsequence of the given sequence.Sample Input1271 7 3 5 9 4 8 Sample Output14 思路dp[i]=max(dp[j]){0&lt;=j&lt;i} 代码1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;using namespace std;const int MAXSIZE=1005;int dp[MAXSIZE];int arr[MAXSIZE];int find(int x)&#123; int max=0,j=0; for(int i=0;i&lt;x;i++) if(max&lt;dp[i]&amp;&amp;arr[x]&gt;arr[i])&#123; max=dp[i]; j=i; &#125; return max;&#125; int main()&#123; int N; cin&gt;&gt;N; for(int i=0;i&lt;N;i++)&#123; cin&gt;&gt;arr[i]; dp[i]=1; &#125; for(int i=1;i&lt;N;i++) dp[i]+=find(i); int ans=0; for(int i=0;i&lt;N;i++) if(ans&lt;dp[i]) ans=dp[i]; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迷宫城堡 HDU - 1269]]></title>
    <url>%2F2019%2F02%2F07%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E8%BF%B7%E5%AE%AB%E5%9F%8E%E5%A0%A1%20HDU%20-%201269%20%2F</url>
    <content type="text"><![CDATA[题目为了训练小希的方向感，Gardon建立了一座大城堡，里面有N个房间(N&lt;=10000)和M条通道(M&lt;=100000)，每个通道都是单向的，就是说若称某通道连通了A房间和B房间，只说明可以通过这个通道由A房间到达B房间，但并不说明通过它可以由B房间到达A房间。Gardon需要请你写个程序确认一下是否任意两个房间都是相互连通的，即：对于任意的i和j，至少存在一条路径可以从房间i到房间j，也存在一条路径可以从房间j到房间i。Input输入包含多组数据，输入的第一行有两个数：N和M，接下来的M行每行有两个数a和b，表示了一条通道可以从A房间来到B房间。文件最后以两个0结束。Output对于输入的每组数据，如果任意两个房间都是相互连接的，输出”Yes”，否则输出”No”。Sample Input1234567893 31 22 33 13 31 22 33 20 0 Sample Output12YesNo 思路用vector来表示邻接表，对每个元素深搜一遍。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;vector&gt;using namespace std;const int MAXSIZE=10000+5;vector&lt;int &gt; edge[MAXSIZE];int visit[MAXSIZE];void DFS(int count)&#123; visit[count]=1; for(int i=0;i&lt;int(edge[count].size());i++)&#123; int x=edge[count][i]; if(visit[x]==0) DFS(x); &#125;&#125;int main()&#123; int N,M; while(cin&gt;&gt;N&gt;&gt;M)&#123; if(N==0&amp;&amp;M==0) break; for(int i=1;i&lt;=N;i++) edge[i].clear(); for(int i=1;i&lt;=M;i++)&#123; int a,b; cin&gt;&gt;a&gt;&gt;b; edge[a].push_back(b); &#125; int flag=1; for(int i=1;i&lt;=N;i++)&#123; memset(visit,0,sizeof(visit)); DFS(i); for(int j=1;j&lt;=N;j++) if(visit[j]==0)&#123; flag=0; break; &#125; if(flag==0) break; &#125; if(flag==0) cout&lt;&lt;&quot;No&quot;; else cout&lt;&lt;&quot;Yes&quot;; cout&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[确定比赛名次 HDU - 1285（拓扑）]]></title>
    <url>%2F2019%2F02%2F07%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E7%A1%AE%E5%AE%9A%E6%AF%94%E8%B5%9B%E5%90%8D%E6%AC%A1%20HDU%20-%201285%EF%BC%88%E6%8B%93%E6%89%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目有N个比赛队（1&lt;=N&lt;=500），编号依次为1，2，3，。。。。，N进行比赛，比赛结束后，裁判委员会要将所有参赛队伍从前往后依次排名，但现在裁判委员会不能直接获得每个队的比赛成绩，只知道每场比赛的结果，即P1赢P2，用P1，P2表示，排名时P1在P2之前。现在请你编程序确定排名。Input输入有若干组，每组中的第一行为二个数N（1&lt;=N&lt;=500），M；其中N表示队伍的个数，M表示接着有M行的输入数据。接下来的M行数据中，每行也有两个整数P1，P2表示即P1队赢了P2队。Output给出一个符合要求的排名。输出时队伍号之间有空格，最后一名后面没有空格。 其他说明：符合条件的排名可能不是唯一的，此时要求输出时编号小的队伍在前；输入数据保证是正确的，即输入数据确保一定能有一个符合要求的排名。Sample Input12344 31 22 34 3 Sample Output11 2 4 3 思路priority_queue&lt;int,vector&lt; int&gt;,greater&lt; int&gt; &gt; qu;优先队列使用。用优先队列记录出度为0的点。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;stack&gt;#include&lt;queue&gt;using namespace std;const int MAXSIZE=500+5;struct node&#123; int value; struct node *next;&#125;; struct list&#123; int count; node *first;&#125;;struct Graph&#123; struct list arr[MAXSIZE];&#125;;void topsort(struct Graph *&amp;G,int N)&#123; priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; qu; for(int i=1;i&lt;=N;i++) if(G-&gt;arr[i].count==0) qu.push(i); int num=1; while(!qu.empty())&#123; int x=qu.top(); qu.pop(); if(num!=N)&#123; cout&lt;&lt;x&lt;&lt;&apos; &apos;; num++; &#125; else cout&lt;&lt;x&lt;&lt;endl; struct node *p; p=G-&gt;arr[x].first; while(p!=NULL)&#123; G-&gt;arr[p-&gt;value].count--; if(G-&gt;arr[p-&gt;value].count==0) qu.push(p-&gt;value); p=p-&gt;next; &#125; &#125;&#125;int main()&#123; int N,M; while(cin&gt;&gt;N&gt;&gt;M)&#123; struct Graph *G=(struct Graph *)malloc(sizeof(struct Graph)); for(int i=1;i&lt;=N;i++)&#123; G-&gt;arr[i].first=NULL; G-&gt;arr[i].count=0; &#125; for(int i=0;i&lt;M;i++)&#123; int a,b; cin&gt;&gt;a&gt;&gt;b; struct node *p=(struct node *)malloc(sizeof(struct node)); p-&gt;value=b; p-&gt;next=G-&gt;arr[a].first; G-&gt;arr[a].first=p; G-&gt;arr[b].count++; &#125; topsort(G,N); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排名 HDU - 1236]]></title>
    <url>%2F2019%2F02%2F05%2FSTL%2F%E6%8E%92%E5%90%8D%20HDU%20-%201236%2F</url>
    <content type="text"><![CDATA[题目今天的上机考试虽然有实时的Ranklist，但上面的排名只是根据完成的题数排序，没有考虑每题的分值，所以并不是最后的排名。给定录取分数线，请你写程序找出最后通过分数线的考生，并将他们的成绩按降序打印。Input测试输入包含若干场考试的信息。每场考试信息的第1行给出考生人数N ( 0 &lt; N &lt; 1000 )、考题数M ( 0 &lt; M &lt; = 10 )、分数线（正整数）G；第2行排序给出第1题至第M题的正整数分值；以下N行，每行给出一名考生的准考证号（长度不超过20的字符串）、该生解决的题目总数m、以及这m道题的题号 （题目号由1到M）。当读入的考生人数为0时，输入结束，该场考试不予处理。Output对每场考试，首先在第1行输出不低于分数线的考生人数n，随后n行按分数从高到低输出上线考生的考号与分数，其间用1空格分隔。若有多名考生分数相同，则按他们考号的升序输出。Sample Input12345678910111213144 5 2510 10 12 13 15CS004 3 5 1 3CS003 5 2 4 1 3 5CS002 2 1 2CS001 3 2 3 51 2 4010 30CS001 1 22 3 2010 10 10CS000000000000000001 0CS000000000000000002 2 1 20 Sample Output123456789101112133CS003 60CS001 37CS004 3701CS000000000000000002 20``` HintHuge input, scanf is recommended.# 思路sort函数的应用。# 代码 #include #include #includeusing namespace std;struct List{ string str; int score;};bool cmp(struct List a,struct List b){ if(a.score==b.score) return a.str&lt;b.str; return a.score&gt;b.score;}int main(){ int people,size,maxScore; while(scanf(“%d”,&amp;people)&amp;&amp;people!=0){ scanf(“%d%d”,&amp;size,&amp;maxScore); int perScore[11]; for(int i=1;i&lt;=size;i++) scanf(“%d”,&amp;perScore[i]); struct List stu[1000+5]; int count=0; for(int i=0;i&lt;people;i++){ stu[i].score=0; cin&gt;&gt;stu[i].str; int a; scanf(“%d”,&amp;a); while(a–){ int b; scanf(“%d”,&amp;b); stu[i].score+=perScore[b]; } if(stu[i].score&gt;=maxScore) count++; } sort(stu,stu+people,cmp); cout&lt;&lt;count&lt;&lt;endl; for(int i=0;i&lt;people;i++) if(stu[i].score&gt;=maxScore) cout&lt;&lt;stu[i].str&lt;&lt;’ ‘&lt;&lt;stu[i].score&lt;&lt;endl; } return 0;}`]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>水题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gunner II HDU - 5233]]></title>
    <url>%2F2019%2F02%2F05%2FSTL%2FGunner%20II%20HDU%20-%205233%20%2F</url>
    <content type="text"><![CDATA[题目Long long ago, there was a gunner whose name is Jack. He likes to go hunting very much. One day he go to the grove. There are n birds and n trees. The i-th bird stands on the top of the i-th tree. The trees stand in straight line from left to the right. Every tree has its height. Jack stands on the left side of the left most tree. When Jack shots a bullet in height H to the right, the nearest bird which stands in the tree with height H will falls.Jack will shot many times, he wants to know which bird will fall during each shot.InputThere are multiple test cases (about 5), every case gives n, m in the first line, n indicates there are n trees and n birds, m means Jack will shot m times.In the second line, there are n numbers h[1],h[2],h[3],…,h[n] which describes the height of the trees.In the third line, there are m numbers q[1],q[2],q[3],…,q[m] which describes the height of the Jack’s shots.Please process to the end of file.“Technical Specification”All input items are integers.1&lt;=n,m&lt;=100000(10^5)1&lt;=h[i],q[i]&lt;=1000000000(10^9)OutputFor each q[i], output an integer in a single line indicates the id of bird Jack shots down. If Jack can’t shot any bird, just output -1. The id starts from 1.Sample Input1235 51 2 3 4 11 3 1 4 2 Sample Output1234567891013542``` # 思路定义map容器时，元素类型设置为queue队列。学到了学到了，tql。# 代码 #include #include #include #includeusing namespace std;int main(){ int n,m; while(cin&gt;&gt;n&gt;&gt;m){ map&lt;int,queue &gt; mp; int a; for(int i=1;i&lt;=n;i++){ scanf(“%d”,&amp;a); mp[a].push(i); } for(int i=0;i&lt;m;i++){ scanf(“%d”,&amp;a); if(mp[a].size()==0) cout&lt;&lt;”-1”; else{ cout&lt;&lt;mp[a].front(); mp[a].pop(); } cout&lt;&lt;endl; } } return 0;}`]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单词数 HDU - 2072]]></title>
    <url>%2F2019%2F02%2F04%2FSTL%2F%E5%8D%95%E8%AF%8D%E6%95%B0%20HDU%20-%202072%2F</url>
    <content type="text"><![CDATA[题目lily的好朋友xiaoou333最近很空，他想了一件没有什么意义的事情，就是统计一篇文章里不同单词的总数。下面你的任务是帮助xiaoou333解决这个问题。Input有多组数据，每组一行，每组就是一篇小文章。每篇小文章都是由小写字母和空格组成，没有标点符号，遇到#时表示输入结束。Output每组只输出一个整数，其单独成行，该整数代表一篇文章里不同单词的总数。Sample Input12you are my friend# Sample Output14 思路练习map？ 代码1234567891011121314151617181920212223#include&lt;iostream&gt;#include&lt;map&gt;using namespace std;int main()&#123; map&lt;string,int&gt; mp; string str; int k=0; while(getline(cin,str)&amp;&amp;str!=&quot;#&quot;)&#123; string t=&quot;&quot;; k=0; mp.clear(); for(int i=0;i&lt;int(str.size());i++)&#123; t=&quot;&quot;; while(str[i]&lt;=&apos;z&apos;&amp;&amp;str[i]&gt;=&apos;a&apos;) t+=str[i++]; if(t!=&quot;&quot;) mp[t]=k++; &#125; cout&lt;&lt;mp.size()&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Repair the Wall HDU - 2124]]></title>
    <url>%2F2019%2F02%2F03%2F%E8%B4%AA%E5%BF%83%2FRepair%20the%20Wall%20HDU%20-%202124%20%2F</url>
    <content type="text"><![CDATA[题目Long time ago , Kitty lived in a small village. The air was fresh and the scenery was very beautiful. The only thing that troubled her is the typhoon. When the typhoon came, everything is terrible. It kept blowing and raining for a long time. And what made the situation worse was that all of Kitty’s walls were made of wood.One day, Kitty found that there was a crack in the wall. The shape of the crack isa rectangle with the size of 1×L (in inch). Luckly Kitty got N blocks and a saw(锯子) from her neighbors.The shape of the blocks were rectangle too, and the width of all blocks were 1 inch. So, with the help of saw, Kitty could cut down some of the blocks(of course she could use it directly without cutting) and put them in the crack, and the wall may be repaired perfectly, without any gap. Now, Kitty knew the size of each blocks, and wanted to use as fewer as possible of the blocks to repair the wall, could you help her ?InputThe problem contains many test cases, please process to the end of file( EOF ).Each test case contains two lines.In the first line, there are two integers L(0&lt;L&lt;1000000000) and N(0&lt;=N&lt;600) whichmentioned above.In the second line, there are N positive integers. The i th integer Ai(0&lt;Ai&lt;1000000000 ) means that the i th block has the size of 1×Ai (in inch).OutputFor each test case , print an integer which represents the minimal number of blocks are needed.If Kitty could not repair the wall, just print “impossible” instead.Sample Input12345 33 2 15 22 1 Sample Output122impossible 思路这道题的大致意思是有个长为Len的缺口，要用尽可能少的砖去补上它，题目告诉了砖的长度。对砖的长度从大到小排序再贪心即可 代码123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int MAXSIZE=600+6;bool cmp(int a,int b)&#123;return a&gt;b;&#125;int main()&#123; int Len,N; while(cin&gt;&gt;Len&gt;&gt;N)&#123; int arr[MAXSIZE]; for(int i=0;i&lt;N;i++) scanf(&quot;%d&quot;,&amp;arr[i]); sort(arr,arr+N,cmp); int ans=0; int sum=0; for(int i=0;i&lt;N;i++)&#123; if(sum&lt;Len)&#123; ans++; sum+=arr[i]; &#125; &#125; if(sum&lt;Len) cout&lt;&lt;&quot;impossible&quot;&lt;&lt;endl; else cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>贪心算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最长上升子序列 CSU - 1047]]></title>
    <url>%2F2019%2F02%2F03%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%20CSU%20-%201047%20%2F</url>
    <content type="text"><![CDATA[题目名词解释： 一串数字比如1、5、3、6、9、8、10，它的子序列是从左到右不连续的若干个数，比如1、5、6，3、9、8、10都是它的子序列。 最长上升子序列即从左到右严格增长的最长的一个子序列，1、5、6、9、10就是这个序列的一个最长上升子序列。 给出若干序列，求出每个序列的最长上升子序列长度。Input 多组数据，每组第一行正整数n，1 &lt;= n &lt;= 1000，第二行n个空格隔开的不大于1,000,000的正整数。 Output 每组数据输出一行，最长上升子序列的长度。 Sample Input1271 5 3 6 9 8 10 Sample Output15 思路若一个序列为a[n]，记录当前元素的最长上升序列的长度为dp[n]。每个元素要满足1# 代码 #include #includeusing namespace std;const int MAXSIZE=1000+5;int getMax(int dp[],int arr[],int x){ int max=0; for(int i=0;i&lt;x;i++) //求0-x间的最大dp if(arr[i]&lt;arr[x]){ if(dp[i]&gt;max) max=dp[i]; } return max;}int main(){ int dp[MAXSIZE]; int arr[MAXSIZE]; int n; while(cin&gt;&gt;n){ for(int i=0;i&lt;n;i++){ scanf(“%d”,&amp;arr[i]); dp[i]=1; } for(int i=1;i&lt;n;i++) dp[i]+=getMax(dp,arr,i); int ans=0; for(int i=0;i&lt;n;i++) if(ans&lt;dp[i]) ans=dp[i]; cout&lt;&lt;ans&lt;&lt;endl; } return 0;}`]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一只小蜜蜂... HDU - 2044 (简单dp)]]></title>
    <url>%2F2019%2F02%2F02%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F%E4%B8%80%E5%8F%AA%E5%B0%8F%E8%9C%9C%E8%9C%82...%20HDU%20-%202044%20(%E7%AE%80%E5%8D%95dp)%2F</url>
    <content type="text"><![CDATA[题目有一只经过训练的蜜蜂只能爬向右侧相邻的蜂房，不能反向爬行。请编程计算蜜蜂从蜂房a爬到蜂房b的可能路线数。其中，蜂房的结构如下所示。 Input输入数据的第一行是一个整数N,表示测试实例的个数，然后是N 行数据，每行包含两个整数a和b(0&lt;a&lt;b&lt;50)。Output对于每个测试实例，请输出蜜蜂从蜂房a爬到蜂房b的可能路线数，每个实例的输出占一行。Sample Input12321 23 6 Sample Output1213 思路由蜂房的结构可以看到，蜂房1可以直接到达蜂房3，蜂房2也可以直接达到蜂房3，那么到达蜂房3的路线为蜂房1的路线加蜂房2的路线，递推公式12此题注意数值范围，（long long int ）。# 代码 #includeusing namespace std;int main(){ int n; long long int dp[550]; dp[1]=1; dp[2]=1; cin&gt;&gt;n; while(n–){ int a,b; cin&gt;&gt;a&gt;&gt;b; dp[a]=1; dp[a+1]=1; for(int i=a+2;i&lt;=b;i++) dp[i]=dp[i-1]+dp[i-2]; cout&lt;&lt;dp[b]&lt;&lt;endl; } return 0;}`]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数塔 HDU - 2084]]></title>
    <url>%2F2019%2F02%2F02%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F%E6%95%B0%E5%A1%94%20HDU%20-%202084%20%2F</url>
    <content type="text"><![CDATA[题目在讲述DP算法的时候，一个经典的例子就是数塔问题，它是这样描述的： 有如下所示的数塔，要求从顶层走到底层，若每一步只能走到相邻的结点，则经过的结点的数字之和最大是多少？ 已经告诉你了，这是个DP的题目，你能AC吗?Input输入数据首先包括一个整数C,表示测试实例的个数，每个测试实例的第一行是一个整数N(1 &lt;= N &lt;= 100)，表示数塔的高度，接下来用N行数字表示数塔，其中第i行有个i个整数，且所有的整数均在区间[0,99]内。Output对于每个测试实例，输出可能得到的最大和，每个实例的输出占一行。Sample Input12345671573 88 1 0 2 7 4 44 5 2 6 5 Sample Output130 思路对每一个节点，受它肩上的两个节点值的影响。即1dp[i][j]+=dp[i-1][j-1] 或1dp[i][j]+=dp[i-1][j] 要求最大的节点路径，只需要加上两个节点值取大的那个即可。最后比较最底层的路径值。 代码12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;using namespace std;const int MAXSIZE=100+5;int dp[MAXSIZE][MAXSIZE];int main()&#123; int Case; cin&gt;&gt;Case; while(Case--)&#123; int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=i;j++) cin&gt;&gt;dp[i][j]; dp[2][1]+=dp[1][1]; dp[2][2]+=dp[1][1]; for(int i=3;i&lt;=n;i++)&#123; dp[i][1]+=dp[i-1][1]; dp[i][i]+=dp[i-1][i-1]; &#125; for(int i=3;i&lt;=n;i++)&#123; for(int j=2;j&lt;i;j++)&#123; int temp=dp[i][j]+dp[i-1][j-1]; if(temp&gt;=(dp[i][j]+dp[i-1][j])) dp[i][j]=temp; else dp[i][j]+=dp[i-1][j]; &#125; &#125; int ans=0; for(int i=1;i&lt;=n;i++) if(dp[n][i]&gt;ans) ans=dp[n][i]; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[今年暑假不AC HDU - 2037]]></title>
    <url>%2F2019%2F02%2F01%2F%E8%B4%AA%E5%BF%83%2F%E4%BB%8A%E5%B9%B4%E6%9A%91%E5%81%87%E4%B8%8DAC%20HDU%20-%202037%20%2F</url>
    <content type="text"><![CDATA[题目“今年暑假不AC？”“是的。”“那你干什么呢？”“看世界杯呀，笨蛋！”“@#$%^&amp;*%…” 确实如此，世界杯来了，球迷的节日也来了，估计很多ACMer也会抛开电脑，奔向电视了。作为球迷，一定想看尽量多的完整的比赛，当然，作为新时代的好青年，你一定还会看一些其它的节目，比如新闻联播（永远不要忘记关心国家大事）、非常6+7、超级女生，以及王小丫的《开心辞典》等等，假设你已经知道了所有你喜欢看的电视节目的转播时间表，你会合理安排吗？（目标是能看尽量多的完整节目）Input输入数据包含多个测试实例，每个测试实例的第一行只有一个整数n(n&lt;=100)，表示你喜欢看的节目的总数，然后是n行数据，每行包括两个数据Ti_s,Ti_e (1&lt;=i&lt;=n)，分别表示第i个节目的开始和结束时间，为了简化问题，每个时间都用一个正整数表示。n=0表示输入结束，不做处理。Output对于每个测试实例，输出能完整看到的电视节目的个数，每个测试实例的输出占一行。Sample Input1234567891011121314121 33 40 73 815 1915 2010 158 186 125 104 142 90 Sample Output15 思路简单题。对节目的结束时间从低到高排序，再贪心 代码1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int MAXSIZE=100+5;struct Time&#123; int begin; int end;&#125;;bool cmp(struct Time a,struct Time b)&#123; return a.end&lt;b.end;&#125;int main()&#123; int N; while(cin&gt;&gt;N)&#123; if(N==0) break; struct Time arr[MAXSIZE]; for(int i=0;i&lt;N;i++) cin&gt;&gt;arr[i].begin&gt;&gt;arr[i].end; sort(arr,arr+N,cmp); int ans=1; int j=0; for(int i=1;i&lt;N;i++) if(arr[i].begin&gt;=arr[j].end)&#123; ans++; j=i; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>贪心算法</category>
      </categories>
      <tags>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[超级楼梯 HDU - 2041 （简单dp）]]></title>
    <url>%2F2019%2F02%2F01%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F%E8%B6%85%E7%BA%A7%E6%A5%BC%E6%A2%AF%20HDU%20-%202041%20%EF%BC%88%E7%AE%80%E5%8D%95dp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目有一楼梯共M级，刚开始时你在第一级，若每次只能跨上一级或二级，要走上第M级，共有多少种走法？Input输入数据首先包含一个整数N，表示测试实例的个数，然后是N行数据，每行包含一个整数M（1&lt;=M&lt;=40）,表示楼梯的级数。Output对于每个测试实例，请输出不同走法的数量Sample Input123223 Sample Output1212 思路对于第n（n&gt;3）级阶梯，可由n-2级阶梯走2步或者由n-1级阶梯走1步到达，可得状态转移方程dp[n]=dp[n-1]+dp[n-2] 代码1234567891011121314151617#include&lt;iostream&gt;using namespace std;int main()&#123; int N; int dp[41]; dp[2]=1; dp[3]=2; for(int i=4;i&lt;=40;i++) dp[i]=dp[i-1]+dp[i-2]; cin&gt;&gt;N; while(N--)&#123; int a; cin&gt;&gt;a; cout&lt;&lt;dp[a]&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[产生冠军 HDU - 2094]]></title>
    <url>%2F2019%2F02%2F01%2FSTL%2F%E4%BA%A7%E7%94%9F%E5%86%A0%E5%86%9B%20HDU%20-%202094%2F</url>
    <content type="text"><![CDATA[题目有一群人，打乒乓球比赛，两两捉对撕杀，每两个人之间最多打一场比赛。球赛的规则如下：如果A打败了B，B又打败了C，而A与C之间没有进行过比赛，那么就认定，A一定能打败C。如果A打败了B，B又打败了C，而且，C又打败了A，那么A、B、C三者都不可能成为冠军。根据这个规则，无需循环较量，或许就能确定冠军。你的任务就是面对一群比赛选手，在经过了若干场撕杀之后，确定是否已经实际上产生了冠军。Input输入含有一些选手群，每群选手都以一个整数n(n&lt;1000)开头，后跟n对选手的比赛结果，比赛结果以一对选手名字（中间隔一空格）表示，前者战胜后者。如果n为0，则表示输入结束。Output对于每个选手群，若你判断出产生了冠军，则在一行中输出“Yes”，否则在一行中输出“No”。Sample Input12345678910113Alice BobSmith JohnAlice Smith5a cc dd eb ea d0 Sample Output12YesNo 思路用map容器给每个人编号，如果谁输了，就标记下，最后统计未被标记的人数即可。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;string&gt; #include&lt;algorithm&gt;using namespace std;const int MAXSIZE=1000+5;int countNum=0;int flag[MAXSIZE]=&#123;0&#125;;map&lt;string,int&gt;mp;void arr(string str[],int &amp;x,int &amp;y)&#123; if(mp.count(str[0])) x=mp[str[0]]; else&#123; mp[str[0]]=countNum++; x=mp[str[0]]; &#125; if(mp.count(str[1])) y=mp[str[1]]; else&#123; mp[str[1]]=countNum++; y=mp[str[1]]; &#125; &#125;int main()&#123; int N; while(cin&gt;&gt;N)&#123; if(N==0) break; for(int i=0;i&lt;countNum;i++) flag[i]=0; mp.clear(); countNum=0; for(int i=0;i&lt;N;i++)&#123; string str[2]; cin&gt;&gt;str[0]&gt;&gt;str[1]; int x,y; arr(str,x,y); flag[y]=1; &#125; int ans=0; for(int i=0;i&lt;countNum;i++) if(flag[i]==0) ans++; if(ans==1) cout&lt;&lt;&quot;Yes&quot;; else cout&lt;&lt;&quot;No&quot;; cout&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最少拦截系统 HDU - 1257]]></title>
    <url>%2F2019%2F01%2F31%2F%E8%B4%AA%E5%BF%83%2F%E6%9C%80%E5%B0%91%E6%8B%A6%E6%88%AA%E7%B3%BB%E7%BB%9F%20HDU%20-%201257%20%2F</url>
    <content type="text"><![CDATA[题目某国为了防御敌国的导弹袭击,发展出一种导弹拦截系统.但是这种导弹拦截系统有一个缺陷:虽然它的第一发炮弹能够到达任意的高度,但是以后每一发炮弹都不能超过前一发的高度.某天,雷达捕捉到敌国的导弹来袭.由于该系统还在试用阶段,所以只有一套系统,因此有可能不能拦截所有的导弹.怎么办呢?多搞几套系统呗!你说说倒蛮容易,成本呢?成本是个大问题啊.所以俺就到这里来求救了,请帮助计算一下最少需要多少套拦截系统.Input输入若干组数据.每组数据包括:导弹总个数(正整数),导弹依此飞来的高度(雷达给出的高度数据是不大于30000的正整数,用空格分隔)Output对应每组数据输出拦截所有导弹最少要配备多少套这种导弹拦截系统.Sample Input18 389 207 155 300 299 170 158 65 Sample Output12 题解导弹是依次飞来的并且每一发都不能超过前一发的高度，可知当后一个导弹的高度高于前一个时，就需要一个新的拦截系统。如果仅仅是这么想，就会被坑了。因为之前的拦截系统的最后一发炮弹的高度可能比新的拦截系统的高度要高。比如这组数据 389 207 155 300 299 170 158 65 100，不想清楚后一种可能那么就需要三套，实际上两套就行了。 代码123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int MAXSIZE=50000;int main()&#123; int n; while(cin&gt;&gt;n)&#123; int sum=0; int arr[MAXSIZE]; for(int i=0;i&lt;n;i++) cin&gt;&gt;arr[i]; int check=1; for(int i=0;i&lt;n;)&#123; if(check==i) break; check=i; int first=arr[i]; int flag=1; for(int j=i+1;j&lt;n;j++)&#123; if(first&gt;arr[j]&amp;&amp;arr[j]!=0)&#123; first=arr[j]; arr[j]=0; &#125; if(flag==1&amp;&amp;first&lt;arr[j])&#123; flag=0; i=j; &#125; &#125; &#125; for(int i=0;i&lt;n;i++) if(arr[i]!=0) sum++; cout&lt;&lt;sum&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>贪心算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Saving HDU HDU - 2111]]></title>
    <url>%2F2019%2F01%2F31%2F%E8%B4%AA%E5%BF%83%2FSaving%20HDU%20HDU%20-%202111%20%2F</url>
    <content type="text"><![CDATA[题目话说上回讲到海东集团面临内外交困，公司的元老也只剩下XHD夫妇二人了。显然，作为多年拼搏的商人，XHD不会坐以待毙的。 一天，当他正在苦思冥想解困良策的时候，突然想到了自己的传家宝，那是公司成立的时候，父亲作为贺礼送来的一个锦囊，徐父当时交代，不到万不得已的时候，不要打开它。“现在不正是最需要的时候吗？”，一边想，XHD一边找到了这个精心保管的锦囊，打开一看，里面只有一句话“杭城北麓千人洞有宝”。 二话不说，XHD拿起一个大口袋就出发了，这个千人洞他是知道的，小的时候，爸爸曾经带他来过这个隐蔽的路口，并告诉他，这是千人洞。他现在才明白爸爸当初这句话的含义。 尽管有点印象，XHD还是花了很大的精力才找到这个异常隐蔽的洞口，走进一看，几乎惊呆了，真的是眼花缭乱！不过尽管宝贝的种类不少，但是每种宝贝的量并不多，当然，每种宝贝单位体积的价格也不一样，为了挽救HDU，现在请你帮忙尽快计算出来XHD最多能带回多少价值的宝贝？（假设宝贝可以分割，分割后的价值和对应的体积成正比）Input输入包含多个测试实例，每个实例的第一行是两个整数v和n(v,n&lt;100)，分别表示口袋的容量和宝贝的种类，接着的n行每行包含2个整数pi和mi(0&lt;pi,mi&lt;10)，分别表示某种宝贝的单价和对应的体积，v为0的时候结束输入。Output对于每个测试实例，请输出XHD最多能取回多少价值的宝贝，每个实例的输出占一行。Sample Input12342 23 12 30 Sample Output15 经过锦囊相助，HDU会脱离危机吗？欲知后事如何，且听下回分解—— 题解对宝贝的价值从高到底排序，再贪心 代码12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int MAXSIZE=500+5;struct Node&#123; int pi; int mi;&#125;;bool cmp(struct Node a,struct Node b)&#123; return a.pi&gt;b.pi;&#125;int main()&#123; int v,n; while(cin&gt;&gt;v)&#123; if(v==0) break; cin&gt;&gt;n; struct Node arr[MAXSIZE]; for(int i=0;i&lt;n;i++) cin&gt;&gt;arr[i].pi&gt;&gt;arr[i].mi; sort(arr,arr+n,cmp); int sum=0; int allVal=0; int i=0; for(i=0;i&lt;n&amp;&amp;((sum+arr[i].mi)&lt;=v);i++)&#123; sum+=arr[i].mi; allVal+=arr[i].pi*arr[i].mi; //if(i&gt;=n) break; &#125; if(i&lt;n) allVal+=(v-sum)*arr[i].pi; cout&lt;&lt;allVal&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>贪心算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[老人是真饿了 HDU - 2187]]></title>
    <url>%2F2019%2F01%2F31%2F%E8%B4%AA%E5%BF%83%2F%E8%80%81%E4%BA%BA%E6%98%AF%E7%9C%9F%E9%A5%BF%E4%BA%86%20HDU%20-%202187%20%2F</url>
    <content type="text"><![CDATA[题目时间：2008年5月16日（震后第4天）地点：汶川县牛脑寨人物：羌族老奶奶 【转载整理】牛脑寨是一个全村600多人的羌族寨子，震后几天，这里依然能常常听到隆隆的声音，那是对面山上石头不断滑落的声音。在完成整个突击队的抢修移动基站的任务后，我提着相机开始记录这里的受创情况。突然，我的视线里出现一个羌族老人，这让我无比的震惊，要知道，那是一个极陡的坡，这个佝偻着腰的老人是怎么艰难地爬上来的？她上来做什么？ 老人背后是极陡的坡，她只有一只眼睛有依稀的视力，望着满地废墟，她徘徊了很久。家在哪里，她极力地用很低的视力找寻着。她曾经的家就在旁边，但是满目废墟已经让老人看不出来。她举目远眺，期望那里能看到家的一点点痕迹。原来家就在旁边，左手抓住一个房橼，努力让自己站住，地震过去三天了，她第一次回到曾经的家。 一个倒塌的柜子，里面装着一丝希望，老人很吃力地搬动掩盖在柜子上的薪柴。老人找到一把木匠用的刨子，老泪纵横，或许有哪个逝去的亲人是木匠。睹物思人，逝者已矣。 继续找，一把散碎的挂面出现在我的眼前。她颤颤巍巍地捞起铺满灰尘的挂面，再次流出了眼泪……看着她仔细地把挂面放进胸前的围腰里，我顿然感觉到，这是老人在得到外援之前赖以生存的口粮了，如果不是交通中断，外部救援进不来，老人家又何必拖着80多岁的躯体，强忍失去亲人的痛苦，重新回到这夺取她亲人生命的废墟，寻找这点点挂面？老人是真饿了…… 老人佝偻着腰，低声喃喃地念着那两句话“你们走了，我可怎么活”，拿着那对我们身处城市的人们微不足道的挂面，远去了…… PS: 拍完这组照片后我才知道，5月14号军用运输飞机第一次给汶川空投救援物资就掉在牛脑寨，受灾的村民们没有占为己有，而是汗流浃背地走了两个小时背到山下的县城交给政府。 对于幸存的灾民来说，最急待解决的显然是温饱问题，救灾部队一边在组织人员全力打通交通，一边在组织采购粮食。现在假设下拨了一定数量的救灾经费要去市场采购大米（散装）。如果市场有m种大米，各种大米的单价和重量已知，请问，为了满足更多灾民的需求，最多能采购多少重量的大米呢？Input输入数据首先包含一个正整数C，表示有C组测试用例，每组测试用例的第一行是两个整数n和m（0&lt;n&lt;=1000,0&lt;m&lt;=1000）,分别表示经费的金额和大米的种类，然后是m行数据，每行包含2个整数p和h(1&lt;=p&lt;=25,1&lt;=h&lt;=100)，分别表示单价和对应大米的重量。Output对于每组测试数据，请输出能够购买大米的最多重量（你可以假设经费买不光所有的大米）。每个实例的输出占一行，保留2位小数。Sample Input123417 23 34 4 Sample Output12.33 题解对大米的价格从低到高排序，再贪心过一遍 代码1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;algorithm&gt; using namespace std;const int MAXSIZE=1000+5;struct Node&#123; int p; int h;&#125;;bool cmp(struct Node a,struct Node b)&#123; return a.p&lt;b.p;&#125;int main()&#123; int Case; cin&gt;&gt;Case; while(Case--)&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; struct Node arr[MAXSIZE]; for(int i=0;i&lt;m;i++) cin&gt;&gt;arr[i].p&gt;&gt;arr[i].h; sort(arr,arr+m,cmp); int i=0; int sum=0; double allVal=0; int S=0; for(i=0;i&lt;m&amp;&amp;((sum+arr[i].p*arr[i].h)&lt;=n);i++)&#123; sum+=arr[i].p*arr[i].h; S+=arr[i].h; &#125; if(i&lt;m) allVal=(n-sum)/arr[i].p+(n-sum)%arr[i].p*1.0/arr[i].p; printf(&quot;%.2lf\n&quot;,allVal+S); &#125; return 0;&#125;]]></content>
      <categories>
        <category>贪心算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bookshelf]]></title>
    <url>%2F2019%2F01%2F30%2F%E8%B4%AA%E5%BF%83%2Fbookshelf%2F</url>
    <content type="text"><![CDATA[题目Farmer John recently bought a bookshelf for cow library, but the shelf is getting filled up quite quickly, and now the only available space is at the top. Each of the N cows (1 &lt;= N &lt;= 20,000) has some height of H_i (1 &lt;= H_i &lt;= 10,000) and a total height summed across all N cows of S. The bookshelf has a height of B (1 &lt;= B &lt;= S &lt; 2,000,000,007). To reach the top of the bookshelf taller than the tallest cow, one or more of the cows can stand on top of each other in a stack, so that their total height is the sum of each of their individual heights. This total height must be no less than the height of the bookshelf. Since more cows than necessary in the stack can be dangerous, your job is to find the set of cows that produces a stack of the smallest number of cows possible such that the stack can reach the bookshelf.Input Line 1: Two space-separated integers: N and B Lines 2..N+1: Line i+1 contains a single integer: H_iOutput Line 1: A single integer representing the size of the smallest set of cows that can reach the bookshelf.Sample Input12345676 4061811131911 Sample Output13 Hint1234567INPUT DETAILS: Six cows; bookshelf height 40. Cow heights fall in the range 6..19. OUTPUT DETAILS: One way to reach 40 with 3 cows is 18+11+13; many others exist 题解不断贪最大高度直到高于height即可。 代码1234567891011121314151617181920212223#include&lt;iostream&gt;#include&lt;algorithm&gt;const int MAXSIZE=20000+5;using namespace std;bool cmp(int a,int b)&#123;return a&gt;b;&#125;int main()&#123; int N,height; while(cin&gt;&gt;N&gt;&gt;height)&#123; int arr[MAXSIZE]; for(int i=0;i&lt;N;i++) cin&gt;&gt;arr[i]; sort(arr,arr+N,cmp); int sum=0; int i=0; for(i=0;i&lt;N;i++)&#123; sum+=arr[i]; if(sum&gt;=height) break; &#125; cout&lt;&lt;i&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>贪心算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[金银岛]]></title>
    <url>%2F2019%2F01%2F30%2F%E8%B4%AA%E5%BF%83%2F%E9%87%91%E9%93%B6%E5%B2%9B%2F</url>
    <content type="text"><![CDATA[题目某天KID利用飞行器飞到了一个金银岛上，上面有许多珍贵的金属，KID虽然更喜欢各种宝石的艺术品，可是也不拒绝这样珍贵的金属。但是他只带着一个口袋，口袋至多只能装重量为w的物品。岛上金属有s个种类, 每种金属重量不同，分别为n 1, n 2, … , n s，同时每个种类的金属总的价值也不同，分别为v 1,v 2, …, v s。KID想一次带走价值尽可能多的金属，问他最多能带走价值多少的金属。注意到金属是可以被任意分割的，并且金属的价值和其重量成正比。Input第1行是测试数据的组数k，后面跟着k组输入。 每组测试数据占3行，第1行是一个正整数w (1 &lt;= w &lt;= 10000)，表示口袋承重上限。第2行是一个正整数s (1 &lt;= s &lt;=100)，表示金属种类。第3行有2s个正整数，分别为n 1, v 1, n 2, v 2, … , n s, v s分别为第一种，第二种，…，第s种金属的总重量和总价值(1 &lt;= n i &lt;= 10000, 1 &lt;= v i &lt;= 10000)。Outputk行，每行输出对应一个输入。输出应精确到小数点后2位。Sample Input1234567250410 100 50 30 7 34 87 1001000051 43 43 323 35 45 43 54 87 43 Sample Output12171.93508.00 题解该题跟圣诞老人题类似传送，单位重量内价值越高优先选择。 代码12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;algorithm&gt;const int MAXSIZE=10000+5;using namespace std;struct Node&#123; int weight; int value; double single;&#125;;bool cmp(struct Node a,struct Node b)&#123;return a.single&gt;b.single;&#125;int main()&#123; int Case; cin&gt;&gt;Case; while(Case--)&#123; int w; cin&gt;&gt;w; int s; cin&gt;&gt;s; struct Node arr[MAXSIZE]; for(int i=0;i&lt;s;i++)&#123; cin&gt;&gt;arr[i].weight&gt;&gt;arr[i].value; arr[i].single=arr[i].value*1.0/arr[i].weight; &#125; sort(arr,arr+s,cmp); int sum=0; int i=0; double allVal=0; for(i=0;i&lt;s&amp;&amp;(sum+arr[i].weight)&lt;=w;i++)&#123; sum+=arr[i].weight; allVal+=arr[i].value; &#125; if(i&lt;s) allVal=allVal+(w-sum)*arr[i].single; printf(&quot;%.2lf\n&quot;,allVal); &#125; return 0;&#125;]]></content>
      <categories>
        <category>贪心算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[圣诞老人的礼物-Santa Clau’s Gifts]]></title>
    <url>%2F2019%2F01%2F30%2F%E8%B4%AA%E5%BF%83%2F%E5%9C%A3%E8%AF%9E%E8%80%81%E4%BA%BA%E7%9A%84%E7%A4%BC%E7%89%A9-Santa%20Clau%E2%80%99s%20Gifts%20%2F</url>
    <content type="text"><![CDATA[题目圣诞节来临了，在城市A中圣诞老人准备分发糖果，现在有多箱不同的糖果，每箱糖果有自己的价值和重量，每箱糖果都可以拆分成任意散装组合带走。圣诞老人的驯鹿最多只能承受一定重量的糖果，请问圣诞老人最多能带走多大价值的糖果。Input第一行由两个部分组成，分别为糖果箱数正整数n(1 &lt;= n &lt;= 100)，驯鹿能承受的最大重量正整数w（0 &lt; w &lt; 10000），两个数用空格隔开。其余n行每行对应一箱糖果，由两部分组成，分别为一箱糖果的价值正整数v和重量正整数w，中间用空格隔开。Output输出圣诞老人能带走的糖果的最大总价值，保留1位小数。输出为一行，以换行符结束。Sample Input123454 15100 4412 8266 7591 2 Sample Output11193.0 题解由一箱糖果的总价值和它的总重量可以算出每一份重量所对应的价值，记为份重量=总价值/总重量。要尽可能地带走价值大的糖果，那么在载重允许范围内，份重量对应的糖果价值越大带走的糖果价值就越高。对份重量从高到底排序，选择即可 代码1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;algorithm&gt;const int MAXSIZE=100+5;using namespace std;struct Santa&#123; int value; int weight; double single;&#125;;bool cmp(struct Santa a,struct Santa b)&#123;return a.single&gt;b.single;&#125;int main()&#123; struct Santa arr[MAXSIZE]; int n,w; while(cin&gt;&gt;n&gt;&gt;w)&#123; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;arr[i].value&gt;&gt;arr[i].weight; arr[i].single=(arr[i].value*1.0)/(arr[i].weight*1.0); &#125; sort(arr,arr+n,cmp); int sum=0; double allVal=0; int i=0; while((arr[i].weight+sum)&lt;=w)&#123; allVal=allVal+arr[i].value; sum+=arr[i].weight; i++; if(i&gt;=n) break; &#125; if(i&lt;n) allVal=allVal+arr[i].single*(w-sum); printf(&quot;%.1lf\n&quot;,allVal); &#125; return 0;&#125;//AC]]></content>
      <categories>
        <category>贪心算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Not half of the heart]]></title>
    <url>%2F2018%2F12%2F09%2F%E9%9A%8F%E7%AC%94%E6%9D%82%E6%83%B3%2Fifeelsad%2F</url>
    <content type="text"><![CDATA[好像每到这个时期，都不知道干些什么 见到那些想要学的习东西，python/前端 都提不起兴趣。 已在这过了一年半了，好快，不久，又是考研了 送走一届又一届 当轮到我时 是否还记得入学时许下的承若。 想到了毕业 又担心自己一事无成 打开电脑，敲下一行行的代码不能使我心安。 外界的嘈杂 尚不及内心的一半 以后无穷无尽的压力 有过绝望。 以前的人们 在19岁时感受到过生活的压力吗 肯定是有的 那么当他们绝望时 是什么支撑着走下去。 熬夜到2点好像已经习惯了 以前可没这样 熬到这时候又做了些什么 没有答案 或许自己也不知道为什么又熬夜了，呵呵。 古来圣贤皆寂寞 唯有饮者留其名 我是谁 我以前干了些什么 我现在在干什么 我以后要干什么。 也曾看过你的微博 也曾删掉联系方式 也曾留恋虚无缥缈的念想 现在 想着 过去了 就不要想了。 莫问前路无知己 天下谁人不识君。 子在川上曰：逝者如斯夫，不舍昼夜 都说时间可以消磨过去的痕迹 可为什么痕迹越来越深了。 2019愿你走的每一步都是坚定而扎实的。]]></content>
      <categories>
        <category>随笔杂想</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[nyoj-71-独木舟上的旅行（贪心入门]]></title>
    <url>%2F2018%2F12%2F02%2F%E8%B4%AA%E5%BF%83%2Fnyoj71%E7%8B%AC%E6%9C%A8%E8%88%9F%E4%B8%8A%E7%9A%84%E6%97%85%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[描述独木舟上的旅行时间限制：3000 ms | 内存限制：65535 KB难度：2描述进行一次独木舟的旅行活动，独木舟可以在港口租到，并且之间没有区别。一条独木舟最多只能乘坐两个人，且乘客的总重量不能超过独木舟的最大承载量。我们要尽量减少这次活动中的花销，所以要找出可以安置所有旅客的最少的独木舟条数。现在请写一个程序，读入独木舟的最大承载量、旅客数目和每位旅客的重量。根据给出的规则，计算要安置所有旅客必须的最少的独木舟条数，并输出结果。输入第一行输入s,表示测试数据的组数；每组数据的第一行包括两个整数w，n，80&lt;=w&lt;=200,1&lt;=n&lt;=300，w为一条独木舟的最大承载量,n为人数；接下来的一组数据为每个人的重量（不能大于船的承载量）；输出每组人数所需要的最少独木舟的条数。样例输入1234567385 65 84 85 80 84 8390 390 45 60100 550 50 90 40 60 样例输出123533 题解以最小的体重为基准，再从最大体重中往下找，满足承载重就说明两者可以搭乘同一船，否则就只有最小的那一个独自搭船。然后依次选择剩下的最小体重。说明：一条船只能坐两人。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;//--const int MAXSIZE=300+5;//--int main()&#123; int Case; cin&gt;&gt;Case; while(Case--)&#123; int weith,people; cin&gt;&gt;weith&gt;&gt;people; int a[MAXSIZE]; for(int i=0;i&lt;people;i++) cin&gt;&gt;a[i]; sort(a,a+people); int ans=0; for(int i=0;i&lt;people;i++)&#123; if(a[i]!=0)&#123; int value=weith-a[i]; for(int j=people-1;j&gt;i;j--)&#123; if(value&gt;=a[j]&amp;&amp;a[j]!=0)&#123; value=value-a[j]; a[j]=0; break; &#125; &#125; ans++; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; /*385 65 84 85 80 84 8390 390 45 60100 550 50 90 40 60*/]]></content>
      <categories>
        <category>贪心算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nyoj-13-会场安排问题（贪心入门]]></title>
    <url>%2F2018%2F12%2F01%2F%E8%B4%AA%E5%BF%83%2Fnyoj14%E4%BC%9A%E5%9C%BA%E5%AE%89%E6%8E%92%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[描述会场安排问题学校的小礼堂每天都会有许多活动，有时间这些活动的计划时间会发生冲突，需要选择出一些活动进行举办。小刘的工作就是安排学校小礼堂的活动，每个时间最多安排一个活动。现在小刘有一些活动计划的时间表，他想尽可能的安排更多的活动，请问他该如何安排。输入第一行是一个整型数m(m&lt;100)表示共有m组测试数据。每组测试数据的第一行是一个整数n(1&lt;n&lt;10000)表示该测试数据共有n个活动。随后的n行，每行有两个正整数Bi,Ei(0&lt;=Bi,Ei&lt;10000),分别表示第i个活动的起始与结束时间（Bi&lt;=Ei)输出对于每一组输入，输出最多能够安排的活动数量。每组的输出占一行样例输入12345678221 1010 1131 1010 1111 20 样例输出1212 提示注意：如果上一个活动在t时间结束，下一个活动最早应该在t+1时间开始 题解活动越早结束，剩余的时间就越多。那么每次找最早结束的活动，然后继续在剩下的活动中找最小的。当然这些满足一个条件，即如提示说明。 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;//--const int MAXSIZE=10000+5;class node&#123; public: int Bi; int Ei;&#125;;node a[MAXSIZE];//--bool cmp(node a,node b)&#123; return a.Ei&lt;b.Ei;&#125;int main()&#123; int Case; cin&gt;&gt;Case; while(Case--)&#123; int n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i].Bi&gt;&gt;a[i].Ei; sort(a,a+n,cmp); int ans=1; int t=0; for(int i=1;i&lt;n;i++)&#123; if(a[i].Bi&gt;a[t].Ei)&#123; ans++; t=i; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>贪心算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HihoCoder-1066-无间道之并查集]]></title>
    <url>%2F2018%2F11%2F29%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%2Fhihocode-1066-%E6%97%A0%E9%97%B4%E9%81%93%E4%B9%8B%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[描述描述这天天气晴朗、阳光明媚、鸟语花香，空气中弥漫着春天的气息……额，说远了，总之，小Hi和小Ho决定趁着这朗朗春光出去玩。 但是刚刚离开居住的宾馆不久，抄近道不小心走入了一条偏僻小道的小Hi和小Ho就发现自己的前方走来了几个彪形大汉，定睛一看还都是地地道道的黑人兄弟！小Hi和小Ho这下就慌了神，捡肥皂事小，这一身百把来斤别一不小心葬身他乡可就没处说去了。 就在两人正举足无措之时，为首的黑叔叔从怀里掏出了一件东西——两张花花绿绿的纸，分别递给了小Hi和小Ho。小Hi和小Ho接过来，只见上面写道（译为中文）：“本地最大的帮派——青龙帮，诚邀您的加入！”下面还详细的列出了加入青龙帮的种种好处。 于是两人略感心安，在同黑叔叔们交谈一番之后，已是均感相见恨晚。同时，在小Hi和小Ho表示自己不日便将回国之后，黑叔叔们也没有再提加入帮派之事，但是那为首的黑叔叔思索一会，开口道（译为中文）：“我现在有一个难题，思索了很久也没法子解决，既然你们俩都是高材生，不如来帮我看看。” 小Hi和小Ho点了点头表示没问题，于是黑叔叔继续说道：“这个问题是这样的，我们帮派最近混进了许多警察的卧底，但是在我们的调查过程中只能够知道诸如‘某人和另一个人是同阵营的’这样的信息，虽然没有办法知道他们具体是哪个阵营的，但是这样的信息也是很重要的，因为我们经常会想要知道某两个人究竟是不是同一阵营的。” 小Hi和小Ho赞同的点了点头，毕竟无间道也都是他们看过的。 黑叔叔接着说道：“于是现在问题就来了，我希望你们能写出这样一个程序，我会有两种操作，一种是告诉它哪两个人是同一阵营的，而另一种是询问某两个人是不是同一阵营的……既然你们就要回国了，不如现在就去我们帮派的总部写好这个程序再走把。” 为了生命安全与……小Hi和小Ho都不得不解决这个问题！那么他们究竟从何下手呢？ 提示：说起来其实就是不断的合并集合嘛~×Close提示：说起来其实就是不断的合并集合嘛~到了青龙帮的总部，望着桌上的电脑，小Ho陷入了沉思，良久，抬起头向小Hi道：“小Hi，你看我这样做可以么，一开始我将每个人视作一个仅由他们自己组成的集合，每次遇见op=0的操作，实际上就是合并这两个人所在的两个集合，而每次遇见op=1的操作，实际上就是询问这两个人是否在同一个集合中。” “你说的很有道理。”小Hi点头道：“但是集合并不是计算机中直接就存在的一个基础类型，你准备用什么样的方式去实现这个集合呢？” “用Set……”小Ho道。 小Hi脸色一黑，道：“能不能有点追求啦，Set那底层实现都是红黑树什么的，你依靠别人的设计虽说没什么问题，但是为了知识水平的提高，自己学习一下还是很有必要的嘛！” “但是……这么短的时间里，你让我学红黑树，我也一时半会学不会吧。”小Ho表示为难。 “没让你用红黑树，我今天就教你一个非常简单的维护集合的方法——并查集。”小Hi道：“这个方法非常简单，就是在每个集合里选出一个代表元素，并且令这个集合里面的每一个元素都指向这个代表元素。像你之前所说‘一开始我将每个人视作一个仅由他们自己组成的集合’，也就是对于每一个人Name_i，都令represent[Name_i]=Name_i。” “那合并怎么办呢？”小Ho问道。 “合并的话首先你要看这两个人A和B所在的集合是不是同一个集合，也就是represent[A]和represent[B]是否相同，如果相同自然无需合并，否则就要把这两个集合合并是吧？” “你这话不等于没说么……”小Ho表示抗议。 小Hi无视了这抗议继续说道：“如果我令A’=represent[A],B’=represent[B]，那么我令represent[A’]=B’是否就在某种意义上将这两个集合合并了？” 小Ho道：“你这个……只改变了A所在集合中一个元素A’的represent值，但是这个集合中其他元素的represent值都没有发生改变啊？” 小Hi挥了挥手道：“别着急，你看，所有原来A所在集合中的元素都指向A’，而A’指向了B’，那么也就是A所在集合里的所有元素如果顺着这条链一直找寻下去，最终找到的那个就一定是它所在集合的代表元素？” “没错……” “所以我们就可以将寻找代表元素，也就是求解represent值这个过程做成一个迭代的过程，比如求解X所在集合的represent值，我先令X’=represent[X]，如果X’=X的话，那么就能说明X所在集合的代表元素就是X本身，否则就令X’’=represent[X’]，如果X’’=X’的话那么就能说明X所在集合的代表元素就是X’……一直持续这样的操作就能够找到最终的集合代表元素了。”小Hi说着说着在纸上写了几行代码递了过来：“就像这样。” 小Ho仔细想了想，继续问道：“但是如果每次合并都是将一条链接到另外一个点上，这样的操作会不会特别的没有效率，接近O(N^2)了？” “是会有这个问题，但是你很容易就注意到——合并这个操作是不可逆的，也就是说如果我求解出了X所在集合的代表元素是X_r的话，那么我就可以直接令represent[X]=X_r，这样就可以避免在下一次询问X所在集合的代表元素的时候再进行一次这样的计算了。”言罢，小Hi将之前写下的代码稍作修改，又递了过来。 “原来是这样，那么我的合并操作实际上就是令represent[find_represent(A)]=find_represent(B)，而询问操作就是判断find_represent(A)和find_represent(B)是否想通了？”小Ho道。 “没错呢！所以赶紧开始写把！，呆久了我可不知道会发生什么呢！” 输入每个测试点（输入文件）有且仅有一组测试数据。 每组测试数据的第1行为一个整数N，表示黑叔叔总共进行的操作次数。 每组测试数据的第2~N+1行，每行分别描述黑叔叔的一次操作，其中第i+1行为一个整数op_i和两个由大小写字母组成的字符串Name1_i, Name2_i，其中op_i只可能为0或1，当op_i=0时，表示黑叔叔判定Name1_i和Name2_i是同一阵营的，当op_i=1时，表示黑叔叔希望知道Name1_i和Name2_i是否为同一阵营的。 对于100%的数据，满足N&lt;=10^5, 且数据中所有涉及的人物中不存在两个名字相同的人（即姓名唯一的确定了一个人），对于所有的i，满足Name1_i和Name2_i是不同的两个人。 输出对于每组测试数据，对于黑叔叔每次op_i=1的操作，输出一行，表示查询的结果：如果根据已知信息（即这次操作之前的所有op_i=0的操作），可以判定询问中的两个人是同一阵营的，则输出yes，否则输出no。 Sample Input1234567891011100 Steven David0 Lcch Dzx1 Lcch Dzx1 David Dzx0 Lcch David0 Frank Dzx1 Steven Dzx1 Frank David0 Steven Dzx0 Dzx Frank Sample Output1234yesnoyesyes 题解这道题学到了map的用法，好开心。把每一个人名在map中比较下，找到下标位置，然后直接套用并查集。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;cstdlib&gt;using namespace std;const int MAXSIZE=500000+10;map&lt;string,int&gt;mp;int k=0;int parent[MAXSIZE];int toParse(string str)&#123; if(mp.count(str)) return mp[str]; else&#123; mp[str]=k++; return mp[str]; &#125;&#125;void create()&#123; for(int i=0;i&lt;MAXSIZE;i++) parent[i]=i;&#125;int find(int x)&#123; while(x!=parent[x]) //找根节点 x=parent[x]; return x;&#125;void unit(int x,int y)&#123; x=find(x); y=find(y); if(x!=y) //直接合并集合 parent[x]=y;&#125;int main()&#123; int total; cin&gt;&gt;total; create(); k=0; while(total--)&#123; int flag; string str1,str2; cin&gt;&gt;flag&gt;&gt;str1&gt;&gt;str2; if(mp.count(str1)==0) mp[str1]=k++; if(mp.count(str2)==0) mp[str2]=k++; if(flag==1) if(find(mp[str1])==find(mp[str2])) cout&lt;&lt;&quot;yes&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;no&quot;&lt;&lt;endl; else unit(mp[str1],mp[str2]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj-2524-Ubiquitous Religions]]></title>
    <url>%2F2018%2F11%2F29%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%2Fpoj2524%2F</url>
    <content type="text"><![CDATA[描述Ubiquitous ReligionsTime Limit: 5000MS Memory Limit: 65536KTotal Submissions: 41487 Accepted: 19782Description There are so many different religions in the world today that it is difficult to keep track of them all. You are interested in finding out how many different religions students in your university believe in. You know that there are n students in your university (0 &lt; n &lt;= 50000). It is infeasible for you to ask every student their religious beliefs. Furthermore, many students are not comfortable expressing their beliefs. One way to avoid these problems is to ask m (0 &lt;= m &lt;= n(n-1)/2) pairs of students and ask them whether they believe in the same religion (e.g. they may know if they both attend the same church). From this data, you may not know what each person believes in, but you can get an idea of the upper bound of how many different religions can be possibly represented on campus. You may assume that each student subscribes to at most one religion.Input The input consists of a number of cases. Each case starts with a line specifying the integers n and m. The next m lines each consists of two integers i and j, specifying that students i and j believe in the same religion. The students are numbered 1 to n. The end of input is specified by a line in which n = m = 0.Output For each test case, print on a single line the case number (starting with 1) followed by the maximum number of different religions that the students in the university believe in.Sample Input1234567891011121314151610 91 21 31 41 51 61 71 81 91 1010 42 34 54 85 80 0 Sample Output12Case 1: 1Case 2: 7 Hint Huge input, scanf is recommended.Source Alberta Collegiate Programming Contest 2003.10.18 题解用并查集把所有人的关系求出来。对总人数遍历，若某人处于一个集合的受位置（根节点），说明有一个集合，将集合加起来。 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;using namespace std;const int MAXSIZE=50000+10;int parent[MAXSIZE];void create(int people)&#123; for(int i=1;i&lt;=people;i++) parent[i]=i;&#125;int findParent(int x)&#123; while(x!=parent[x]) x=parent[x]; return x;&#125;void unit(int x,int y)&#123; x=findParent(x); y=findParent(y); parent[x]=y; &#125; int main()&#123; int people,Case; int Count=1; while(cin&gt;&gt;people&gt;&gt;Case)&#123; if(people==0&amp;&amp;Case==0) break; create(people); while(Case--)&#123; int a,b; cin&gt;&gt;a&gt;&gt;b; unit(a,b); &#125; int ans=0; for(int i=1;i&lt;=people;i++)&#123; if(i==parent[i]) ans++; &#125; cout&lt;&lt;&quot;Case &quot;&lt;&lt;Count++&lt;&lt;&quot;: &quot;&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj-1611-The Suspects]]></title>
    <url>%2F2018%2F11%2F29%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%2Fpoj1611%2F</url>
    <content type="text"><![CDATA[描述The SuspectsTime Limit: 1000MS Memory Limit: 20000KTotal Submissions: 51831 Accepted: 24779Description Severe acute respiratory syndrome (SARS), an atypical pneumonia of unknown aetiology, was recognized as a global threat in mid-March 2003. To minimize transmission to others, the best strategy is to separate the suspects from others.In the Not-Spreading-Your-Sickness University (NSYSU), there are many student groups. Students in the same group intercommunicate with each other frequently, and a student may join several groups. To prevent the possible transmissions of SARS, the NSYSU collects the member lists of all student groups, and makes the following rule in their standard operation procedure (SOP).Once a member in a group is a suspect, all members in the group are suspects.However, they find that it is not easy to identify all the suspects when a student is recognized as a suspect. Your job is to write a program which finds all the suspects.Input The input file contains several cases. Each test case begins with two integers n and m in a line, where n is the number of students, and m is the number of groups. You may assume that 0 &lt; n &lt;= 30000 and 0 &lt;= m &lt;= 500. Every student is numbered by a unique integer between 0 and n−1, and initially student 0 is recognized as a suspect in all the cases. This line is followed by m member lists of the groups, one line per group. Each line begins with an integer k by itself representing the number of members in the group. Following the number of members, there are k integers representing the students in this group. All the integers in a line are separated by at least one space.A case with n = 0 and m = 0 indicates the end of the input, and need not be processed.Output For each case, output the number of suspects in one line.Sample Input12345678910100 42 1 25 10 13 11 12 142 0 12 99 2200 21 55 1 2 3 4 51 00 0 Sample Output123411 Source Asia Kaohsiung 2003 题解将0所在的集合的所有元素全部加起来即可。判断0与其他元素再同一个集合，仅需判断两元素根节点是否相同。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;iostream&gt;using namespace std;class Tree&#123; public: int data; int parent; int rank;&#125;;const int MAXSIZE=30000+5;Tree tree[MAXSIZE];void createTree(int people)&#123; for(int i=0;i&lt;people;i++)&#123; tree[i].data=i; tree[i].parent=i; tree[i].rank=0; &#125;&#125;int findParent(Tree tree[],int x)&#123; if(x!=tree[x].parent) findParent(tree,tree[x].parent); else return x;&#125;void unit(Tree tree[],int x,int y)&#123; x=findParent(tree,x); y=findParent(tree,y); if(tree[x].rank&gt;tree[y].rank)&#123; tree[y].parent=x; &#125; else&#123; tree[x].parent=y; if(tree[x].rank==tree[y].rank) tree[y].rank++; &#125; &#125;int main()&#123; int people,group; while(cin&gt;&gt;people&gt;&gt;group)&#123; if(people==0&amp;&amp;group==0) break; createTree(people); while(group--)&#123; int total; int num[MAXSIZE]; cin&gt;&gt;total; int a,b; cin&gt;&gt;a; for(int i=1;i&lt;total;i++)&#123; cin&gt;&gt;b; unit(tree,a,b); &#125; &#125; int result=1; int value=findParent(tree,0); //查找0元素的根节点 for(int i=1;i&lt;people;i++) if(value==findParent(tree,i)) result++; cout&lt;&lt;result&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[判断连通图]]></title>
    <url>%2F2018%2F11%2F10%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E5%88%A4%E6%96%AD%E8%BF%9E%E9%80%9A%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[判断无向图是否连通 题目描述3967: 连通图时间限制: 1 Sec 内存限制: 32 MB提交: 4 解决: 4题目描述给定一个无向图和其中的所有边，判断这个图是否所有顶点都是连通的。 输入每组数据的第一行是两个整数 n 和 m（0&lt;=n&lt;=1000）。n 表示图的顶点数目，m 表示图中边的数目。如果 n 为 0 表示输入结束。随后有 m 行数据，每行有两个值 x 和 y（0&lt;x, y &lt;=n），表示顶点 x 和 y 相连，顶点的编号从 1 开始计算。输入不保证这些边是否重复。 输出对于每组输入数据，如果所有顶点都是连通的，输出”YES”，否则输出”NO”。 样例输入12345678910111213141516174 34 31 21 35 73 52 31 33 22 53 44 17 36 23 15 60 0 样例输出123YESYESNO 前几天写图遍历时，一直是按照书上先把矩阵转化为邻接表再遍历，这次终于换了一种方式。矩阵转邻接表：12345678910111213void MatToList(Graph *&amp;G, int n) &#123; Anode *p; for (int i = 1; i &lt;= n; i++) &#123; for (int j = n; j &gt;=1; j--) &#123; if (edge[i][j] == 1) &#123; p = new Anode; p-&gt;value = j; p-&gt;next = G-&gt;adjlist[i].firstarc; G-&gt;adjlist[i].firstarc = p; &#125; &#125; &#125;&#125; 想明白邻接表后直接对表头赋值如下1234567891011121314151617void input(Graph *&amp;G, int m) &#123; while (m--) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; Anode *p = new Anode; Anode *q = new Anode; p-&gt;value = b; q-&gt;value = a; p-&gt;next = G-&gt;adjlist[a].firstarc; G-&gt;adjlist[a].firstarc = p; q-&gt;next = G-&gt;adjlist[b].firstarc; G-&gt;adjlist[b].firstarc = q; &#125;&#125; AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;iostream&gt;using namespace std;const int MAXSIZE = 1000;int visited[MAXSIZE] = &#123; 0 &#125;;int edge[MAXSIZE][MAXSIZE] = &#123; 0 &#125;;class Anode &#123;public: int value; Anode *next;&#125;;class Adjlist &#123;public: Anode *firstarc;&#125;;class Graph &#123;public: Adjlist adjlist[MAXSIZE];&#125;;void initGraph(Graph *&amp;G, int n) &#123; G = new Graph; for (int i = 1; i &lt;= n; i++) G-&gt;adjlist[i].firstarc = NULL; //表头指针指向NULL&#125;void input(Graph *&amp;G, int m) &#123; while (m--) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; Anode *p = new Anode; Anode *q = new Anode; p-&gt;value = b; q-&gt;value = a; //头插法建表 p-&gt;next = G-&gt;adjlist[a].firstarc; G-&gt;adjlist[a].firstarc = p; q-&gt;next = G-&gt;adjlist[b].firstarc; G-&gt;adjlist[b].firstarc = q; &#125;&#125;void DFS(Graph *&amp;G, int count) &#123; Anode *p; visited[count] = 1; p = G-&gt;adjlist[count].firstarc; while (p != NULL) &#123; if (visited[p-&gt;value] == 0) DFS(G, p-&gt;value); //递归深搜 p = p-&gt;next; &#125;&#125;bool isConnectedGraph(Graph *&amp;G, int n) &#123; DFS(G, 1); for (int i = 1; i &lt;= n; i++) if (visited[i] != 1) //只要有一个节点未被访问就返回 return false; return true;&#125;int main()&#123; int n, m; while (cin &gt;&gt; n &gt;&gt; m) &#123; for (int i = 1; i &lt;= MAXSIZE; i++) &#123; visited[i] = 0 ; for (int j = 1; j &lt;= MAXSIZE; j++) edge[i][j] = 0; &#125; if (n == 0 &amp;&amp; m == 0) break; Graph *G; initGraph(G, n);//对图初始化 input(G,m); if (isConnectedGraph(G, n)) cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>图遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[银行排队]]></title>
    <url>%2F2018%2F11%2F10%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E9%93%B6%E8%A1%8C%E6%8E%92%E9%98%9F%2F</url>
    <content type="text"><![CDATA[数据结构，化腐朽为神奇的力量 问题描述3970: 银行排队时间限制: 1 Sec 内存限制: 32 MB提交: 5 解决: 5题目描述我们大多都有在银行排队的经历，唉，那坑爹的排队啊！现在就让我们来算算我们这些客户平均需要等多久吧。每天刚开始时银行会开m个窗口来为我们total个客户办理业务，当有客户需要办理业务时，先选择可以办理业务的窗口，如果有多个窗口可以办理业务就选择空闲时间最长的窗口，如果有多个窗口空闲的时间一样长，则选择序号小的窗口办理业务。假设我们每个人来到的时间和办理业务所需要的时间（为了简化问题，采用整数表示时间）都知道了。现在请你算算我们平均需要等待多久呢？ 输入有多组测试数据，每组数据开始有两个正整数m(&lt;20)和total(&lt;200)，后面有total对整数，对应客户先后到来的时间以及办理业务所需的时间。 输出平均等待的时间，保留两位小数。 样例输入1232 6 1 3 4 1 5 3 9 2 13 4 13 33 14 0 3 2 2 2 4 5 4 7 2 11 3 12 3 12 4 12 1 13 3 15 4 19 1 22 3 23 22 5 0 6 0 5 0 6 7 1 7 2 样例输出1230.000.291.20 题解利用数组来模拟队列，序号从小到大每一个数组元素表示一个窗口。首先分析一个人处理业务后的时间，假设只有一个窗口。来到的时间：x1；办理业务的时间为y1；那么这个窗口在x1+y1时间后才能被下一个人使用，即此人的离开时间 ；如果另一个人（来到时间x2，办理业务时间y2）在[x1,y1]时间段内到达，就意味着他必须等待的时间为y1-x2。 可分为两种情况：1、后者[x1,y1]的到达时间比前者[x2,y2]的离开时间晚。这个窗口的可使用时间为x1+y1；2、后者[x1,y1]来了，前者[x2,y2]还未离开。先记下这个窗口的编号，再遍历所有的窗口，若有窗口空闲，则取办理业务。否则，找到最早离开的人所在的窗口，计算等待时间，即为y1-x2。 代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt; const int MAXSIZE = 20; //定义10*10的矩阵大小using namespace std; double run(int m, int total) &#123; int countTime = 0; int a, b; int num[MAXSIZE] = &#123; 0 &#125;; while (total--) &#123; cin &gt;&gt; a &gt;&gt; b; int min = 0; int minTime = 1000; for (int i = 1; i &lt;= m; i++) &#123; if (a &gt;= num[i]) &#123; num[i] = a + b; min = 0; minTime = 1000; break; &#125; if (a &lt; num[i]&amp;&amp;minTime&gt;num[i]) &#123; min = i; minTime = num[i]; &#125; &#125; if (min != 0) &#123; countTime = countTime + num[min] - a; num[min] = num[min] + b; &#125; &#125; return countTime;&#125;int main()&#123; int m, total; while (cin &gt;&gt; m &gt;&gt; total) &#123; double countTime = run(m, total); printf(&quot;%.2lf\n&quot;, countTime/(1.0*total)); &#125; return 0;&#125; 关于 cout 浮点数输出头文件1#include&lt;iomanip&gt; 输出格式1cout&lt;&lt;setprecision(2)&lt;&lt;x&lt;&lt;endl;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>模拟队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu14.04文件操作]]></title>
    <url>%2F2018%2F11%2F06%2FLinux%2Fubuntu14.04%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[使用xshell连接云服务器一些文件操作 安装rzsz1apt-get install lrzsz rzsz说明：sz命令 发送文件到本地： #sz filenamerz命令 将本地上传文件到服务器 #rz执行该命令后，在弹出框中选择要上传的文件即可 新建文件夹1mkdir filename 重命名文件1mv filename1 filename2 这也是移动某文件到另一文件目录下的操作]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>基本操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迷宫寻路可视化]]></title>
    <url>%2F2018%2F10%2F27%2F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%2F%E8%BF%B7%E5%AE%AB%E5%AF%BB%E8%B7%AF%E5%8F%AF%E8%A7%86%E5%8C%96%2F</url>
    <content type="text"><![CDATA[学了数据结构，一直想做个东西出来玩。八皇后？五子棋？贪吃蛇？推箱子？二叉树？来个我最熟悉的迷宫求解吧。函数说明：设置背景颜色：setbkcolor(RED);画线算法：line(x1,y1,x2,y2);画矩阵算法：rectangle(left,top,right,bottom);字体颜色：settextcolor(YELLOW);输出字符串：RECT r = { left,top,right,bottom}; drawtext(_T(“退出”), &amp;r, DT_CENTER | DT_VCENTER | DT_SINGLELINE);编译环境：Visual Studio 2017123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577#include &lt;iostream&gt;#include &lt;graphics.h&gt;#include&lt;malloc.h&gt;#include &lt;time.h&gt;#include &lt;conio.h&gt;//在控制台输入输出文件using namespace std;#define MAXSIZE 1000+10void MEUN2(struct Stack *&amp;stack, struct Queue *&amp;queue);void MEUN1(struct Stack *&amp;stack, struct Queue *&amp;queue);void init();void PrintLine();void FillColor();void QueueRoad(struct Queue *&amp;queue);void StackRoad(struct Stack *&amp;stack);//栈寻找迷宫路径struct Box&#123; int x; int y; int di;//方位值&#125;;struct Stack&#123; struct Box data[MAXSIZE]; int top;&#125;;//队列寻找迷宫路径struct Box1&#123; int x; int y; int pre;&#125;;struct Queue&#123; struct Box1 data[MAXSIZE]; int rear; int front;&#125;;int px1 = 0, px2 = 0, py1 = 0, py2 = 0;int flag1 = 0;//迷宫数组int mg[14][22] = &#123; 0 &#125;;//设置迷宫的边界void init() &#123; for (int i = 0; i &lt; 14; i++) for (int j = 0; j &lt; 22; j++) mg[i][j] = 0; for (int i = 0; i &lt; 14; i++) mg[i][21] = 1; for (int i = 0; i &lt; 14; i++) mg[i][0] = 1; for (int i = 0; i &lt; 22; i++) mg[13][i] = 1; for (int i = 0; i &lt; 22; i++) mg[0][i] = 1;&#125;//栈寻找路径bool StackFind(struct Stack *&amp;stack, int x1, int y1, int x2, int y2)&#123; int i = 0; int j = 0; struct Box box; //di的用来记录方位值，如果要退回的话，就不用再一次的重新来找一遍了 box.x = x1; box.y = y1; box.di = -1; stack-&gt;top++; stack-&gt;data[stack-&gt;top] = box; mg[x1][y1] = -1; //solidrectangle((box.y-1) * 50, (box.x-1) * 50, (box.y-1) * 50 + 50, (box.x-1) * 50 + 50); while (stack-&gt;top != -1) &#123; box = stack-&gt;data[stack-&gt;top]; int x = box.x; int y = box.y; int di = box.di; if (x == x2 &amp;&amp; y == y2) return true; else &#123; while (di &lt; 4) &#123; di++; switch (di) &#123; case 0: i = x - 1; j = y; break; case 1: i = x; j = y + 1; break; case 2: i = x + 1; j = y; break; case 3: i = x; j = y - 1; break; &#125; if (mg[i][j] == 0) break; &#125; if (di &lt; 4) &#123; stack-&gt;data[stack-&gt;top].di = di; box.x = i; box.y = j; box.di = -1; stack-&gt;top++; stack-&gt;data[stack-&gt;top] = box; mg[i][j] = -1; &#125; else &#123; stack-&gt;top--; mg[x][y] = 0; &#125; &#125; &#125; return false;&#125;//队列寻找路径bool QueueFind(struct Queue *&amp;queue, int x1, int y1, int x2, int y2)&#123; int i = 0; int j = 0; //pre的用来记录上一个可走方块在 struct Box1 box1; box1.x = x1; box1.y = y1; box1.pre = -1; queue-&gt;rear++; queue-&gt;data[queue-&gt;rear] = box1; mg[x1][y1] = -1; while (queue-&gt;rear != queue-&gt;front) &#123; queue-&gt;front++; box1 = queue-&gt;data[queue-&gt;front]; int x = box1.x; int y = box1.y; if (x == x2 &amp;&amp; y == y2) &#123; return true; &#125; else &#123; int di = -1; while (di &lt; 4) &#123; di++; switch (di) &#123; case 0: i = x - 1; j = y; break; case 1: i = x; j = y + 1; break; case 2: i = x + 1; j = y; break; case 3: i = x; j = y - 1; break; &#125; if (mg[i][j] == 0) &#123; box1.x = i; box1.y = j; box1.pre = queue-&gt;front; queue-&gt;rear++; queue-&gt;data[queue-&gt;rear] = box1; mg[i][j] = -1; &#125; &#125; &#125; &#125;&#125;//画迷宫图形void PrintLine()&#123; setbkcolor(WHITE); cleardevice(); //画迷宫图形 setlinecolor(BLACK); for (int i = 0; i &lt;= 1000; i += 50) line(i, 0, i, 1000); for (int i = 0; i &lt;= 600; i += 50) line(0, i, 1000, i);&#125;//填充颜色void FillColor()&#123; setfillcolor(RED); //填充颜色，以分别可走路径和不可走路径 int flag = 1; for (int i = 0; i &lt; 1000; i += 50) &#123; for (int j = 0; j &lt; 600; j += 50) &#123; //随机设置位置为不可走状态 flag = rand(); if (flag % 2 != 0 &amp;&amp; flag % 3 != 0) &#123; solidrectangle(i, j, i + 50, j + 50); mg[(j + 50) / 50][(i + 50) / 50] = 1; Sleep(10); &#125; &#125; &#125;&#125;void QueueRoad(struct Queue *&amp;queue)&#123; if (QueueFind(queue, px1, py1, px2, py2) == true) &#123; int root = queue-&gt;front; while (root != 0) &#123; int pre = queue-&gt;data[root].pre; queue-&gt;data[root].pre = -1; root = pre; &#125; struct Box1 box1; for (int i = 1; i &lt; queue-&gt;front; i++)&#123; if (queue-&gt;data[i].pre == -1) &#123; setfillcolor(GREEN); box1 = queue-&gt;data[i]; solidrectangle((box1.y - 1) * 50, (box1.x - 1) * 50, (box1.y - 1) * 50 + 50, (box1.x - 1) * 50 + 50); Sleep(1000); &#125; &#125; &#125;&#125;void StackRoad(struct Stack *&amp;stack)&#123; struct Box box; if (StackFind(stack, px1, py1, px2, py2) == true) &#123; for (int i = 1; i &lt; stack-&gt;top; i++) &#123; setfillcolor(GREEN); box = stack-&gt;data[i]; solidrectangle((box.y - 1) * 50, (box.x - 1) * 50, (box.y - 1) * 50 + 50, (box.x - 1) * 50 + 50); //暂停0.1s钟以便于观察路径过程 Sleep(1000); &#125; &#125;&#125;void MEUN1(struct Stack *&amp;stack,struct Queue *&amp;queue)&#123; initgraph(1300, 600); setbkmode(TRANSPARENT);//透明字体 HWND hwnd = GetHWnd();//获取当前窗口句柄 setbkcolor(RED); cleardevice(); setlinecolor(GREEN); settextcolor(GREEN);//字体颜色 LOGFONT f; gettextstyle(&amp;f); // 获取当前字体设置 f.lfHeight = 48; // 设置字体高度为 48 _tcscpy_s(f.lfFaceName, _T(&quot;微软雅黑&quot;)); // 设置字体为“黑体”(高版本 VC 推荐使用 _tcscpy_s 函数) //f.lfQuality = ANTIALIASED_QUALITY; // 设置输出效果为抗锯齿 settextstyle(&amp;f); // 设置字体样式 rectangle(550, 300, 750, 400); rectangle(550, 400, 750, 500); rectangle(550, 500, 750, 600); RECT r1 = &#123; 550, 300, 750, 400 &#125;; drawtext(_T(&quot;栈寻路&quot;), &amp;r1, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r2 = &#123; 550, 400, 750, 500 &#125;; drawtext(_T(&quot;队列寻路&quot;), &amp;r2, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r3 = &#123; 550,500,750,600 &#125;; drawtext(_T(&quot;退出&quot;), &amp;r3, DT_CENTER | DT_VCENTER | DT_SINGLELINE); MOUSEMSG Mou; BeginBatchDraw(); bool flag = true; while (flag) &#123; Mou = GetMouseMsg(); switch (Mou.uMsg) &#123; case WM_MOUSEMOVE: EndBatchDraw(); if ((Mou.y &gt;= 300 &amp;&amp; Mou.y &lt;= 400) &amp;&amp; (Mou.x &lt;= 750 &amp;&amp; Mou.x &gt;= 550)) &#123; settextcolor(YELLOW); rectangle(550, 300, 750, 400); RECT r1 = &#123; 550, 300, 750, 400 &#125;; drawtext(_T(&quot;栈寻路&quot;), &amp;r1, DT_CENTER | DT_VCENTER | DT_SINGLELINE); settextcolor(GREEN); rectangle(550, 400, 750, 500); RECT r2 = &#123; 550,400,750,500 &#125;; drawtext(_T(&quot;队列寻路&quot;), &amp;r2, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r3 = &#123; 550, 750, 500, 600 &#125;; drawtext(_T(&quot;退出&quot;), &amp;r3, DT_CENTER | DT_VCENTER | DT_SINGLELINE); &#125; else if (Mou.y &gt;= 400 &amp;&amp; Mou.y &lt;= 500 &amp;&amp; Mou.x &lt;= 750 &amp;&amp; Mou.x &gt;= 550) &#123; settextcolor(YELLOW); RECT r2 = &#123; 550,400,750,500 &#125;; drawtext(_T(&quot;队列寻路&quot;), &amp;r2, DT_CENTER | DT_VCENTER | DT_SINGLELINE); settextcolor(GREEN); rectangle(550, 300, 750, 400); RECT r1 = &#123; 550, 300, 750, 400 &#125;; drawtext(_T(&quot;栈寻路&quot;), &amp;r1, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r3 = &#123; 550, 750, 500, 600 &#125;; drawtext(_T(&quot;退出&quot;), &amp;r3, DT_CENTER | DT_VCENTER | DT_SINGLELINE); &#125; else if (Mou.x &gt;= 550 &amp;&amp; Mou.x &lt;= 750 &amp;&amp; Mou.y &gt;= 500 &amp;&amp; Mou.y &lt;= 600) &#123; settextcolor(YELLOW); RECT r3 = &#123; 550, 500, 750, 600 &#125;; drawtext(_T(&quot;退出&quot;), &amp;r3, DT_CENTER | DT_VCENTER | DT_SINGLELINE); settextcolor(GREEN); rectangle(550, 300, 750, 400); rectangle(550, 400, 750, 500); RECT r1 = &#123; 550, 300, 750, 400 &#125;; drawtext(_T(&quot;栈寻路&quot;), &amp;r1, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r2 = &#123; 550, 400, 750, 500 &#125;; drawtext(_T(&quot;队列寻路&quot;), &amp;r2, DT_CENTER | DT_VCENTER | DT_SINGLELINE); &#125; else &#123; settextcolor(GREEN); rectangle(550, 300, 750, 400); rectangle(550, 400, 750, 500); rectangle(550, 500, 750, 600); RECT r1 = &#123; 550, 300, 750, 400 &#125;; drawtext(_T(&quot;栈寻路&quot;), &amp;r1, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r2 = &#123; 550, 400, 750, 500 &#125;; drawtext(_T(&quot;队列寻路&quot;), &amp;r2, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r3 = &#123; 550,500,750,600 &#125;; drawtext(_T(&quot;退出&quot;), &amp;r3, DT_CENTER | DT_VCENTER | DT_SINGLELINE); &#125; break; case WM_LBUTTONDOWN: EndBatchDraw(); if (Mou.x &gt;= 550 &amp;&amp; Mou.x &lt;= 750 &amp;&amp; Mou.y &lt;= 400 &amp;&amp; Mou.y &gt;= 300) &#123; flag1 = 1; closegraph(); MEUN2(stack,queue); &#125; else if (Mou.x &gt;= 550 &amp;&amp; Mou.x &lt;= 750 &amp;&amp; Mou.y &gt;= 400 &amp;&amp; Mou.y &lt;= 500)&#123; flag1 = 2; closegraph(); MEUN2(stack,queue); &#125; else if (Mou.x &gt;= 550 &amp;&amp; Mou.x &lt;= 750 &amp;&amp; Mou.y &gt;= 500 &amp;&amp; Mou.y &lt;= 600) &#123; closegraph(); flag = false; &#125; break; &#125; &#125;&#125;void MEUN2(struct Stack *&amp;stack, struct Queue *&amp;queue)&#123; initgraph(1300, 600); setbkcolor(WHITE); cleardevice(); PrintLine(); settextcolor(GREEN);//字体颜色 LOGFONT f; gettextstyle(&amp;f); // 获取当前字体设置 f.lfHeight = 48; // 设置字体高度为 48 _tcscpy_s(f.lfFaceName, _T(&quot;微软雅黑&quot;)); // 设置字体为“黑体”(高版本 VC 推荐使用 _tcscpy_s 函数) f.lfQuality = ANTIALIASED_QUALITY; // 设置输出效果为抗锯齿 settextstyle(&amp;f); // 设置字体样式 rectangle(1050, 100, 1250, 150);//设置起点 rectangle(1050, 150, 1250, 200);//设置终点 rectangle(1050, 200, 1250, 250);//随机障碍 rectangle(1050, 250, 1250, 300);//开始寻路 rectangle(1050, 300, 1250, 350);//退出迷宫 RECT r1 = &#123; 1050, 100, 1250, 150 &#125;; drawtext(_T(&quot;设置起点&quot;), &amp;r1, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r2 = &#123; 1050, 150, 1250, 200 &#125;; drawtext(_T(&quot;设置终点&quot;), &amp;r2, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r3 = &#123; 1050, 200, 1250, 250 &#125;; drawtext(_T(&quot;随机障碍&quot;), &amp;r3, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r4 = &#123; 1050, 250, 1250, 300 &#125;; drawtext(_T(&quot;开始寻路&quot;), &amp;r4, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r5 = &#123; 1050, 300, 1250, 350 &#125;; drawtext(_T(&quot;退出迷宫&quot;), &amp;r5, DT_CENTER | DT_VCENTER | DT_SINGLELINE); MOUSEMSG Mou; while (true) &#123; Mou = GetMouseMsg(); BeginBatchDraw(); switch (Mou.uMsg) &#123; case WM_MOUSEMOVE: EndBatchDraw(); if ((Mou.x &gt;= 1050 &amp;&amp; Mou.x &lt;= 1250) &amp;&amp; (Mou.y &gt;= 100 &amp;&amp; Mou.y &lt;= 150)) &#123; settextcolor(YELLOW); rectangle(1050, 100, 1250, 150); RECT r1 = &#123; 1050, 100, 1250, 150 &#125;; drawtext(_T(&quot;设置起点&quot;), &amp;r1, DT_CENTER | DT_VCENTER | DT_SINGLELINE); settextcolor(GREEN); rectangle(1050, 150, 1250, 200);//设置终点 rectangle(1050, 200, 1250, 250);//随机障碍 rectangle(1050, 250, 1250, 300);//开始寻路 rectangle(1050, 300, 1250, 350);//退出迷宫 RECT r2 = &#123; 1050, 150, 1250, 200 &#125;; drawtext(_T(&quot;设置终点&quot;), &amp;r2, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r3 = &#123; 1050, 200, 1250, 250 &#125;; drawtext(_T(&quot;随机障碍&quot;), &amp;r3, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r4 = &#123; 1050, 250, 1250, 300 &#125;; drawtext(_T(&quot;开始寻路&quot;), &amp;r4, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r5 = &#123; 1050, 300, 1250, 350 &#125;; drawtext(_T(&quot;退出迷宫&quot;), &amp;r5, DT_CENTER | DT_VCENTER | DT_SINGLELINE); &#125; else if (Mou.x &gt;= 1050 &amp;&amp; Mou.x &lt;= 1250 &amp;&amp; Mou.y &gt;= 150 &amp;&amp; Mou.y &lt;= 200) &#123; settextcolor(YELLOW); rectangle(1050, 150, 1250, 200); RECT r2 = &#123; 1050, 150, 1250, 200 &#125;; drawtext(_T(&quot;设置终点&quot;), &amp;r2, DT_CENTER | DT_VCENTER | DT_SINGLELINE); settextcolor(GREEN); rectangle(1050, 100, 1250, 150);//设置起点 rectangle(1050, 200, 1250, 250);//随机障碍 rectangle(1050, 250, 1250, 300);//开始寻路 rectangle(1050, 300, 1250, 350);//退出迷宫 RECT r1 = &#123; 1050, 100, 1250, 150 &#125;; drawtext(_T(&quot;设置起点&quot;), &amp;r1, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r3 = &#123; 1050, 200, 1250, 250 &#125;; drawtext(_T(&quot;随机障碍&quot;), &amp;r3, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r4 = &#123; 1050, 250, 1250, 300 &#125;; drawtext(_T(&quot;开始寻路&quot;), &amp;r4, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r5 = &#123; 1050, 300, 1250, 350 &#125;; drawtext(_T(&quot;退出迷宫&quot;), &amp;r5, DT_CENTER | DT_VCENTER | DT_SINGLELINE); &#125; else if (Mou.x &gt;= 1050 &amp;&amp; Mou.x &lt;= 1250 &amp;&amp; Mou.y &gt;= 200 &amp;&amp; Mou.y &lt;= 250) &#123; stack-&gt;top = -1; queue-&gt;front = queue-&gt;rear = -1; settextcolor(YELLOW); rectangle(1050, 200, 1250, 250); RECT r3 = &#123; 1050, 200, 1250, 250 &#125;; drawtext(_T(&quot;随机障碍&quot;), &amp;r3, DT_CENTER | DT_VCENTER | DT_SINGLELINE); settextcolor(GREEN); rectangle(1050, 100, 1250, 150);//设置起点 rectangle(1050, 150, 1250, 200);//设置终点 rectangle(1050, 250, 1250, 300);//开始寻路 rectangle(1050, 300, 1250, 350);//退出迷宫 RECT r1 = &#123; 1050, 100, 1250, 150 &#125;; drawtext(_T(&quot;设置起点&quot;), &amp;r1, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r2 = &#123; 1050, 150, 1250, 200 &#125;; drawtext(_T(&quot;设置终点&quot;), &amp;r2, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r4 = &#123; 1050, 250, 1250, 300 &#125;; drawtext(_T(&quot;开始寻路&quot;), &amp;r4, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r5 = &#123; 1050, 300, 1250, 350 &#125;; drawtext(_T(&quot;退出迷宫&quot;), &amp;r5, DT_CENTER | DT_VCENTER | DT_SINGLELINE); &#125; else if (Mou.x &gt;= 1050 &amp;&amp; Mou.x &lt;= 1250 &amp;&amp; Mou.y &lt;= 300 &amp;&amp; Mou.y &gt;= 250) &#123; settextcolor(YELLOW); rectangle(1050, 250, 1250, 300); RECT r4 = &#123; 1050, 250, 1250, 300 &#125;; drawtext(_T(&quot;开始寻路&quot;), &amp;r4, DT_CENTER | DT_VCENTER | DT_SINGLELINE); settextcolor(GREEN); rectangle(1050, 100, 1250, 150);//设置起点 rectangle(1050, 150, 1250, 200);//设置终点 rectangle(1050, 200, 1250, 250);//随机障碍 rectangle(1050, 300, 1250, 350);//退出迷宫 RECT r1 = &#123; 1050, 100, 1250, 150 &#125;; drawtext(_T(&quot;设置起点&quot;), &amp;r1, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r2 = &#123; 1050, 150, 1250, 200 &#125;; drawtext(_T(&quot;设置终点&quot;), &amp;r2, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r3 = &#123; 1050, 200, 1250, 250 &#125;; drawtext(_T(&quot;随机障碍&quot;), &amp;r3, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r5 = &#123; 1050, 300, 1250, 350 &#125;; drawtext(_T(&quot;退出迷宫&quot;), &amp;r5, DT_CENTER | DT_VCENTER | DT_SINGLELINE); &#125; else if (Mou.x &gt;= 1050 &amp;&amp; Mou.x &lt;= 1250 &amp;&amp; Mou.y &gt;= 300 &amp;&amp; Mou.y &lt;= 350) &#123; settextcolor(YELLOW); rectangle(1050, 250, 1250, 300); RECT r5 = &#123; 1050, 300, 1250, 350 &#125;; drawtext(_T(&quot;退出迷宫&quot;), &amp;r5, DT_CENTER | DT_VCENTER | DT_SINGLELINE); settextcolor(GREEN); rectangle(1050, 100, 1250, 150);//设置起点 rectangle(1050, 150, 1250, 200);//设置终点 rectangle(1050, 200, 1250, 250);//随机障碍 rectangle(1050, 250, 1250, 300);//开始寻路 RECT r1 = &#123; 1050, 100, 1250, 150 &#125;; drawtext(_T(&quot;设置起点&quot;), &amp;r1, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r2 = &#123; 1050, 150, 1250, 200 &#125;; drawtext(_T(&quot;设置终点&quot;), &amp;r2, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r3 = &#123; 1050, 200, 1250, 250 &#125;; drawtext(_T(&quot;随机障碍&quot;), &amp;r3, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r4 = &#123; 1050, 250, 1250, 300 &#125;; drawtext(_T(&quot;开始寻路&quot;), &amp;r4, DT_CENTER | DT_VCENTER | DT_SINGLELINE); &#125; else &#123; settextcolor(GREEN); rectangle(1050, 100, 1250, 150);//设置起点 rectangle(1050, 150, 1250, 200);//设置终点 rectangle(1050, 200, 1250, 250);//随机障碍 rectangle(1050, 250, 1250, 300);//开始寻路 rectangle(1050, 300, 1250, 350);//退出迷宫 RECT r1 = &#123; 1050, 100, 1250, 150 &#125;; drawtext(_T(&quot;设置起点&quot;), &amp;r1, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r2 = &#123; 1050, 150, 1250, 200 &#125;; drawtext(_T(&quot;设置终点&quot;), &amp;r2, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r3 = &#123; 1050, 200, 1250, 250 &#125;; drawtext(_T(&quot;随机障碍&quot;), &amp;r3, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r4 = &#123; 1050, 250, 1250, 300 &#125;; drawtext(_T(&quot;开始寻路&quot;), &amp;r4, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r5 = &#123; 1050, 300, 1250, 350 &#125;; drawtext(_T(&quot;退出迷宫&quot;), &amp;r5, DT_CENTER | DT_VCENTER | DT_SINGLELINE); &#125; break; case WM_LBUTTONDOWN: EndBatchDraw(); if (Mou.x &gt;= 1050 &amp;&amp; Mou.x &lt;= 1250 &amp;&amp; Mou.y &gt;= 100 &amp;&amp; Mou.y &lt;= 150) &#123; bool flag = true; while (flag) &#123; //FlushMouseMsgBuffer(); Mou = GetMouseMsg(); BeginBatchDraw(); switch (Mou.uMsg) &#123; case WM_LBUTTONDOWN: EndBatchDraw(); py1 = Mou.x / 50; px1 = Mou.y / 50; if (mg[py1 + 1][px1 + 1] != 1) &#123; setfillcolor(BLUE); fillrectangle(Mou.x / 50 * 50, Mou.y / 50 * 50, Mou.x / 50 * 50 + 50, Mou.y / 50 * 50 + 50); flag = false; &#125; py1 += 1; px1 += 1; break; &#125; &#125; &#125; else if (Mou.x &gt;= 1050 &amp;&amp; Mou.x &lt;= 1250 &amp;&amp; Mou.y &gt;= 150 &amp;&amp; Mou.y &lt;= 200) &#123; bool flag = true; while (flag) &#123; //FlushMouseMsgBuffer(); Mou = GetMouseMsg(); BeginBatchDraw(); switch (Mou.uMsg) &#123; case WM_LBUTTONDOWN: EndBatchDraw(); py2 = Mou.x / 50; px2 = Mou.y / 50; if (mg[py2 + 1][px2 + 1] != 1) &#123; setfillcolor(YELLOW); fillrectangle(Mou.x / 50 * 50, Mou.y / 50 * 50, Mou.x / 50 * 50 + 50, Mou.y / 50 * 50 + 50); flag = false; &#125; py2 += 1; px2 += 1; break; &#125; &#125; &#125; else if (Mou.x &gt;= 1050 &amp;&amp; Mou.x &lt;= 1250 &amp;&amp; Mou.y &gt;= 200 &amp;&amp; Mou.y &lt;= 250) &#123; stack-&gt;top = -1; queue-&gt;front = queue-&gt;rear = -1; init(); cleardevice(); PrintLine(); FillColor(); &#125; else if (Mou.x &gt;= 1050 &amp;&amp; Mou.x &lt;= 1250 &amp;&amp; Mou.y &lt;= 300 &amp;&amp; Mou.y &gt;= 250) &#123; if (flag1 == 1) &#123; cout &lt;&lt; px1 &lt;&lt; &apos; &apos; &lt;&lt; py1 &lt;&lt; endl; cout &lt;&lt; px2 &lt;&lt; &apos; &apos; &lt;&lt; py2 &lt;&lt; endl; StackRoad(stack); &#125; else if (flag1 == 2) &#123; cout &lt;&lt; px1 &lt;&lt; &apos; &apos; &lt;&lt; py1 &lt;&lt; endl; cout &lt;&lt; px2 &lt;&lt; &apos; &apos; &lt;&lt; py2 &lt;&lt; endl; QueueRoad(queue); &#125; &#125; else if (Mou.x &gt;= 1050 &amp;&amp; Mou.x &lt;= 1250 &amp;&amp; Mou.y &gt;= 300 &amp;&amp; Mou.y &lt;= 350) &#123; closegraph(); stack-&gt;top = -1; queue-&gt;front = queue-&gt;rear = -1; flag1 = 0; init(); MEUN1(stack,queue); &#125; &#125; &#125;&#125;int main()&#123; //栈 struct Stack *stack; stack = (struct Stack *)malloc(sizeof(struct Stack)); stack-&gt;top = -1; //队列 struct Queue *queue; queue = (struct Queue *)malloc(sizeof(struct Queue)); queue-&gt;rear = queue-&gt;front = -1; //设置迷宫边界值 init(); //Sleep(1000); MEUN1(stack,queue); return 0;&#125; 编译完整版本：链接：https://pan.baidu.com/s/1RrWjaRj_w47mxJy3aWdBhw提取码：0dy0 下个目标：五子棋？]]></content>
      <categories>
        <category>课程设计</category>
      </categories>
      <tags>
        <tag>小玩具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈队列容器用法整理]]></title>
    <url>%2F2018%2F10%2F27%2FSTL%2F%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[记下学习STL的经历。STL很强大。变量减少了，代码也更清晰明了。但有个困惑的地方，我个人使用队列写题的时候，会采用一种取巧的方法，就是随机访问队列中的元素（大概会被老师打死qwq）如下1for(int i=queue-&gt;front;i&lt;=queue-&gt;rear;i++) 但在STL里没有？是不鼓励我们这么做吧，囧rz。 stack容器stack的模板包含在#include&lt;stack&gt;内 定义：123stack&lt;int&gt; s;stack&lt;double&gt; s;stack&lt;char&gt; s; 基本用法：12345入栈：s.push(x);出栈：s.pop(); 出栈只是删除栈顶元素并不返回该元素判断栈空：s.empty();若为空返回ture访问栈顶：s.top();访问栈的元素个数：s.size(); 应用实列–括号匹配1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;string&gt;using namespace std;int main()&#123; int Case; cin &gt;&gt; Case; while (Case--) &#123; string str; stack&lt;char&gt; s; cin &gt;&gt; str; string::iterator it; for (it = str.begin(); it != str.end(); it++) &#123; if (*it == &apos;[&apos; || *it == &apos;&#123;&apos; || *it == &apos;(&apos;) &#123; s.push(*it); &#125; if (*it == &apos;]&apos;) if (s.empty()||s.top() != &apos;[&apos;) break; else s.pop(); if (*it == &apos;)&apos;) if (s.empty() || s.top() != &apos;(&apos;) break; else s.pop(); if (*it == &apos;&#125;&apos;) if (s.empty() || s.top() != &apos;&#123;&apos;) break; else s.pop(); &#125; if (!s.empty() || it &lt; str.end()) cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; &#125; return 0;&#125; 队列queue包含在#include&lt;queue&gt;中 定义123queue&lt;int&gt; q;queue&lt;double&gt; q;queue&lt;char&gt; q; 基本用法123456入队：queue.push(x);出队：queue.pop(); 出队只是删除队首元素并不返回该元素判断队空：queue.empty();访问队首元素：queue.front();访问队尾元素：queue.back();访问队列中元素个数：queue.size(); 应用实例–队列元素倒置1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;string&gt;#include&lt;malloc.h&gt;#define MAXSIZE 10using namespace std;int main()&#123; char str[MAXSIZE]; cin &gt;&gt; str; stack&lt;char&gt; stack; queue&lt;char&gt; queue; for (int i = 0; i &lt; strlen(str); i++)&#123; queue.push(str[i]); &#125; cout &lt;&lt;&quot;the queue&apos;s size is &quot;&lt;&lt; queue.size() &lt;&lt; endl; while (!queue.empty()) &#123; stack.push(queue.front()); queue.pop(); &#125; while (!stack.empty()) &#123; queue.push(stack.top()); stack.pop(); &#125; while (!queue.empty()) &#123; char x = queue.front(); cout &lt;&lt; x &lt;&lt; &apos; &apos;; queue.pop(); &#125; return 0;&#125; 时间过的好快啊。]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hustoj的一些操作]]></title>
    <url>%2F2018%2F10%2F25%2FLinux%2Fhustoj%E7%BB%B4%E6%8A%A4%2F</url>
    <content type="text"><![CDATA[从10月5号开始OJ的导入数据，然，未知的总是让人恐惧。陆陆续续搞了多少天？网站挂了，数据库删了，一切重新来一遍吧。想到什么说什么啊！永远告诉自己啊！不要瞎操作啊！教训啊！你知道我这些天怎么过的啊！心里郁闷啊！明明是一样的操作啊！明明一样的环境啊！为什么得到不同的结果啊！ navicat连接数据库要想navicat能够连接到数据库，需要满足两个条件1、数据库用户有足够的权限访问数据库里说有的数据2、开放3306端口 创建数据库用户并分配权限登录数据库12root@Ubuntu:~# mysql -u root -pEnter password: 按提示输入密码注意：在数据库下所有命令都要以 ；结尾。 查看数据库用户名1select host,user,password from mysql.user; 一般来说输入上面命令会出现如下123456789101112mysql&gt; select Host,user,password from mysql.user;+-----------+------------------+-------------------------------------------+| Host | user | password |+-----------+------------------+-------------------------------------------+| localhost | root | password| ubuntu | root | password| 127.0.0.1 | root | password| ::1 | root | password| localhost | debian-sys-maint | password| % | passwords | password+-----------+------------------+-------------------------------------------+6 rows in set (0.00 sec) 其中Host栏目下的%代表该用户拥有所有的权限，如果没有该用户，就需要创建。 创建用户1234mysql&gt; create user youname identified by &apos;youname&apos;;Query OK, 0 rows affected (0.00 sec)mysql&gt; 其中第一个youname是你创建的这个数据库用户名的名称，第二个youname就是密码了。 授权1234mysql&gt; grant all privileges on *.* to &apos;youname&apos;@&apos;%&apos;identified by &apos;youname&apos; with grant option; Query OK, 0 rows affected (0.00 sec)mysql&gt; 操作完成后刷新mysql用户权限相关表1234mysql&gt; flush privileges ;Query OK, 0 rows affected (0.00 sec)mysql&gt; 查看端口开放1netstat -an | grep 3306 出现如下表示端口开放,12root@Ubuntu:~# netstat -an | grep 3306tcp 0 0 0.0.0.0:3306 0.0.0.0:* LISTEN 若是1127.0.0.1:3306 表示3306端口被本机IP绑定，外机无法访问，所以需要将其开放。 打开my.cnf配置文件1root@Ubuntu:~# vim /etc/mysql/my.cnf 找到 bind-address =127.0.0.1，将其注释掉或者改为bind-address = 0.0.0.01234567## Instead of skip-networking the default is now to listen only on# localhost which is more compatible and is not less secure.bind-address = 127.0.0.1## * Fine Tuning# 如此navicat就可以连接上数据库了。 OJ重要的配置文件1234/home/judge/etc/judge.conf/home/judge/src/web/include/db_info.inc.php/etc/php5/fpm/php.ini 或 /etc/php7.0/fpm/php.ini/etc/nginx/sites-enabled/default 开启考试模式因为学校作业练习的需要，在考试时需要改成比赛模式，以防止使用原来提交过的代码。修改db_info.inc.php文件1root@Ubuntu:~# vim /home/judge/src/web/include/db_info.inc.php 如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;?php @session_start(); ini_set(&quot;display_errors&quot;,&quot;Off&quot;); //set this to &quot;On&quot; for debugging ,especially when no reason blank shows up. ini_set(&quot;session.cookie_httponly&quot;, 1); header(&apos;X-Frame-Options:SAMEORIGIN&apos;);//for people using hustoj out of China , be careful of the last two line of this file !// connect db static $DB_HOST=&quot;localhost&quot;;static $DB_NAME=&quot;jol&quot;;static $DB_USER=&quot;root&quot;;static $DB_PASS=&quot;root&quot;;//上面四行中如果没有问题就不要动，都是默认好的。可能数据库账户密码不是root，这点并不影响。//16.04安装可能数据库账户密码为空，如果为空，账户填写为 root 密码填写 自己设置的。//如果需要改写的话一定要用vim或者vi打开static $OJ_NAME=&quot;HUSTOJ&quot;;static $OJ_HOME=&quot;./&quot;;static $OJ_ADMIN=&quot;root@localhost&quot;;static $OJ_DATA=&quot;/home/judge/data&quot;;static $OJ_BBS=&quot;discuss3&quot;;//&quot;bbs&quot; for phpBB3 bridge or &quot;discuss&quot; for mini-forumstatic $OJ_ONLINE=false;static $OJ_LANG=&quot;en&quot;;static $OJ_SIM=false; static $OJ_DICT=false;static $OJ_LANGMASK=0; //1mC 2mCPP 4mPascal 8mJava 16mRuby 32mBash 1008 for security reason to mask all other languagestatic $OJ_EDITE_AREA=true;//true: syntax highlighting is activestatic $OJ_ACE_EDITOR=true;static $OJ_AUTO_SHARE=false;//true: One can view all AC submit if he/she has ACed it onece.static $OJ_CSS=&quot;white.css&quot;;static $OJ_SAE=false; //using sina application enginestatic $OJ_VCODE=false;static $OJ_APPENDCODE=false;static $OJ_CE_PENALTY=false;static $OJ_PRINTER=false;static $OJ_MAIL=false;static $OJ_MEMCACHE=false;static $OJ_MEMSERVER=&quot;127.0.0.1&quot;;static $OJ_MEMPORT=11211;static $OJ_REDIS=false;static $OJ_REDISSERVER=&quot;127.0.0.1&quot;;static $OJ_REDISPORT=6379;static $OJ_REDISQNAME=&quot;hustoj&quot;;static $SAE_STORAGE_ROOT=&quot;http://hustoj-web.stor.sinaapp.com/&quot;;static $OJ_TEMPLATE=&quot;bs3&quot;; //使用的默认模板if(isset($_GET[&apos;tp&apos;])) $OJ_TEMPLATE=$_GET[&apos;tp&apos;];static $OJ_LOGIN_MOD=&quot;hustoj&quot;;static $OJ_REGISTER=true; //允许注册新用户static $OJ_REG_NEED_CONFIRM=false; //新注册用户需要审核static $OJ_NEED_LOGIN=false; //需要登录才能访问static $OJ_RANK_LOCK_PERCENT=0; //比赛封榜时间比例static $OJ_SHOW_DIFF=false; //是否显示WA的对比说明static $OJ_TEST_RUN=false; //提交界面是否允许测试运行static $OJ_BLOCKLY=false; //是否启用Blockly界面static $OJ_ENCODE_SUBMIT=false; //是否启用base64编码提交的功能，用来回避WAF防火墙误拦截。//static $OJ_EXAM_CONTEST_ID=1000; // 启用考试状态，填写考试比赛ID//static $OJ_ON_SITE_CONTEST_ID=1000; //启用现场赛状态，填写现场赛比赛IDstatic $OJ_OPENID_PWD = &apos;8a367fe87b1e406ea8e94d7d508dcf01&apos;;/* weibo config here */static $OJ_WEIBO_AUTH=false;static $OJ_WEIBO_AKEY=&apos;1124518951&apos;;static $OJ_WEIBO_ASEC=&apos;df709a1253ef8878548920718085e84b&apos;;static $OJ_WEIBO_CBURL=&apos;http://192.168.0.108/JudgeOnline/login_weibo.php&apos;;/* renren config here */static $OJ_RR_AUTH=false;static $OJ_RR_AKEY=&apos;d066ad780742404d85d0955ac05654df&apos;;static $OJ_RR_ASEC=&apos;c4d2988cf5c149fabf8098f32f9b49ed&apos;;static $OJ_RR_CBURL=&apos;http://192.168.0.108/JudgeOnline/login_renren.php&apos;;/* qq config here */static $OJ_QQ_AUTH=false;static $OJ_QQ_AKEY=&apos;1124518951&apos;;static $OJ_QQ_ASEC=&apos;df709a1253ef8878548920718085e84b&apos;;static $OJ_QQ_CBURL=&apos;192.168.0.108&apos;;//if(date(&apos;H&apos;)&lt;5||date(&apos;H&apos;)&gt;21||isset($_GET[&apos;dark&apos;])) $OJ_CSS=&quot;dark.css&quot;;if( isset($_SERVER[&apos;HTTP_ACCEPT_LANGUAGE&apos;]) &amp;&amp; strstr($_SERVER[&apos;HTTP_ACCEPT_LANGUAGE&apos;],&quot;zh-CN&quot;)) &#123; $OJ_LANG=&quot;cn&quot;;&#125;if (isset($_SESSION[$OJ_NAME.&apos;_&apos;.&apos;OJ_LANG&apos;])) $OJ_LANG=$_SESSION[$OJ_NAME.&apos;_&apos;.&apos;OJ_LANG&apos;];require_once(dirname(__FILE__).&quot;/pdo.php&quot;); // use db //pdo_query(&quot;set names utf8&quot;); if(isset($OJ_CSRF)&amp;&amp;$OJ_CSRF&amp;&amp;$OJ_TEMPLATE==&quot;bs3&quot;&amp;&amp;basename($_SERVER[&apos;PHP_SELF&apos;])!=&quot;problem_judge&quot;) require_once(&apos;csrf_check.php&apos;); //sychronize php and mysql server with timezone settings, dafault setting for China //if you are not from China, comment out these two lines or modify them. //date_default_timezone_set(&quot;PRC&quot;); //pdo_query(&quot;SET time_zone =&apos;+8:00&apos;&quot;);?&gt; 找到并取消注释就可以了12//static $OJ_EXAM_CONTEST_ID=1000; // 启用考试状态，填写考试比赛ID//static $OJ_ON_SITE_CONTEST_ID=1000; //启用现场赛状态，填写现场赛比赛ID OJ判题语言，找到并修改1static $OJ_LANGMASK=0; //1mC 2mCPP 4mPascal 8mJava 16mRuby 32mBash 1008 for security reason to mask all other language 在源码中的位置1root@Ubuntu:~# vim /home/judge/src/core/judge_client/judge_client.cc 大约在130行，这个文件有2000+行代码qwq123456#ifdef _mysql_hMYSQL *conn;#endifstatic char lang_ext[18][8] = &#123; &quot;c&quot;, &quot;cc&quot;, &quot;pas&quot;, &quot;java&quot;, &quot;rb&quot;, &quot;sh&quot;, &quot;py&quot;, &quot;php&quot;, &quot;pl&quot;, &quot;cs&quot;, &quot;m&quot;, &quot;bas&quot;, &quot;scm&quot;,&quot;c&quot;,&quot;cc&quot;,&quot;lua&quot;,&quot;js&quot;,&quot;go&quot; &#125;; 按照上文$OJ_LANGMASK=0代表所有的语言都可以提交，可知0决定何种语言可以使用。先说明0代表启用，1代表禁用。比如想要c和c++可以使用，那么二进制编码就是001111111111111111，转换成十进制就是‭65535‬，让 OJ_LANGMASK=65535就可以了。 转移数据库关于把原来服务器上的OJ上的数据全部转移到另一台服务器上的具体命令。首先在新服务器上装上hustoj。两个重要的数据：jol数据库 学生做题记录，ac代码/home/judge/data 题目的测试数据 转移jol在原来服务器上12mysqldump -u root -p密码 数据库名 &gt; 数据库文件路径如：mysqldump -u root -ppassword jol &gt; /home/jol.sql //在home文件下的data.sql文件 下载到本地：sz 命令是从linux下载文件到本地1sz /home/jol.sql 在后一台服务器上把本地的文件上传到该服务器上进入相应的文件路径，然后输入rz选择你本地（假如是window）1rz 登录数据库1mysql - u root -p 选择转入的数据库1use jol; 然后把jol.sql传入database中，注意/home/jol.sql是你从本地上传到服务器上的文件路径1source /home/jol.sql; 转移/home/judge/data原服务器上打包data(不压缩)1tar -cvf /home/judge/data.tar data 下载到本地1sz /home/judge/data.tar 后一台服务器上将data.tar上传到/home/judge1rz 在路径/home/judge下解包1tar -xvf data.tar 可以了。维护工作尚在进行，祝自己好运吧，qwq。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>OJ运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对未来的一些规划]]></title>
    <url>%2F2018%2F10%2F24%2F%E9%9A%8F%E7%AC%94%E6%9D%82%E6%83%B3%2Fdowhatiwant%2F</url>
    <content type="text"><![CDATA[子在川上曰：逝者如斯夫，不舍昼夜。不知不觉中已经快要11月了，想起来电脑已经买来4个月了。也做过一些好玩的东西，但不知怎么地总是达不到心理的预期目标。明明好像一直呆在实验室，但为什么心里就是感觉不踏实呢？或许看到别人的状态，以为自己还是学到了东西，其实眼光一直局限在学校内，看不到外面的世界，井底之蛙罢了。YI到底还是做出了选择。心里肯定非常不甘的，但还有什么用呢？当初逃避的是你，能怨谁呢？只是在默默祝福。图形学是要学的。但怎么学呢？Csharp你花了多少时间？听说你又想搞前端了？蓝桥杯有能力拿奖吗？网络安全技能大赛又懂得多少？Linux+MySQL现在开始了吗？以前没有服务器，现在有个服务器了你又干了多少事？OJ你不能落下，这是你接的任务就必须完成！数据结构好久没做题了，准备什么时候开始？算法作为计算机专业的核心课程，懂了多少？六级考试只剩50多天了，做了几个题，背了几个单词，听力练过吗？现在就好好考虑吧？我真的担心你一事无成，白白浪费父母的血汉钱！ 主线：计算机图形学+CPP 副线：csharp 到leetcode上写题 熟练语法后开始跟项目 跟上副线：数据结构+算法 解决 蓝桥杯 前端+服务器 前端每天练习30分钟，不做完不睡觉 六级英语：听力 单词 阅读 其中听力单词最为重要 最后做：Linux+Mysql解决OJ linux看鸟哥的书 对于课间的时间就别刷知乎了，看前端也行Linux也可以。手机知乎就卸了吧]]></content>
      <categories>
        <category>随笔杂想</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[think what i want]]></title>
    <url>%2F2018%2F09%2F28%2F%E9%9A%8F%E7%AC%94%E6%9D%82%E6%83%B3%2Fthinkwhatiwant%2F</url>
    <content type="text"><![CDATA[断断续续，从开学至今，将这些天所发生的事心里想法写下来，感觉真的做了好多好多的蠢事，有时候晚上躺在床上不自觉地脑海中就浮现出来，有些影响日常学习了。今天把这些写下来，算是对过去一段时间地总结吧。希望做的不要违背内心。 还记得智商被虐的感觉吧。是不是非常水的考试导致了你对这门学科的懈怠。上课，做题，然后学习其他的，好像有些专门做给别人看的感觉。其实真的会有人在意吗？不要去想这有的没的。想起看过的传记，却发现你已经变得越来越骄躁了。感觉已经坐不住了，想要去显摆自己。可是什么都没学得会，真的想不懂资本在哪。现在是快速提升自己的黄金时期，不要在急功近利中把原本大好的局面葬送了。 计算机给了你弯道超车的机会，你确定还要在无谓的迷茫和迟疑而停留吗。任凭前方多么艰难，要知道，高中的小伙伴已经迈进了新世界的大门。不要让自己变得目光短浅，大学会有不求上进的，但那不该是你浪费精力浪费时间逃避困难的借口。既然选择了这一条路，就别再左顾右盼徒生迷茫了。这时候不应该想这些问题，而是在为前途、为明天着想。 有想去却没去成的地方，有想打却没打完的游戏。小说依然在那，却没了作者的凝视，缺少的不只是生气，更有永不相见的绝望。既然知道了，便不要再想了。纷纷扰扰许久了，还是我怂了。]]></content>
      <categories>
        <category>随笔杂想</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[皇后问题]]></title>
    <url>%2F2018%2F09%2F25%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2FN%E7%9A%87%E5%90%8E%2F</url>
    <content type="text"><![CDATA[皇后问题最重要的就是递归回溯思维。从第一行第一列开始逐级往下放皇后，若可以放置，则放置下一行的皇后，否则就退回到上一皇后的位置。 一、数组加回溯弄清楚了回溯怎么回事，就可以进行第二步了。如何判断在该位置可以放置皇后呢？举个例子来说，在图中，小圆圈代表在当前位置试探性放置，由于皇后是一行一行地放置，也就是说只需要判断位于它上方的位置，而与它位置想冲突的，就是左上角右上角和正上方了。定义一个二维数组eq[10][10]，如果在当前位置(i,j)放置了皇后,就让eq[i][j]=1; 2、代码说明以八皇后为例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#define SIZE 8using namespace std;int ep[SIZE][SIZE]=&#123;0&#125;;int num=0;void judge(int x);bool check(int x,int y);void print();int main()&#123; judge(0); return 0;&#125;void judge(int x)&#123; int j; for(j=0;j&lt;SIZE;j++)&#123; ep[x][j]=1;//先在该位置放置皇后 if(check(x,j)==true)&#123; /*若这个位置可以放置，则判断整个棋盘是否全部放完*/ if(x==SIZE-1) print(); else /*若这个位置可以放置，则这一行的皇后放置完成，转而判断下一行的皇后放置*/ judge(x+1); &#125; /*若这个位置不可以放置，就把该位置的状态恢复，转而判断这一行的下一个位置*/ ep[x][j]=0; &#125;&#125;bool check(int x,int y)&#123; /*判断正上方是否有皇后*/ for(int i=0;i&lt;x;i++) if(ep[i][y]==1) return false; /*判断左上方是否有皇后*/ int i=x-1; int j=y-1; while(i&gt;=0&amp;&amp;j&gt;=0)&#123; if(ep[i][j]==1)//若有，则不可放置，返回假 return false; i--; j--; &#125; /*判断当前位置右上角是否有皇后*/ i=x-1; j=y+1; while(i&gt;=0&amp;&amp;j&lt;SIZE)&#123; if(ep[i][j]==1)//若有皇后，说明这个位置不可以放置 return false; i--; j++; &#125; return true;&#125;void print()&#123; num++; cout&lt;&lt;&quot;No. &quot;&lt;&lt;num&lt;&lt;endl; for(int i=0;i&lt;SIZE;i++)&#123; for(int j=0;j&lt;SIZE;j++) cout&lt;&lt;ep[i][j]&lt;&lt;&apos; &apos;; cout&lt;&lt;endl; &#125; &#125; 二、栈加回溯说是栈，其实可以不用栈的结构，而是用栈存储数据的思想。用栈数组来存储数据，非常方便递归回溯。定义stack[10]，top=-1；用top来存当前位置的行坐标，用stack[top]来存当前位置的列坐标。再次用到这个图，那么当前位置可表示为(2,2)，用栈存储就是stack[2]=2；判断它正上方是否有皇后，那就只需要看整个栈里面是否有与这个位置的列坐标相等的数了，需要做的就是遍历整个栈；代码表示为： 123for(int i=0;i&lt;top;i++)&#123; if(stack1[i]==stack1[top]) return false; 再来看右上角和左上角由于它们是斜对角关系，可知这些位置中，每两个在同一斜线的行坐标之差必定等于列坐标的差比如(x1,y1),(x2,y2)，这两个点在同一斜线，必定fabs(x2-x1)==fabs(y2-y1)；代码表示：123for(int i=0;i&lt;top;i++)&#123; if((top-i)==fabs(stack1[top]-stack1[i])) return false; 2、代码说明以八皇后为例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;#include&lt;cmath&gt;#define SIZE 8using namespace std;int stack1[SIZE];int top=-1;int num=0;void judge(int x);bool check(int stack1[]);void print(int stack1[]);int main()&#123; judge(0); return 0; &#125;void judge(int x)&#123; for(int j=0;j&lt;SIZE;j++)&#123; top++; /*top代表行坐标，stack1[top]代表列坐标*/ stack1[top]=j; if(check(stack1)==true)&#123; if(top==SIZE-1) print(stack1); else /*递归判断下一行的皇后位置*/ judge(x+1); &#125; top--;//不能放置皇后就退栈 &#125;&#125;bool check(int stack1[])&#123; for(int i=0;i&lt;top;i++)&#123; /*判断该位置正上方是否放置了皇后*/ /*判断右上方和左上方是否放置皇后*/ if((top-i)==fabs(stack1[top]-stack1[i])||stack1[i]==stack1[top]) return false; &#125; return true;&#125;void print(int stack1[])&#123; num++; cout&lt;&lt;num&lt;&lt;endl; for(int i=0;i&lt;SIZE;i++)&#123; for(int j=0;j&lt;SIZE;j++) if(stack1[i]==j) cout&lt;&lt;&apos;1&apos;&lt;&lt;&apos; &apos;; else cout&lt;&lt;&apos;0&apos;&lt;&lt;&apos; &apos;; cout&lt;&lt;endl; &#125;&#125; 三、例题1、N皇后问题传送门描述 在N*N的方格棋盘放置了N个皇后，使得它们不相互攻击（即任意2个皇后不允许处在同一排，同一列，也不允许处在与棋盘边框成45角的斜线上。你的任务是，对于给定的N，求出有多少种合法的放置方法。 Input 共有若干行，每行一个正整数N≤10，表示棋盘和皇后的数量；如果N=0，表示结束。 Output 共有若干行，每行一个正整数，表示对应输入行的皇后的不同放置数量。 Sample Input12341850 Sample Output12319210 2、题解代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;#include&lt;cmath&gt;#define MAXSIZE 11using namespace std;int stack1[MAXSIZE];int top=-1;int num=0;void judge(int row,int N);bool check(int stack1[]);int main()&#123; int N; int val[11]; for(int i=1;i&lt;=10;i++)&#123; judge(0,i); val[i]=num; num=0; top=-1; &#125; while(cin&gt;&gt;N)&#123; if(N==0) break; cout&lt;&lt;val[N]&lt;&lt;endl; &#125; return 0; &#125;void judge(int row,int N)&#123; for(int j=0;j&lt;N;j++)&#123; top++; stack1[top]=j; if(check(stack1)==true)&#123; if(top==N-1) num++; else judge(row+1,N); &#125; top--; &#125;&#125;bool check(int stack1[])&#123; for(int i=0;i&lt;top;i++) if(((top-i)==fabs(stack1[top]-stack1[i]))||(stack1[i]==stack1[top])) return false; return true;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《数据结构 李春葆版》课后练习题三（栈与队列）]]></title>
    <url>%2F2018%2F09%2F24%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0%E9%A2%98%E4%B8%89%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[开始做的话，是在灌水吧。栈与队列，刚开始接触这部分知识感觉不是很上手，然而又有什么关系呢？东西就在那里，你学与不学又能怎么样呢？如果总是逃避的难题，碰到真正地难题你还会有信心去面对吗？况且这不能算是难题。明天很美好，前提是你有能力获得美好。然而又有什么好玩的呢？一天又一天的过去，真正做了什么呢？学了什么呢？不清楚自己在做什么，时间并不会等人。做自己想做的，学自己想学的，不要把别人要求你的当成包袱。 一、练习题三第十题括号匹配12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;using namespace std;#define MAXSIZE 1000+10struct Stack&#123; char num[MAXSIZE]; int top;&#125;; int main()&#123; char str[MAXSIZE]; cin&gt;&gt;str; struct Stack stack; stack.top=-1; for(int i=0;i&lt;strlen(str);i++)&#123; if(str[i]==&apos;(&apos;||str[i]==&apos;[&apos;||str[i]==&apos;&#123;&apos;)&#123; stack.top++; stack.num[stack.top]=str[i]; &#125; if(str[i]==&apos;)&apos;) if(stack.num[stack.top]==&apos;(&apos;) stack.top--; else break; if(str[i]==&apos;]&apos;) if(stack.num[stack.top]==&apos;[&apos;) stack.top--; else break; if(str[i]==&apos;&#125;&apos;) if(stack.num[stack.top]==&apos;&#123;&apos;) stack.top--; else break; &#125; if(stack.top==-1&amp;&amp;i&gt;=strlen(str)) cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; return 0;&#125; /*测试数据*//*1、][ No2、[][][]()&#123;&#125;&#123; No3、][][ No4、()[[(&#123;&#125;)]] Yes*/ 第十一题每天要喝八杯水，orz1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &quot;pch.h&quot;#include &lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;string&gt;#include&lt;malloc.h&gt;#define MAXSIZE 10using namespace std;struct Queue&#123; char ch[MAXSIZE]; int rear; int front;&#125;;int main()&#123; char str; struct Queue *queue; queue = (struct Queue *)malloc(sizeof(struct Queue)); queue-&gt;front = queue-&gt;rear = 0; while (1) &#123; cin &gt;&gt; str; if (str&lt;&apos;0&apos; || (str &gt; &apos;9&apos;&amp;&amp;str &lt; &apos;a&apos;) || str&gt;&apos;z&apos;) break; if (str &gt;= &apos;0&apos;&amp;&amp;str &lt;= &apos;9&apos;&amp;&amp;((queue-&gt;rear + 1) % MAXSIZE != queue-&gt;front)) &#123; queue-&gt;rear = (queue-&gt;rear + 1) % MAXSIZE; queue-&gt;ch[queue-&gt;rear] = str; &#125; if (str &gt;= &apos;a&apos;&amp;&amp;str &lt;= &apos;z&apos; &amp;&amp; (queue-&gt;front != queue-&gt;rear)) &#123; queue-&gt;front = (queue-&gt;front + 1) % MAXSIZE; &#125; &#125; while (queue-&gt;front != queue-&gt;rear) &#123; queue-&gt;front = (queue-&gt;front + 1) % MAXSIZE; cout &lt;&lt; queue-&gt;ch[queue-&gt;front] &lt;&lt; &apos; &apos;; &#125; free(queue); return 0;&#125;/*测试数据*//*1、123asw1sw123. 123*/ 第十二题将一个环形队列（容量为n,元素下标从0到n-1）的元素倒置思路：利用栈先进后出的特点，先把队列中的元素全部存到栈中，然后把栈中的元素转移到队列中，over。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;string&gt;#include&lt;malloc.h&gt;#define MAXSIZE 10using namespace std;struct Queue&#123; char ch[MAXSIZE]; int rear; int front;&#125;;struct Stack&#123; char data[MAXSIZE]; int top;&#125;;void Queue1();int main()&#123; char str[MAXSIZE]; cin &gt;&gt; str; struct Queue *queue; struct Stack *stack; queue = (struct Queue *)malloc(sizeof(struct Queue)); queue-&gt;front = queue-&gt;rear = 0; stack = (struct Stack *)malloc(sizeof(struct Stack)); stack-&gt;top = -1; for (int i = 0; i &lt; strlen(str); i++)&#123; queue-&gt;rear = (queue-&gt;rear + 1) % MAXSIZE; queue-&gt;ch[queue-&gt;rear] = str[i]; &#125; while (queue-&gt;front != queue-&gt;rear) &#123; queue-&gt;front = (queue-&gt;front + 1) % MAXSIZE; stack-&gt;top++; stack-&gt;data[stack-&gt;top] = queue-&gt;ch[queue-&gt;front]; &#125; queue-&gt;front = queue-&gt;rear = 0; while (stack-&gt;top != -1) &#123; queue-&gt;rear = (queue-&gt;rear + 1) % MAXSIZE; queue-&gt;ch[queue-&gt;rear] = stack-&gt;data[stack-&gt;top]; stack-&gt;top--; &#125; while (queue-&gt;front != queue-&gt;rear) &#123; queue-&gt;front = (queue-&gt;front + 1) % MAXSIZE; cout &lt;&lt; queue-&gt;ch[queue-&gt;front] &lt;&lt; &apos; &apos;; &#125; return 0;&#125;/*测试数据*//*abcdeff e d c b a*/ 待续……]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《数据结构 李春葆版》课后练习题二（线性表）]]></title>
    <url>%2F2018%2F09%2F21%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0%E9%A2%98%E4%BA%8C%E7%BA%BF%E6%80%A7%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[数据结构课程，做作业，打代码。头昏脑涨时写写这些题目，算是把学过的再重新温习一遍？再复习一遍？不过再写这些题目的时候还真有些地方有点感悟，做OJ上得题，通常会有时间限制，代码不够优化题目测试数据又庞大无比就必定超时。而这些题目呢？一直说要优化，却没有配套的数据来检测，写出来谁知道是不是够优化了。况且题目又只要写函数，这样一来，写的函数不放在完整的程序里跑一遍谁知道是不会出现编译错误（doge~）。好了，就这样吧，就当放松下得得得啊。题目就不抄了，太过练习打码熟练度的题目也不写了。 一、练习题二第六题原地算法了解一下123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;#include&lt;cstdlib&gt;using namespace std;#define MAXSIZE 1000struct List&#123; int data[MAXSIZE]; int length;&#125;;void fun6(struct List *&amp;L,int x,int y);int main()&#123; struct List *L; L=(struct List *)malloc(sizeof(struct List)); for(int i=0;i&lt;9;i++) cin&gt;&gt;L-&gt;data[i]; L-&gt;length=10; fun6(L,4,8); for(int i=0;i&lt;L-&gt;length;i++) cout&lt;&lt;L-&gt;data[i]&lt;&lt;&apos; &apos;; return 0;&#125;/*第六题*/void fun6(struct List *&amp;L,int x,int y)&#123; int j=0; for(int i=0;i&lt;L-&gt;length;i++)&#123; if(L-&gt;data[i]&lt;x||L-&gt;data[i]&gt;y)&#123; L-&gt;data[j]=L-&gt;data[i]; j++; &#125; &#125; L-&gt;length=j-1;&#125;/*测试数据*//*1、1 2 4 6 7 8 9 5 4 1 2 92、2 3 2 4 6 2 7 1 5 2 3 2 2 1*/ 第七题123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;#include&lt;cstdlib&gt;using namespace std;#define MAXSIZE 1000struct List&#123; int data[MAXSIZE]; int length;&#125;;void fun7(struct List *&amp;L,int x);int main()&#123; struct List *L; L=(struct List *)malloc(sizeof(struct List)); for(int i=0;i&lt;9;i++) cin&gt;&gt;L-&gt;data[i]; L-&gt;length=9; fun7(L,4); for(int i=0;i&lt;L-&gt;length;i++) cout&lt;&lt;L-&gt;data[i]&lt;&lt;&apos; &apos;; return 0;&#125;void fun7(struct List *&amp;L,int x)&#123; int i=0; for(i=0;i&lt;L-&gt;length;i++) if(x&lt;L-&gt;data[i]) break; for(int j=L-&gt;length-1;j&gt;=i;j--) L-&gt;data[j+1]=L-&gt;data[j]; L-&gt;data[i]=x; L-&gt;length++;&#125; /*测试数据*//*1、1 2 3 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10*/ 第八题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;#include&lt;cstdlib&gt;using namespace std;#define MAXSIZE 1000#define true1 L-&gt;data[j]&gt;0&amp;&amp;L-&gt;data[i]&lt;0 #define true2 L-&gt;data[j]&lt;0&amp;&amp;L-&gt;data[i]&gt;0struct List&#123; int data[MAXSIZE]; int length;&#125;;void fun8(struct List *&amp;L);void swap(int &amp;a,int &amp;b);int main()&#123; struct List *L; L=(struct List *)malloc(sizeof(struct List)); for(int i=0;i&lt;9;i++) cin&gt;&gt;L-&gt;data[i]; L-&gt;length=9; fun8(L); for(int i=0;i&lt;L-&gt;length;i++) cout&lt;&lt;L-&gt;data[i]&lt;&lt;&apos; &apos;; return 0;&#125;void fun8(struct List *&amp;L)&#123; int j=0; for(int i=1;i&lt;L-&gt;length;i++)&#123; if(true1)&#123; swap(L-&gt;data[j],L-&gt;data[i]); j++; &#125; if(true2) j++; &#125;&#125; void swap(int &amp;a,int &amp;b)&#123; int temp=a; a=b; b=temp;&#125;/*测试数据*/ /*1、-1 2 -2 3 -4 5 -6 7 -8 -1 -2 -4 -6 -8 5 3 7 22、1 -2 -3 1 -1 2 3 -2 -7 -2 -3 -1 -2 -7 2 3 1 1*/ 第十题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;#include&lt;cstdlib&gt;using namespace std;struct List&#123; int num; struct List *next,*pre;&#125;;void creat(struct List *&amp;L);void fun10(struct List *&amp;L);int main()&#123; struct List *L,*p,*p1; L=(struct List *)malloc(sizeof(struct List)); creat(L); fun10(L); p=L-&gt;next; while(p!=NULL)&#123; cout&lt;&lt;p-&gt;num&lt;&lt;&apos; &apos;; p1=p; //p1为验证双链表专用指针 p=p-&gt;next; &#125; /*验证双链表*/ cout&lt;&lt;endl&lt;&lt;&quot;验证双链表&quot;&lt;&lt;endl; while(p1!=L)&#123; cout&lt;&lt;p1-&gt;num&lt;&lt;&apos; &apos;; p1=p1-&gt;pre; &#125; return 0;&#125;void fun10(struct List *&amp;L)&#123; struct List *p1,*p2,*p3; p1=L; for(int i=0;i&lt;2;i++)&#123; p2=p1; p1=p1-&gt;next; &#125; p3=p1-&gt;next; p1-&gt;next=p3-&gt;next; p3-&gt;next=p1; p2-&gt;next=p3; p3-&gt;pre=p2; p1-&gt;next-&gt;pre=p1; p1-&gt;pre=p3; &#125;void creat(struct List *&amp;L)&#123; struct List *p1,*p2; p2=L; for(int i=0;i&lt;5;i++)&#123; p1=(struct List *)malloc(sizeof(struct List)); scanf(&quot;%d&quot;,&amp;p1-&gt;num); p2-&gt;next=p1; p1-&gt;pre=p2; p2=p1; &#125; p2-&gt;next=NULL;&#125;/*测试数据 选择第二个数与第三个数交换*//*1、1 2 3 4 5 1 3 2 4 52、3 4 5 6 3 3 5 4 6 3 */ 第十一题快慢指针了解下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;bits/stdc++.h&gt; #include&lt;cstdlib&gt;using namespace std;#define ture truestruct List&#123; int num; struct List *next;&#125;;void creat(struct List *&amp;L);bool sertchone(struct List *&amp;L,int x);bool sertchtwo(struct List *&amp;L,int x);bool sertchthree(struct List *&amp;L,int x);int main()&#123; struct List *L; L=(struct List *)malloc(sizeof(struct List)); creat(L); bool result1=sertchone(L,2); if(result1) cout&lt;&lt;&quot;true&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;false&quot;&lt;&lt;endl; bool result2=sertchtwo(L,2); if(result2) cout&lt;&lt;&quot;true&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;false&quot;&lt;&lt;endl; bool result3=sertchthree(L,2); if(result3) cout&lt;&lt;&quot;true&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;false&quot;&lt;&lt;endl; return 0;&#125;void creat(struct List *&amp;L)&#123; struct List *p1,*p2; p2=L; for(int i=0;i&lt;5;i++)&#123; p1=(struct List *)malloc(sizeof(struct List)); //scanf(&quot;%d&quot;,&amp;p1-&gt;num); cin&gt;&gt;p1-&gt;num; p2-&gt;next=p1; p2=p1; &#125; p2-&gt;next=NULL;&#125;bool sertchone(struct List *&amp;L,int x)//无序查找，遍历链表，时间复杂度为O(n) &#123; struct List *p=L; while(p!=NULL)&#123; if(p-&gt;num==x) return true; p=p-&gt;next; &#125; return false; &#125;bool sertchtwo(struct List *&amp;L,int x)//递增有序 ,快指针，时间复杂度为O(n/2); &#123; struct List *p1,*p2; p1=p2=L; while(p2-&gt;next-&gt;next!=NULL)&#123; if(p2-&gt;next-&gt;next-&gt;num&lt;=x)&#123; p2=p2-&gt;next-&gt;next; &#125; else&#123; p2=p2-&gt;next; &#125; if(p2-&gt;num==x) return true; &#125; return false; &#125;bool sertchthree(struct List *&amp;L,int x)//递减有序 快指针，时间复杂度为O(n/2); &#123; struct List *p1,*p2; p1=p2=L; while(p2-&gt;next-&gt;next!=NULL)&#123; if(p2-&gt;next-&gt;next-&gt;num&gt;=x)&#123; p2=p2-&gt;next-&gt;next; &#125; else&#123; p2=p2-&gt;next; &#125; if(p2-&gt;num==x) return true; &#125; return false;&#125; 第十二题链表逆转，比较有趣12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;#include&lt;cstdlib&gt;using namespace std;struct List&#123; int num; struct List *next;&#125;;void creat(struct List *&amp;L);void reverse(struct List *&amp;L); int main()&#123; struct List *L,*p; L=(struct List *)malloc(sizeof(struct List)); creat(L); reverse(L); p=L; while(p!=NULL)&#123; cout&lt;&lt;p-&gt;num&lt;&lt;&apos; &apos;; p=p-&gt;next; &#125; return 0;&#125;void creat(struct List *&amp;L)&#123; struct List *p1,*p2; p2=L; for(int i=0;i&lt;5;i++)&#123; p1=(struct List *)malloc(sizeof(struct List)); cin&gt;&gt;p1-&gt;num; if(i==0) L=p2=p1; else p2-&gt;next=p1; p2=p1; &#125; p2-&gt;next=NULL;&#125;void reverse(struct List *&amp;L)&#123; struct List *head,*p1,*p2; p1=p2=L; while(p1-&gt;next!=NULL) p1=p1-&gt;next; head=L; while(head!=p1)&#123; head=head-&gt;next; p2-&gt;next=p1-&gt;next; p1-&gt;next=p2; p2=head; &#125; L=head;&#125;/*测试数据*//*1、1 2 3 4 5 5 4 3 2 1*/ 第十三题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;#include&lt;cstdlib&gt;using namespace std;struct List&#123; int num; struct List *next;&#125;;void creat(struct List *&amp;L);int seartch(struct List *&amp;L);int main()&#123; struct List *L; L=(struct List *)malloc(sizeof(struct List)); creat(L); int result=seartch(L); cout&lt;&lt;result&lt;&lt;endl; return 0;&#125;void creat(struct List *&amp;L)&#123; struct List *p1,*p2; p2=L; for(int i=0;i&lt;7;i++)&#123; p1=(struct List *)malloc(sizeof(struct List)); cin&gt;&gt;p1-&gt;num; p2-&gt;next=p1; p2=p1; &#125; p2-&gt;next=NULL;&#125;int seartch(struct List *&amp;L)//利用快指针，时间复杂度降低&#123; struct List *p; p=L-&gt;next; int length=0; while(p!=NULL)&#123; length++; p=p-&gt;next; &#125; int count=1; p=L-&gt;next; int len; if(length%2==0) len=length/2; else len=length/2+1; while(count&lt;len)&#123; if(len-count&gt;=2)&#123; p=p-&gt;next-&gt;next; count+=2; &#125; else&#123; p=p-&gt;next; count++; &#125; &#125; return p-&gt;num;&#125;/*测试数据*//*1、1 2 3 4 5 6 7 8 42、1 2 3 4 5 6 7 4 */ 第十四题喵。题目看错了。下面代码错的。更新：遇到目前max时，在此值前面插入结点，同时用一个指针记下这个结点前面的位置，若在后面遍历过程中遇到比max还大，将前面插入的结点删去，同时插入结点记下位置。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;#include&lt;cstdlib&gt;#define MAXSIZE 100using namespace std;struct List&#123; int num; struct List *next;&#125;;void creat(struct List *&amp;L);void insert(struct List *&amp;L,int x); int main()&#123; struct List *L,*p; L=(struct List *)malloc(sizeof(struct List)); creat(L); insert(L,3); p=L-&gt;next; while(p!=NULL)&#123; cout&lt;&lt;p-&gt;num&lt;&lt;&apos; &apos;; p=p-&gt;next; &#125; return 0;&#125;void creat(struct List *&amp;L)&#123; struct List *p1,*p2; p2=L; for(int i=0;i&lt;7;i++)&#123; p1=(struct List *)malloc(sizeof(struct List)); cin&gt;&gt;p1-&gt;num; p2-&gt;next=p1; p2=p1; &#125; p2-&gt;next=NULL;&#125;void insert(struct List *&amp;L,int x)&#123; struct List *p1=L-&gt;next,*p2; int max=p1-&gt;num; while(p1!=NULL)&#123; if(max&lt;=p1-&gt;num)&#123; max=p1-&gt;num; &#125; p1=p1-&gt;next; &#125; p1=L; int flag=1; while(p1-&gt;next!=NULL)&#123; if(max==p1-&gt;next-&gt;num)&#123; p2=(struct List *)malloc(sizeof(struct List)); p2-&gt;num=x; p2-&gt;next=p1-&gt;next; p1-&gt;next=p2; flag=0; &#125; if(flag==1) p1=p1-&gt;next; else&#123; p1=p1-&gt;next-&gt;next; flag=1; &#125; &#125;&#125;/*测试数据*//*1、1 4 2 4 4 1 4 1 3 4 2 3 4 3 4 1 3 42、6 6 1 3 6 3 6 3 6 3 6 1 3 3 6 3 3 6 */ 第十五题空间复杂度满足了，但时间耗费好多，感觉这程序写的好蠢&lt;/\=/>12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;#include&lt;cstdio&gt;using namespace std;struct List&#123; int data; struct List *next;&#125;;void creat(struct List *&amp;L);void print(struct List *&amp;L);int main()&#123; struct List *L; L=(struct List *)malloc(sizeof(struct List)); creat(L); print(L); return 0;&#125; void creat(struct List *&amp;L)&#123; struct List *p1,*p2; p2=L; for(int i=0;i&lt;5;i++)&#123; p1=(struct List *)malloc(sizeof(struct List)); cin&gt;&gt;p1-&gt;data; p2-&gt;next=p1; p2=p1; &#125; p2-&gt;next=NULL;&#125;void print(struct List *&amp;L)&#123; struct List *p1,*p2; p1=L-&gt;next; while(L-&gt;next!=NULL)&#123; int max=p1-&gt;data; p2=L; while(p1-&gt;next!=NULL)&#123; if(max&lt;p1-&gt;next-&gt;data)&#123; p2=p1; max=p1-&gt;next-&gt;data; &#125; p1=p1-&gt;next; &#125; cout&lt;&lt;p2-&gt;next-&gt;data&lt;&lt;&apos; &apos;; p1=p2-&gt;next; p2-&gt;next=p1-&gt;next; free(p1); p1=L-&gt;next; &#125;&#125;/*测试数据*//*1、2 3 5 2 4 5 4 3 2 22、3 7 2 9 3 9 7 3 3 2 */ 第十七题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;#include&lt;cstdlib&gt;using namespace std;struct List&#123; int data; struct List *next;&#125;;struct List *creat();void unionList(struct List *&amp;ha,struct List *&amp;hb,struct List *&amp;hc);int main()&#123; struct List *ha,*hb,*hc,*p; ha=hb=hc=(struct List *)malloc(sizeof(struct List)); ha=creat(); hb=creat(); unionList(ha,hb,hc); p=hc-&gt;next; while(p!=hc)&#123; cout&lt;&lt;p-&gt;data&lt;&lt;&apos; &apos;; p=p-&gt;next; &#125; return 0;&#125;struct List *creat()&#123; struct List *p1,*p2,*L; L=(struct List *)malloc(sizeof(struct List)); p2=L; for(int i=0;i&lt;5;i++)&#123; p1=(struct List *)malloc(sizeof(struct List)); cin&gt;&gt;p1-&gt;data; p2-&gt;next=p1; p2=p1; &#125; p2-&gt;next=L; return L;&#125;void unionList(struct List *&amp;ha,struct List *&amp;hb,struct List *&amp;hc)&#123; struct List *p1,*p2; p1=hb-&gt;next; p2=ha-&gt;next; while(p1-&gt;next!=hb)&#123; p1=p1-&gt;next; &#125; while(p2-&gt;next!=ha)&#123; p2=p2-&gt;next; &#125; hc-&gt;next=ha-&gt;next; p2-&gt;next=hc; p2-&gt;next=hb-&gt;next; p1-&gt;next=hc;&#125;/*测试数据*//*1、1 2 3 4 5 2 3 4 5 6 1 2 3 4 5 2 3 4 5 6*/ 二、综合性实验实验题10单链表存储一元多项式，并实现两个多项式的相加运算123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include &lt;iostream&gt;#include&lt;malloc.h&gt;#define N 5using namespace std;struct List&#123; int x; //系数 int y; //指数 struct List *next; &#125;;struct List *creat(struct List *list)&#123; struct List *p1, *p2, *temp, *pre; p1 = pre = list; int flag = 1; for (int i = 0; i &lt; N; i++) &#123; temp = list-&gt;next; pre = list; p2 = (struct List *)malloc(sizeof(struct List)); cin &gt;&gt; p2-&gt;x &gt;&gt; p2-&gt;y; //使得多项式按照 指数大小 呈升序排列 if (flag == 1) &#123; p1-&gt;next = p2; p1 = p2; p1-&gt;next = NULL; &#125; else &#123; while (temp-&gt;next!= NULL &amp;&amp; temp-&gt;y &lt; p2-&gt;y) &#123; //p1 = temp; pre = temp; temp = temp-&gt;next; &#125; if (temp-&gt;y &lt; p2-&gt;y) &#123; p2-&gt;next = temp-&gt;next; temp-&gt;next = p2; &#125; else &#123; //p2-&gt;next = list-&gt;next; //list-&gt;next = p2; p2-&gt;next = temp; pre-&gt;next = p2; pre = pre-&gt;next; &#125; &#125; flag++; &#125; return list;&#125;struct List *AddPolynomial(struct List *list1, struct List *list2)&#123; //将相加后的结果保留在list1中 struct List *p1, *p2, *temp1, *temp2; p1 = list1-&gt;next; p2 = list2-&gt;next; //temp1,temp2用来指向p1,p2的前驱，便于操作 temp1 = list1; temp2 = list2; while (p1 != NULL &amp;&amp; p2 != NULL) &#123; if (p1-&gt;y == p2-&gt;y) &#123; p1-&gt;x += p2-&gt;x; if (p1-&gt;x != 0) &#123; temp1 = p1; temp2 = p2; p1 = p1-&gt;next; p2 = p2-&gt;next; &#125; else &#123; //若相加后p1的系数为0，则跳过p1并释放其内存 temp1-&gt;next = p1-&gt;next; free(p1); temp2 = p2; p1 = temp1-&gt;next; p2 = p2-&gt;next; &#125; &#125; else if (p1-&gt;y &lt; p2-&gt;y) &#123; //只需p1后移 temp1 = p1; p1 = p1-&gt;next; &#125; else if (p1-&gt;y &gt; p2-&gt;y) &#123; temp2-&gt;next = p2-&gt;next; //将p2插入temp1和p1中 p2-&gt;next = p1; temp1-&gt;next = p2; //p2指向下一个值，p1不变 p2 = temp2-&gt;next; &#125; &#125; return list1;&#125;void FreeNode(struct List *list)&#123; struct List *p1, *p2; p1 = p2 = list; while (p1-&gt;next != NULL) &#123; p2 = p1; p1 = p1-&gt;next; free(p2); &#125; free(p1);&#125;int main()&#123; struct List *list1, *list2; list1 = (struct List *)malloc(sizeof(struct List)); list2 = (struct List *)malloc(sizeof(struct List)); cout &lt;&lt; &quot;list1:&quot; &lt;&lt; endl; list1 = creat(list1); cout &lt;&lt; &quot;list2:&quot; &lt;&lt; endl; list2 = creat(list2); //验证输入是否按照指数升序排列 cout &lt;&lt; endl; struct List *p1 = list1-&gt;next; while (p1 != NULL) &#123; cout &lt;&lt; p1-&gt;x &lt;&lt; &apos; &apos; &lt;&lt; p1-&gt;y &lt;&lt; endl; p1 = p1-&gt;next; &#125; cout &lt;&lt; endl; p1 = list2-&gt;next; while (p1 != NULL) &#123; cout &lt;&lt; p1-&gt;x &lt;&lt; &apos; &apos; &lt;&lt; p1-&gt;y &lt;&lt; endl; p1 = p1-&gt;next; &#125; list1 = AddPolynomial(list1, list2); cout &lt;&lt; endl &lt;&lt; endl &lt;&lt; endl; //输出验证结果 p1=list1-&gt;next; while (p1 != NULL) &#123; cout &lt;&lt; p1-&gt;x &lt;&lt; &apos; &apos; &lt;&lt; p1-&gt;y &lt;&lt; endl; p1 = p1-&gt;next; &#125; //释放内存 FreeNode(list1); FreeNode(list2); return 0;&#125; 测试数据12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758其中x代表系数，y代表指数数据组1：list1：x y2 31 23 14 65 5list2：x y2 14 65 46 33 5相加： x y5 11 28 35 48 58 6数据组2：list1：x y3 15 36 23 9-1 4list2：x y1 44 32 71 56 2相加： x y3 112 29 32 73 9数据组3：list1：x y-1 14 3-4 92 05 2list2：x y1 1-4 32 22 95 5相加： x y2 07 25 5-2 9 实验题12本题用链表求大数加法，简单用链表模拟下加法运算。只写了具体求结果的代码，求中间位的就不写了。数据保证为正整数，小数负数这代码求不了，而我等有时间再改吧。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;using namespace std;#define MAXSIZE 100000+1000struct List&#123; int data; struct List *next;&#125;;struct List *rever(char ch[]);void add(struct List *&amp;L1,struct List *&amp;L2);int main()&#123; char str1[MAXSIZE],str2[MAXSIZE]; while(cin&gt;&gt;str1&gt;&gt;str2)&#123;//多组样列输入 struct List *L1,*L2; L1=L2=(struct List *)malloc(sizeof(struct List)); L1=rever(str1); L2=rever(str2); add(L1,L2); &#125; return 0;&#125;struct List *rever(char ch[])//将字符数组存入链表中 &#123; struct List *L,*p1,*p2; L=(struct List *)malloc(sizeof(struct List)); p2=L; for(int i=strlen(ch)-1;i&gt;=0;i--)&#123; p1=(struct List *)malloc(sizeof(struct List)); p1-&gt;data=ch[i]-48; p2-&gt;next=p1; p2=p1; &#125; p2-&gt;next=NULL; return L;&#125;void add(struct List *&amp;L1,struct List *&amp;L2)&#123; int num[MAXSIZE+10]; int i=0,t=0; struct List *p1=L1-&gt;next,*p2=L2-&gt;next; while(p1!=NULL||p2!=NULL)&#123; if(p1!=NULL&amp;&amp;p2!=NULL)&#123; num[i++]=(p1-&gt;data+p2-&gt;data+t)%10; t=(p1-&gt;data+p2-&gt;data+t)/10; p1=p1-&gt;next; p2=p2-&gt;next; &#125; if(p1!=NULL&amp;&amp;p2==NULL)&#123; num[i++]=(p1-&gt;data+t)%10; t=(p1-&gt;data+t)/10; p1=p1-&gt;next; &#125; if(p1==NULL&amp;&amp;p2!=NULL)&#123; num[i++]=(p2-&gt;data+t)%10; t=(p2-&gt;data+t)/10; p2=p2-&gt;next; &#125; &#125; if(t!=0) num[i++]=t; for(int j=i-1;j&gt;=0;j--) cout&lt;&lt;num[j]; cout&lt;&lt;endl;&#125; /*测试数据*//*1、112233445566778899 998877665544332211 11111111111111111102、1314 4131 5445 */ 待续…]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[火车调度（栈）]]></title>
    <url>%2F2018%2F09%2F20%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E7%81%AB%E8%BD%A6%E8%B0%83%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[一、题目描述 火车调度传送门 Description 有一条东西方向的铁路穿过小城A，小城A有一个火车调度站，示意图如下：现在有N列火车自东向西依次开过来了，按照到达的先后次序编号为0号到N-1号。 根据调度局的要求，小城A的调度站要改变这些列车驶离A城的顺序。 为了达到这一目的， 调度站在任意时刻可以执行以下三种操作之一：1、如果调度站还有剩余空间，则可以令下一列开来的火车进入调度站；2、如果调度站内有列车，则可以令调度站最前方的火车离开调度站并驶离A城；3、可以命令下一列开来的火车不经过调度站而直接驶离A城。不过小城A的调度站实在太小了，只能容纳M列火车，请帮忙确认调度站能否完成任务。 例子如果有4列火车开来，调度站可以容纳2列火车，调度局要求火车按照2、1、3、0的顺序驶离A城，则此任务可满足，一种可能的方案如下：Step 1：火车0进入调度站；Step 2：火车1进入调度站；Step 3：火车2不经过调度站驶离A城；Step 4：火车1从调度站驶离A城；Step 5：火车3不经过调度站驶离A城；当然，你只需要回答是否可行，不需要列出一种可行方案。 Input Format 第一行是一个正整数T，表示本测试数据有多少个独立的测试点。（ T≤300 ）之后有T个独立的测试点，每个测试点占两行。 第一行有两个数字N和M，分别表示开来的火车数量，以及调度站最多可容纳的火车数量，两个数字之间用一个空格隔开。 第二行有N个整数，他们都在0到N−1之间，且不重复，用空格隔开，表示火车驶离A城的次序。N是正整数，且N≤1000；M是非负整数，且M≤1000。 M可能为0（这也许说明调度站的工作人员罢工了，或者正在这个考场考试）。 Output Format 输出共T行，每行对应一个测试点。如果能够调度，则回答YES，否则回答NO。 输出请注意大小写，每行行末直接回车，不要有其他字符。 Sample Input1234524 22 1 3 05 22 4 3 1 0 Sample Output12YESNO 二、题解一步步模拟即可，例子说的很明白。现在假如从山那边开来0，1，2，3······M-1，M列火车。从出站次序数组零号元素开始模拟，如果当前数组元素恰好等于开来的火车序号，说明此时火车可直接开过去，否则将开来的火车送入调度站。如果调度站满了，但开来的火车还不等于当前数组元素，就无解了，输出NO。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt; #define MAXSIZE 1000+100struct Stack&#123; int num[MAXSIZE]; int top; &#125;;int main()&#123; int Case; scanf(&quot;%d&quot;,&amp;Case); while(Case--)&#123; int N,M; int val[MAXSIZE]; scanf(&quot;%d%d&quot;,&amp;N,&amp;M); for(int i=0;i&lt;N;i++) scanf(&quot;%d&quot;,&amp;val[i]); struct Stack stack; stack.top=-1; int number=0; int flag=1; for(int i=0;i&lt;N;)&#123; if(val[i]==number)&#123; i++; number++; continue; &#125; if(val[i]==stack.num[stack.top])&#123; i++; stack.top--; continue; &#125; if(val[i]!=number)&#123; stack.top++; stack.num[stack.top]=number; number++; &#125; if(stack.top==M)&#123; flag=0; break; &#125; &#125; if(flag==1) printf(&quot;YES\n&quot;); else printf(&quot;NO\n&quot;); &#125; return 0;&#125; 继续补题…]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NYOJ465中缀式变后缀式（套题）]]></title>
    <url>%2F2018%2F09%2F19%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E4%B8%AD%E7%BC%80%E5%BC%8F%E5%8F%98%E5%90%8E%E7%BC%80%E5%BC%8F2%2F</url>
    <content type="text"><![CDATA[一、题目描述中缀式变后缀式时间限制：1000 ms | 内存限制：65535 KB难度：3描述 人们的日常习惯是把算术表达式写成中缀式，但对于机器来说更“习惯于”后缀式，关于算术表达式的中缀式和后缀式的论述一般的数据结构书都有相关内容可供参看，这里不再赘述，现在你的任务是将中缀式变为后缀式。输入第一行输入一个整数n，共有n组测试数据（n&lt;10)。每组测试数据只有一行，是一个长度不超过1000的字符串，表示这个运算式的中缀式，每个运算式都是以“=”结束。这个表达式里只包含+-*/与小括号这几种符号。其中小括号可以嵌套使用。数据保证输入的操作数中不会出现负数。数据保证除数不会为0 输出 每组都输出该组中缀式相应的后缀式，要求相邻的操作数操作符用空格隔开。样例输入12321.000+2/4=((1+2)*5+1)/4= 样例输出121.000 2 4 / + =1 2 + 5 * 1 + 4 / = 二、题解模拟过程点这123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;stdio.h&gt;#include&lt;string.h&gt; #define MAXSIZE 3000struct Stack&#123; char character[MAXSIZE]; int top; int flag[MAXSIZE];&#125;;int main()&#123; int Case; scanf(&quot;%d&quot;,&amp;Case); while(Case--) &#123; char str[MAXSIZE]; char ch[MAXSIZE]; struct Stack stack; int count=0; stack.top=-1; scanf(&quot;%s&quot;,str); for(int i=0;i&lt;strlen(str)-1;i++)&#123; if((str[i]&gt;=&apos;0&apos;&amp;&amp;str[i]&lt;=&apos;9&apos;)||str[i]==&apos;.&apos;)&#123; if((str[i+1]&gt;=&apos;0&apos;&amp;&amp;str[i+1]&lt;=&apos;9&apos;)||str[i+1]==&apos;.&apos;) ch[count++]=str[i]; else&#123; ch[count++]=str[i]; ch[count++]=&apos; &apos;; &#125; &#125; else &#123; switch(str[i])&#123; case &apos;-&apos;: case &apos;+&apos;: if(stack.top==-1)&#123; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=1; &#125; else&#123; if(stack.flag[stack.top]!=3)&#123; if(stack.flag[stack.top]==2)&#123; ch[count++]=stack.character[stack.top]; ch[count++]=&apos; &apos;; stack.top--; &#125; if(stack.flag[stack.top]==1)&#123; ch[count++]=stack.character[stack.top]; ch[count++]=&apos; &apos;; stack.top--; &#125; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=1; &#125; else&#123; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=1; &#125; &#125; break; case &apos;*&apos;: case &apos;/&apos;: if(stack.top==-1)&#123; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=2; &#125; else&#123; if(stack.flag[stack.top]==1||stack.flag[stack.top]==3)&#123; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=2; &#125; else&#123; ch[count++]=stack.character[stack.top]; ch[count++]=&apos; &apos;; stack.top--; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=2; &#125; &#125; break; case &apos;(&apos;: stack.top++; stack.character[stack.top]=&apos;(&apos;; stack.flag[stack.top]=3; break; case &apos;)&apos;: while(stack.character[stack.top]!=&apos;(&apos;)&#123; ch[count++]=stack.character[stack.top]; ch[count++]=&apos; &apos;; stack.top--; &#125; stack.top--; break; &#125; &#125; &#125; while(stack.top!=-1)&#123; ch[count++]=stack.character[stack.top]; ch[count++]=&apos; &apos;; stack.top--; &#125; ch[count++]=&apos;=&apos;; ch[count]=&apos;\0&apos;; printf(&quot;%s\n&quot;,ch); &#125; return 0; &#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NYOJ257中缀式变后缀式]]></title>
    <url>%2F2018%2F09%2F17%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E4%B8%AD%E7%BC%80%E5%BC%8F%E5%8F%98%E5%90%8E%E7%BC%80%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、题目描述郁闷的C小加（一）时间限制：1000 ms | 内存限制：65535 KB难度：3描述 我们熟悉的表达式如a+b、a+b(c+d)等都属于中缀表达式。中缀表达式就是（对于双目运算符来说）操作符在两个操作数中间：num1 operand num2。同理，后缀表达式就是操作符在两个操作数之后：num1 num2 operand。ACM队的“C小加”正在郁闷怎样把一个中缀表达式转换为后缀表达式，现在请你设计一个程序，帮助C小加把中缀表达式转换成后缀表达式。为简化问题，操作数均为个位数，操作符只有+-/ 和小括号。输入第一行输入T，表示有T组测试数据（T&lt;10）。每组测试数据只有一行，是一个长度不超过1000的字符串，表示这个表达式。这个表达式里只包含+-*/与小括号这几种符号。其中小括号可以嵌套使用。数据保证输入的操作数中不会出现负数。并且输入数据不会出现不匹配现象。 输出 每组输出都单独成行，输出转换的后缀表达式。 样例输入12321+2(1+2)*3+4*5 样例输出1212+12+3*45*+ 二、题解本题可以用栈来解决。设置运算符的优先级，本题中令+、-的优先级为1，*、/的优先级为2，(的优先级为3。遍历字符串，若发现运算符，将其优先级与栈首元素优先级比较，（如果栈为空直接进栈），若大于则该运算符进栈，若小于且栈首不为’(‘将栈首元素出栈然后将其进栈，若栈首为’(‘，无论何运算符，进栈。若遍历到’)’，则将栈中元素出栈直到栈首为’(‘，最后把’(‘出栈。遍历完字符串，若栈不为空，将栈中元素全部出栈。代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;stdio.h&gt;#include&lt;string.h&gt; #define MAXSIZE 3000struct Stack&#123; char character[MAXSIZE]; int top; int flag[MAXSIZE];//优先级&#125;;int main()&#123; int Case; scanf(&quot;%d&quot;,&amp;Case); while(Case--) &#123; char str[MAXSIZE]; char ch[MAXSIZE]; struct Stack stack; int count=0; stack.top=-1; scanf(&quot;%s&quot;,str); for(int i=0;i&lt;strlen(str);i++)&#123; if(str[i]&gt;=&apos;0&apos;&amp;&amp;str[i]&lt;=&apos;9&apos;) ch[count++]=str[i]; else &#123; switch(str[i])&#123; case &apos;-&apos;: case &apos;+&apos;: if(stack.top==-1)&#123; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=1; &#125; else&#123; if(stack.flag[stack.top]!=3)&#123; if(stack.flag[stack.top]==2)&#123; ch[count++]=stack.character[stack.top]; stack.top--; &#125; if(stack.flag[stack.top]==1)&#123; ch[count++]=stack.character[stack.top]; stack.top--; &#125; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=1; &#125; else&#123; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=1; &#125; &#125; break; case &apos;*&apos;: case &apos;/&apos;: if(stack.top==-1)&#123; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=2; &#125; else&#123; if(stack.flag[stack.top]==1||stack.flag[stack.top]==3)&#123; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=2; &#125; else&#123; ch[count++]=stack.character[stack.top]; stack.top--; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=2; &#125; &#125; break; case &apos;(&apos;: stack.top++; stack.character[stack.top]=&apos;(&apos;; stack.flag[stack.top]=3; break; case &apos;)&apos;: while(stack.character[stack.top]!=&apos;(&apos;)&#123; ch[count++]=stack.character[stack.top]; stack.top--; &#125; stack.top--; break; &#125; &#125; &#125; while(stack.top!=-1)&#123; ch[count++]=stack.character[stack.top]; stack.top--; &#125; ch[count]=&apos;\0&apos;; printf(&quot;%s\n&quot;,ch); &#125; return 0; &#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NYOJ305另类表达式求值（栈）]]></title>
    <url>%2F2018%2F09%2F15%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E5%8F%A6%E7%B1%BB%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一、题目描述表达式求值时间限制：3000 ms | 内存限制：65535 KB难度：3描述 Dr.Kong设计的机器人卡多掌握了加减法运算以后，最近又学会了一些简单的函数求值，比如，它知道函数min(20,23)的值是20 ，add(10,98) 的值是108等等。经过训练，Dr.Kong设计的机器人卡多甚至会计算一种嵌套的更复杂的表达式。假设表达式可以简单定义为: 一个正的十进制数 x 是一个表达式。 如果 x 和 y 是 表达式，则 函数min(x,y )也是表达式,其值为x,y 中的最小数。 如果 x 和 y 是 表达式，则 函数max(x,y )也是表达式,其值为x,y 中的最大数。 如果 x 和 y 是 表达式，则 函数add(x,y )也是表达式,其值为x,y 之和。例如， 表达式 max(add(1,2),7) 的值为 7。请你编写程序，对于给定的一组表达式，帮助 Dr.Kong 算出正确答案，以便校对卡多计算的正误。 输入 第一行： N 表示要计算的表达式个数 （1≤ N ≤ 10）接下来有N行， 每行是一个字符串，表示待求值的表达式（表达式中不会有多余的空格，每行不超过300个字符，表达式中出现的十进制数都不超过1000。） 输出 输出有N行，每一行对应一个表达式的值。 样例输入123add(1,2) max(1,999) add(min(1,1000),add(100,99)) 样例输出1233999200 二、题解本题是栈应用的类型。首先定义两个栈，一个用来存放运算符（记为栈1），一个用来存放待计算的数据（记为栈2）。从字符串首开始遍历直到尾部，若发现add串（在这里我们只需要识别字符a和字符d），则表示需要求和，将其存入栈1中。若发现min串、max串继续存放。若遍历到的是数字，则存入栈2，需要注意的是，由于输入的是字符串，在识别数据就要小心了。比如识别 47，首先识别到4，这时候可以发现后面还跟着7，4是十位上的数，7是各位上的数，如果在识别是不能处理，那么4就会被单独当成一个数存入栈2中，7也如此。具体看代码。举例add(min(1,1000),add(100,99))1、字符串遍历，到add处，将其进栈1，用“加”代替，那么这时候栈1：加-&gt;null;2、遍历到min，将其精栈1，用“小”代替，栈1：加-&gt;小-&gt;null；3、遍历到1，通过处理将得到的数字进栈2，栈2：1-&gt;null;4、遍历到1000串，处理得到1000进栈2，栈2：1-&gt;1000-&gt;null;5、遍历到），说明此时需要计算数据了，查看栈1栈首的元素，发现此时为小，表明前面两个数据需要比较大小求得较小的数据，拿栈2中栈首元素与次首元素比较，就是1和1000比较得到1，栈2退栈一位，此时栈2：1-&gt;null；将比较得到的数据赋给栈首元素，那么栈2：1-&gt;null；处理完栈2，发现刚才栈1中的栈首得到了应用，将其退栈一位，栈1：加-&gt;null；6、遍历到add处，用“加”代替，进栈，栈1：加-&gt;加-&gt;null;7、接着遍历100，99，分别将他们进栈2，此时栈2：1-&gt;100-&gt;99-&gt;null；8、遍历到），计算数据，栈1中栈首元素为加，则栈2中100和99相加的199，退栈，赋值。栈2：1-&gt;199-&gt;null。栈1退栈一位；9、遍历到），计算数据，栈1中栈首元素为加，则栈2中1和199相加的199，退栈，赋值。栈2：200-&gt;null。栈1退栈一位；10、200为表达式值。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#define MAXSIZE 300+10struct Stack1&#123; int flag[MAXSIZE]; int top;&#125;;struct Stack2&#123; int number[MAXSIZE]; int top;&#125;;double calculate(char str[]);int main()&#123; int Case; scanf(&quot;%d&quot;,&amp;Case); while(Case--)&#123; char str[MAXSIZE]; scanf(&quot;%s&quot;,str); double ans=calculate(str); printf(&quot;%.0lf\n&quot;,ans); &#125; return 0;&#125;double calculate(char str[])&#123; struct Stack1 stack1; //字符栈 struct Stack2 stack2; //数字栈 stack1.top=stack2.top=-1; int value=0; for(int i=0;i&lt;strlen(str);i++)&#123; if(str[i]==&apos;a&apos;&amp;&amp;str[i-1]!=&apos;m&apos;)&#123;//避免与求最大值的max区分开 value=0; stack1.top++; stack1.flag[stack1.top]=1; &#125; if(str[i]==&apos;m&apos;)&#123; value=0; stack1.top++; if(str[i+1]==&apos;i&apos;) stack1.flag[stack1.top]=2;//判断求最小值 else if(str[i+2]==&apos;x&apos;) stack1.flag[stack1.top]=3;//判断求最大值 &#125; if(str[i]==&apos;,&apos;) value=0; if(str[i]&gt;=&apos;0&apos;&amp;&amp;str[i]&lt;=&apos;9&apos;)&#123; if(str[i-1]&gt;=&apos;0&apos;&amp;&amp;str[i]&lt;=&apos;9&apos;)&#123; value=value*10+str[i]-48; &#125; else&#123; value=str[i]-48;//字符转数字 &#125; if(str[i+1]&lt;&apos;0&apos;||str[i+1]&gt;&apos;9&apos;)&#123; stack2.top++; stack2.number[stack2.top]=value; &#125; &#125; int temp=0; if(str[i]==&apos;)&apos;)&#123; value=0; switch(stack1.flag[stack1.top])&#123; case 1: temp=stack2.number[stack2.top]+stack2.number[stack2.top-1]; stack2.top--; stack2.number[stack2.top]=temp; break; case 2: if(stack2.number[stack2.top]&gt;=stack2.number[stack2.top-1]) stack2.top--; else&#123; temp=stack2.number[stack2.top]; stack2.top--; stack2.number[stack2.top]=temp; &#125; break; case 3: if(stack2.number[stack2.top]&lt;=stack2.number[stack2.top-1]) stack2.top--; else&#123; temp=stack2.number[stack2.top]; stack2.top--; stack2.number[stack2.top]=temp; &#125; &#125; stack1.top--; &#125; &#125; return double(stack2.number[stack2.top]); &#125; 继续补题ing…]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[走迷宫（迷宫问题补题）]]></title>
    <url>%2F2018%2F09%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E8%B5%B0%E8%BF%B7%E5%AE%AB%2F</url>
    <content type="text"><![CDATA[一、题目描述 一个迷宫由R行C列格子组成，有的格子里有障碍物，不能走；有的格子是空地，可以走。给定一个迷宫，求从左上角走到右下角最少需要走多少步(数据保证一定能走到)。只能在水平方向或垂直方向走，不能斜着走。Input第一行是两个整数，Ｒ和Ｃ，代表迷宫的长和宽。（ 1&lt;= R，C &lt;= 40)接下来是Ｒ行，每行Ｃ个字符，代表整个迷宫。 空地格子用’.’表示，有障碍物的格子用’#’表示。迷宫左上角和右下角都是’.’。Output输出从左上角走到右下角至少要经过多少步（即至少要经过多少个空地格子）。计算步数要包括起点和终点。 样列输入1234565 5..####....#.#.##.#.##.#.. 样列输出19 二、题解本题方法跟前一篇写的《迷宫求解》队列实现方法一致，传送门需要注意的是二维字符数组的输入问题，可以单个字符的输入，但这就要考虑回车键对数组的影响；而采用字符串形式输入则不会有这个问题，具体见代码。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt;const int MAXSIZE=10000+10;struct Box&#123; int i; int j; int pre;&#125;;struct Type&#123; struct Box data[MAXSIZE]; int front,rear;&#125;;const int LEN=sizeof(struct Type);int findRoad(int a,int b,int c,int d,char mg[42][42]);int main()&#123; char mg[42][42],mgtemp[42][42]; int N,M; scanf(&quot;%d%d&quot;,&amp;N,&amp;M); for(int i=1;i&lt;=N;i++)&#123; scanf(&quot;%s&quot;,mgtemp[i]); //采用临时数组，注意列行从0开始而不是需要的从1开始 &#125; for(int i=1;i&lt;=N;i++)&#123; int t=1; for(int j=0;j&lt;M;j++) mg[i][t++]=mgtemp[i][j];//用此转换 &#125; int ans=findRoad(1,1,N,M,mg); printf(&quot;%d\n&quot;,ans); return 0; &#125; int findRoad(int a,int b,int c,int d,char mg[42][42])&#123; Box e; struct Type *queue; queue=(struct Type *)malloc(LEN); queue-&gt;front=queue-&gt;rear=-1; int i,j; e.i=a;e.j=b;e.pre=-1; mg[a][b]=&apos;/&apos;; queue-&gt;rear++; queue-&gt;data[queue-&gt;rear]=e; while(queue-&gt;rear!=queue-&gt;front)&#123; queue-&gt;front++; e=queue-&gt;data[queue-&gt;front]; i=e.i;j=e.j; if(i==c&amp;&amp;j==d)&#123; int temp=queue-&gt;front; while(temp!=0)&#123; int num=queue-&gt;data[temp].pre; queue-&gt;data[temp].pre=-1; temp=num; &#125; temp=0; int count=0; while(temp&lt;=queue-&gt;front)&#123; if(queue-&gt;data[temp].pre==-1) count++; temp++; &#125; return count; &#125; int x,y; for(int k=0;k&lt;4;k++)&#123; switch(k)&#123; case 0: x=i-1;y=j;break; case 1: x=i;y=j+1;break; case 2: x=i+1;y=j;break; case 3: x=i;y=j-1;break; &#125; if(mg[x][y]==&apos;.&apos;)&#123; e.i=x;e.j=y;e.pre=queue-&gt;front; queue-&gt;rear++; queue-&gt;data[queue-&gt;rear]=e; mg[x][y]=&apos;/&apos;; &#125; &#125; &#125;&#125; 继续补题ing…]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迷宫求解]]></title>
    <url>%2F2018%2F09%2F13%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E8%BF%B7%E5%AE%AB%E6%B1%82%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[想不到迷宫求解还困惑我这么久久久？搞清楚了吧？做下笔记防止遗忘？去补点题？let’s go! 一、问题描述给定一个10*10的迷宫图，求一条从指定路口到指定出口的路径。在这里可以定义一个二维数组，用0来代表迷宫路径可走，用1代表路径不可走。迷宫问题可以用两种数据结构来解决（我暂时只会两种，囧rz），分别为栈、队列。栈只能简单地求出从指定路口到制定出口的路径，也就是说并不能考虑路径长短问题；而用队列来求解的话，可以求出一条最短路径。 二、栈实现1、解决方案说实话，不喜欢用栈来求解，耗时耗力还得不到最优解。就这样吧。从指定路口开始，将指定入口入栈。然后查找与栈头相邻且可走的路口。需要说明是首先要制定一个选择路口的方案，不然计算机怎么知道往哪走呢？我选择的是顺时针查看，即先查看上再右其次下最后左方。若找到，则将其入栈，在这里有一个非常关键的地方，就是需要记住处于栈头相对于前一个路口的方位值，所谓方位值，简单来讲，用0代表上，1代表右，2代表下，3代表左。接着再次查找相邻可走路口。为避免查找到的路口是已经走过的，在设计程序的时候，每一个路口入栈后，都将该路口的状态改变，比如，前面用0代表路径可走，那么可以设置入栈的入口状态值为-1，为区分起始条件不可走的状态值1。若没有找到，也就是说处于当前路口时，上下左右都不可走，不要怕，退一步。退一步就是退回到上一路口。那么整个栈中的元素就是从入口到出口的迷宫路径了。如此直到找到出口，若没有出口，就。。。 2、代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define MAXSIZE 10000int mg[10][10]=&#123; //迷宫数组 &#123;1,1,1,1,1,1,1,1,1,1&#125;, &#123;1,0,0,1,0,0,0,1,0,1&#125;, &#123;1,0,0,1,0,0,0,1,0,1&#125;, &#123;1,0,0,0,0,1,1,0,0,1&#125;, &#123;1,0,1,1,1,0,0,0,0,1&#125;, &#123;1,0,0,0,1,0,0,0,0,1&#125;, &#123;1,0,1,0,0,0,1,0,0,1&#125;, &#123;1,0,1,1,1,0,1,1,0,1&#125;, &#123;1,1,0,0,0,0,0,0,0,1&#125;, &#123;1,1,1,1,1,1,1,1,1,1&#125; &#125;;struct Box&#123; int i; int j; int di; //表示方位值&#125;;struct Type&#123; struct Box data[MAXSIZE]; int top;&#125;;bool findRode(int m,int n,int it,int yt);int main()&#123; if(findRode(1,1,8,8)==false) printf(&quot;failed\n&quot;); return 0;&#125;bool findRode(int m,int n,int it,int yt)&#123; int i,j,di,k=0; Box e; struct Type *stack; stack=(struct Type *)malloc(sizeof(struct Type)); stack-&gt;top=-1; e.i=m;e.j=n;e.di=0; stack-&gt;top++; //将第一个路口入栈 stack-&gt;data[stack-&gt;top]=e; mg[e.i][e.j]=-1; while(stack-&gt;top!=-1)&#123; e=stack-&gt;data[stack-&gt;top]; i=e.i;j=e.j;k=e.di; if(i==it&amp;&amp;j==yt)&#123; while(stack-&gt;top!=-1)&#123; e=stack-&gt;data[stack-&gt;top]; printf(&quot;(%d,%d) &quot;,e.i,e.j); mg[e.i][e.j]=0; stack-&gt;top--; &#125; free(stack); return true; &#125; bool find=false; while(k&lt;4&amp;&amp;find!=true)&#123; k++; switch(k)&#123; case 0: i=e.i-1;j=e.j;break; case 1: i=e.i;j=e.j+1;break; case 2: i=e.i+1;j=e.j;break; case 3: i=e.i;j=e.j-1;break; &#125; if(mg[i][j]==0) find=true; &#125; if(k&lt;4)&#123; stack-&gt;data[stack-&gt;top].di=k; e.i=i;e.j=j;e.di=-1; stack-&gt;top++; stack-&gt;data[stack-&gt;top]=e; mg[i][j]=-1; &#125;else&#123; //如果当前路口没有相邻可走且不是出口，则退栈回到上一路口 stack-&gt;top--; mg[e.i][e.j]=0; //将该路口状态值重置，表示可走 &#125; &#125; free(stack); return false;&#125; 三、队列实现1、解决方案为什么说用队列来解可以求得最短路径呢？与栈不同的是，队列在查看相邻可走路口时，是将全部相邻可走路口进队；首先将入口进队，队列中就记录下该路口的信息了。将队首元素出队，（注意此时队伍中还记录有路口的信息），以该路口为中心查看相邻路口，使全部相邻可走路口记下该路口在队列中的位置，然后将它们进队。比如起点为A，进队。此时队列为A-&gt;NULL；此时A在队列中的位置就是0（记0是开始），出队，B、C、D是A的相邻可走路口，则B、C、D的前导值就是0，通过查询前导值，就可以清楚地知道A的位置（说明下，第一个路口的前导值记为-1）。此时队列为a-&gt;B-&gt;C-&gt;D-&gt;NULL；（A已出队，但A的信息保留着，所以用a代替）注意队首为B（B在队列中的位置是1），然后将B出队，执行与出队A类似的步骤。直到找到出口。找到出口后，那么通过出口的前导值可以知道它前面的路口（记为M）在哪（将M在队列中的状态值记为-1，后面皆是如此），通过M的前导值又可以知道M前面的路口在哪，直到与入口联系起来。从队首信息开始扫描整个队列，若队列中的元素的状态值为-1，则将该元素记录的坐标输出。求解完成。 2、代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define MAXSIZE 10000#define LEN sizeof(struct Type )int mg[10][10]=&#123; &#123;1,1,1,1,1,1,1,1,1,1&#125;, &#123;1,0,0,1,0,0,0,1,0,1&#125;, &#123;1,0,0,1,0,0,0,1,0,1&#125;, &#123;1,0,0,0,0,1,1,0,0,1&#125;, &#123;1,0,1,1,1,0,0,0,0,1&#125;, &#123;1,0,0,0,1,0,0,0,0,1&#125;, &#123;1,0,1,0,0,0,1,0,0,1&#125;, &#123;1,0,1,1,1,0,1,1,0,1&#125;, &#123;1,1,0,0,0,0,0,0,0,1&#125;, &#123;1,1,1,1,1,1,1,1,1,1&#125; &#125;;struct Box&#123; int i; int j; int pre;//记录上一路口的前导值,所谓前导值，就是可走路口在队列中的位置&#125;;struct Type&#123; struct Box data[MAXSIZE]; int front,rear;&#125;;bool findRoad(int m,int n,int it,int yt);int main()&#123; if(findRoad(1,1,8,8)==false) printf(&quot;failed\n&quot;); return 0;&#125;bool findRoad(int m,int n,int it,int yt)&#123; int i,j; Box e; struct Type *queue; queue=(struct Type *)malloc(LEN); e.i=m;e.j=n;e.pre=-1; queue-&gt;front=queue-&gt;rear=-1; queue-&gt;rear++; queue-&gt;data[queue-&gt;rear]=e; mg[e.i][e.j]=-1; while(queue-&gt;rear!=queue-&gt;front)&#123; queue-&gt;front++; e=queue-&gt;data[queue-&gt;front]; i=e.i;j=e.j; if(i==it&amp;&amp;j==yt)&#123; int temp=queue-&gt;front; int num=0; while(temp!=0)&#123; num=queue-&gt;data[temp].pre; queue-&gt;data[temp].pre=-1; temp=num; &#125; temp=0; int count=1; while(temp&lt;=queue-&gt;rear)&#123; if(queue-&gt;data[temp].pre==-1)&#123; printf(&quot;(%d,%d)&quot;,queue-&gt;data[temp].i,queue-&gt;data[temp].j); if(count%5==0) printf(&quot;\n&quot;); count++; &#125; temp++; &#125; return true; &#125; int x,y; int k=0; while(k&lt;4)&#123; switch(k)&#123; case 0: x=i-1;y=j;break; case 1: x=i;y=j+1;break; case 2: x=i+1;y=j;break; case 3: x=i;y=j-1;break; &#125; k++; if(mg[x][y]==0)&#123; /*只要该路口可走，就将其进队 *并且记录上一路口的前导值 */ queue-&gt;rear++; e.i=x;e.j=y;e.pre=queue-&gt;front; queue-&gt;data[queue-&gt;rear]=e; mg[i][j]=-1; &#125; &#125; &#125; return false;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NYOJ63 小猴子下落（二叉树）]]></title>
    <url>%2F2018%2F08%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2FNYOJ63%E5%B0%8F%E7%8C%B4%E5%AD%90%E4%B8%8B%E8%90%BD%2F</url>
    <content type="text"><![CDATA[一、题目描述小猴子下落时间限制：3000 ms | 内存限制：65535 KB难度：3描述 有一颗二叉树，最大深度为D,且所有叶子的深度都相同。所有结点从左到右从上到下的编号为1,2,3，·····，2的D次方减1。在结点1处放一个小猴子，它会往下跑。每个内结点上都有一个开关，初始全部关闭，当每次有小猴子跑到一个开关上时，它的状态都会改变，当到达一个内结点时，如果开关关闭，小猴子往左走，否则往右走，直到走到叶子结点。一些小猴子从结点1处开始往下跑，最后一个小猴儿会跑到哪里呢？输入输入二叉树叶子的深度D,和小猴子数目I，假设I不超过整棵树的叶子个数，D&lt;=20.最终以 0 0 结尾 输出 输出第I个小猴子所在的叶子编号。 样例输入1234 23 40 0 样例输出12127 来源[张洁烽]原创上传者张洁烽 二、题解思路如下 1、首先可以明确当节点值为0时，往左走，然后节点值变为1，反之往右走，节点值变为0；2、定义一个大数组用来存放节点状态值，将数组看成满二叉树存储值的状态；3、左节点的序号为上一节点的2倍，右节点的序号为上一节点的2倍加1。 123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;memory.h&gt;#define MAXSIZE 40000+10int flag[MAXSIZE]=&#123;0&#125;; int main()&#123; int N,M; while(scanf(&quot;%d%d&quot;,&amp;N,&amp;M)!=EOF)&#123; memset(flag,0,MAXSIZE); if(N==0&amp;&amp;M==0) break; int temp=1; for(int i=1;i&lt;=M;i++)&#123; int depth=1; temp=1; while(depth&lt;N)&#123; if(flag[temp]==0)&#123; flag[temp]=1; temp=temp*2; &#125;else&#123; flag[temp]=0; temp=temp*2+1; &#125; depth++; &#125; &#125; printf(&quot;%d\n&quot;,temp); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo小配置]]></title>
    <url>%2F2018%2F08%2F10%2F%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%8A%80%E5%B7%A7%2Fhexo%E5%B0%8F%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[一、hexo部署本地图片把图片在hexo/blog/public/css/images目录下，其中(hexo/blog)是你博客所在文件夹。使用/css/images/at.png的方式进行链接。 二、在首页只显示摘要信息12345这里写文章的简介&lt;!-- more --&gt;这里写文章的正文 三、在首页显示图片123456---title: hexo小配置categories: hexotags: 小技巧photo: https://hexo.io/logo.svg //写上这一行，注意“photo:”有一个空格，“photo: ”后面就写上图片的地址--- 四、新建“about”页面1、在git Bash命令行界面输入1hexo new page &quot;about&quot; 2、在主题配置文件中将menu中about的注释去掉文件路径：themes/hiero/config（hiero是你主题的名称123456menu: Home: / Archives: /archives Categories: /categories Tags: /tags About: /about 上面代码为已经去掉注释后的这里就可以拓展一下，比如分类、标签页面等等。分类：123456---title: categoriesdate: 2018-09-09 23:48:07layout: &quot;categories&quot;--- 标签：12345---title: tagsdate: 2018-09-09 23:47:25layout: &quot;tags&quot;--- 未完待续……]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的创建及其遍历]]></title>
    <url>%2F2018%2F08%2F09%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%9B%E5%BB%BA%E5%8F%8A%E5%85%B6%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[二叉树是一种非常重要的数据结构，许多其他的数据结构都是基于二叉树发展推演过来的。用递归定义树的结构非常简洁，同样，递归遍历也非常简洁。在学习过程中，我发现递归算法往往只是一个简单的语句，虽然简洁的语句实现了功能，但在算法具体过程方面没有很好的阐述，我也很纠结为什么可以这么用，一次次调式试图弄明白内在机理，总是达不到预期效果，所以我转而写非递归的算法以此希望能够理解树的节点的构造、遍历。在这里，我写下这些天学习二叉树的历程。 一、树的创建利用递归创建二叉树。123456789101112131415struct Btree *inputTree()//创建二叉树 &#123; int number; struct Btree *tree; scanf(&quot;%d&quot;,&amp;number); if(number==0)&#123; //当输入0时，表示左孩子或右孩子为空 tree=NULL; &#125;else&#123; tree=(struct Btree *)malloc(LEN); tree-&gt;data=number; tree-&gt;lchild=inputTree(); //递归左孩子 tree-&gt;rchild=inputTree(); //递归右孩子 &#125; return tree;&#125; 二、三种遍历递归实现1、先序遍历递归算法规则：先根节点，再左子树，后右子树，简记NLR。具体，可将整棵树分为左子树和右子树，然后再将左子树分为次左子树、次右子树123456789void preTraversal(struct Btree *tree)&#123; if(tree!=NULL)&#123; printf(&quot;%d &quot;,tree-&gt;data); //打印根节点 preTraversal(tree-&gt;lchild); //遍历左孩子树 preTraversal(tree-&gt;rchild); //遍历右孩子树 &#125; return;&#125; 2、中序遍历递归算法规则：先左子树，再根节点，后右子树，简记LNR。具体同先序。123456789void inTraversal(struct Btree *tree)&#123; if(tree!=NULL)&#123; preTraversal(tree-&gt;lchild); //遍历左孩子树 printf(&quot;%d&quot;,tree-&gt;data); //打印根节点 preTraversal(tree-&gt;rchild); //遍历右孩子树 &#125; return;&#125; 3、后序遍历递归算法规则：先左子树，再右子树，后根节点，简记LRN。具体同先序。12345678void postTraversal(struct Btree *tree)&#123; if(tree!=NULL)&#123; postTraversal(tree-&gt;lchild); //遍历左孩子树 postTraversal(tree-&gt;rchild); //遍历右孩子树 printf(&quot;%d &quot;,tree-&gt;data); //打印根节点 &#125;&#125; 三、三种遍历非递归实现1、先序遍历非递归算法算法主要步骤：1、当树不为空时，将根节点压入栈中；2、当栈不为空时，说明需要此时访问当前节点，退栈访问；3、查看该节点的右孩子(这里先查看右孩子是因为这是先序遍历，先遍历根节点其次左孩子最后右孩子，这里用到栈也是因为栈的特点，先进后出，后进先出)，若右孩子存在，则压入栈中；4、查看该节点的左孩子，同3；5、若栈不为空，转2，循环。12345678910111213141516171819202122232425void preTraversal(struct Btree *tree)&#123; struct Btree *stack[MAXSIZE]; struct Btree *temp; int top=-1; if(tree!=NULL)&#123; top++; stack[top]=tree; //将根节点进栈 while(top!=-1)&#123; temp=stack[top]; top--; printf(&quot;%d &quot;,temp-&gt;data); if(temp-&gt;rchild!=NULL)&#123; //右孩子不为空，进栈 top++; stack[top]=temp-&gt;rchild; &#125; if(temp-&gt;lchild!=NULL)&#123; //左孩子不为空，进栈 top++; stack[top]=temp-&gt;lchild; &#125; &#125; &#125; printf(&quot;\n&quot;); return;&#125; 2、中序遍历非递归算法算法主要步骤：1、首先查看根节点，若根节点不为空，将其进栈；2、查看根节点的左孩子，若左孩子存在，将其进栈，继续访问以左孩子为根节点的次树；3、 若次树无左孩子，访问当前次树的根节点，然后查看该根节点的右孩子；4、循环。12345678910111213141516171819202122void inTraversal(struct Btree *tree)&#123; struct Btree *stack[MAXSIZE],*temp; int top=-1; if(tree!=NULL)&#123; temp=tree; while(top&gt;-1||temp!=NULL)&#123; if(temp!=NULL)&#123; top++; stack[top]=temp; temp=temp-&gt;lchild; &#125;else&#123; //此时说明当前次树已无左孩子，则访问该节点 temp=stack[top]; top--; printf(&quot;%d &quot;,temp-&gt;data); temp=temp-&gt;rchild; //查看该节点的右孩子 &#125; &#125; &#125; printf(&quot;\n&quot;); return; &#125; 3、后序遍历非递归算法算法主要步骤：1、首先将根节点进栈，若栈不为空，循环；2、查看栈顶元素，若其有左孩子或右孩子并且左右孩子没有被访问，将其左孩子或右孩子入栈，否则，访问该节点；3、 在2步骤中，若访问完一节点，则用pre指针记录下来 。1234567891011121314151617181920212223242526void postTraversal(struct Btree *tree)&#123; struct Btree *stack[MAXSIZE],*temp,*pre=NULL; int top=-1; top++; stack[top]=tree; while(top!=-1)&#123; temp=stack[top]; if((temp-&gt;lchild==NULL&amp;&amp;temp-&gt;rchild==NULL)||\ (pre!=NULL&amp;&amp;(temp-&gt;lchild==pre||temp-&gt;rchild==pre)))&#123; printf(&quot;%d &quot;,temp-&gt;data);//到此表明该节点无左右孩子 top--; //或者有左右孩子但已被访问输出，访问该节点 pre=temp; //pre指针用来记录上一访问过的节点 &#125;else&#123; if(temp-&gt;rchild!=NULL)&#123; //若右孩子存在，将其入栈 top++; stack[top]=temp-&gt;rchild; &#125; if(temp-&gt;lchild!=NULL)&#123; //若左孩子存在，将其入栈 top++; stack[top]=temp-&gt;lchild; &#125; &#125; &#125; printf(&quot;\n&quot;); &#125; 四、源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define LEN sizeof(struct Btree)#define MAXSIZE 1000+10struct Btree&#123; int data; struct Btree *lchild,*rchild;&#125;;void preTraversal(struct Btree *tree);void inTraversal(struct Btree *tree);void postTraversal(struct Btree *tree);struct Btree *inputTree();int main()&#123; struct Btree *tree; tree=inputTree(); printf(&quot;先序遍历:\n&quot;); preTraversal(tree); printf(&quot;中序遍历:\n&quot;); inTraversal(tree); printf(&quot;后序遍历:\n&quot;); postTraversal(tree); return 0;&#125;struct Btree *inputTree()//创建二叉树 &#123; int number; struct Btree *tree; scanf(&quot;%d&quot;,&amp;number); if(number==0)&#123; //当输入0时，表示左孩子或右孩子 为空 tree=NULL; &#125;else&#123; tree=(struct Btree *)malloc(LEN); tree-&gt;data=number; tree-&gt;lchild=inputTree(); //递归左孩子 tree-&gt;rchild=inputTree(); //递归右孩子 &#125; return tree;&#125;void preTraversal(struct Btree *tree)//先序递归&#123; if(tree!=NULL)&#123; printf(&quot;%d &quot;,tree-&gt;data); //打印根节点 preTraversal(tree-&gt;lchild); //遍历左孩子树 preTraversal(tree-&gt;rchild); //遍历右孩子树 &#125; return;&#125;void preTraversal(struct Btree *tree)//先序非递归&#123; struct Btree *stack[MAXSIZE]; struct Btree *temp; int top=-1; if(tree!=NULL)&#123; top++; stack[top]=tree; //将根节点进栈 while(top!=-1)&#123; temp=stack[top]; top--; printf(&quot;%d &quot;,temp-&gt;data); if(temp-&gt;rchild!=NULL)&#123; //右孩子不为空，进栈 top++; stack[top]=temp-&gt;rchild; &#125; if(temp-&gt;lchild!=NULL)&#123; //左孩子不为空，进栈 top++; stack[top]=temp-&gt;lchild; &#125; &#125; &#125; printf(&quot;\n&quot;); return; &#125;void inTraversal(struct Btree *tree)//中序递归&#123; if(tree!=NULL)&#123; preTraversal(tree-&gt;lchild); //遍历左孩子树 printf(&quot;%d&quot;,tree-&gt;data); //打印根节点 preTraversal(tree-&gt;rchild); //遍历右孩子树 &#125; return;&#125;void inTraversal(struct Btree *tree)//中序非递归&#123; struct Btree *stack[MAXSIZE],*temp; int top=-1; if(tree!=NULL)&#123; temp=tree; while(top&gt;-1||temp!=NULL)&#123; if(temp!=NULL)&#123; top++; stack[top]=temp; temp=temp-&gt;lchild; &#125;else&#123; //此时说明当前次树已无左孩子，则访问该节点 temp=stack[top]; top--; printf(&quot;%d &quot;,temp-&gt;data); temp=temp-&gt;rchild; //查看该节点的右孩子 &#125; &#125; &#125; printf(&quot;\n&quot;); return; &#125; void postTraversal(struct Btree *tree)//后序递归&#123; if(tree!=NULL)&#123; postTraversal(tree-&gt;lchild); //遍历左孩子树 postTraversal(tree-&gt;rchild); //遍历右孩子树 printf(&quot;%d &quot;,tree-&gt;data); //打印根节点 &#125; return;&#125;void postTraversal(struct Btree *tree)&#123; struct Btree *stack[MAXSIZE],*temp,*pre=NULL; int top=-1; top++; stack[top]=tree; while(top!=-1)&#123; temp=stack[top]; if((temp-&gt;lchild==NULL&amp;&amp;temp-&gt;rchild==NULL)||\ (pre!=NULL&amp;&amp;(temp-&gt;lchild==pre||temp-&gt;rchild==pre)))&#123; printf(&quot;%d &quot;,temp-&gt;data);//到此表明该节点无左右孩子 top--; //或者有左右孩子但已被访问输出，访问该节点 pre=temp;//pre指针用来记录上一访问过的节点 &#125;else&#123; if(temp-&gt;rchild!=NULL)&#123;//若右孩子存在，将其入栈 top++; stack[top]=temp-&gt;rchild; &#125; if(temp-&gt;lchild!=NULL)&#123;//若左孩子存在，将其入栈 top++; stack[top]=temp-&gt;lchild; &#125; &#125; &#125; printf(&quot;\n&quot;); return;&#125; 五、后记在用递归遍历二叉树时，总想搞明白递归遍历的过程是怎么样的，但每次都以头昏脑涨结尾。说实话，递归说它难，也就那样，说它简单，但……总之，用递归求解时，不要深究细节，逻辑对，递归一定对。最后若有什么想法，欢迎在评论区留言。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[I am coming]]></title>
    <url>%2F2018%2F08%2F02%2F%E9%9A%8F%E7%AC%94%E6%9D%82%E6%83%B3%2Fhello-world%2F</url>
    <content type="text"><![CDATA[ONE 将学习and工作中遇到的问题记录下来，小白成长为大佬，若干年后，相必值得回味。这是我的第一篇博客。想写博客，但会不会变成为了写博客而写博客呢，不知道。认真地想，以往遇到问题，求助知乎、csdn、博客园，大部分问题都能得到很好的解决，感慨众多大神and大佬的无私分享，遂生出想法，记录问题，待知识丰富后，再来看看这些，希望能够得到些许乐趣吧。 ——GageShan 于2018.08.02 夜]]></content>
      <categories>
        <category>随笔杂想</category>
      </categories>
  </entry>
</search>
