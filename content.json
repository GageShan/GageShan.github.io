{"meta":{"title":"GageShan's blog","subtitle":null,"description":"我也渣，一起学","author":"一杯冰水","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2018-08-14T12:45:56.000Z","updated":"2018-09-29T07:45:14.876Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"以前不知道喜欢什么所以来到这里现在明白了想要什么未来会去哪里 ————SGZ"},{"title":"friends","date":"2018-09-12T14:50:58.000Z","updated":"2018-09-26T15:44:21.393Z","comments":true,"path":"friends/index.html","permalink":"http://yoursite.com/friends/index.html","excerpt":"","text":"大佬们 Z-坤-K禹都一只猫Collation&amp;Seek Group 蔚然博客一木博客"},{"title":"categories","date":"2018-09-29T06:24:08.000Z","updated":"2018-09-29T12:01:30.787Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-09-29T06:23:42.000Z","updated":"2018-09-29T11:59:52.965Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"think what i want","slug":"随笔杂想/thinkwhatiwant","date":"2018-09-27T16:39:39.702Z","updated":"2018-09-29T13:37:45.038Z","comments":true,"path":"2018/09/28/随笔杂想/thinkwhatiwant/","link":"","permalink":"http://yoursite.com/2018/09/28/随笔杂想/thinkwhatiwant/","excerpt":"断断续续，从开学至今，将这些天所发生的事心里想法写下来，感觉真的做了好多好多的蠢事，有时候晚上躺在床上不自觉地脑海中就浮现出来，有些影响日常学习了。今天把这些写下来，算是对过去一段时间地总结吧。希望做的不要违背内心。","text":"断断续续，从开学至今，将这些天所发生的事心里想法写下来，感觉真的做了好多好多的蠢事，有时候晚上躺在床上不自觉地脑海中就浮现出来，有些影响日常学习了。今天把这些写下来，算是对过去一段时间地总结吧。希望做的不要违背内心。 还记得智商被虐的感觉吧。是不是非常水的考试导致了你对这门学科的懈怠。上课，做题，然后学习其他的，好像有些专门做给别人看的感觉。其实真的会有人在意吗？不要去想这有的没的。想起看过的传记，却发现你已经变得越来越骄躁了。感觉已经坐不住了，想要去显摆自己。可是什么都没学得会，真的想不懂资本在哪。现在是快速提升自己的黄金时期，不要在急功近利中把原本大好的局面葬送了。 计算机给了你弯道超车的机会，你确定还要在无谓的迷茫和迟疑而停留吗。任凭前方多么艰难，要知道，高中的小伙伴已经迈进了新世界的大门。不要让自己变得目光短浅，大学会有不求上进的，但那不该是你浪费精力浪费时间逃避困难的借口。既然选择了这一条路，就别再左顾右盼徒生迷茫了。这时候不应该想这些问题，而是在为前途、为明天着想。 有想去却没去成的地方，有想打却没打完的游戏。小说依然在那，却没了作者的凝视，缺少的不只是生气，更有永不相见的绝望。既然知道了，便不要再想了。纷纷扰扰许久了，还是我怂了。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"皇后问题","slug":"数据结构/N皇后","date":"2018-09-25T07:17:43.684Z","updated":"2018-09-29T08:20:58.172Z","comments":true,"path":"2018/09/25/数据结构/N皇后/","link":"","permalink":"http://yoursite.com/2018/09/25/数据结构/N皇后/","excerpt":"皇后问题最重要的就是递归回溯思维。从第一行第一列开始逐级往下放皇后，若可以放置，则放置下一行的皇后，否则就退回到上一皇后的位置。","text":"皇后问题最重要的就是递归回溯思维。从第一行第一列开始逐级往下放皇后，若可以放置，则放置下一行的皇后，否则就退回到上一皇后的位置。 一、数组加回溯弄清楚了回溯怎么回事，就可以进行第二步了。如何判断在该位置可以放置皇后呢？举个例子来说，在图中，小圆圈代表在当前位置试探性放置，由于皇后是一行一行地放置，也就是说只需要判断位于它上方的位置，而与它位置想冲突的，就是左上角右上角和正上方了。定义一个二维数组eq[10][10]，如果在当前位置(i,j)放置了皇后,就让eq[i][j]=1; 2、代码说明以八皇后为例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#define SIZE 8using namespace std;int ep[SIZE][SIZE]=&#123;0&#125;;int num=0;void judge(int x);bool check(int x,int y);void print();int main()&#123; judge(0); return 0;&#125;void judge(int x)&#123; int j; for(j=0;j&lt;SIZE;j++)&#123; ep[x][j]=1;//先在该位置放置皇后 if(check(x,j)==true)&#123; /*若这个位置可以放置，则判断整个棋盘是否全部放完*/ if(x==SIZE-1) print(); else /*若这个位置可以放置，则这一行的皇后放置完成，转而判断下一行的皇后放置*/ judge(x+1); &#125; /*若这个位置不可以放置，就把该位置的状态恢复，转而判断这一行的下一个位置*/ ep[x][j]=0; &#125;&#125;bool check(int x,int y)&#123; /*判断正上方是否有皇后*/ for(int i=0;i&lt;x;i++) if(ep[i][y]==1) return false; /*判断左上方是否有皇后*/ int i=x-1; int j=y-1; while(i&gt;=0&amp;&amp;j&gt;=0)&#123; if(ep[i][j]==1)//若有，则不可放置，返回假 return false; i--; j--; &#125; /*判断当前位置右上角是否有皇后*/ i=x-1; j=y+1; while(i&gt;=0&amp;&amp;j&lt;SIZE)&#123; if(ep[i][j]==1)//若有皇后，说明这个位置不可以放置 return false; i--; j++; &#125; return true;&#125;void print()&#123; num++; cout&lt;&lt;&quot;No. &quot;&lt;&lt;num&lt;&lt;endl; for(int i=0;i&lt;SIZE;i++)&#123; for(int j=0;j&lt;SIZE;j++) cout&lt;&lt;ep[i][j]&lt;&lt;&apos; &apos;; cout&lt;&lt;endl; &#125; &#125; 二、栈加回溯说是栈，其实可以不用栈的结构，而是用栈存储数据的思想。用栈数组来存储数据，非常方便递归回溯。定义stack[10]，top=-1；用top来存当前位置的行坐标，用stack[top]来存当前位置的列坐标。再次用到这个图，那么当前位置可表示为(2,2)，用栈存储就是stack[2]=2；判断它正上方是否有皇后，那就只需要看整个栈里面是否有与这个位置的列坐标相等的数了，需要做的就是遍历整个栈；代码表示为： 123for(int i=0;i&lt;top;i++)&#123; if(stack1[i]==stack1[top]) return false; 再来看右上角和左上角由于它们是斜对角关系，可知这些位置中，每两个在同一斜线的行坐标之差必定等于列坐标的差比如(x1,y1),(x2,y2)，这两个点在同一斜线，必定fabs(x2-x1)==fabs(y2-y1)；代码表示：123for(int i=0;i&lt;top;i++)&#123; if((top-i)==fabs(stack1[top]-stack1[i])) return false; 2、代码说明以八皇后为例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;#include&lt;cmath&gt;#define SIZE 8using namespace std;int stack1[SIZE];int top=-1;int num=0;void judge(int x);bool check(int stack1[]);void print(int stack1[]);int main()&#123; judge(0); return 0; &#125;void judge(int x)&#123; for(int j=0;j&lt;SIZE;j++)&#123; top++; /*top代表行坐标，stack1[top]代表列坐标*/ stack1[top]=j; if(check(stack1)==true)&#123; if(top==SIZE-1) print(stack1); else /*递归判断下一行的皇后位置*/ judge(x+1); &#125; top--;//不能放置皇后就退栈 &#125;&#125;bool check(int stack1[])&#123; for(int i=0;i&lt;top;i++)&#123; /*判断该位置正上方是否放置了皇后*/ /*判断右上方和左上方是否放置皇后*/ if((top-i)==fabs(stack1[top]-stack1[i])||stack1[i]==stack1[top]) return false; &#125; return true;&#125;void print(int stack1[])&#123; num++; cout&lt;&lt;num&lt;&lt;endl; for(int i=0;i&lt;SIZE;i++)&#123; for(int j=0;j&lt;SIZE;j++) if(stack1[i]==j) cout&lt;&lt;&apos;1&apos;&lt;&lt;&apos; &apos;; else cout&lt;&lt;&apos;0&apos;&lt;&lt;&apos; &apos;; cout&lt;&lt;endl; &#125;&#125; 三、例题1、N皇后问题传送门描述 在N*N的方格棋盘放置了N个皇后，使得它们不相互攻击（即任意2个皇后不允许处在同一排，同一列，也不允许处在与棋盘边框成45角的斜线上。你的任务是，对于给定的N，求出有多少种合法的放置方法。 Input 共有若干行，每行一个正整数N≤10，表示棋盘和皇后的数量；如果N=0，表示结束。 Output 共有若干行，每行一个正整数，表示对应输入行的皇后的不同放置数量。 Sample Input12341850 Sample Output12319210 2、题解代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;#include&lt;cmath&gt;#define MAXSIZE 11using namespace std;int stack1[MAXSIZE];int top=-1;int num=0;void judge(int row,int N);bool check(int stack1[]);int main()&#123; int N; int val[11]; for(int i=1;i&lt;=10;i++)&#123; judge(0,i); val[i]=num; num=0; top=-1; &#125; while(cin&gt;&gt;N)&#123; if(N==0) break; cout&lt;&lt;val[N]&lt;&lt;endl; &#125; return 0; &#125;void judge(int row,int N)&#123; for(int j=0;j&lt;N;j++)&#123; top++; stack1[top]=j; if(check(stack1)==true)&#123; if(top==N-1) num++; else judge(row+1,N); &#125; top--; &#125;&#125;bool check(int stack1[])&#123; for(int i=0;i&lt;top;i++) if(((top-i)==fabs(stack1[top]-stack1[i]))||(stack1[i]==stack1[top])) return false; return true;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"http://yoursite.com/tags/c-c/"}]},{"title":"《数据结构 李春葆版》课后练习题三（栈与队列）","slug":"数据结构/数据结构课后练习题三栈与队列","date":"2018-09-24T15:42:06.967Z","updated":"2018-09-29T08:23:15.106Z","comments":true,"path":"2018/09/24/数据结构/数据结构课后练习题三栈与队列/","link":"","permalink":"http://yoursite.com/2018/09/24/数据结构/数据结构课后练习题三栈与队列/","excerpt":"开始做的话，是在灌水吧。栈与队列，刚开始接触这部分知识感觉不是很上手，然而又有什么关系呢？东西就在那里，你学与不学又能怎么样呢？如果总是逃避的难题，碰到真正地难题你还会有信心去面对吗？况且这不能算是难题。明天很美好，前提是你有能力获得美好。然而又有什么好玩的呢？一天又一天的过去，真正做了什么呢？学了什么呢？不清楚自己在做什么，时间并不会等人。做自己想做的，学自己想学的，不要把别人要求你的当成包袱。","text":"开始做的话，是在灌水吧。栈与队列，刚开始接触这部分知识感觉不是很上手，然而又有什么关系呢？东西就在那里，你学与不学又能怎么样呢？如果总是逃避的难题，碰到真正地难题你还会有信心去面对吗？况且这不能算是难题。明天很美好，前提是你有能力获得美好。然而又有什么好玩的呢？一天又一天的过去，真正做了什么呢？学了什么呢？不清楚自己在做什么，时间并不会等人。做自己想做的，学自己想学的，不要把别人要求你的当成包袱。 一、练习题三第十题括号匹配12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;using namespace std;#define MAXSIZE 1000+10struct Stack&#123; char num[MAXSIZE]; int top;&#125;; int main()&#123; char str[MAXSIZE]; cin&gt;&gt;str; struct Stack stack; stack.top=-1; for(int i=0;i&lt;strlen(str);i++)&#123; if(str[i]==&apos;(&apos;||str[i]==&apos;[&apos;||str[i]==&apos;&#123;&apos;)&#123; stack.top++; stack.num[stack.top]=str[i]; &#125; if(str[i]==&apos;)&apos;) if(stack.num[stack.top]==&apos;(&apos;) stack.top--; else break; if(str[i]==&apos;]&apos;) if(stack.num[stack.top]==&apos;[&apos;) stack.top--; else break; if(str[i]==&apos;&#125;&apos;) if(stack.num[stack.top]==&apos;&#123;&apos;) stack.top--; else break; &#125; if(stack.top==-1&amp;&amp;i&gt;=strlen(str)) cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; return 0;&#125; /*测试数据*//*1、][ No2、[][][]()&#123;&#125;&#123; No3、][][ No4、()[[(&#123;&#125;)]] Yes*/ 第十一题每天要喝八杯水，orz12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#define MAXSIZE 100using namespace std;struct Queue&#123; char num[MAXSIZE]; int front,rear;&#125;; int main()&#123; struct Queue queue; queue.rear=queue.front=0; char str[MAXSIZE]; cin&gt;&gt;str; for(int i=0;i&lt;strlen(str);i++)&#123; if(str[i]&gt;=&apos;0&apos;&amp;&amp;str[i]&lt;=&apos;9&apos;)&#123; queue.rear=(queue.rear+1)%MAXSIZE; queue.num[queue.rear]=str[i]; &#125; else if(str[i]&gt;=&apos;a&apos;&amp;&amp;str[i]&lt;=&apos;z&apos;)&#123; if(queue.front!=queue.rear) queue.front=(queue.front+1)%MAXSIZE; &#125; else break; &#125; while(queue.front!=queue.rear)&#123; queue.front=(queue.front+1)%MAXSIZE; cout&lt;&lt;queue.num[queue.front]&lt;&lt;&apos; &apos;; &#125; return 0;&#125;/*测试数据*//*1、123asw1sw123. 123*/ 待续……","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"http://yoursite.com/tags/c-c/"}]},{"title":"《数据结构 李春葆版》课后练习题二（线性表）","slug":"数据结构/数据结构课后练习题二线性表","date":"2018-09-21T13:41:19.043Z","updated":"2018-09-29T08:22:57.520Z","comments":true,"path":"2018/09/21/数据结构/数据结构课后练习题二线性表/","link":"","permalink":"http://yoursite.com/2018/09/21/数据结构/数据结构课后练习题二线性表/","excerpt":"数据结构课程，做作业，打代码。头昏脑涨时写写这些题目，算是把学过的再重新温习一遍？再复习一遍？不过再写这些题目的时候还真有些地方有点感悟，做OJ上得题，通常会有时间限制，代码不够优化题目测试数据又庞大无比就必定超时。","text":"数据结构课程，做作业，打代码。头昏脑涨时写写这些题目，算是把学过的再重新温习一遍？再复习一遍？不过再写这些题目的时候还真有些地方有点感悟，做OJ上得题，通常会有时间限制，代码不够优化题目测试数据又庞大无比就必定超时。而这些题目呢？一直说要优化，却没有配套的数据来检测，写出来谁知道是不是够优化了。况且题目又只要写函数，这样一来，写的函数不放在完整的程序里跑一遍谁知道是不会出现编译错误（doge~）。好了，就这样吧，就当放松下得得得啊。题目就不抄了，太过练习打码熟练度的题目也不写了。 一、练习题二第六题原地算法了解一下123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;#include&lt;cstdlib&gt;using namespace std;#define MAXSIZE 1000struct List&#123; int data[MAXSIZE]; int length;&#125;;void fun6(struct List *&amp;L,int x,int y);int main()&#123; struct List *L; L=(struct List *)malloc(sizeof(struct List)); for(int i=0;i&lt;9;i++) cin&gt;&gt;L-&gt;data[i]; L-&gt;length=10; fun6(L,4,8); for(int i=0;i&lt;L-&gt;length;i++) cout&lt;&lt;L-&gt;data[i]&lt;&lt;&apos; &apos;; return 0;&#125;/*第六题*/void fun6(struct List *&amp;L,int x,int y)&#123; int j=0; for(int i=0;i&lt;L-&gt;length;i++)&#123; if(L-&gt;data[i]&lt;x||L-&gt;data[i]&gt;y)&#123; L-&gt;data[j]=L-&gt;data[i]; j++; &#125; &#125; L-&gt;length=j-1;&#125;/*测试数据*//*1、1 2 4 6 7 8 9 5 4 1 2 92、2 3 2 4 6 2 7 1 5 2 3 2 2 1*/ 第七题123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;#include&lt;cstdlib&gt;using namespace std;#define MAXSIZE 1000struct List&#123; int data[MAXSIZE]; int length;&#125;;void fun7(struct List *&amp;L,int x);int main()&#123; struct List *L; L=(struct List *)malloc(sizeof(struct List)); for(int i=0;i&lt;9;i++) cin&gt;&gt;L-&gt;data[i]; L-&gt;length=9; fun7(L,4); for(int i=0;i&lt;L-&gt;length;i++) cout&lt;&lt;L-&gt;data[i]&lt;&lt;&apos; &apos;; return 0;&#125;void fun7(struct List *&amp;L,int x)&#123; int i=0; for(i=0;i&lt;L-&gt;length;i++) if(x&lt;L-&gt;data[i]) break; for(int j=L-&gt;length-1;j&gt;=i;j--) L-&gt;data[j+1]=L-&gt;data[j]; L-&gt;data[i]=x; L-&gt;length++;&#125; /*测试数据*//*1、1 2 3 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10*/ 第八题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;#include&lt;cstdlib&gt;using namespace std;#define MAXSIZE 1000#define true1 L-&gt;data[j]&gt;0&amp;&amp;L-&gt;data[i]&lt;0 #define true2 L-&gt;data[j]&lt;0&amp;&amp;L-&gt;data[i]&gt;0struct List&#123; int data[MAXSIZE]; int length;&#125;;void fun8(struct List *&amp;L);void swap(int &amp;a,int &amp;b);int main()&#123; struct List *L; L=(struct List *)malloc(sizeof(struct List)); for(int i=0;i&lt;9;i++) cin&gt;&gt;L-&gt;data[i]; L-&gt;length=9; fun8(L); for(int i=0;i&lt;L-&gt;length;i++) cout&lt;&lt;L-&gt;data[i]&lt;&lt;&apos; &apos;; return 0;&#125;void fun8(struct List *&amp;L)&#123; int j=0; for(int i=1;i&lt;L-&gt;length;i++)&#123; if(true1)&#123; swap(L-&gt;data[j],L-&gt;data[i]); j++; &#125; if(true2) j++; &#125;&#125; void swap(int &amp;a,int &amp;b)&#123; int temp=a; a=b; b=temp;&#125;/*测试数据*/ /*1、-1 2 -2 3 -4 5 -6 7 -8 -1 -2 -4 -6 -8 5 3 7 22、1 -2 -3 1 -1 2 3 -2 -7 -2 -3 -1 -2 -7 2 3 1 1*/ 第十题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;#include&lt;cstdlib&gt;using namespace std;struct List&#123; int num; struct List *next,*pre;&#125;;void creat(struct List *&amp;L);void fun10(struct List *&amp;L);int main()&#123; struct List *L,*p,*p1; L=(struct List *)malloc(sizeof(struct List)); creat(L); fun10(L); p=L-&gt;next; while(p!=NULL)&#123; cout&lt;&lt;p-&gt;num&lt;&lt;&apos; &apos;; p1=p; //p1为验证双链表专用指针 p=p-&gt;next; &#125; /*验证双链表*/ cout&lt;&lt;endl&lt;&lt;&quot;验证双链表&quot;&lt;&lt;endl; while(p1!=L)&#123; cout&lt;&lt;p1-&gt;num&lt;&lt;&apos; &apos;; p1=p1-&gt;pre; &#125; return 0;&#125;void fun10(struct List *&amp;L)&#123; struct List *p1,*p2,*p3; p1=L; for(int i=0;i&lt;2;i++)&#123; p2=p1; p1=p1-&gt;next; &#125; p3=p1-&gt;next; p1-&gt;next=p3-&gt;next; p3-&gt;next=p1; p2-&gt;next=p3; p3-&gt;pre=p2; p1-&gt;next-&gt;pre=p1; p1-&gt;pre=p3; &#125;void creat(struct List *&amp;L)&#123; struct List *p1,*p2; p2=L; for(int i=0;i&lt;5;i++)&#123; p1=(struct List *)malloc(sizeof(struct List)); scanf(&quot;%d&quot;,&amp;p1-&gt;num); p2-&gt;next=p1; p1-&gt;pre=p2; p2=p1; &#125; p2-&gt;next=NULL;&#125;/*测试数据 选择第二个数与第三个数交换*//*1、1 2 3 4 5 1 3 2 4 52、3 4 5 6 3 3 5 4 6 3 */ 第十一题快慢指针了解下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;bits/stdc++.h&gt; #include&lt;cstdlib&gt;using namespace std;#define ture truestruct List&#123; int num; struct List *next;&#125;;void creat(struct List *&amp;L);bool sertchone(struct List *&amp;L,int x);bool sertchtwo(struct List *&amp;L,int x);bool sertchthree(struct List *&amp;L,int x);int main()&#123; struct List *L; L=(struct List *)malloc(sizeof(struct List)); creat(L); bool result1=sertchone(L,2); if(result1) cout&lt;&lt;&quot;true&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;false&quot;&lt;&lt;endl; bool result2=sertchtwo(L,2); if(result2) cout&lt;&lt;&quot;true&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;false&quot;&lt;&lt;endl; bool result3=sertchthree(L,2); if(result3) cout&lt;&lt;&quot;true&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;false&quot;&lt;&lt;endl; return 0;&#125;void creat(struct List *&amp;L)&#123; struct List *p1,*p2; p2=L; for(int i=0;i&lt;5;i++)&#123; p1=(struct List *)malloc(sizeof(struct List)); //scanf(&quot;%d&quot;,&amp;p1-&gt;num); cin&gt;&gt;p1-&gt;num; p2-&gt;next=p1; p2=p1; &#125; p2-&gt;next=NULL;&#125;bool sertchone(struct List *&amp;L,int x)//无序查找，遍历链表，时间复杂度为O(n) &#123; struct List *p=L; while(p!=NULL)&#123; if(p-&gt;num==x) return true; p=p-&gt;next; &#125; return false; &#125;bool sertchtwo(struct List *&amp;L,int x)//递增有序 ,快指针，时间复杂度为O(n/2); &#123; struct List *p1,*p2; p1=p2=L; while(p2-&gt;next-&gt;next!=NULL)&#123; if(p2-&gt;next-&gt;next-&gt;num&lt;=x)&#123; p2=p2-&gt;next-&gt;next; &#125; else&#123; p2=p2-&gt;next; &#125; if(p2-&gt;num==x) return true; &#125; return false; &#125;bool sertchthree(struct List *&amp;L,int x)//递减有序 快指针，时间复杂度为O(n/2); &#123; struct List *p1,*p2; p1=p2=L; while(p2-&gt;next-&gt;next!=NULL)&#123; if(p2-&gt;next-&gt;next-&gt;num&gt;=x)&#123; p2=p2-&gt;next-&gt;next; &#125; else&#123; p2=p2-&gt;next; &#125; if(p2-&gt;num==x) return true; &#125; return false;&#125; 第十二题链表逆转，比较有趣12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;#include&lt;cstdlib&gt;using namespace std;struct List&#123; int num; struct List *next;&#125;;void creat(struct List *&amp;L);void reverse(struct List *&amp;L); int main()&#123; struct List *L,*p; L=(struct List *)malloc(sizeof(struct List)); creat(L); reverse(L); p=L; while(p!=NULL)&#123; cout&lt;&lt;p-&gt;num&lt;&lt;&apos; &apos;; p=p-&gt;next; &#125; return 0;&#125;void creat(struct List *&amp;L)&#123; struct List *p1,*p2; p2=L; for(int i=0;i&lt;5;i++)&#123; p1=(struct List *)malloc(sizeof(struct List)); cin&gt;&gt;p1-&gt;num; if(i==0) L=p2=p1; else p2-&gt;next=p1; p2=p1; &#125; p2-&gt;next=NULL;&#125;void reverse(struct List *&amp;L)&#123; struct List *head,*p1,*p2; p1=p2=L; while(p1-&gt;next!=NULL) p1=p1-&gt;next; head=L; while(head!=p1)&#123; head=head-&gt;next; p2-&gt;next=p1-&gt;next; p1-&gt;next=p2; p2=head; &#125; L=head;&#125;/*测试数据*//*1、1 2 3 4 5 5 4 3 2 1*/ 第十三题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;#include&lt;cstdlib&gt;using namespace std;struct List&#123; int num; struct List *next;&#125;;void creat(struct List *&amp;L);int seartch(struct List *&amp;L);int main()&#123; struct List *L; L=(struct List *)malloc(sizeof(struct List)); creat(L); int result=seartch(L); cout&lt;&lt;result&lt;&lt;endl; return 0;&#125;void creat(struct List *&amp;L)&#123; struct List *p1,*p2; p2=L; for(int i=0;i&lt;7;i++)&#123; p1=(struct List *)malloc(sizeof(struct List)); cin&gt;&gt;p1-&gt;num; p2-&gt;next=p1; p2=p1; &#125; p2-&gt;next=NULL;&#125;int seartch(struct List *&amp;L)//利用快指针，时间复杂度降低&#123; struct List *p; p=L-&gt;next; int length=0; while(p!=NULL)&#123; length++; p=p-&gt;next; &#125; int count=1; p=L-&gt;next; int len; if(length%2==0) len=length/2; else len=length/2+1; while(count&lt;len)&#123; if(len-count&gt;=2)&#123; p=p-&gt;next-&gt;next; count+=2; &#125; else&#123; p=p-&gt;next; count++; &#125; &#125; return p-&gt;num;&#125;/*测试数据*//*1、1 2 3 4 5 6 7 8 42、1 2 3 4 5 6 7 4 */ 第十四题喵。题目看错了。下面代码错的。更新：遇到目前max时，在此值前面插入结点，同时用一个指针记下这个结点前面的位置，若在后面遍历过程中遇到比max还大，将前面插入的结点删去，同时插入结点记下位置。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;#include&lt;cstdlib&gt;#define MAXSIZE 100using namespace std;struct List&#123; int num; struct List *next;&#125;;void creat(struct List *&amp;L);void insert(struct List *&amp;L,int x); int main()&#123; struct List *L,*p; L=(struct List *)malloc(sizeof(struct List)); creat(L); insert(L,3); p=L-&gt;next; while(p!=NULL)&#123; cout&lt;&lt;p-&gt;num&lt;&lt;&apos; &apos;; p=p-&gt;next; &#125; return 0;&#125;void creat(struct List *&amp;L)&#123; struct List *p1,*p2; p2=L; for(int i=0;i&lt;7;i++)&#123; p1=(struct List *)malloc(sizeof(struct List)); cin&gt;&gt;p1-&gt;num; p2-&gt;next=p1; p2=p1; &#125; p2-&gt;next=NULL;&#125;void insert(struct List *&amp;L,int x)&#123; struct List *p1=L-&gt;next,*p2; int max=p1-&gt;num; while(p1!=NULL)&#123; if(max&lt;=p1-&gt;num)&#123; max=p1-&gt;num; &#125; p1=p1-&gt;next; &#125; p1=L; int flag=1; while(p1-&gt;next!=NULL)&#123; if(max==p1-&gt;next-&gt;num)&#123; p2=(struct List *)malloc(sizeof(struct List)); p2-&gt;num=x; p2-&gt;next=p1-&gt;next; p1-&gt;next=p2; flag=0; &#125; if(flag==1) p1=p1-&gt;next; else&#123; p1=p1-&gt;next-&gt;next; flag=1; &#125; &#125;&#125;/*测试数据*//*1、1 4 2 4 4 1 4 1 3 4 2 3 4 3 4 1 3 42、6 6 1 3 6 3 6 3 6 3 6 1 3 3 6 3 3 6 */ 第十五题空间复杂度满足了，但时间耗费好多，感觉这程序写的好蠢&lt;/\\=/>12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;#include&lt;cstdio&gt;using namespace std;struct List&#123; int data; struct List *next;&#125;;void creat(struct List *&amp;L);void print(struct List *&amp;L);int main()&#123; struct List *L; L=(struct List *)malloc(sizeof(struct List)); creat(L); print(L); return 0;&#125; void creat(struct List *&amp;L)&#123; struct List *p1,*p2; p2=L; for(int i=0;i&lt;5;i++)&#123; p1=(struct List *)malloc(sizeof(struct List)); cin&gt;&gt;p1-&gt;data; p2-&gt;next=p1; p2=p1; &#125; p2-&gt;next=NULL;&#125;void print(struct List *&amp;L)&#123; struct List *p1,*p2; p1=L-&gt;next; while(L-&gt;next!=NULL)&#123; int max=p1-&gt;data; p2=L; while(p1-&gt;next!=NULL)&#123; if(max&lt;p1-&gt;next-&gt;data)&#123; p2=p1; max=p1-&gt;next-&gt;data; &#125; p1=p1-&gt;next; &#125; cout&lt;&lt;p2-&gt;next-&gt;data&lt;&lt;&apos; &apos;; p1=p2-&gt;next; p2-&gt;next=p1-&gt;next; free(p1); p1=L-&gt;next; &#125;&#125;/*测试数据*//*1、2 3 5 2 4 5 4 3 2 22、3 7 2 9 3 9 7 3 3 2 */ 第十七题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;#include&lt;cstdlib&gt;using namespace std;struct List&#123; int data; struct List *next;&#125;;struct List *creat();void unionList(struct List *&amp;ha,struct List *&amp;hb,struct List *&amp;hc);int main()&#123; struct List *ha,*hb,*hc,*p; ha=hb=hc=(struct List *)malloc(sizeof(struct List)); ha=creat(); hb=creat(); unionList(ha,hb,hc); p=hc-&gt;next; while(p!=hc)&#123; cout&lt;&lt;p-&gt;data&lt;&lt;&apos; &apos;; p=p-&gt;next; &#125; return 0;&#125;struct List *creat()&#123; struct List *p1,*p2,*L; L=(struct List *)malloc(sizeof(struct List)); p2=L; for(int i=0;i&lt;5;i++)&#123; p1=(struct List *)malloc(sizeof(struct List)); cin&gt;&gt;p1-&gt;data; p2-&gt;next=p1; p2=p1; &#125; p2-&gt;next=L; return L;&#125;void unionList(struct List *&amp;ha,struct List *&amp;hb,struct List *&amp;hc)&#123; struct List *p1,*p2; p1=hb-&gt;next; p2=ha-&gt;next; while(p1-&gt;next!=hb)&#123; p1=p1-&gt;next; &#125; while(p2-&gt;next!=ha)&#123; p2=p2-&gt;next; &#125; hc-&gt;next=ha-&gt;next; p2-&gt;next=hc; p2-&gt;next=hb-&gt;next; p1-&gt;next=hc;&#125;/*测试数据*//*1、1 2 3 4 5 2 3 4 5 6 1 2 3 4 5 2 3 4 5 6*/ 二、综合性实验实验题12本题用链表求大数加法，简单用链表模拟下加法运算。只写了具体求结果的代码，求中间位的就不写了。数据保证为正整数，小数负数这代码求不了，而我等有时间再改吧。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;using namespace std;#define MAXSIZE 100000+1000struct List&#123; int data; struct List *next;&#125;;struct List *rever(char ch[]);void add(struct List *&amp;L1,struct List *&amp;L2);int main()&#123; char str1[MAXSIZE],str2[MAXSIZE]; while(cin&gt;&gt;str1&gt;&gt;str2)&#123;//多组样列输入 struct List *L1,*L2; L1=L2=(struct List *)malloc(sizeof(struct List)); L1=rever(str1); L2=rever(str2); add(L1,L2); &#125; return 0;&#125;struct List *rever(char ch[])//将字符数组存入链表中 &#123; struct List *L,*p1,*p2; L=(struct List *)malloc(sizeof(struct List)); p2=L; for(int i=strlen(ch)-1;i&gt;=0;i--)&#123; p1=(struct List *)malloc(sizeof(struct List)); p1-&gt;data=ch[i]-48; p2-&gt;next=p1; p2=p1; &#125; p2-&gt;next=NULL; return L;&#125;void add(struct List *&amp;L1,struct List *&amp;L2)&#123; int num[MAXSIZE+10]; int i=0,t=0; struct List *p1=L1-&gt;next,*p2=L2-&gt;next; while(p1!=NULL||p2!=NULL)&#123; if(p1!=NULL&amp;&amp;p2!=NULL)&#123; num[i++]=(p1-&gt;data+p2-&gt;data+t)%10; t=(p1-&gt;data+p2-&gt;data+t)/10; p1=p1-&gt;next; p2=p2-&gt;next; &#125; if(p1!=NULL&amp;&amp;p2==NULL)&#123; num[i++]=(p1-&gt;data+t)%10; t=(p1-&gt;data+t)/10; p1=p1-&gt;next; &#125; if(p1==NULL&amp;&amp;p2!=NULL)&#123; num[i++]=(p2-&gt;data+t)%10; t=(p2-&gt;data+t)/10; p2=p2-&gt;next; &#125; &#125; if(t!=0) num[i++]=t; for(int j=i-1;j&gt;=0;j--) cout&lt;&lt;num[j]; cout&lt;&lt;endl;&#125; /*测试数据*//*1、112233445566778899 998877665544332211 11111111111111111102、1314 4131 5445 */ 待续…","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"http://yoursite.com/tags/c-c/"}]},{"title":"火车调度（栈）","slug":"数据结构/火车调度","date":"2018-09-20T07:15:33.971Z","updated":"2018-09-29T08:22:00.406Z","comments":true,"path":"2018/09/20/数据结构/火车调度/","link":"","permalink":"http://yoursite.com/2018/09/20/数据结构/火车调度/","excerpt":"一、题目描述 火车调度传送门 Description 有一条东西方向的铁路穿过小城A，小城A有一个火车调度站，示意图如下：","text":"一、题目描述 火车调度传送门 Description 有一条东西方向的铁路穿过小城A，小城A有一个火车调度站，示意图如下：现在有N列火车自东向西依次开过来了，按照到达的先后次序编号为0号到N-1号。 根据调度局的要求，小城A的调度站要改变这些列车驶离A城的顺序。 为了达到这一目的， 调度站在任意时刻可以执行以下三种操作之一：1、如果调度站还有剩余空间，则可以令下一列开来的火车进入调度站；2、如果调度站内有列车，则可以令调度站最前方的火车离开调度站并驶离A城；3、可以命令下一列开来的火车不经过调度站而直接驶离A城。不过小城A的调度站实在太小了，只能容纳M列火车，请帮忙确认调度站能否完成任务。 例子如果有4列火车开来，调度站可以容纳2列火车，调度局要求火车按照2、1、3、0的顺序驶离A城，则此任务可满足，一种可能的方案如下：Step 1：火车0进入调度站；Step 2：火车1进入调度站；Step 3：火车2不经过调度站驶离A城；Step 4：火车1从调度站驶离A城；Step 5：火车3不经过调度站驶离A城；当然，你只需要回答是否可行，不需要列出一种可行方案。 Input Format 第一行是一个正整数T，表示本测试数据有多少个独立的测试点。（ T≤300 ）之后有T个独立的测试点，每个测试点占两行。 第一行有两个数字N和M，分别表示开来的火车数量，以及调度站最多可容纳的火车数量，两个数字之间用一个空格隔开。 第二行有N个整数，他们都在0到N−1之间，且不重复，用空格隔开，表示火车驶离A城的次序。N是正整数，且N≤1000；M是非负整数，且M≤1000。 M可能为0（这也许说明调度站的工作人员罢工了，或者正在这个考场考试）。 Output Format 输出共T行，每行对应一个测试点。如果能够调度，则回答YES，否则回答NO。 输出请注意大小写，每行行末直接回车，不要有其他字符。 Sample Input1234524 22 1 3 05 22 4 3 1 0 Sample Output12YESNO 二、题解一步步模拟即可，例子说的很明白。现在假如从山那边开来0，1，2，3······M-1，M列火车。从出站次序数组零号元素开始模拟，如果当前数组元素恰好等于开来的火车序号，说明此时火车可直接开过去，否则将开来的火车送入调度站。如果调度站满了，但开来的火车还不等于当前数组元素，就无解了，输出NO。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt; #define MAXSIZE 1000+100struct Stack&#123; int num[MAXSIZE]; int top; &#125;;int main()&#123; int Case; scanf(&quot;%d&quot;,&amp;Case); while(Case--)&#123; int N,M; int val[MAXSIZE]; scanf(&quot;%d%d&quot;,&amp;N,&amp;M); for(int i=0;i&lt;N;i++) scanf(&quot;%d&quot;,&amp;val[i]); struct Stack stack; stack.top=-1; int number=0; int flag=1; for(int i=0;i&lt;N;)&#123; if(val[i]==number)&#123; i++; number++; continue; &#125; if(val[i]==stack.num[stack.top])&#123; i++; stack.top--; continue; &#125; if(val[i]!=number)&#123; stack.top++; stack.num[stack.top]=number; number++; &#125; if(stack.top==M)&#123; flag=0; break; &#125; &#125; if(flag==1) printf(&quot;YES\\n&quot;); else printf(&quot;NO\\n&quot;); &#125; return 0;&#125; 继续补题…","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"http://yoursite.com/tags/c-c/"}]},{"title":"NYOJ465中缀式变后缀式（套题）","slug":"数据结构/中缀式变后缀式2","date":"2018-09-19T15:47:44.303Z","updated":"2018-09-29T08:23:37.364Z","comments":true,"path":"2018/09/19/数据结构/中缀式变后缀式2/","link":"","permalink":"http://yoursite.com/2018/09/19/数据结构/中缀式变后缀式2/","excerpt":"一、题目描述中缀式变后缀式时间限制：1000 ms | 内存限制：65535 KB难度：3描述 人们的日常习惯是把算术表达式写成中缀式，但对于机器来说更“习惯于”后缀式，关于算术表达式的中缀式和后缀式的论述一般的数据结构书都有相关内容可供参看，这里不再赘述，现在你的任务是将中缀式变为后缀式。","text":"一、题目描述中缀式变后缀式时间限制：1000 ms | 内存限制：65535 KB难度：3描述 人们的日常习惯是把算术表达式写成中缀式，但对于机器来说更“习惯于”后缀式，关于算术表达式的中缀式和后缀式的论述一般的数据结构书都有相关内容可供参看，这里不再赘述，现在你的任务是将中缀式变为后缀式。输入第一行输入一个整数n，共有n组测试数据（n&lt;10)。每组测试数据只有一行，是一个长度不超过1000的字符串，表示这个运算式的中缀式，每个运算式都是以“=”结束。这个表达式里只包含+-*/与小括号这几种符号。其中小括号可以嵌套使用。数据保证输入的操作数中不会出现负数。数据保证除数不会为0 输出 每组都输出该组中缀式相应的后缀式，要求相邻的操作数操作符用空格隔开。样例输入12321.000+2/4=((1+2)*5+1)/4= 样例输出121.000 2 4 / + =1 2 + 5 * 1 + 4 / = 二、题解模拟过程点这123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;stdio.h&gt;#include&lt;string.h&gt; #define MAXSIZE 3000struct Stack&#123; char character[MAXSIZE]; int top; int flag[MAXSIZE];&#125;;int main()&#123; int Case; scanf(&quot;%d&quot;,&amp;Case); while(Case--) &#123; char str[MAXSIZE]; char ch[MAXSIZE]; struct Stack stack; int count=0; stack.top=-1; scanf(&quot;%s&quot;,str); for(int i=0;i&lt;strlen(str)-1;i++)&#123; if((str[i]&gt;=&apos;0&apos;&amp;&amp;str[i]&lt;=&apos;9&apos;)||str[i]==&apos;.&apos;)&#123; if((str[i+1]&gt;=&apos;0&apos;&amp;&amp;str[i+1]&lt;=&apos;9&apos;)||str[i+1]==&apos;.&apos;) ch[count++]=str[i]; else&#123; ch[count++]=str[i]; ch[count++]=&apos; &apos;; &#125; &#125; else &#123; switch(str[i])&#123; case &apos;-&apos;: case &apos;+&apos;: if(stack.top==-1)&#123; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=1; &#125; else&#123; if(stack.flag[stack.top]!=3)&#123; if(stack.flag[stack.top]==2)&#123; ch[count++]=stack.character[stack.top]; ch[count++]=&apos; &apos;; stack.top--; &#125; if(stack.flag[stack.top]==1)&#123; ch[count++]=stack.character[stack.top]; ch[count++]=&apos; &apos;; stack.top--; &#125; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=1; &#125; else&#123; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=1; &#125; &#125; break; case &apos;*&apos;: case &apos;/&apos;: if(stack.top==-1)&#123; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=2; &#125; else&#123; if(stack.flag[stack.top]==1||stack.flag[stack.top]==3)&#123; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=2; &#125; else&#123; ch[count++]=stack.character[stack.top]; ch[count++]=&apos; &apos;; stack.top--; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=2; &#125; &#125; break; case &apos;(&apos;: stack.top++; stack.character[stack.top]=&apos;(&apos;; stack.flag[stack.top]=3; break; case &apos;)&apos;: while(stack.character[stack.top]!=&apos;(&apos;)&#123; ch[count++]=stack.character[stack.top]; ch[count++]=&apos; &apos;; stack.top--; &#125; stack.top--; break; &#125; &#125; &#125; while(stack.top!=-1)&#123; ch[count++]=stack.character[stack.top]; ch[count++]=&apos; &apos;; stack.top--; &#125; ch[count++]=&apos;=&apos;; ch[count]=&apos;\\0&apos;; printf(&quot;%s\\n&quot;,ch); &#125; return 0; &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"http://yoursite.com/tags/c-c/"}]},{"title":"NYOJ257中缀式变后缀式","slug":"数据结构/中缀式变后缀式","date":"2018-09-17T06:04:47.021Z","updated":"2018-09-29T08:23:27.307Z","comments":true,"path":"2018/09/17/数据结构/中缀式变后缀式/","link":"","permalink":"http://yoursite.com/2018/09/17/数据结构/中缀式变后缀式/","excerpt":"一、题目描述郁闷的C小加（一）时间限制：1000 ms | 内存限制：65535 KB难度：3描述 我们熟悉的表达式如a+b、a+b(c+d)等都属于中缀表达式。中缀表达式就是（对于双目运算符来说）操作符在两个操作数中间：num1 operand num2。同理，后缀表达式就是操作符在两个操作数之后：num1 num2 operand。ACM队的“C小加”正在郁闷怎样把一个中缀表达式转换为后缀表达式，现在请你设计一个程序，帮助C小加把中缀表达式转换成后缀表达式。为简化问题，操作数均为个位数，操作符只有+-/ 和小括号。","text":"一、题目描述郁闷的C小加（一）时间限制：1000 ms | 内存限制：65535 KB难度：3描述 我们熟悉的表达式如a+b、a+b(c+d)等都属于中缀表达式。中缀表达式就是（对于双目运算符来说）操作符在两个操作数中间：num1 operand num2。同理，后缀表达式就是操作符在两个操作数之后：num1 num2 operand。ACM队的“C小加”正在郁闷怎样把一个中缀表达式转换为后缀表达式，现在请你设计一个程序，帮助C小加把中缀表达式转换成后缀表达式。为简化问题，操作数均为个位数，操作符只有+-/ 和小括号。输入第一行输入T，表示有T组测试数据（T&lt;10）。每组测试数据只有一行，是一个长度不超过1000的字符串，表示这个表达式。这个表达式里只包含+-*/与小括号这几种符号。其中小括号可以嵌套使用。数据保证输入的操作数中不会出现负数。并且输入数据不会出现不匹配现象。 输出 每组输出都单独成行，输出转换的后缀表达式。 样例输入12321+2(1+2)*3+4*5 样例输出1212+12+3*45*+ 二、题解本题可以用栈来解决。设置运算符的优先级，本题中令+、-的优先级为1，*、/的优先级为2，(的优先级为3。遍历字符串，若发现运算符，将其优先级与栈首元素优先级比较，（如果栈为空直接进栈），若大于则该运算符进栈，若小于且栈首不为’(‘将栈首元素出栈然后将其进栈，若栈首为’(‘，无论何运算符，进栈。若遍历到’)’，则将栈中元素出栈直到栈首为’(‘，最后把’(‘出栈。遍历完字符串，若栈不为空，将栈中元素全部出栈。代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;stdio.h&gt;#include&lt;string.h&gt; #define MAXSIZE 3000struct Stack&#123; char character[MAXSIZE]; int top; int flag[MAXSIZE];//优先级&#125;;int main()&#123; int Case; scanf(&quot;%d&quot;,&amp;Case); while(Case--) &#123; char str[MAXSIZE]; char ch[MAXSIZE]; struct Stack stack; int count=0; stack.top=-1; scanf(&quot;%s&quot;,str); for(int i=0;i&lt;strlen(str);i++)&#123; if(str[i]&gt;=&apos;0&apos;&amp;&amp;str[i]&lt;=&apos;9&apos;) ch[count++]=str[i]; else &#123; switch(str[i])&#123; case &apos;-&apos;: case &apos;+&apos;: if(stack.top==-1)&#123; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=1; &#125; else&#123; if(stack.flag[stack.top]!=3)&#123; if(stack.flag[stack.top]==2)&#123; ch[count++]=stack.character[stack.top]; stack.top--; &#125; if(stack.flag[stack.top]==1)&#123; ch[count++]=stack.character[stack.top]; stack.top--; &#125; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=1; &#125; else&#123; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=1; &#125; &#125; break; case &apos;*&apos;: case &apos;/&apos;: if(stack.top==-1)&#123; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=2; &#125; else&#123; if(stack.flag[stack.top]==1||stack.flag[stack.top]==3)&#123; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=2; &#125; else&#123; ch[count++]=stack.character[stack.top]; stack.top--; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=2; &#125; &#125; break; case &apos;(&apos;: stack.top++; stack.character[stack.top]=&apos;(&apos;; stack.flag[stack.top]=3; break; case &apos;)&apos;: while(stack.character[stack.top]!=&apos;(&apos;)&#123; ch[count++]=stack.character[stack.top]; stack.top--; &#125; stack.top--; break; &#125; &#125; &#125; while(stack.top!=-1)&#123; ch[count++]=stack.character[stack.top]; stack.top--; &#125; ch[count]=&apos;\\0&apos;; printf(&quot;%s\\n&quot;,ch); &#125; return 0; &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"http://yoursite.com/tags/c-c/"}]},{"title":"NYOJ305另类表达式求值（栈）","slug":"数据结构/另类表达式求解","date":"2018-09-15T08:35:59.739Z","updated":"2018-09-29T08:22:16.764Z","comments":true,"path":"2018/09/15/数据结构/另类表达式求解/","link":"","permalink":"http://yoursite.com/2018/09/15/数据结构/另类表达式求解/","excerpt":"一、题目描述表达式求值时间限制：3000 ms | 内存限制：65535 KB难度：3描述 Dr.Kong设计的机器人卡多掌握了加减法运算以后，最近又学会了一些简单的函数求值，比如，它知道函数min(20,23)的值是20 ，add(10,98) 的值是108等等。经过训练，Dr.Kong设计的机器人卡多甚至会计算一种嵌套的更复杂的表达式。假设表达式可以简单定义为:","text":"一、题目描述表达式求值时间限制：3000 ms | 内存限制：65535 KB难度：3描述 Dr.Kong设计的机器人卡多掌握了加减法运算以后，最近又学会了一些简单的函数求值，比如，它知道函数min(20,23)的值是20 ，add(10,98) 的值是108等等。经过训练，Dr.Kong设计的机器人卡多甚至会计算一种嵌套的更复杂的表达式。假设表达式可以简单定义为: 一个正的十进制数 x 是一个表达式。 如果 x 和 y 是 表达式，则 函数min(x,y )也是表达式,其值为x,y 中的最小数。 如果 x 和 y 是 表达式，则 函数max(x,y )也是表达式,其值为x,y 中的最大数。 如果 x 和 y 是 表达式，则 函数add(x,y )也是表达式,其值为x,y 之和。例如， 表达式 max(add(1,2),7) 的值为 7。请你编写程序，对于给定的一组表达式，帮助 Dr.Kong 算出正确答案，以便校对卡多计算的正误。 输入 第一行： N 表示要计算的表达式个数 （1≤ N ≤ 10）接下来有N行， 每行是一个字符串，表示待求值的表达式（表达式中不会有多余的空格，每行不超过300个字符，表达式中出现的十进制数都不超过1000。） 输出 输出有N行，每一行对应一个表达式的值。 样例输入123add(1,2) max(1,999) add(min(1,1000),add(100,99)) 样例输出1233999200 二、题解本题是栈应用的类型。首先定义两个栈，一个用来存放运算符（记为栈1），一个用来存放待计算的数据（记为栈2）。从字符串首开始遍历直到尾部，若发现add串（在这里我们只需要识别字符a和字符d），则表示需要求和，将其存入栈1中。若发现min串、max串继续存放。若遍历到的是数字，则存入栈2，需要注意的是，由于输入的是字符串，在识别数据就要小心了。比如识别 47，首先识别到4，这时候可以发现后面还跟着7，4是十位上的数，7是各位上的数，如果在识别是不能处理，那么4就会被单独当成一个数存入栈2中，7也如此。具体看代码。举例add(min(1,1000),add(100,99))1、字符串遍历，到add处，将其进栈1，用“加”代替，那么这时候栈1：加-&gt;null;2、遍历到min，将其精栈1，用“小”代替，栈1：加-&gt;小-&gt;null；3、遍历到1，通过处理将得到的数字进栈2，栈2：1-&gt;null;4、遍历到1000串，处理得到1000进栈2，栈2：1-&gt;1000-&gt;null;5、遍历到），说明此时需要计算数据了，查看栈1栈首的元素，发现此时为小，表明前面两个数据需要比较大小求得较小的数据，拿栈2中栈首元素与次首元素比较，就是1和1000比较得到1，栈2退栈一位，此时栈2：1-&gt;null；将比较得到的数据赋给栈首元素，那么栈2：1-&gt;null；处理完栈2，发现刚才栈1中的栈首得到了应用，将其退栈一位，栈1：加-&gt;null；6、遍历到add处，用“加”代替，进栈，栈1：加-&gt;加-&gt;null;7、接着遍历100，99，分别将他们进栈2，此时栈2：1-&gt;100-&gt;99-&gt;null；8、遍历到），计算数据，栈1中栈首元素为加，则栈2中100和99相加的199，退栈，赋值。栈2：1-&gt;199-&gt;null。栈1退栈一位；9、遍历到），计算数据，栈1中栈首元素为加，则栈2中1和199相加的199，退栈，赋值。栈2：200-&gt;null。栈1退栈一位；10、200为表达式值。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#define MAXSIZE 300+10struct Stack1&#123; int flag[MAXSIZE]; int top;&#125;;struct Stack2&#123; int number[MAXSIZE]; int top;&#125;;double calculate(char str[]);int main()&#123; int Case; scanf(&quot;%d&quot;,&amp;Case); while(Case--)&#123; char str[MAXSIZE]; scanf(&quot;%s&quot;,str); double ans=calculate(str); printf(&quot;%.0lf\\n&quot;,ans); &#125; return 0;&#125;double calculate(char str[])&#123; struct Stack1 stack1; //字符栈 struct Stack2 stack2; //数字栈 stack1.top=stack2.top=-1; int value=0; for(int i=0;i&lt;strlen(str);i++)&#123; if(str[i]==&apos;a&apos;&amp;&amp;str[i-1]!=&apos;m&apos;)&#123;//避免与求最大值的max区分开 value=0; stack1.top++; stack1.flag[stack1.top]=1; &#125; if(str[i]==&apos;m&apos;)&#123; value=0; stack1.top++; if(str[i+1]==&apos;i&apos;) stack1.flag[stack1.top]=2;//判断求最小值 else if(str[i+2]==&apos;x&apos;) stack1.flag[stack1.top]=3;//判断求最大值 &#125; if(str[i]==&apos;,&apos;) value=0; if(str[i]&gt;=&apos;0&apos;&amp;&amp;str[i]&lt;=&apos;9&apos;)&#123; if(str[i-1]&gt;=&apos;0&apos;&amp;&amp;str[i]&lt;=&apos;9&apos;)&#123; value=value*10+str[i]-48; &#125; else&#123; value=str[i]-48;//字符转数字 &#125; if(str[i+1]&lt;&apos;0&apos;||str[i+1]&gt;&apos;9&apos;)&#123; stack2.top++; stack2.number[stack2.top]=value; &#125; &#125; int temp=0; if(str[i]==&apos;)&apos;)&#123; value=0; switch(stack1.flag[stack1.top])&#123; case 1: temp=stack2.number[stack2.top]+stack2.number[stack2.top-1]; stack2.top--; stack2.number[stack2.top]=temp; break; case 2: if(stack2.number[stack2.top]&gt;=stack2.number[stack2.top-1]) stack2.top--; else&#123; temp=stack2.number[stack2.top]; stack2.top--; stack2.number[stack2.top]=temp; &#125; break; case 3: if(stack2.number[stack2.top]&lt;=stack2.number[stack2.top-1]) stack2.top--; else&#123; temp=stack2.number[stack2.top]; stack2.top--; stack2.number[stack2.top]=temp; &#125; &#125; stack1.top--; &#125; &#125; return double(stack2.number[stack2.top]); &#125; 继续补题ing…","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"http://yoursite.com/tags/c-c/"}]},{"title":"走迷宫（迷宫问题补题）","slug":"数据结构/走迷宫","date":"2018-09-14T15:22:22.908Z","updated":"2018-09-29T08:23:52.931Z","comments":true,"path":"2018/09/14/数据结构/走迷宫/","link":"","permalink":"http://yoursite.com/2018/09/14/数据结构/走迷宫/","excerpt":"一、题目描述 一个迷宫由R行C列格子组成，有的格子里有障碍物，不能走；有的格子是空地，可以走。给定一个迷宫，求从左上角走到右下角最少需要走多少步(数据保证一定能走到)。只能在水平方向或垂直方向走，不能斜着走。","text":"一、题目描述 一个迷宫由R行C列格子组成，有的格子里有障碍物，不能走；有的格子是空地，可以走。给定一个迷宫，求从左上角走到右下角最少需要走多少步(数据保证一定能走到)。只能在水平方向或垂直方向走，不能斜着走。Input第一行是两个整数，Ｒ和Ｃ，代表迷宫的长和宽。（ 1&lt;= R，C &lt;= 40)接下来是Ｒ行，每行Ｃ个字符，代表整个迷宫。 空地格子用’.’表示，有障碍物的格子用’#’表示。迷宫左上角和右下角都是’.’。Output输出从左上角走到右下角至少要经过多少步（即至少要经过多少个空地格子）。计算步数要包括起点和终点。 样列输入1234565 5..####....#.#.##.#.##.#.. 样列输出19 二、题解本题方法跟前一篇写的《迷宫求解》队列实现方法一致，传送门需要注意的是二维字符数组的输入问题，可以单个字符的输入，但这就要考虑回车键对数组的影响；而采用字符串形式输入则不会有这个问题，具体见代码。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt;const int MAXSIZE=10000+10;struct Box&#123; int i; int j; int pre;&#125;;struct Type&#123; struct Box data[MAXSIZE]; int front,rear;&#125;;const int LEN=sizeof(struct Type);int findRoad(int a,int b,int c,int d,char mg[42][42]);int main()&#123; char mg[42][42],mgtemp[42][42]; int N,M; scanf(&quot;%d%d&quot;,&amp;N,&amp;M); for(int i=1;i&lt;=N;i++)&#123; scanf(&quot;%s&quot;,mgtemp[i]); //采用临时数组，注意列行从0开始而不是需要的从1开始 &#125; for(int i=1;i&lt;=N;i++)&#123; int t=1; for(int j=0;j&lt;M;j++) mg[i][t++]=mgtemp[i][j];//用此转换 &#125; int ans=findRoad(1,1,N,M,mg); printf(&quot;%d\\n&quot;,ans); return 0; &#125; int findRoad(int a,int b,int c,int d,char mg[42][42])&#123; Box e; struct Type *queue; queue=(struct Type *)malloc(LEN); queue-&gt;front=queue-&gt;rear=-1; int i,j; e.i=a;e.j=b;e.pre=-1; mg[a][b]=&apos;/&apos;; queue-&gt;rear++; queue-&gt;data[queue-&gt;rear]=e; while(queue-&gt;rear!=queue-&gt;front)&#123; queue-&gt;front++; e=queue-&gt;data[queue-&gt;front]; i=e.i;j=e.j; if(i==c&amp;&amp;j==d)&#123; int temp=queue-&gt;front; while(temp!=0)&#123; int num=queue-&gt;data[temp].pre; queue-&gt;data[temp].pre=-1; temp=num; &#125; temp=0; int count=0; while(temp&lt;=queue-&gt;front)&#123; if(queue-&gt;data[temp].pre==-1) count++; temp++; &#125; return count; &#125; int x,y; for(int k=0;k&lt;4;k++)&#123; switch(k)&#123; case 0: x=i-1;y=j;break; case 1: x=i;y=j+1;break; case 2: x=i+1;y=j;break; case 3: x=i;y=j-1;break; &#125; if(mg[x][y]==&apos;.&apos;)&#123; e.i=x;e.j=y;e.pre=queue-&gt;front; queue-&gt;rear++; queue-&gt;data[queue-&gt;rear]=e; mg[x][y]=&apos;/&apos;; &#125; &#125; &#125;&#125; 继续补题ing…","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"http://yoursite.com/tags/c-c/"}]},{"title":"迷宫求解","slug":"数据结构/迷宫求解","date":"2018-09-13T15:51:59.612Z","updated":"2018-09-29T08:22:36.442Z","comments":true,"path":"2018/09/13/数据结构/迷宫求解/","link":"","permalink":"http://yoursite.com/2018/09/13/数据结构/迷宫求解/","excerpt":"想不到迷宫求解还困惑我这么久久久？搞清楚了吧？做下笔记防止遗忘？去补点题？let’s go! 一、问题描述给定一个10*10的迷宫图，求一条从指定路口到指定出口的路径。在这里可以定义一个二维数组，用0来代表迷宫路径可走，用1代表路径不可走。迷宫问题可以用两种数据结构来解决（我暂时只会两种，囧rz），分别为栈、队列。栈只能简单地求出从指定路口到制定出口的路径，也就是说并不能考虑路径长短问题；而用队列来求解的话，可以求出一条最短路径。","text":"想不到迷宫求解还困惑我这么久久久？搞清楚了吧？做下笔记防止遗忘？去补点题？let’s go! 一、问题描述给定一个10*10的迷宫图，求一条从指定路口到指定出口的路径。在这里可以定义一个二维数组，用0来代表迷宫路径可走，用1代表路径不可走。迷宫问题可以用两种数据结构来解决（我暂时只会两种，囧rz），分别为栈、队列。栈只能简单地求出从指定路口到制定出口的路径，也就是说并不能考虑路径长短问题；而用队列来求解的话，可以求出一条最短路径。 二、栈实现1、解决方案说实话，不喜欢用栈来求解，耗时耗力还得不到最优解。就这样吧。从指定路口开始，将指定入口入栈。然后查找与栈头相邻且可走的路口。需要说明是首先要制定一个选择路口的方案，不然计算机怎么知道往哪走呢？我选择的是顺时针查看，即先查看上再右其次下最后左方。若找到，则将其入栈，在这里有一个非常关键的地方，就是需要记住处于栈头相对于前一个路口的方位值，所谓方位值，简单来讲，用0代表上，1代表右，2代表下，3代表左。接着再次查找相邻可走路口。为避免查找到的路口是已经走过的，在设计程序的时候，每一个路口入栈后，都将该路口的状态改变，比如，前面用0代表路径可走，那么可以设置入栈的入口状态值为-1，为区分起始条件不可走的状态值1。若没有找到，也就是说处于当前路口时，上下左右都不可走，不要怕，退一步。退一步就是退回到上一路口。那么整个栈中的元素就是从入口到出口的迷宫路径了。如此直到找到出口，若没有出口，就。。。 2、代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define MAXSIZE 10000int mg[10][10]=&#123; //迷宫数组 &#123;1,1,1,1,1,1,1,1,1,1&#125;, &#123;1,0,0,1,0,0,0,1,0,1&#125;, &#123;1,0,0,1,0,0,0,1,0,1&#125;, &#123;1,0,0,0,0,1,1,0,0,1&#125;, &#123;1,0,1,1,1,0,0,0,0,1&#125;, &#123;1,0,0,0,1,0,0,0,0,1&#125;, &#123;1,0,1,0,0,0,1,0,0,1&#125;, &#123;1,0,1,1,1,0,1,1,0,1&#125;, &#123;1,1,0,0,0,0,0,0,0,1&#125;, &#123;1,1,1,1,1,1,1,1,1,1&#125; &#125;;struct Box&#123; int i; int j; int di; //表示方位值&#125;;struct Type&#123; struct Box data[MAXSIZE]; int top;&#125;;bool findRode(int m,int n,int it,int yt);int main()&#123; if(findRode(1,1,8,8)==false) printf(&quot;failed\\n&quot;); return 0;&#125;bool findRode(int m,int n,int it,int yt)&#123; int i,j,di,k=0; Box e; struct Type *stack; stack=(struct Type *)malloc(sizeof(struct Type)); stack-&gt;top=-1; e.i=m;e.j=n;e.di=0; stack-&gt;top++; //将第一个路口入栈 stack-&gt;data[stack-&gt;top]=e; mg[e.i][e.j]=-1; while(stack-&gt;top!=-1)&#123; e=stack-&gt;data[stack-&gt;top]; i=e.i;j=e.j;k=e.di; if(i==it&amp;&amp;j==yt)&#123; while(stack-&gt;top!=-1)&#123; e=stack-&gt;data[stack-&gt;top]; printf(&quot;(%d,%d) &quot;,e.i,e.j); mg[e.i][e.j]=0; stack-&gt;top--; &#125; free(stack); return true; &#125; bool find=false; while(k&lt;4&amp;&amp;find!=true)&#123; k++; switch(k)&#123; case 0: i=e.i-1;j=e.j;break; case 1: i=e.i;j=e.j+1;break; case 2: i=e.i+1;j=e.j;break; case 3: i=e.i;j=e.j-1;break; &#125; if(mg[i][j]==0) find=true; &#125; if(k&lt;4)&#123; stack-&gt;data[stack-&gt;top].di=k; e.i=i;e.j=j;e.di=-1; stack-&gt;top++; stack-&gt;data[stack-&gt;top]=e; mg[i][j]=-1; &#125;else&#123; //如果当前路口没有相邻可走且不是出口，则退栈回到上一路口 stack-&gt;top--; mg[e.i][e.j]=0; //将该路口状态值重置，表示可走 &#125; &#125; free(stack); return false;&#125; 三、队列实现1、解决方案为什么说用队列来解可以求得最短路径呢？与栈不同的是，队列在查看相邻可走路口时，是将全部相邻可走路口进队；首先将入口进队，队列中就记录下该路口的信息了。将队首元素出队，（注意此时队伍中还记录有路口的信息），以该路口为中心查看相邻路口，使全部相邻可走路口记下该路口在队列中的位置，然后将它们进队。比如起点为A，进队。此时队列为A-&gt;NULL；此时A在队列中的位置就是0（记0是开始），出队，B、C、D是A的相邻可走路口，则B、C、D的前导值就是0，通过查询前导值，就可以清楚地知道A的位置（说明下，第一个路口的前导值记为-1）。此时队列为a-&gt;B-&gt;C-&gt;D-&gt;NULL；（A已出队，但A的信息保留着，所以用a代替）注意队首为B（B在队列中的位置是1），然后将B出队，执行与出队A类似的步骤。直到找到出口。找到出口后，那么通过出口的前导值可以知道它前面的路口（记为M）在哪（将M在队列中的状态值记为-1，后面皆是如此），通过M的前导值又可以知道M前面的路口在哪，直到与入口联系起来。从队首信息开始扫描整个队列，若队列中的元素的状态值为-1，则将该元素记录的坐标输出。求解完成。 2、代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define MAXSIZE 10000#define LEN sizeof(struct Type )int mg[10][10]=&#123; &#123;1,1,1,1,1,1,1,1,1,1&#125;, &#123;1,0,0,1,0,0,0,1,0,1&#125;, &#123;1,0,0,1,0,0,0,1,0,1&#125;, &#123;1,0,0,0,0,1,1,0,0,1&#125;, &#123;1,0,1,1,1,0,0,0,0,1&#125;, &#123;1,0,0,0,1,0,0,0,0,1&#125;, &#123;1,0,1,0,0,0,1,0,0,1&#125;, &#123;1,0,1,1,1,0,1,1,0,1&#125;, &#123;1,1,0,0,0,0,0,0,0,1&#125;, &#123;1,1,1,1,1,1,1,1,1,1&#125; &#125;;struct Box&#123; int i; int j; int pre;//记录上一路口的前导值,所谓前导值，就是可走路口在队列中的位置&#125;;struct Type&#123; struct Box data[MAXSIZE]; int front,rear;&#125;;bool findRoad(int m,int n,int it,int yt);int main()&#123; if(findRoad(1,1,8,8)==false) printf(&quot;failed\\n&quot;); return 0;&#125;bool findRoad(int m,int n,int it,int yt)&#123; int i,j; Box e; struct Type *queue; queue=(struct Type *)malloc(LEN); e.i=m;e.j=n;e.pre=-1; queue-&gt;front=queue-&gt;rear=-1; queue-&gt;rear++; queue-&gt;data[queue-&gt;rear]=e; mg[e.i][e.j]=-1; while(queue-&gt;rear!=queue-&gt;front)&#123; queue-&gt;front++; e=queue-&gt;data[queue-&gt;front]; i=e.i;j=e.j; if(i==it&amp;&amp;j==yt)&#123; int temp=queue-&gt;front; int num=0; while(temp!=0)&#123; num=queue-&gt;data[temp].pre; queue-&gt;data[temp].pre=-1; temp=num; &#125; temp=0; int count=1; while(temp&lt;=queue-&gt;rear)&#123; if(queue-&gt;data[temp].pre==-1)&#123; printf(&quot;(%d,%d)&quot;,queue-&gt;data[temp].i,queue-&gt;data[temp].j); if(count%5==0) printf(&quot;\\n&quot;); count++; &#125; temp++; &#125; return true; &#125; int x,y; int k=0; while(k&lt;4)&#123; switch(k)&#123; case 0: x=i-1;y=j;break; case 1: x=i;y=j+1;break; case 2: x=i+1;y=j;break; case 3: x=i;y=j-1;break; &#125; k++; if(mg[x][y]==0)&#123; /*只要该路口可走，就将其进队 *并且记录上一路口的前导值 */ queue-&gt;rear++; e.i=x;e.j=y;e.pre=queue-&gt;front; queue-&gt;data[queue-&gt;rear]=e; mg[i][j]=-1; &#125; &#125; &#125; return false;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"http://yoursite.com/tags/c-c/"}]},{"title":"统计磁盘文件数量（c#实现）","slug":"C#/统计磁盘文件数","date":"2018-09-11T15:34:59.406Z","updated":"2018-09-29T08:25:22.785Z","comments":true,"path":"2018/09/11/C#/统计磁盘文件数/","link":"","permalink":"http://yoursite.com/2018/09/11/C#/统计磁盘文件数/","excerpt":"一、想法想到能不能写一个小程序用来统计磁盘中有多少个文件呢？虽然系统可以统计出来，但如果自己也可以写出来会不会更舒服，而且这也可以作为c#实践的练手玩具啊啊啊啊？想到了就去做？让我造个轮子出来吧，orz。","text":"一、想法想到能不能写一个小程序用来统计磁盘中有多少个文件呢？虽然系统可以统计出来，但如果自己也可以写出来会不会更舒服，而且这也可以作为c#实践的练手玩具啊啊啊啊？想到了就去做？让我造个轮子出来吧，orz。 二、原理编译环境：Visual Studio 2017页面控件： Button、Label、TextBox、ListBox应用项目：.NET Framework 解决方案：1、首先识别磁盘第一层（就是点开磁盘后所显示的）中有多少文件夹2、然后从上往下从第一个文件夹（记为文件夹A）开始识别，若文件夹A中还有若干个子文件夹，则又从第一个子文件夹开始识别3、接2，直到文件夹里没有其他子文件夹了，则开始统计文件的数量 4、接3，统计完当前文件夹里的文件后，返回上一层，也就是与当前文件夹处于同一层。这就是递归处理了，以前写过，递归算法不要深究，逻辑对递归一定对。注意事项：在用到GetDirectories方法时，要在命名空间添加1using System.IO; 使用截图: 三、实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657using System;using System.Collections.Generic;using System.ComponentModel;using System.Data;using System.Drawing;using System.Linq;using System.Text;using System.Threading.Tasks;using System.IO;using System.Windows.Forms;namespace 小轮子之统计文件数&#123; public partial class Form1 : Form &#123; public Form1() &#123; InitializeComponent(); &#125; private void PathName_TextChanged(object sender, EventArgs e) &#123; /*吃好睡好身体好*/ &#125; private void button1_Click(object sender, EventArgs e) &#123; MessageBox.Show(&quot;统计中，请耐心等待...&quot;); string str = PathName.Text.ToString(); long count = GetFiles(str); MessageBox.Show(count.ToString(), &quot;共有文件数&quot;); &#125; static long GetFiles(string path) &#123; long count = 0L; try &#123; var files = Directory.GetFiles(path); count += files.Length; var dirs = Directory.GetDirectories(path); foreach (var dir in dirs) &#123; count += GetFiles(dir);//递归实现深度查找 &#125; &#125; catch (Exception e) &#123; /* 欲渡黄河冰塞川 * 将登太行雪满山 * 闲来垂钓碧溪上 * 忽复乘舟梦日边 */ &#125; return count; &#125; &#125;&#125;","categories":[{"name":"c#","slug":"c","permalink":"http://yoursite.com/categories/c/"}],"tags":[{"name":"小轮子","slug":"小轮子","permalink":"http://yoursite.com/tags/小轮子/"}]},{"title":"c#中try catch finally用法","slug":"C#/C#中try catch finally用法","date":"2018-09-09T15:19:35.884Z","updated":"2018-09-29T08:25:03.781Z","comments":true,"path":"2018/09/09/C#/C#中try catch finally用法/","link":"","permalink":"http://yoursite.com/2018/09/09/C#/C#中try catch finally用法/","excerpt":"一、处理机制1、基本语法123456789101112try&#123; //语句&#125;catch&#123; //语句&#125;finally&#123; //语句&#125;","text":"一、处理机制1、基本语法123456789101112try&#123; //语句&#125;catch&#123; //语句&#125;finally&#123; //语句&#125; try：将可能产生异常的代码块放到try中，这一语句在整个异常处理中不可缺少catch：如果try中的代码出现了异常，则在这一块中需给出异常处理程序，提示使用者出现了怎样的问题。这一语句与下面的finally语句两者必须有一个，可以都有，若两者都有，finally语句在最后。当然这一语句可以有多条，用以处理不同的代码异常。这里还要指出的是catch语句抓取异常分为三种形式。 1、catch{…..代码…..} 一般形式，这样的子句将抓取任何try中出现的异常2、catch(Exception){…..代码…..} 特定形式，这样的子句抓取try中与Exception匹配的异常3、catch(Exception e){…..代码…..} 带对象的特定形式，其中e为异常变量，在这里可以该异常变量并获得与其相关得信息 如123456catch (Exception e)&#123; Console.WriteLine(&quot;Message:&#123;0&#125;&quot;, e.Message); Console.WriteLine(&quot;Source:&#123;0&#125;&quot;, e.Source); Console.WriteLine(&quot;Stack:&#123;0&#125;&quot;, e.StackTrace);&#125; finally：这一语句如果出现，则不管try语句中是否出现异常，finally包涵的代码都要执行，在这里特别要说明得是即使try语块中有return语句，finally块中得语句也要先执行完然后才能执行return语句。如：123456789101112131415try&#123; var number = 5; if (number &lt;= 10) &#123; Console.WriteLine(&quot;天生我材必有用&quot;); return; &#125; else Console.WriteLine(&quot;人生得意须尽欢&quot;);&#125;finally&#123; Console.WriteLine(&quot;千金散尽还复来&quot;);&#125; 2、异常代码示例我们都知道，被除数不能为0。那么要一个数除以0会发生什么情况呢？如没有异常处理机制，程序会直接中断，俗称的程序崩了或者说“闪退”？但如有，就不会发生这种情况了，程序会提示使用者哪里哪里出现了什么什么问题，提示之后程序继续运行。无处理机制：12345678910111213namespace 验证try_catch&#123; class Program &#123; static void Main(string[] args) &#123; var number1 = 10; var number2 = 0; number1 /= number2; //程序运行到这里会报错 Console.WriteLine(number1); &#125; &#125; &#125; 有处理机制：1234567891011121314151617181920namespace 验证try_catch&#123; class Program &#123; static void Main(string[] args) &#123; try &#123; var number1 = 10; var number2 = 0; number1 /= number2;//抛出异常 Console.WriteLine(number1); &#125; catch //抓住异常 &#123; Console.WriteLine(&quot;There has an error --Keep on running!&quot;); &#125; &#125; &#125;&#125; 3、小结12345678910111213141516try&#123; //可能出现异常得代码放入其中&#125;catch&#123; //抓取异常并提示信息&#125;catch&#123; //可以有多个catch语块用来抓取不同得异常&#125;finally&#123; //只要有该语块则一定要执行且在&#125; 二、解读try catch程序123456789101112131415161718192021222324252627282930313233343536373839404142using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace 验证try_catch&#123; class Program &#123; private static void PrintString(string str) &#123; if (str == null) throw new ArgumentException();//抛出异常 &#125; static void Main(string[] args) &#123; string str = null; try &#123; PrintString(str); &#125; catch (ArgumentException e) &#123; /*抓住来自PrintString函数抛来的异常 e为异常变量，通过打印与之相关得信息我们可以知道程序出现了什么问题 */ Console.WriteLine(&quot;Message:&#123;0&#125;&quot;,e.Message); &#125; catch(Exception) &#123; Console.WriteLine(&quot;今朝有酒今朝醉&quot;); &#125; finally &#123; Console.WriteLine(&quot;知我者谓我心忧，不知我者谓我何求&quot;); &#125; Console.ReadLine(); &#125; &#125;&#125;","categories":[{"name":"c#","slug":"c","permalink":"http://yoursite.com/categories/c/"}],"tags":[{"name":"编程实验","slug":"编程实验","permalink":"http://yoursite.com/tags/编程实验/"}]},{"title":"语言熟练之计算器（c#实现）","slug":"C#/语言熟练之计算器","date":"2018-09-08T12:59:18.479Z","updated":"2018-09-29T08:25:56.817Z","comments":true,"path":"2018/09/08/C#/语言熟练之计算器/","link":"","permalink":"http://yoursite.com/2018/09/08/C#/语言熟练之计算器/","excerpt":"一、大致介绍本次的编程实验是为了更进一步熟练c#语言，现写下实验过程。 1、工具选用这个计算器可以解决int64位内的+、-、*、/运算。在设计实验时，选用的是.NET Framework，页面控件选择了 Button、Label、TextBox。编译环境：Visual Studio 2017","text":"一、大致介绍本次的编程实验是为了更进一步熟练c#语言，现写下实验过程。 1、工具选用这个计算器可以解决int64位内的+、-、*、/运算。在设计实验时，选用的是.NET Framework，页面控件选择了 Button、Label、TextBox。编译环境：Visual Studio 2017 2、处理异常在测试数据的时候，我发现不输入数据直接点击运算符号时，会出现异常，所以在这里步，用到了try{}catch{}语句，也算是知道如何抓取异常。（之后会专门写下try{}catch{}的使用方法） 3、运行截图 二、代码训练123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100using System;using System.Collections.Generic;using System.ComponentModel;using System.Data;using System.Drawing;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Windows.Forms;namespace 计算器&#123; public partial class Form1 : Form &#123; public Form1() &#123; InitializeComponent(); &#125; private void label1_Click(object sender, EventArgs e) &#123; /* 人生得意须尽欢 */ &#125; /* 莫使金樽空对月 */ private void number1_TextChanged(object sender, EventArgs e) &#123; /* 天生我材必有用 千金散尽还复来 */ &#125; private void button1_Click(object sender, EventArgs e) //处理加法运算 &#123; try &#123; double value1 = double.Parse(number1.Text); double value2 = double.Parse(number2.Text); string result = (value1 + value2).ToString(); MessageBox.Show(result); &#125; catch &#123; MessageBox.Show(&quot;傻嗨，把两个数都输完(￣▽￣)&quot;); &#125; &#125; private void button2_Click(object sender, EventArgs e)//处理减法运算 &#123; try &#123; double value1 = double.Parse(number1.Text); double value2 = double.Parse(number2.Text); string result = (value1 - value2).ToString(); MessageBox.Show(result); &#125; catch &#123; MessageBox.Show(&quot;傻嗨，把两个数都输完(￣▽￣)&quot;); &#125; &#125; private void button3_Click(object sender, EventArgs e)//处理乘法运算 &#123; try &#123; double value1 = double.Parse(number1.Text); double value2 = double.Parse(number2.Text); string result = (value1 * value2).ToString(); MessageBox.Show(result); &#125; catch &#123; MessageBox.Show(&quot;傻嗨，把两个数都输完(￣▽￣)&quot;); &#125; &#125; private void button4_Click(object sender, EventArgs e)//处理除法运算 &#123; try &#123; double value1 = double.Parse(number1.Text); double value2 = double.Parse(number2.Text); string result = (value1 / value2).ToString(); MessageBox.Show(result); &#125; catch &#123; MessageBox.Show(&quot;傻嗨，把两个数都输完(￣▽￣)&quot;); &#125; &#125; &#125;&#125; 三、总结完成这个简单计算器后，我将其跟手机上的计算器做了对比。当然运算功能上没有可比性，只是在页面设计上，我觉得还有改进的地方。比如输入框输入的不是数字时抛出的异常却是把两个数字输完，这个bug我还没有改过来。其实我觉得在键入非数字的符号时，程序可以提示使用者键入了非数字。然涉及到知识盲区了，囧rz。如有更好的想法，欢迎在评论区留言，一起找bug，改bug。人生多少欢乐事，尽在debug中。","categories":[{"name":"c#","slug":"c","permalink":"http://yoursite.com/categories/c/"}],"tags":[{"name":"小轮子","slug":"小轮子","permalink":"http://yoursite.com/tags/小轮子/"}]},{"title":"验证回文字符串（c#实现）","slug":"C#/验证回文字符串","date":"2018-09-07T04:34:18.465Z","updated":"2018-09-29T08:25:37.014Z","comments":true,"path":"2018/09/07/C#/验证回文字符串/","link":"","permalink":"http://yoursite.com/2018/09/07/C#/验证回文字符串/","excerpt":"最近在学习c#语言，为提高c#熟练度，特意到leetcode上写题，现写下代码 回文字符串概念：一个字符串从左往右数和从右往左数是一样的。","text":"最近在学习c#语言，为提高c#熟练度，特意到leetcode上写题，现写下代码 回文字符串概念：一个字符串从左往右数和从右往左数是一样的。 12345678910111213141516171819202122232425262728293031using System;namespace 验证回文字符串__leetcode&#123; class Program &#123; static void Main(string[] args) &#123; string s = &quot;A man, a plan, a canal: Panama&quot;; bool result = IsPalindrome(s); Console.WriteLine(result); Console.ReadLine(); &#125; public static bool IsPalindrome(string s) &#123; string s1 = &quot;&quot;; s = s.ToUpper(); for (int i = 0; i &lt; s.Length; i++) &#123; if ((s[i] &gt;= &apos;A&apos; &amp;&amp; s[i] &lt;= &apos;Z&apos;) || (s[i] &gt;= &apos;0&apos; &amp;&amp; s[i] &lt;= &apos;9&apos;)) s1 += s[i]; &#125; Console.WriteLine(s1); char[] arr = s1.ToCharArray(); Array.Reverse(arr); string str = new string(arr); return str == s1; &#125; &#125;&#125;","categories":[{"name":"c#","slug":"c","permalink":"http://yoursite.com/categories/c/"}],"tags":[{"name":"基础算法","slug":"基础算法","permalink":"http://yoursite.com/tags/基础算法/"}]},{"title":"NYOJ63 小猴子下落（二叉树）","slug":"数据结构/NYOJ63小猴子下落","date":"2018-08-14T12:06:28.320Z","updated":"2018-09-29T08:18:57.277Z","comments":true,"path":"2018/08/14/数据结构/NYOJ63小猴子下落/","link":"","permalink":"http://yoursite.com/2018/08/14/数据结构/NYOJ63小猴子下落/","excerpt":"一、题目描述小猴子下落时间限制：3000 ms | 内存限制：65535 KB难度：3描述 有一颗二叉树，最大深度为D,且所有叶子的深度都相同。所有结点从左到右从上到下的编号为1,2,3，·····，2的D次方减1。在结点1处放一个小猴子，它会往下跑。每个内结点上都有一个开关，初始全部关闭，当每次有小猴子跑到一个开关上时，它的状态都会改变，当到达一个内结点时，如果开关关闭，小猴子往左走，否则往右走，直到走到叶子结点。一些小猴子从结点1处开始往下跑，最后一个小猴儿会跑到哪里呢？","text":"一、题目描述小猴子下落时间限制：3000 ms | 内存限制：65535 KB难度：3描述 有一颗二叉树，最大深度为D,且所有叶子的深度都相同。所有结点从左到右从上到下的编号为1,2,3，·····，2的D次方减1。在结点1处放一个小猴子，它会往下跑。每个内结点上都有一个开关，初始全部关闭，当每次有小猴子跑到一个开关上时，它的状态都会改变，当到达一个内结点时，如果开关关闭，小猴子往左走，否则往右走，直到走到叶子结点。一些小猴子从结点1处开始往下跑，最后一个小猴儿会跑到哪里呢？输入输入二叉树叶子的深度D,和小猴子数目I，假设I不超过整棵树的叶子个数，D&lt;=20.最终以 0 0 结尾 输出 输出第I个小猴子所在的叶子编号。 样例输入1234 23 40 0 样例输出12127 来源[张洁烽]原创上传者张洁烽 二、题解思路如下 1、首先可以明确当节点值为0时，往左走，然后节点值变为1，反之往右走，节点值变为0；2、定义一个大数组用来存放节点状态值，将数组看成满二叉树存储值的状态；3、左节点的序号为上一节点的2倍，右节点的序号为上一节点的2倍加1。 123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;memory.h&gt;#define MAXSIZE 40000+10int flag[MAXSIZE]=&#123;0&#125;; int main()&#123; int N,M; while(scanf(&quot;%d%d&quot;,&amp;N,&amp;M)!=EOF)&#123; memset(flag,0,MAXSIZE); if(N==0&amp;&amp;M==0) break; int temp=1; for(int i=1;i&lt;=M;i++)&#123; int depth=1; temp=1; while(depth&lt;N)&#123; if(flag[temp]==0)&#123; flag[temp]=1; temp=temp*2; &#125;else&#123; flag[temp]=0; temp=temp*2+1; &#125; depth++; &#125; &#125; printf(&quot;%d\\n&quot;,temp); &#125; return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"基础算法","slug":"基础算法","permalink":"http://yoursite.com/tags/基础算法/"}]},{"title":"hexo小配置","slug":"一些小技巧/hexo小配置","date":"2018-08-10T12:00:32.068Z","updated":"2018-09-29T08:24:43.615Z","comments":true,"path":"2018/08/10/一些小技巧/hexo小配置/","link":"","permalink":"http://yoursite.com/2018/08/10/一些小技巧/hexo小配置/","excerpt":"一、hexo部署本地图片把图片在hexo/blog/public/css/images目录下，其中(hexo/blog)是你博客所在文件夹。使用/css/images/at.png的方式进行链接。","text":"一、hexo部署本地图片把图片在hexo/blog/public/css/images目录下，其中(hexo/blog)是你博客所在文件夹。使用/css/images/at.png的方式进行链接。 二、在首页只显示摘要信息12345这里写文章的简介&lt;!-- more --&gt;这里写文章的正文 三、在首页显示图片123456---title: hexo小配置categories: hexotags: 小技巧photo: https://hexo.io/logo.svg //写上这一行，注意“photo:”有一个空格，“photo: ”后面就写上图片的地址--- 四、新建“about”页面1、在git Bash命令行界面输入1hexo new page &quot;about&quot; 2、在主题配置文件中将menu中about的注释去掉文件路径：themes/hiero/config（hiero是你主题的名称123456menu: Home: / Archives: /archives Categories: /categories Tags: /tags About: /about 上面代码为已经去掉注释后的这里就可以拓展一下，比如分类、标签页面等等。分类：123456---title: categoriesdate: 2018-09-09 23:48:07layout: &quot;categories&quot;--- 标签：12345---title: tagsdate: 2018-09-09 23:47:25layout: &quot;tags&quot;--- 未完待续……","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"http://yoursite.com/tags/小技巧/"}]},{"title":"二叉树的创建及其遍历","slug":"数据结构/二叉树的创建及其遍历","date":"2018-08-09T15:37:26.625Z","updated":"2018-09-29T08:22:19.352Z","comments":true,"path":"2018/08/09/数据结构/二叉树的创建及其遍历/","link":"","permalink":"http://yoursite.com/2018/08/09/数据结构/二叉树的创建及其遍历/","excerpt":"二叉树是一种非常重要的数据结构，许多其他的数据结构都是基于二叉树发展推演过来的。用递归定义树的结构非常简洁，同样，递归遍历也非常简洁。在学习过程中，我发现递归算法往往只是一个简单的语句，","text":"二叉树是一种非常重要的数据结构，许多其他的数据结构都是基于二叉树发展推演过来的。用递归定义树的结构非常简洁，同样，递归遍历也非常简洁。在学习过程中，我发现递归算法往往只是一个简单的语句，虽然简洁的语句实现了功能，但在算法具体过程方面没有很好的阐述，我也很纠结为什么可以这么用，一次次调式试图弄明白内在机理，总是达不到预期效果，所以我转而写非递归的算法以此希望能够理解树的节点的构造、遍历。在这里，我写下这些天学习二叉树的历程。 一、树的创建利用递归创建二叉树。123456789101112131415struct Btree *inputTree()//创建二叉树 &#123; int number; struct Btree *tree; scanf(&quot;%d&quot;,&amp;number); if(number==0)&#123; //当输入0时，表示左孩子或右孩子为空 tree=NULL; &#125;else&#123; tree=(struct Btree *)malloc(LEN); tree-&gt;data=number; tree-&gt;lchild=inputTree(); //递归左孩子 tree-&gt;rchild=inputTree(); //递归右孩子 &#125; return tree;&#125; 二、三种遍历递归实现1、先序遍历递归算法规则：先根节点，再左子树，后右子树，简记NLR。具体，可将整棵树分为左子树和右子树，然后再将左子树分为次左子树、次右子树123456789void preTraversal(struct Btree *tree)&#123; if(tree!=NULL)&#123; printf(&quot;%d &quot;,tree-&gt;data); //打印根节点 preTraversal(tree-&gt;lchild); //遍历左孩子树 preTraversal(tree-&gt;rchild); //遍历右孩子树 &#125; return;&#125; 2、中序遍历递归算法规则：先左子树，再根节点，后右子树，简记LNR。具体同先序。123456789void inTraversal(struct Btree *tree)&#123; if(tree!=NULL)&#123; preTraversal(tree-&gt;lchild); //遍历左孩子树 printf(&quot;%d&quot;,tree-&gt;data); //打印根节点 preTraversal(tree-&gt;rchild); //遍历右孩子树 &#125; return;&#125; 3、后序遍历递归算法规则：先左子树，再右子树，后根节点，简记LRN。具体同先序。12345678void postTraversal(struct Btree *tree)&#123; if(tree!=NULL)&#123; postTraversal(tree-&gt;lchild); //遍历左孩子树 postTraversal(tree-&gt;rchild); //遍历右孩子树 printf(&quot;%d &quot;,tree-&gt;data); //打印根节点 &#125;&#125; 三、三种遍历非递归实现1、先序遍历非递归算法算法主要步骤：1、当树不为空时，将根节点压入栈中；2、当栈不为空时，说明需要此时访问当前节点，退栈访问；3、查看该节点的右孩子(这里先查看右孩子是因为这是先序遍历，先遍历根节点其次左孩子最后右孩子，这里用到栈也是因为栈的特点，先进后出，后进先出)，若右孩子存在，则压入栈中；4、查看该节点的左孩子，同3；5、若栈不为空，转2，循环。12345678910111213141516171819202122232425void preTraversal(struct Btree *tree)&#123; struct Btree *stack[MAXSIZE]; struct Btree *temp; int top=-1; if(tree!=NULL)&#123; top++; stack[top]=tree; //将根节点进栈 while(top!=-1)&#123; temp=stack[top]; top--; printf(&quot;%d &quot;,temp-&gt;data); if(temp-&gt;rchild!=NULL)&#123; //右孩子不为空，进栈 top++; stack[top]=temp-&gt;rchild; &#125; if(temp-&gt;lchild!=NULL)&#123; //左孩子不为空，进栈 top++; stack[top]=temp-&gt;lchild; &#125; &#125; &#125; printf(&quot;\\n&quot;); return;&#125; 2、中序遍历非递归算法算法主要步骤：1、首先查看根节点，若根节点不为空，将其进栈；2、查看根节点的左孩子，若左孩子存在，将其进栈，继续访问以左孩子为根节点的次树；3、 若次树无左孩子，访问当前次树的根节点，然后查看该根节点的右孩子；4、循环。12345678910111213141516171819202122void inTraversal(struct Btree *tree)&#123; struct Btree *stack[MAXSIZE],*temp; int top=-1; if(tree!=NULL)&#123; temp=tree; while(top&gt;-1||temp!=NULL)&#123; if(temp!=NULL)&#123; top++; stack[top]=temp; temp=temp-&gt;lchild; &#125;else&#123; //此时说明当前次树已无左孩子，则访问该节点 temp=stack[top]; top--; printf(&quot;%d &quot;,temp-&gt;data); temp=temp-&gt;rchild; //查看该节点的右孩子 &#125; &#125; &#125; printf(&quot;\\n&quot;); return; &#125; 3、后序遍历非递归算法算法主要步骤：1、首先将根节点进栈，若栈不为空，循环；2、查看栈顶元素，若其有左孩子或右孩子并且左右孩子没有被访问，将其左孩子或右孩子入栈，否则，访问该节点；3、 在2步骤中，若访问完一节点，则用pre指针记录下来 。1234567891011121314151617181920212223242526void postTraversal(struct Btree *tree)&#123; struct Btree *stack[MAXSIZE],*temp,*pre=NULL; int top=-1; top++; stack[top]=tree; while(top!=-1)&#123; temp=stack[top]; if((temp-&gt;lchild==NULL&amp;&amp;temp-&gt;rchild==NULL)||\\ (pre!=NULL&amp;&amp;(temp-&gt;lchild==pre||temp-&gt;rchild==pre)))&#123; printf(&quot;%d &quot;,temp-&gt;data);//到此表明该节点无左右孩子 top--; //或者有左右孩子但已被访问输出，访问该节点 pre=temp; //pre指针用来记录上一访问过的节点 &#125;else&#123; if(temp-&gt;rchild!=NULL)&#123; //若右孩子存在，将其入栈 top++; stack[top]=temp-&gt;rchild; &#125; if(temp-&gt;lchild!=NULL)&#123; //若左孩子存在，将其入栈 top++; stack[top]=temp-&gt;lchild; &#125; &#125; &#125; printf(&quot;\\n&quot;); &#125; 四、源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define LEN sizeof(struct Btree)#define MAXSIZE 1000+10struct Btree&#123; int data; struct Btree *lchild,*rchild;&#125;;void preTraversal(struct Btree *tree);void inTraversal(struct Btree *tree);void postTraversal(struct Btree *tree);struct Btree *inputTree();int main()&#123; struct Btree *tree; tree=inputTree(); printf(&quot;先序遍历:\\n&quot;); preTraversal(tree); printf(&quot;中序遍历:\\n&quot;); inTraversal(tree); printf(&quot;后序遍历:\\n&quot;); postTraversal(tree); return 0;&#125;struct Btree *inputTree()//创建二叉树 &#123; int number; struct Btree *tree; scanf(&quot;%d&quot;,&amp;number); if(number==0)&#123; //当输入0时，表示左孩子或右孩子 为空 tree=NULL; &#125;else&#123; tree=(struct Btree *)malloc(LEN); tree-&gt;data=number; tree-&gt;lchild=inputTree(); //递归左孩子 tree-&gt;rchild=inputTree(); //递归右孩子 &#125; return tree;&#125;void preTraversal(struct Btree *tree)//先序递归&#123; if(tree!=NULL)&#123; printf(&quot;%d &quot;,tree-&gt;data); //打印根节点 preTraversal(tree-&gt;lchild); //遍历左孩子树 preTraversal(tree-&gt;rchild); //遍历右孩子树 &#125; return;&#125;void preTraversal(struct Btree *tree)//先序非递归&#123; struct Btree *stack[MAXSIZE]; struct Btree *temp; int top=-1; if(tree!=NULL)&#123; top++; stack[top]=tree; //将根节点进栈 while(top!=-1)&#123; temp=stack[top]; top--; printf(&quot;%d &quot;,temp-&gt;data); if(temp-&gt;rchild!=NULL)&#123; //右孩子不为空，进栈 top++; stack[top]=temp-&gt;rchild; &#125; if(temp-&gt;lchild!=NULL)&#123; //左孩子不为空，进栈 top++; stack[top]=temp-&gt;lchild; &#125; &#125; &#125; printf(&quot;\\n&quot;); return; &#125;void inTraversal(struct Btree *tree)//中序递归&#123; if(tree!=NULL)&#123; preTraversal(tree-&gt;lchild); //遍历左孩子树 printf(&quot;%d&quot;,tree-&gt;data); //打印根节点 preTraversal(tree-&gt;rchild); //遍历右孩子树 &#125; return;&#125;void inTraversal(struct Btree *tree)//中序非递归&#123; struct Btree *stack[MAXSIZE],*temp; int top=-1; if(tree!=NULL)&#123; temp=tree; while(top&gt;-1||temp!=NULL)&#123; if(temp!=NULL)&#123; top++; stack[top]=temp; temp=temp-&gt;lchild; &#125;else&#123; //此时说明当前次树已无左孩子，则访问该节点 temp=stack[top]; top--; printf(&quot;%d &quot;,temp-&gt;data); temp=temp-&gt;rchild; //查看该节点的右孩子 &#125; &#125; &#125; printf(&quot;\\n&quot;); return; &#125; void postTraversal(struct Btree *tree)//后序递归&#123; if(tree!=NULL)&#123; postTraversal(tree-&gt;lchild); //遍历左孩子树 postTraversal(tree-&gt;rchild); //遍历右孩子树 printf(&quot;%d &quot;,tree-&gt;data); //打印根节点 &#125; return;&#125;void postTraversal(struct Btree *tree)&#123; struct Btree *stack[MAXSIZE],*temp,*pre=NULL; int top=-1; top++; stack[top]=tree; while(top!=-1)&#123; temp=stack[top]; if((temp-&gt;lchild==NULL&amp;&amp;temp-&gt;rchild==NULL)||\\ (pre!=NULL&amp;&amp;(temp-&gt;lchild==pre||temp-&gt;rchild==pre)))&#123; printf(&quot;%d &quot;,temp-&gt;data);//到此表明该节点无左右孩子 top--; //或者有左右孩子但已被访问输出，访问该节点 pre=temp;//pre指针用来记录上一访问过的节点 &#125;else&#123; if(temp-&gt;rchild!=NULL)&#123;//若右孩子存在，将其入栈 top++; stack[top]=temp-&gt;rchild; &#125; if(temp-&gt;lchild!=NULL)&#123;//若左孩子存在，将其入栈 top++; stack[top]=temp-&gt;lchild; &#125; &#125; &#125; printf(&quot;\\n&quot;); return;&#125; 五、后记在用递归遍历二叉树时，总想搞明白递归遍历的过程是怎么样的，但每次都以头昏脑涨结尾。说实话，递归说它难，也就那样，说它简单，但……总之，用递归求解时，不要深究细节，逻辑对，递归一定对。最后若有什么想法，欢迎在评论区留言。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"http://yoursite.com/tags/c-c/"}]},{"title":"I am coming","slug":"随笔杂想/hello-world","date":"2018-08-02T01:30:58.139Z","updated":"2018-09-29T08:24:24.866Z","comments":true,"path":"2018/08/02/随笔杂想/hello-world/","link":"","permalink":"http://yoursite.com/2018/08/02/随笔杂想/hello-world/","excerpt":"ONE 将学习and工作中遇到的问题记录下来，小白成长为大佬，若干年后，相必值得回味。","text":"ONE 将学习and工作中遇到的问题记录下来，小白成长为大佬，若干年后，相必值得回味。这是我的第一篇博客。想写博客，但会不会变成为了写博客而写博客呢，不知道。认真地想，以往遇到问题，求助知乎、csdn、博客园，大部分问题都能得到很好的解决，感慨众多大神and大佬的无私分享，遂生出想法，记录问题，待知识丰富后，再来看看这些，希望能够得到些许乐趣吧。 ——GageShan 于2018.08.02 夜","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}],"tags":[]}]}