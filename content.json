{"meta":{"title":"GageShan","subtitle":null,"description":"一点想法，一点思考，一点记录","author":"学号021","url":"https://shann.xyz","root":"/"},"pages":[{"title":"about","date":"2018-08-14T12:45:56.000Z","updated":"2020-02-27T18:39:22.712Z","comments":true,"path":"about/index.html","permalink":"https://shann.xyz/about/index.html","excerpt":"","text":"关于站点本站创建于2018年7月30号，期间陆陆续续折腾着8月2号左右开始更新。用以记录成长学习过程中遇到的问题。 关于博主一个希望自己能有所成就的人。 劝勉自己以前不知道喜欢什么所以来到这里现在明白了想要什么未来会去哪里 ——SGZ"},{"title":"categories","date":"2018-09-29T06:24:08.000Z","updated":"2018-09-29T12:01:32.000Z","comments":false,"path":"categories/index.html","permalink":"https://shann.xyz/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2018-09-12T14:50:58.000Z","updated":"2019-11-15T08:38:40.397Z","comments":true,"path":"friends/index.html","permalink":"https://shann.xyz/friends/index.html","excerpt":"","text":"name address Z-坤-K Z-坤-K 凯凯同学 凯凯同学 阿朱 阿朱 另一个阿朱 另一个阿朱 Matthew’s Track Matthew’s Track Hank’s home Hank’s home 禹都一只猫 禹都一只猫 Collation&amp;Seek Group Collation&amp;Seek Group 蔚然博客 蔚然博客 一木博客 一木博客 乱码博客 乱码博客"},{"title":"tags","date":"2018-09-29T06:23:42.000Z","updated":"2018-09-29T11:59:54.000Z","comments":false,"path":"tags/index.html","permalink":"https://shann.xyz/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Redis持久化方式","slug":"redis/redis持久化方式（rdb-aof）","date":"2021-05-04T14:56:28.633Z","updated":"2021-05-04T15:09:04.812Z","comments":true,"path":"2021/05/04/redis/redis持久化方式（rdb-aof）/","link":"","permalink":"https://shann.xyz/2021/05/04/redis/redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F%EF%BC%88rdb-aof%EF%BC%89/","excerpt":"","text":"[TOC]redis持久化分为rdb和aof，rdb是将整个数据库保存为二进制文件，aof则是记录命令的方式保存。 一、rdbrdb持久化功能所生成的rdb文件是一个经过压缩的二进制文件。在载入rdb文件过程中，redis服务器一直处于阻塞状态，直到载入完毕。 创建rdb文件的两种方式有两个命令可以用来保存rdb文件，save和bgsave。不同的是，save命令会阻塞redis服务器进程，直到rdb文件创建完成，在此期间不再处理redis命令。而bgsave则是fork父进程，由子进程负责rdb文件的创建，在子进程创建rdb文件过程中，redis服务器任然会处理redis命令。 1、save、bgsave、bgrewriteaof1、为了避免产生竞争条件，在bgsave命令执行期间，redis服务器会拒绝save和bgsave命令2、在bgsave命令执行过程中，客户端发送的bgrewriteaof命令会被延后到bgsave命令执行完3、在bgrewriteaof命令执行过程中，客户端发送的bgsave命令会被拒绝 2、自动间隔性保存用户可以通过设置服务器配置的save选项，让服务器每隔一段时间自动执行一次bgsave。123save 900 1 900秒内数据库至少修改1次save 300 10 300秒内数据库至少修改10次save 60 1000 60秒内数据库至少修改1000次redis服务器使用saveparams数组来保存这些信息1234struct saveparam &#123; time_t seconds;//秒数 int changes;//修改数&#125;123struct redisServer &#123; struct saveparam *saveprames;//记录保存条件的数组&#125; 3、dirty、lastsave属性redis服务器维护了一个dirty计数器和lastsave属性。 dirty表示自上次执行save或者bgsave命令后服务器对数据库进行了多少次更新操作（包括增加，修改，删除） lastsave是一个unix时间戳，记录服务器上一次执行save或者bgsave命令1234struct redisServer &#123; long long dirty;&#x2F;&#x2F;计数器 time_t lastsave;&#x2F;&#x2F;上一次执行保存的时间&#125; redis服务器周期性操作函数serverCron默认每隔100毫秒就会执行一次，这个函数就会检查save选项配置是否已经满足，如果满足就执行bgsave命令。二、aofaof持久化是通过保存redis服务器执行的命令来实现持久化功能的。 1、aof持久化实现1、命令追加redis服务器在执行完一个命令后，会以协议格式将被执行的命令追加到服务器状态的aof_buf缓冲区末尾。123struct redisServer &#123; sds aof_buf;//aof缓冲区&#125; 2、aof文件的写入和同步redis服务器实际上就是一个事件循环，这个循环中的文件事件会处理客户端的命令请求；时间事件则处理如serverCron函数这样需要定时运行的函数。服务器在每次结束一个事件循环之前，都会调用flushAppendOnlyFile函数，考虑是否将aof_buf缓冲区中的内容写入和保存到aof文件里面。 1、always服务器在每个事件循环都要将aof_buf中的内容写入并且同步到aof文件中，always是三个选项中效率最慢的，但即使出现故障停机，aof持久化也只会丢失一个事件循环中的命令数据 2、everysec服务器在每个数据循环都要将aof_buf中的内容写入aof文件，并且每个一秒就要在子线程中对aof文件进行同步。everysec效率足够快，如果出现故障停机只会丢失一秒钟信息。 3、no服务器在每个事件循环中都要对aof_buf中的内容写入到aof文件中，至于何时对aof文件进行同步则要看操作系统的调度。no是三者中效率最高的，但单次同步时间最长。 2、aof文件载入与数据还原redis服务器读取aof文件的顺序步骤 创建一个不带网络连接的伪客户端（因为redis命令只能在客户端上下文中执行） 从aof文件中读取一条写命令 使用伪客户端执行读取的命令 循环，直到所有的命令都被处理完毕 3、aof重写对于aof持久化来说，如果事无巨细的将全部命令保存下来，随着redis不间断运行，那势必会造成aof文件无比巨大，使得载入数据的时候会多很多无用功。为了解决aof文件体积过大的问题，redis提供了aof文件重写的功能。通过这个功能，redis会创建一个新的aof文件来代替旧的aof文件。新旧aof文件数据库状态相同，但新aof文件不会包含冗余的命令。 1、重写实现新的aof文件不会对旧的aof文件造成任何影响，新的aof文件由当前数据库状态得来。重写前1234sadd a 1sadd a 2sadd a 3srem a 1重写后1sadd a 2 3值得注意的一点是，为了避免执行命令过程中造成客户端输入缓冲区溢出，重写程序在处理列表、哈希表、集合、有序集合这些可能带有多个元素的时候，会先检查元素的数量超过了redis.h/REDIS_AOF_REWRITE_LITEMS_PER_CMD（64）常量时，会使用多条命令来代替单条命令。 2、后台重写由于aof重写程序aof_rewrite会进行大量的文件写入操作，所以调用这个函数的线程会被长时间的阻塞，redis服务器使用单线程处理命令请求，如果由服务器直接调用aof_write函数，那么在aof文件重写期间，服务器将无法处理命令请求。redis将aof重写程序放到子进程中执行，子进程获得了父进程的数据副本，避免了锁的使用。同时父进程也可以继续处理命令请求。 由于在子进程中执行aof重写程序，子进程获取到的只是父进程的数据副本，在aof重写过程中，父进程可能会处理其它的命令请求，这就会使得数据库状态与重写后的aof文件不一致。为了解决数据不一致的问题，redis服务器设置了一个aof重写缓冲区，这个缓冲区在服务器创建子进程之后才开始使用。redis服务器在执行完一个写命令后，会将这个写命令同时发送给aof缓冲区和aof重写缓冲区。 当子进程完成aof重写工作，子进程会向父进程发送一个信号，父进程接受到该信号后，会调用一个信号处理函数，这个函数会执行一下操作。 将aof重写缓冲区内容写入到新的aof文件，这是新的aof文件所保存的数据库状态与redis服务器当前数据库状态保持一致 对新的aof文件进行改名，原子覆盖现有的aof文件，完成两个文件的新旧交替。这个函数执行完毕后，父进程就会像往常一样接受命令请求。 在整个aof后台重写过程中，只有信号处理函数执行过程中才会对父进程造成阻塞，在其它时候，aof后台重写都不会阻塞父进程。aof后台重写也就是bgsavewriteaof命令。 三、aof与rdb的不同1、保存格式不同rdb文件是一个经过压缩的二进制文件，aof文件则是记录命令。 2、使用优先级aof更新频率比rdb高，当redis服务器开启了aof持久化功能，那么服务器会优先使用aof文件来还原数据库，只有在aof持久化功能关闭时，才使用rdb文件。","categories":[{"name":"Redis","slug":"Redis","permalink":"https://shann.xyz/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://shann.xyz/tags/Redis/"}]},{"title":"Spring Boot使用@Autowired注入对象为null","slug":"java/springboot使用@autowried注入对象为null","date":"2020-05-08T15:28:28.526Z","updated":"2020-06-26T16:07:54.726Z","comments":true,"path":"2020/05/08/java/springboot使用@autowried注入对象为null/","link":"","permalink":"https://shann.xyz/2020/05/08/java/springboot%E4%BD%BF%E7%94%A8@autowried%E6%B3%A8%E5%85%A5%E5%AF%B9%E8%B1%A1%E4%B8%BAnull/","excerpt":"","text":"在做项目的时候，在某类使用@Autowired注入了一个Service层的对象，但在使用的时候，却发现这个Service层实例为null值。 原因：当使用new关键字创建对象时，虽然使用了@Autowired对这个对象进行装配，但实际上Spring不会这样做。因为Spring不会对任何一个new出来的对象进行自动装配，只有当一个对象也是一个在Spring中注册过的Bean，才会获得自动装配的功能1234567891011121314151617/** * @Configuration：指明当前类是一个配置类；就是来替代之前的Spring配置文件 * * 在配置文件中用&lt;bean&gt;&lt;bean/&gt;标签添加组件 * */@Configurationpublic class MyAppConfig &#123; //将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名 @Bean public HelloService helloService02()&#123; System.out.println(&quot;配置类@Bean给容器中添加组件了...&quot;); return new HelloService(); &#125;&#125;@Configuration会告知Spring这是一个配置类，会为Spring上下文提供bean。@Bean标注的方法表明这些方法返回的对象会以bean的形式添加到Spring的应用上下文中（默认情况下，bean所对应的bean Id就是定义的方法名称）。","categories":[{"name":"Spring","slug":"Spring","permalink":"https://shann.xyz/categories/Spring/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://shann.xyz/tags/Spring-Boot/"}]},{"title":"Java Web基础（Servlet、Cookie、Session、Jsp回顾整理）","slug":"java/Java Web基础","date":"2020-02-18T13:41:10.482Z","updated":"2020-02-27T16:29:43.258Z","comments":true,"path":"2020/02/18/java/Java Web基础/","link":"","permalink":"https://shann.xyz/2020/02/18/java/Java%20Web%E5%9F%BA%E7%A1%80/","excerpt":"一、servletservlet是JavaWeb三大组件之一，属于动态资源 servlet有两种创建顺序，第一是在服务器启动时创建，第二是用户访问时创建。服务器启动时创建需要在web.xml中配置0来实现，其中，0就是创建的次序，数字越小，越先创建。","text":"一、servletservlet是JavaWeb三大组件之一，属于动态资源 servlet有两种创建顺序，第一是在服务器启动时创建，第二是用户访问时创建。服务器启动时创建需要在web.xml中配置0来实现，其中，0就是创建的次序，数字越小，越先创建。 实现 javax.servlet.Servlet 接口生命周期方法： void init(ServletConfig servletconfig) servlet被创建之后立即调用，只执行1次 void service(ServletRequest requset,ServletResponse servletresponse) 执行多次 void destory() servlet被销毁之前调用，只执行1次 特性： 单例，一个类只有一个对象。可以存在多个servlet 线程是不安全的，所以它的效率非常高 servlet由我们来写，但对象由服务器来创建，方法也由服务器来调用。 实现 javax.servlet.GenericServlet 类实现 javax.servlet.HttpServlet 类 void service(ServletRequest req, ServletResponse res) protected void service(HttpServletRequest req, HttpServletResponse resp) protected void doPut(HttpServletRequest req, HttpServletResponse resp) protected void doPost(HttpServletRequest req, HttpServletResponse resp) HttpServlet类结构介绍：在实例化HttpServlet后，先调用service(ServletRequest, ServletResponse)方法，在这个方法中将ServletRequest和ServletResponse强转为HttpServletRequest和HttpServletResponse，最后根据HttpServletRequest中的参数决定调用doPost方法还是doGet方法 注意：如果没有覆写doPost或doGet方法，当这两个方法被调用时，浏览器会出现405错误，表示不支持该种请求方式。 ServletContext一个项目中只有一个ServletContext（也叫做application），所以可以在多个servlet中利用这个对象来传递数据。 服务器为每一个应用程序创建ServletContext对象，ServletContext对象在服务器启动时创建，在服务器关闭时销毁。 获取ServletContext ServletConfig#getServletContext() GenericServlet#getServletContext() HttpSession#getServletContext() ServletContextEvent#getServletContext() 统计网页访问量小案例从ServletContext中利用getAttribute方法获取访问量count值，如果访问量值为null，说明本次访问是第一次访问，利用setAttribute方法将访问量保存下来。 123456789101112131415public class Bservlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; ServletContext servletContext = this.getServletContext(); Integer count = (Integer)servletContext.getAttribute(&quot;count&quot;); if(count == null) &#123; servletContext.setAttribute(&quot;count&quot;,1); &#125; else &#123; servletContext.setAttribute(&quot;count&quot;,count + 1); &#125; PrintWriter pw = resp.getWriter(); pw.println(&quot;&lt;h1&gt;&quot; + count + &quot;&lt;/h1&gt;&quot;); &#125;&#125; PrintWriter是向网页输出的输出流，从response中获取对象。 获取类路径资源如果在文件路径前写有‘/’，那么此时对准的文件路径起始点就是classes目录下，如果不写，那么对准的文件路径起始点就是 .class文件目录下。 两种方式： ClassLoader Class ClassLoader如果资源文件存在于src目录下，那么直接使用getResourceAsStream(“a.txt”)，就可以获取文件资源；如果资源文件存在于其它包目录下，假如存在于包web/day1_3下，那么将文件路径写全即可getResourceAsStream(“web/day1_3/a.txt”)。 代码示例： 1234567891011121314public class BServlet extends HttpServlet &#123; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; ClassLoader classLoader = this.getClass().getClassLoader(); InputStream input = classLoader.getResourceAsStream(&quot;web/day1_3/a.txt&quot;); byte[] data = new byte[1024]; int len = 0; while((len = input.read(data)) != -1) &#123; String line = new String(data,0,len); System.out.println(line); &#125; input.close(); &#125;&#125; ClassClass是相对于classes文件来说的。.java文件会被编译成.class文件存放于classes目录下。 如果资源文件与调用该文件的.class文件处于同一路径，那么直接使用getResourceAsStream(“a.txt”)即可； 如果处于不同路径，例如存放于src目录下，那么使用getResourceAsStream(“/a.txt”)； 如果处于其它包下，例如存放于/web/day1_2下，而.class文件位于/web/day1_3下，那么使用getResourceAsStream(“/web/day1_2/a.txt”)即可。 代码示例： 123456789101112131415public class BServlet extends HttpServlet &#123; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; Class cl = this.getClass(); InputStream input = cl.getResourceAsStream(&quot;/web/day1_2/a.txt&quot;); byte[] data = new byte[1024]; int len = 0; while((len = input.read(data)) != -1) &#123; String line = new String(data,0,len); System.out.println(line); &#125; input.close(); &#125;&#125; 二、cookiecookie是以键值对的形式由服务器发送给浏览器保存在客户端上的。属于Http。 示例代码： 添加cookie12Cookie cookie1 = new Cookie(&quot;aaa&quot;,&quot;AAA&quot;);response.addCookie(cookie1);获取cookie的key1cookie.getName();获取cookie的value1cookie.getValue() 设置cookie的生命周期 cookie#setMaxAge(int MaxAge); MaxAge &lt; 0，浏览器一旦关闭，该cookie即死亡 MaxAge = 0，该cookie立即被销毁 MaxAge &gt; 0，cookie存活时间，以秒为单位 cookie的path： 如果访问路径包含cookie的保存路径，则会将该cookie带回给服务器 三、HttpSessionHttpSession是由JavaWeb提供的，Servlet三大域对象之一。 三大域对象： request，一次请求对应一个request，但一个request可以在多个servlet中传递 session，一个用户对应一个session，同一个用户的请求都在同一个session内 application（ServletContex），一个应用程序对应一个application，应用程序不死，application不死 作用域范围 session的会话范围从用户打开浏览器访问服务器开始到关闭浏览器结束。生命周期：session默认存活30分钟。 理解：一个Session就是一个会话。一个用户可以对一个服务器发出多个request，一个session包含多个request。 很少出现并发请求，session保存在服务器端。 转发：地址栏不发生改变，写的路径不需要带项目名重定向：地址栏发生改变，写的路径需要带项目名。重定向后就是两个不同的请求 原理当用户访问服务器时，服务器会创建一个session，并分配一个sessionId，这个sessionId跟创建的session对应。session会被保存在服务器端，而sessionId会被保存在cookie中。 创建了新的session，浏览器会得到一个包含sessionId的cookie，这个cookie的生命为-1，即只保存在内存中，当浏览器关闭时，cookie即被销毁。 之后请求session时，因为可以通过cookie中的sessionIs找到session，所以与上次请求的session是同一session对象。 服务器并不会一开始就创建session，而是第一次获取session时才会创建。 session最大不活跃时间 session有一个最大不活跃时间，当用户不对页面做任何操作时，session或被服务器销毁，下次就需要重新创建session，这样做可以保证用户信息安全。 四、JSP三种jsp脚本 1、&lt;% — %&gt;，方法体内能写什么就能写什么 2、&lt;%= — %&gt;，out.write()能写什么就写什么 3、&lt;%! — %&gt;，类里面能写什么就能写什么，一般不用，用了会被敲死 jsp指令一个jsp页面中，可以有0个或N个page指令。 三大指令： page include taglib page 1&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; pageEncoding=&quot;utf-8&quot; %&gt; contentType和pageEncoding是等价的，一个什么值另一个也是同样的值，所以一般只用设置一个。如果两个都没有设置，那么默认是iso。 import：导入Java包，可以使用多次 errorPage：当当前页面抛出异常，则转发到指定页面，设置状态码为200 isErrorPage：设置某个页面为处理错误页面，当属性为true时，会设置状态码为500。并且只有这个页面能使用九大内置对象中的Exception。 include静态包含，将多个jsp文件合并成一个文件然后被编译成.class文件，在运行之前就合并。 九大内置对象 out（response.getWriter()），jsp的输出流，用来响应客户端 page，当前jsp对象，它的引用类型是Object，即真身中有以下代码：Object page = this; exception（Throwable） request（HttpServletRequest） response（HttpServletResponse） config（ServletConfig），对应真身中的ServletConfig session（HttpSession） pageContext，一个顶九个 application（ServletContext） servlet三大域对象，jsp四大域对象。 ServletContext，作用于整个应用程序 session，整个会话，一个会话只有一个用户 request，一次请求，一个请求可能跨多个servlet pageContext，一个jsp页面，在当前页面和当前页面所使用的标签之间共享数据。 1、代理其它域； pageContext.setAttribute(“xxx”,”XXX”，PageContext.PAGE_SCOPE);2、全域查找； pageContext.findAttribute(“xxx”);从范围较小的域查到范围大的域，小域优先于大域3、获取其它域对象 jsp动作标签动作标签是由服务器来执行的，而静态的html是由浏览器的解释的。 jsp:forward 请求转发jsp:include 动态包含，在运行的时候调用另一个页面。与&lt;%@include&gt;不同。jsp:param 作为include和forward的子标签，用来给转发和包含的页面传值。 JavaBean规范1、必须要有一个默认构造器2、提供get/set方法，如果只有get方法，那么这个是可读属性3、属性：有get/set方法的成员，还可以没有成员。属性名称由get/set方法来决定，即get/set方法名称去掉get/set后小写的名称。 EL表达式EL是jsp内置的表达式语言。作用： 替代&lt;%= … %&gt;，也就是说，EL是用来输出的 读取四大域对象，${xxx}，全域查找名为xxx的属性，如果不存在就输出空串而不是null。${pageScope.xxx}、${requestScope.xxx}、${sessionScope.xxx}、${applicationScope.xxx}，指定域获取属性。 javaBean导航，${requestScope.emp.address.street}，使用El获取request域的emp —-&gt; request.getAttribute(“emp”).getAddress().getStreet()。 EL函数库123&lt;%@ taglib prefix=&quot;fn&quot; uri=&quot;http://java.sun.com/jsp/jstl/functions&quot; %&gt;$&#123;fn:toLowerCase(&quot;Hellowosdio&quot;)&#125; jstlcore库out标签12345&lt;%request.setAttribute(&quot;code&quot;,&quot;&lt;script&gt;alter(&#x27;helloworld&#x27;);&lt;/script&gt;&quot;);%&gt;$&#123;code&#125;&lt;c:out value=&quot;$&#123;code&#125;&quot; /&gt; set标签12&lt;c:set var=&quot;name&quot; value=&quot;&lt;script&gt;alter(&#x27;helloworld&#x27;);&lt;/script&gt;&quot; scope=&quot;request&quot;/&gt;&lt;c:out value=&quot;$&#123;name&#125;&quot; /&gt; 重要属性：scope：默认为page，可选值为page，request，session，application。 remove标签如果不写scope，那么删除的全域中所有的属性 url标签value属性：指定一个路径名，自动在路径前面添加项目名。 注意：路径名必须以斜杠开头12&lt;c:url value=&quot;/Aservlet&quot; /&gt;//在页面上输出/jsp/Aservlet 1234&lt;c:url value=&quot;/Aservlet&quot; &gt; &lt;c:param name=&quot;name&quot; value=&quot;gageshan&quot; /&gt;&lt;/c:url&gt;// 输出为 jsp/Aservlet?name=gageshan 重要属性：var：指定变量名，添加这个属性后，url标签就不会输出到页面中，而是会保存到域中。scope：与var一起使用，将url标签保存到域中。 if、chooseif对应Java中的if语句，choose对应Java中的if/else if/else 123&lt;c:if test=&quot;11&gt;4&quot;&gt; &lt;c:out value=&quot;/a&quot;/&gt;&lt;/c:if&gt; 123456&lt;c:choose&gt; &lt;c:when test=&quot;&quot;&gt;&lt;/c:when&gt; &lt;c:when test=&quot;&quot;&gt;&lt;/c:when&gt; &lt;c:when test=&quot;&quot;&gt;&lt;/c:when&gt; &lt;c:otherwise&gt;&lt;/c:otherwise&gt;&lt;/c:choose&gt; foreach用来循环遍历数组，集合。1234&lt;c:forEach var=&quot;i&quot; begin=&quot;1&quot; end=&quot;10&quot; step=&quot;1&quot;&gt;$&#123;i&#125;&lt;/c:forEach&gt; 重要的属性：items：指定要循环谁，可以是数组或者集合，items=”${…}”，不能写有空格。var：将数组或集合中的元素赋给var指定的变量。varStatus，循环状态变量。 fmt格式化库 格式化日期&lt;fmt:formatDate value=”” pattern=””&gt; value：指定一个Date类型变量pattern：指定输出的模板，”yyyy-mm-dd HH:mm:ss” 格式化数字&lt;fmt:formatNumber value=”${num1}” pattern=”0.00” /&gt;pattern：0.00：保留小数点后两位，不足两位以0来补，并且会四舍五入。#.##，不补位。 自定义标签写标签类： 12345678910111213package web.day3_2;import javax.servlet.jsp.JspException;import javax.servlet.jsp.tagext.JspTag;import javax.servlet.jsp.tagext.SimpleTagSupport;import java.io.IOException;public class MyTag1 extends SimpleTagSupport &#123; @Override public void doTag() throws JspException, IOException &#123; this.getJspContext().getOut().write(&quot;hello tag&quot;); &#125;&#125; 配置tld文件12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;taglib xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-jsptaglibrary_2_1.xsd&quot; version=&quot;2.1&quot;&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;short-name&gt;itcast&lt;/short-name&gt; &lt;uri&gt;http://www.itcast.cn/tags/it-1.0&lt;/uri&gt; &lt;!-- Invoke &#x27;Generate&#x27; action to add tags or functions --&gt; &lt;tag&gt; &lt;name&gt;mytag1&lt;/name&gt; &lt;tag-class&gt;web.day3_2.MyTag1&lt;/tag-class&gt; &lt;body-content&gt;empty&lt;/body-content&gt; &lt;/tag&gt;&lt;/taglib&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://shann.xyz/categories/JavaWeb/"}],"tags":[]},{"title":"第二讲 二分与前缀和","slug":"二分/第二讲 二分与前缀和","date":"2020-02-04T07:35:17.310Z","updated":"2020-02-27T16:32:26.540Z","comments":true,"path":"2020/02/04/二分/第二讲 二分与前缀和/","link":"","permalink":"https://shann.xyz/2020/02/04/%E4%BA%8C%E5%88%86/%E7%AC%AC%E4%BA%8C%E8%AE%B2%20%E4%BA%8C%E5%88%86%E4%B8%8E%E5%89%8D%E7%BC%80%E5%92%8C/","excerpt":"数的范围题目给定一个按照升序排列的长度为n的整数数组，以及 q 个查询。 对于每个查询，返回一个元素k的起始位置和终止位置（位置从0开始计数）。 如果数组中不存在该元素，则返回“-1 -1”。","text":"数的范围题目给定一个按照升序排列的长度为n的整数数组，以及 q 个查询。 对于每个查询，返回一个元素k的起始位置和终止位置（位置从0开始计数）。 如果数组中不存在该元素，则返回“-1 -1”。输入格式第一行包含整数n和q，表示数组长度和询问个数。 第二行包含n个整数（均在1~10000范围内），表示完整数组。 接下来q行，每行包含一个整数k，表示一个询问元素。 输出格式共q行，每行包含两个整数，表示所求元素的起始位置和终止位置。 如果数组中不存在该元素，则返回“-1 -1”。 数据范围1231≤n≤1000001≤q≤100001≤k≤10000输入样例：123456 31 2 2 3 3 4345输出样例：1233 45 5-1 -1 思路整数二分模板题。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.util.Scanner;public class Main &#123; static int[] q = new int[100100]; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n,m; n = sc.nextInt(); m = sc.nextInt(); for(int i = 0; i &lt; n; i++) &#123; q[i] = sc.nextInt(); &#125; while(m-- &gt; 0) &#123; int x = sc.nextInt(); int l = 0, r = n - 1; while(l &lt; r) &#123; int mid = (l + r) /2; if(q[mid] &gt;= x) &#123; r = mid; &#125; else &#123; l = mid + 1; &#125; &#125; if(q[l] == x) &#123; System.out.print(l + &quot; &quot;); r = n - 1; while(l &lt; r) &#123; int mid = (l + r + 1) / 2; if(q[mid] &lt;= x) &#123; l = mid; &#125; else &#123; r = mid - 1; &#125; &#125; if(q[l] == x) &#123; System.out.println(l); &#125; &#125; else &#123; System.out.println(&quot;-1 -1&quot;); &#125; &#125; &#125;&#125; 数的三次方根题目给定一个浮点数n，求它的三次方根。 输入格式共一行，包含一个浮点数n。 输出格式共一行，包含一个浮点数，表示问题的解。 注意，结果保留6位小数。 数据范围−10000≤n≤10000输入样例：11000.00输出样例：110.000000 思路实数二分。要注意的点是当题目指出要保留多少位小数时，在计算时一般多指定两位参与运算。 代码123456789101112131415161718192021222324import java.text.DecimalFormat;import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); double n = sc.nextDouble(); double l = -10000d,r = 10000d; while(r - l &gt; 1e-8) &#123; double mid = (r + l) / 2; if(mid * mid * mid &lt; n) &#123; l = mid; &#125; else r = mid; &#125; System.out.println(new DecimalFormat(&quot;#.000000&quot;).format(l)); &#125;&#125; 子矩阵的和题目输入一个n行m列的整数矩阵，再输入q个询问，每个询问包含四个整数x1, y1, x2, y2，表示一个子矩阵的左上角坐标和右下角坐标。 对于每个询问输出子矩阵中所有数的和。 输入格式第一行包含三个整数n，m，q。 接下来n行，每行包含m个整数，表示整数矩阵。 接下来q行，每行包含四个整数x1, y1, x2, y2，表示一组询问。 输出格式共q行，每行输出一个询问的结果。 数据范围123451≤n,m≤1000,1≤q≤200000,1≤x1≤x2≤n,1≤y1≤y2≤m,−1000≤矩阵内元素的值≤1000 输入样例：12345673 4 31 7 2 43 6 2 82 1 2 31 1 2 22 1 3 41 3 3 4输出样例：123172721 思路二维数组前缀和模板题。1mg[i][j] += mg[i - 1][j] + mg[i][j] - mg[i - 1][j -1] 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.Scanner;public class Main &#123; static int[][] row = new int[1005][1005]; static int[][] col = new int[1005][1005]; static BufferedReader sc = new BufferedReader(new InputStreamReader(System.in)); public static void main(String[] args) throws Exception &#123; String line = sc.readLine(); String src[] = line.split(&quot; &quot;); int n = Integer.parseInt(src[0]); int m = Integer.parseInt(src[1]); int q = Integer.parseInt(src[2]); for(int i = 1; i &lt;= n; i++) &#123; line = sc.readLine(); src = line.split(&quot; &quot;); int j = 1; for(String str : src) &#123; row[i][j] = Integer.parseInt(str); col[i][j] = col[i - 1][j] + col[i][j - 1] - col[i - 1][j - 1] + row[i][j]; j++; &#125; &#125; while(q-- &gt; 0) &#123; line = sc.readLine(); src = line.split(&quot; &quot;); int a = Integer.parseInt(src[0]); int b = Integer.parseInt(src[1]); int c = Integer.parseInt(src[2]); int d = Integer.parseInt(src[3]); System.out.println(col[c][d] - col[c][b - 1] - col[a - 1][d] + col[a - 1][b - 1]); &#125; &#125;&#125; 机器人跳跃问题题目机器人正在玩一个古老的基于DOS的游戏。 游戏中有N+1座建筑——从0到N编号，从左到右排列。 编号为0的建筑高度为0个单位，编号为 i 的建筑高度为H(i)个单位。 起初，机器人在编号为0的建筑处。 每一步，它跳到下一个（右边）建筑。 假设机器人在第k个建筑，且它现在的能量值是E，下一步它将跳到第k+1个建筑。 如果H(k+1)&gt;E，那么机器人就失去H(k+1)-E的能量值，否则它将得到E-H(k+1)的能量值。 游戏目标是到达第N个建筑，在这个过程中能量值不能为负数个单位。 现在的问题是机器人以多少能量值开始游戏，才可以保证成功完成游戏？ 输入格式第一行输入整数N。 第二行是N个空格分隔的整数，H(1),H(2),…,H(N)代表建筑物的高度。 输出格式输出一个整数，表示所需的最少单位的初始能量值。 数据范围1≤N,H(i)≤10^5, 输入样例1：1253 4 3 2 4输出样例1：14输入样例2：1234 4 4输出样例2：14输入样例3：1231 6 4输出样例3：13 思路二分答案。 二分初始能量值（即0-10^5），将每次得到的数带入题中所给的条件，看能否满足要求，不断地缩小答案数量。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import java.util.Scanner;public class Main &#123; static final int MAXN = 100005; static long[] q = new long[MAXN]; static int n; private static boolean check1(long mid) &#123; for(int i = 0; i &lt; n; i++) &#123; if(q[i] &gt; mid) &#123; return false; &#125; &#125; return true; &#125; public static boolean check(long mid) &#123; for(int i = 0; i &lt; n; i++) &#123; if(check1(mid)) &#123; return true; &#125; if(mid &lt; q[i]) &#123; mid = mid - (q[i] - mid); &#125; else &#123; mid = mid + (mid - q[i]); &#125; if(mid &lt; 0) &#123; return false; &#125; &#125; return true; &#125; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); n = sc.nextInt(); for(int i = 0; i &lt; n; i++) &#123; q[i] = sc.nextLong(); &#125; long l = 0, r = MAXN; while(l &lt; r) &#123; long mid = (l + r) / 2; if(check(mid)) &#123; r = mid; &#125; else &#123; l = mid + 1; &#125; &#125; System.out.println(l); &#125;&#125; 四平方和题目四平方和定理，又称为拉格朗日定理： 每个正整数都可以表示为至多 4 个正整数的平方和。 如果把 0 包括进去，就正好可以表示为 4 个数的平方和。 比如： 5=0^2+0^2+1^2+2^2 7=1^2+1^2+1^2+2^2 对于一个给定的正整数，可能存在多种平方和的表示法。 要求你对 4 个数排序： 0≤a≤b≤c≤d 并对所有的可能表示法按 a,b,c,d 为联合主键升序排列，最后输出第一个表示法。 输入格式输入一个正整数 N。 输出格式输出4个非负整数，按从小到大排序，中间用空格分开。 数据范围 0&lt;N&lt;5∗10^6 输入样例：15输出样例：10 0 1 2 思路对于这样的题目，如果一开始找不出思路，那就开始想一个暴力的解法。 可以看到，任意找4个数使得它们的平方的和等于给定的数，首先想到的就是4个循环解决。123456789for(i = 0; ; i++) &#123; for(j = i; ; j++) &#123; for(t = j; ; t++) &#123; for(k = t; ; k++) &#123; i*i+j*j+k*k+t*t; &#125; &#125; &#125;&#125;明显的会超出时间。 其实不妨这样想，假如现在已经求得了两个数的平方和了（记为a），那么另外两个数的平方和就是n-a=b。 b可以怎么求呢？ 可以知道，如果a+b能够组成n，b一定要能够分成两个数的平方和，如果不能，那么说明组成a的两个整数不是答案。 提前算好b的每种可能组合，之后查找即可。 又因为只要字典序最小的答案，利用map的特性，只保存第一次组合即可。 代码1234567891011121314151617181920212223242526272829303132import java.util.HashMap;import java.util.Map;import java.util.Scanner;public class Main &#123; static int n ; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); n = sc.nextInt(); Map&lt;Integer,String&gt; map = new HashMap&lt;Integer,String&gt;(); for(int i = 0; i * i &lt;= n; i++) &#123; for(int j = i; i * i + j * j &lt;= n; j++) &#123; if(!map.containsKey(i * i + j * j)) &#123; map.put(i * i + j * j, i + &quot; &quot; + j); &#125; &#125; &#125; for(int i = 0; i * i &lt;= n; i++) &#123; for(int j = i; i * i + j * j &lt;= n; j++) &#123; int t = n - (i * i + j * j); if(map.containsKey(t)) &#123; String ans = i + &quot; &quot; + j + &quot; &quot; +map.get(t); System.out.println(ans); return; &#125; &#125; &#125; &#125;&#125; 分巧克力题目儿童节那天有 K 位小朋友到小明家做客。 小明拿出了珍藏的巧克力招待小朋友们。 小明一共有 N 块巧克力，其中第 i 块是 Hi×Wi 的方格组成的长方形。 为了公平起见，小明需要从这 N 块巧克力中切出 K 块巧克力分给小朋友们。 切出的巧克力需要满足： 形状是正方形，边长是整数大小相同例如一块 6×5 的巧克力可以切出 6 块 2×2 的巧克力或者 2 块 3×3 的巧克力。 当然小朋友们都希望得到的巧克力尽可能大，你能帮小明计算出最大的边长是多少么？ 输入格式第一行包含两个整数 N 和 K。 以下 N 行每行包含两个整数 Hi 和 Wi。 输入保证每位小朋友至少能获得一块 1×1 的巧克力。 输出格式输出切出的正方形巧克力最大可能的边长。 数据范围1≤N,K≤105,1≤Hi,Wi≤105输入样例：1232 106 55 6输出样例：12 思路二分答案。 二分正方形的边长，将枚举的边长带入看能否满足题目条件。不断缩小答案。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.util.Scanner;public class Main &#123; static final int MAXN = 100000 + 5; static int n, k; static int[] H = new int[MAXN]; static int[] W = new int[MAXN]; public static boolean check(int mid) &#123; int cnt = 0; for(int i = 1; i &lt;= n; i++) &#123; cnt += (H[i] / mid) * (W[i] / mid); &#125; if(cnt &lt; k) &#123; return false; &#125; return true; &#125; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); n = sc.nextInt(); k = sc.nextInt(); for(int i = 1; i &lt;= n; i++) &#123; H[i] = sc.nextInt(); W[i] = sc.nextInt(); &#125; int l = 1, r = MAXN; while(l &lt; r) &#123; int mid = (l + r + 1) / 2; if(check(mid)) &#123; l = mid; &#125; else &#123; r = mid - 1; &#125; &#125; System.out.println(r); sc.close(); &#125;&#125; K倍区间题目给定一个长度为 N 的数列，A1,A2,…AN，如果其中一段连续的子序列 Ai,Ai+1,…Aj 之和是 K 的倍数，我们就称这个区间 [i,j] 是 K 倍区间。 你能求出数列中总共有多少个 K 倍区间吗？ 输入格式第一行包含两个整数 N 和 K。 以下 N 行每行包含一个整数 Ai。 输出格式输出一个整数，代表 K 倍区间的数目。 数据范围 1≤N,K≤100000, 1≤Ai≤100000 输入样例：1234565 212345输出样例：16 思路可以很容易的想到一个方法：枚举一段区间，求得这段区间和，能整除k即是一个答案。而快速求区间和可以利用前缀和算法。 很快的写出暴力解法：1234567for(len = 1; len &lt;= n ; len++) &#123; for(i = 1; i &lt;=n ; i++) &#123; if((arr[i + len - 1] - arr[i - 1]) % k == 0) &#123; ans++; &#125; &#125;&#125; 其中arr为前缀和数组。推导算式12345(arr[i + len - 1] - arr[i - 1]) % k == 0，(arr[i] - arr[j]) % k == 0，arr[i] % k == arr[j] % k 说明，在前缀和数组中，只要后面的数模k余数与前面的数模k余数相等，即满足答案。 代码1234567891011121314151617181920212223242526import java.util.Scanner;public class Main &#123; static final int MAXN = 100000 + 5; static int n,k; static long[] q = new long[MAXN]; static long[] p = new long[MAXN]; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); n = sc.nextInt(); k = sc.nextInt(); long ans = 0; for(int i = 1; i &lt;= n; i++) &#123; q[i] = sc.nextInt(); q[i] = (q[i - 1] + q[i]) % k; ans += p[(int)q[i]]; p[(int)q[i]]++; &#125; System.out.println(ans + p[0]); &#125;&#125;","categories":[{"name":"二分-三分-分治","slug":"二分-三分-分治","permalink":"https://shann.xyz/categories/%E4%BA%8C%E5%88%86-%E4%B8%89%E5%88%86-%E5%88%86%E6%B2%BB/"}],"tags":[{"name":"基础算法","slug":"基础算法","permalink":"https://shann.xyz/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}]},{"title":"Java实现批量解压zip文件","slug":"java/Java实现解压zip文件","date":"2020-02-01T15:33:02.191Z","updated":"2020-02-27T16:30:02.545Z","comments":true,"path":"2020/02/01/java/Java实现解压zip文件/","link":"","permalink":"https://shann.xyz/2020/02/01/java/Java%E5%AE%9E%E7%8E%B0%E8%A7%A3%E5%8E%8Bzip%E6%96%87%E4%BB%B6/","excerpt":"到网上下载的教学视频一般都是经过层层压缩的，手动解压的耗时耗力，遂写了个程序自动解压。 主要利用了Java核心库中的ZipInputStream类。","text":"到网上下载的教学视频一般都是经过层层压缩的，手动解压的耗时耗力，遂写了个程序自动解压。 主要利用了Java核心库中的ZipInputStream类。代码： 其中File src为目标文件，String des为要存储到的存储路径12345678910111213141516171819202122232425262728public void unZip(File src,String des) throws Exception &#123; ZipInputStream zipInputStream = new ZipInputStream(new FileInputStream(src), Charset.forName(&quot;gbk&quot;)); ZipEntry zipEntry = null; while((zipEntry = zipInputStream.getNextEntry()) != null) &#123; File file = new File(des + File.separator + zipEntry.getName()); if(zipEntry.isDirectory()) &#123; file.mkdirs(); continue; &#125; file.getParentFile().mkdirs(); int len; FileOutputStream out = new FileOutputStream(file); while((len = zipInputStream.read(buffer)) != -1) &#123; out.write(buffer,0,len); &#125; out.close(); &#125; zipInputStream.closeEntry(); zipInputStream.close();&#125; 遇到的问题：在定义ZipInputStream类时，如果不指定文件流的编码格式，则默认为utf-8。假如要解压的文件路径中包含中文，则会抛出异常：1Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: malformed input off : 19, length : 1 这时就要手动指定编码格式了。 见源码：123public ZipInputStream(InputStream in) &#123; this(in, StandardCharsets.UTF_8); &#125;12345678910public ZipInputStream(InputStream in, Charset charset) &#123; super(new PushbackInputStream(in, 512), new Inflater(true), 512); usesDefaultInflater = true; if (in == null) &#123; throw new NullPointerException(&quot;in is null&quot;); &#125; if (charset == null) throw new NullPointerException(&quot;charset is null&quot;); this.zc = ZipCoder.get(charset);&#125; 由于ZipInputStream中是没有编码常量的，所以需要借助Charset.forName(&quot;gbk&quot;)来指定。","categories":[{"name":"Java","slug":"Java","permalink":"https://shann.xyz/categories/Java/"}],"tags":[]},{"title":"处理机调度","slug":"操作系统/处理机调度","date":"2019-11-15T07:59:17.771Z","updated":"2020-02-27T16:31:32.949Z","comments":true,"path":"2019/11/15/操作系统/处理机调度/","link":"","permalink":"https://shann.xyz/2019/11/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/","excerpt":"操作系统笔记 层次和目标处理机调度分为三个层次，分别为 高级调度（作业调度），将处于后备队列中的作业调入内存 中级调度（内存调度），将暂时不能运行的进程调至外存等待 低级调度（进程调度），决定就绪队列中的哪个进程（或线程）得到处理机资源 不同类型的操作系统采用了不同的处理机调度算法。调度算法应当使得系统资源利用率尤其是处理机的利用率尽可能地高（资源利用率），要保证每个进程都能获得合理的CPU时间（公平性），还要保证系统的各种资源使用的平衡性（平衡性），另外对制定的策略只要需要就一定要执行（策略强制执行性）。","text":"操作系统笔记 层次和目标处理机调度分为三个层次，分别为 高级调度（作业调度），将处于后备队列中的作业调入内存 中级调度（内存调度），将暂时不能运行的进程调至外存等待 低级调度（进程调度），决定就绪队列中的哪个进程（或线程）得到处理机资源 不同类型的操作系统采用了不同的处理机调度算法。调度算法应当使得系统资源利用率尤其是处理机的利用率尽可能地高（资源利用率），要保证每个进程都能获得合理的CPU时间（公平性），还要保证系统的各种资源使用的平衡性（平衡性），另外对制定的策略只要需要就一定要执行（策略强制执行性）。 作业调度在多道批处理系统中，作业是用户提交给系统的一项想多独立的工作。作业不仅包含通常说的程序和数据还有配有一份作业说明书。 当一个作业进入系统时，相应的调度程序为其建立一个作业控制块（Job Control Block，JCB），JCB中含有该作业的有关信息（比如作业标识、类型、优先级等），之后把这个作业放入后备队列中等待后续调度。 作业从进入系统到运行结束经过了3个阶段。 后备状态，系统建立JCB并将该作业放入后备队列等待作业调度。 运行阶段，作业被作业调度进程分配相关的资源后调入就绪队列。 完成状态，当作业完成或者发生异常情况提前结束，被系统收回已分配的资源。 作业调度要根据JCB中相关信息检查系统中是否有足够的资源满足该作业的需求，之后按照相应的调度算法从外存中的后备队列中选取作业调入内存中的就绪队列，为其创建进程、分配相应的资源。 作业调度应该调度哪些作业呢？这取决于系统采用的调度算法。比较常用的有先来先服务算法、短作业优先算法和高响应比优先调度算法。 先来先服务算法（First come first served，FCFS）：FCFS算法按照作业到达系统的先后顺序来调度作业。 短作业优先算法（Short job first SJF）：SJF算法按照作业的估计运行时间长短来调度作业。可以发现，这种算法有不少的缺点，实际上是很难估计作业的运行时间，而且这种算法对长作业是非常不利的，长作业的周转时间会明显的增长，完全忽视长作业的等待时间，导致长作业的实际完成时间被拉长，这是用户不想得到的结果。当用户急需完成某一任务，而该任务的估计运行时间较长，该紧急长作业在后备队列中等待被调度时，这时来了一个短作业，那么，短作业先被调度，紧急作业长延后无法被调度，不能保证紧急作业得到及时处理。 高响应比优先调度算法（Highest response ratio next,HRRN）：HRRN算法结合了FCFS和SJF算法。为每一个作业设置一个优先级，在后备队列中作业按照优先级排序等待被调度。 优先权 = $\\frac{等待时间 + 要求服务时间}{要求服务时间}$HRRN的缺点是在进行调度之前都要进行一次响应比计算，无疑这会增加系统开销。 进程调度在进行进程调度的时候首先要将当前正在使用处理机的进程的相关信息保存到进程的进程控制块中，比如程序计数器、寄存器中的内容。其次根据一定的调度算法选取就绪队列中的进程。最后将处理机分配给选取的进程，并将进程控制块中的相关信息填入处理机，让它从上次的断点处恢复运行。 进程调度的机制 排队器，按照一定的策略将进程排序 分派器，根据调度程序选出进程，将其从就绪队列中取出，将处理机分配给该进程 上下文切换器，在进行进程切换时，保存旧进程的相关信息，并将新进程的信息填入处理机中 进程调度方式1.非抢占式，一旦把处理机分配给某一进程后，除非这个进程发出中断或者异常，否则一直运行下去，直至完成。 2.抢占式，这种调度方式允许调度程序根据某种原则去暂停某个正在执行的程序，转而将处理机分配给其他进程。 注意，在分时系统中，只有抢占式才能实现人机交互。 抢占式也并不是一种任意的行为，它也必须遵循一定的原则。1.允许优先权高的抢占优先权低的。2.允许新调入就绪队列中的短进程抢占正在运行的长进程，即当前运行的长进程的尚需运行时间明显比短进程要求运行时间长时，允许抢占。3.如果调度算法是基于时间片原则的，当前进程在属于它的时间片内尚未执行完毕，可被其他进程抢占。 调度算法较常用的算法有基于时间片的轮转调度算法（Round robin，RR）。 RR算法让就绪队列中进程每次仅能获得一个时间片，在一个时间片用完该进程还未执行完毕就换下一个进程。由此确保每个进程在一定时间间隔内都能获得一次处理机。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://shann.xyz/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[]},{"title":"银行家算法实现","slug":"操作系统/OS实验五-银行家算法","date":"2019-11-13T08:43:53.615Z","updated":"2020-02-27T16:31:21.317Z","comments":true,"path":"2019/11/13/操作系统/OS实验五-银行家算法/","link":"","permalink":"https://shann.xyz/2019/11/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/OS%E5%AE%9E%E9%AA%8C%E4%BA%94-%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/","excerpt":"操作系统编程小作业 银行家算法详细讲解","text":"操作系统编程小作业 银行家算法详细讲解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int process_MAXN = 5; // the process numberconst int resource_MAXN = 3; // the resource numberstruct bankAlgorithm&#123;private: int Available[resource_MAXN] = &#123;2,3,0&#125;; int tmpAvailable[process_MAXN][resource_MAXN]; // int Max[process_MAXN][resource_MAXN] = &#123; &#123;7, 5, 3&#125;,&#123;3, 2, 1&#125;,&#123;9, 0, 2&#125;,&#123;2, 2, 2&#125;,&#123;4, 3, 3&#125; &#125;; int Allocation[process_MAXN][resource_MAXN] = &#123;&#123;0, 1, 0&#125;,&#123;2, 0, 0&#125;,&#123;3, 0, 2&#125;,&#123;2,1,1&#125;,&#123;0, 0, 2&#125;&#125;; int Need[process_MAXN][resource_MAXN] = &#123;&#123;7, 4, 3&#125;,&#123;1, 2, 2&#125;,&#123;6, 0, 0&#125;,&#123;0, 1, 1&#125;,&#123;4, 3, 1&#125;&#125;; int processId = 1; int request[3] = &#123;1,0,2&#125;; int visit[process_MAXN][3] = &#123;&#123;0&#125;&#125;; // the priority of visitpublic: void mainCtrl(); void sayHelloworld(); void inputData(); void outputData(); bool sendRequest(); void tryToAskResource(); void showInformation(); void showError();&#125;;void bankAlgorithm::mainCtrl()&#123; inputData(); outputData(); sendRequest();&#125;void bankAlgorithm::sayHelloworld()&#123; printf(&quot;\\thello the cruel world\\n&quot;);&#125;void bankAlgorithm::inputData()&#123; printf(&quot;input the process id and the three request resource\\n&quot;); scanf(&quot;%d%d%d%d&quot;,&amp;processId,&amp;request[0],&amp;request[1],&amp;request[2]);&#125;void bankAlgorithm::outputData()&#123; printf(&quot;ProcessId：%d\\nrequest：&quot;,processId); for(int i = 0; i &lt; resource_MAXN; i++) &#123; printf(&quot;%d &quot;,request[i]); &#125; printf(&quot;\\n&quot;);&#125;bool bankAlgorithm::sendRequest() //no bug&#123; for(int i = 0; i &lt; resource_MAXN; i++) &#123; if(request[i] &gt; Need[processId][i]) &#123; printf(&quot;The requested resource has exceeded the required resource\\n&quot;); return false; &#125; if(request[i] &gt; Available[i]) &#123; printf(&quot;The requested resource has exceeded the Available resource\\n&quot;); return false; &#125; &#125; tryToAskResource();&#125;void bankAlgorithm::tryToAskResource()&#123; for(int i = 0; i &lt; resource_MAXN; i++) &#123; Available[i] -= request[i]; Need[processId][i] -= request[i]; Allocation[processId][i] += request[i]; &#125; int cnt = 0; //the visitted priority for(int i = 0; i &lt; process_MAXN; i++) &#123; visit[i][0] = 0; &#125; while(true) &#123; bool judgeToRun = true; for(int i = 0; i &lt; process_MAXN; i++) &#123; if(!visit[i][0]) &#123; bool flag = true; for(int j = 0; j &lt; resource_MAXN; j++) &#123; if(Available[j] &lt; Need[i][j]) &#123; flag = false; break; &#125; &#125; if(flag) &#123; for(int j = 0; j &lt; resource_MAXN; j++) &#123; tmpAvailable[i][j] = Available[j]; Available[j] += Allocation[i][j]; &#125; judgeToRun = false; visit[i][0] = 1; visit[i][1] = cnt++; visit[i][2] = i;// cout&lt;&lt;&quot;i = &quot;&lt;&lt;i&lt;&lt;endl; &#125; &#125; &#125; if(judgeToRun) &#123;break;&#125; &#125;// sayHelloworld();// cout&lt;&lt;cnt&lt;&lt;&#x27; &#x27;&lt;&lt;process_MAXN&lt;&lt;endl; if(cnt != process_MAXN) &#123; showError(); return; &#125; showInformation();&#125;void bankAlgorithm::showInformation()&#123; printf(&quot;Resource\\tMax\\tAvailable Allocation Need Work\\n&quot;); int tmp[3]; int len = sizeof(visit[0]); for(int i = 0; i &lt; process_MAXN; i++) &#123; for(int j = i + 1; j &lt; process_MAXN; j++) &#123; if(visit[i][1] &gt; visit[j][1]) &#123; memcpy(tmp,visit[i],len); memcpy(visit[i],visit[j],len); memcpy(visit[j],tmp,len); &#125; &#125; &#125; for(int i = 0; i &lt; process_MAXN; i++) &#123; int process_id = visit[i][2]; printf(&quot;\\t%d &quot;,process_id); printf(&quot;\\t&quot;); for(int j = 0; j &lt; resource_MAXN; j++) &#123; printf(&quot;%d &quot;,Max[process_id][j]); &#125; printf(&quot;\\t &quot;); for(int j = 0; j &lt; resource_MAXN; j++) &#123; printf(&quot;%d &quot;,tmpAvailable[process_id][j]); &#125; printf(&quot;\\t&quot;); for(int j = 0; j &lt; resource_MAXN; j++) &#123; printf(&quot;%d &quot;,Allocation[process_id][j]); &#125; printf(&quot;\\t &quot;); for(int j = 0; j &lt; resource_MAXN; j++) &#123; printf(&quot;%d &quot;,Need[process_id][j]); &#125; printf(&quot;\\t&quot;); for(int j = 0; j &lt; resource_MAXN; j++) &#123; printf(&quot;%d &quot;,tmpAvailable[process_id][j] + Allocation[process_id][j]); &#125; printf(&quot;\\n&quot;); &#125;&#125;void bankAlgorithm::showError()&#123; printf(&quot;Sorry,you can&#x27;t allocate resources to %d.\\nBecause the Available resource can&#x27;t satisfy any of the Process\\n&quot;,processId);&#125;int main()&#123; struct bankAlgorithm shan; shan.mainCtrl(); return 0;&#125;","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://shann.xyz/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[]},{"title":"银行家算法避免死锁问题","slug":"操作系统/银行家算法避免死锁","date":"2019-10-13T09:27:35.962Z","updated":"2020-02-27T16:31:41.785Z","comments":true,"path":"2019/10/13/操作系统/银行家算法避免死锁/","link":"","permalink":"https://shann.xyz/2019/10/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81/","excerpt":"操作系统笔记 算法实现 介绍在死锁避免方法中，把系统的状态分为安全状态和不安全状态。系统处于安全状态，可以避免发生死锁；而当系统处于不安全状态时，则可能发生死锁。死锁是要尽量避免的。","text":"操作系统笔记 算法实现 介绍在死锁避免方法中，把系统的状态分为安全状态和不安全状态。系统处于安全状态，可以避免发生死锁；而当系统处于不安全状态时，则可能发生死锁。死锁是要尽量避免的。安全状态举例： 现有P1、P2、P3三个进程，它们需要一定的资源才能完成各自的任务，每一种资源一旦被一个进程占用，就不予许另外的进程申请，而当某一进程完成任务时，该进程占用的资源就会释放，也就是说资源可被其它的进程使用。如果三个进程都无妨申请资源以完成各自的任务，这三个进程就会发生死锁。 现在我们需要找到一条有效的执行序列，使得每一个进程都得以执行，不会出现无法申请资源而死锁。 进程 最大需求 已分配 还需要 可用 P1 10 5 5 3 P2 4 2 2 NULL P3 9 2 7 NULL 注最大需求：进程需要该数量资源才能执行已分配：已经分配给该进程的资源数量还需要：即进程一旦申请申请到该数量的资源就可以执行，也就是`还需要 = 最大需求 - 已分配可用：系统中还可以的申请的资源数量，每个尚未完成的进程都可以申请 现在系统中还有3个资源可以被申请。此时，P1需要5个资源，P3需要7个资源，系统可分配的资源不足以分配使得它们执行，只能分配给还需资源数小于可分配数的P2进程。 这样，那就分配2个资源给P2进程，可分配资源还剩下1个。P2进程得到后可执行完成，接着就会释放4个资源，由此，系统可分配资源就增加到了5个。 P1进程还需要5个资源就可以执行完成，所以，我们就可以把可以分配的5个资源全部分配给P1进程，等P1进程执行完成释放10个资源后，可分配的资源就增加到了10个资源。 把可分配资源全部分配给P3进程，使得P3进程执行完成。可分配资源就增加到了12个，当然，不用去管这个问题了，因为我们的进程都已经执行完毕。 由此，我们可以找到一条安全的执行序列P2-&gt;P1-&gt;P3，使得三个进程得以安全的执行而不会发生死锁。 在分配资源给一个进程时，我们需要先尝试着是否能分配资源，如果分配资源后，剩下的资源不足以使得还未完成的进程形成一条安全的执行序列，这就说明此时我们不能分配，如果能够形成安全的序列，则可以分配。 某进程发出资源请求后，相应地可用资源减少，该进程的资源状态改变（也就是上面说的已分配、可用、还需资源数）。剩下的就是在所有进程中找到一条=使所有进程进入安全状态的执行序列。能找到，则可分配，否则不能。有个这个认识，我们就可以来说下银行家算法了。（这段话是基于理论上的，实际上，要先确定能够分配，资源才会减少，但这并不会妨碍我们的解释） 当一个新进程进入系统时，它必须申明在运行过程中，可能需要的每种资源类型的最大单元数，这个数量不应该超过系统所拥有的资源总数，否则无法执行这个新进程。银行家算法来确定当这个新进程发出资源请求时，是否能够满足这个请求。 下面介绍下银行家算法中涉及到的数据结构。 名称 含义 例子 Available 一个含有M个元素的数组，每个元素代表每类资源的可用数量 [1,2,3,4] Max 一个N*M的矩阵，Max[i][j]表示第i个进程需要的最大资源需求 [[1,2,3],[1,2,3],[1,2,3]] Allocation 一个N*M的矩阵，Allocation[i][j]表示第i个进程已经分配了多少资源 Need 一个N*M的矩阵，Need[i][j]表示第i个进程还多少资源就可以参与执行 事实上，这跟我们开篇所提到的安全状态举例类似，我们可以把Max看一个单个的数组，代表每个进程最大资源需求数，当然，已经从一类资源变为多种资源。Allocation和Need也是一样。在银行家算法中使用矩阵统一表示是为了方便。 已知：Need = Max - Allocation 当一个进程完成后，系统将回收该进程占用的资源，即 Available = Available + Max。 银行家算法是为了避免进程死锁的，也就是说，系统提出资源请求时，会有一个Request数组，表示该进程请求的每类资源的数量。 注意： Request &lt;= Need，否则认为出错，因为它申请的资源（Request）不能大于它实际需要的资源（Need）。 Request &lt;= Available，否则认为出错，因为此时申请的资源（Request）已经超过系统可分配的资源，它必须等待 举例说明现系统中有5个进程，分别为P0、P1、P2、P3、P4和3类资源A、B、C。各类资源的数量分别为10、5、7。 具体情况见下表 表1 表1 资源情况 Max Allocation Need Available - 进程 A B C A B C A B C A B C - P0 7 5 3 0 1 0 7 4 3 3 3 2 - P1 3 2 1 2 0 0 1 2 2 - P2 9 0 2 3 0 2 6 0 0 - p3 2 2 2 2 1 1 0 1 1 - p4 4 3 3 0 0 2 4 3 1 现在我们要来找一条能够让这5个进程不发生死锁的执行序列。 需要知道一个进程一旦执行完毕，系统就可以收回该进程所占用的各类资源。所以或许我们可以总结出这样一条规则：总是将系统可以分配的资源全部分配给一个进程来帮助这个进程尽快执行完毕，这样等它执行完毕，系统就回收它占用的资源，从而就可以帮助其他需要资源的多的进程。也就是说，或许把资源分配给资源需求数少的进程是一种较优选择。 如此一来，仔细分析上述表格，我们可以推导出这样一条执行序列： P1-&gt;P3-&gt;P4-&gt;P2-&gt;P0。 对应 表2： 表2 资源情况 Available Allocation Need Available + Allocation - 进程 A B C A B C A B C A B C - P1 3 3 2 2 0 0 1 2 2 5 3 2 - P3 5 3 2 2 1 1 0 1 1 7 4 3 - P4 7 4 3 0 0 2 4 3 1 7 4 5 - p2 7 4 5 3 0 2 6 0 0 10 4 7 - p0 10 4 7 0 1 0 7 4 3 10 5 7 问题一此时P1请求资源，发出Request(1,0,2)，请求1个A资源，0个B资源，2个C资源。 分析 Request(1,0,2) &lt;= Need(1,2,2) Request(1,0,2) &lt;= Available(3 3 2) 现在假设可以为它分配资源，那么P1的资源状态会有如下变化：表3： 表3 资源情况 Max Allocation Need Available - 进程 A B C A B C A B C A B C - P3 3 2 2 3 0 2 0 2 0 2 3 0 也就是Allocation中A+1，C+2，Need中A-1，C-2。 可以看到，此时，系统可以分配的资源就变为了Available(2,3,0)。知道了系统资源可分配量，我们就要在这5个进程中找一个安全序列。再次强调，如果可以找到，就说明假设的分配资源可以实现，否则不行。 接着看5个进程的Need资源量，从中我们要找到一个进程为它分配资源。 发现P3的Need(0,1,1) &lt;= Available(2,3,0)，如果将资源分配给他，P3进程得到资源后可立即执行，执行完毕后可释放资源，这也就意味着Available数量会增加，变化的Available(4,4 1)，就可以分配给那些资源需求量大的进程。直到全部进程执行完毕。 表4： 表4 资源情况 Available Allocation Need Available + Allocation - 进程 A B C A B C A B C A B C - P1 2 3 0 3 0 2 0 2 0 5 3 2 - P3 5 3 2 2 1 1 0 1 1 7 4 3 - P4 7 4 3 0 0 2 4 3 1 7 4 5 - p2 7 4 5 3 0 2 6 0 0 10 4 7 - p0 10 4 7 0 1 0 7 4 3 10 5 7 安全序列： P1-&gt;P3-&gt;P4-&gt;P2-P0 P1-&gt;P3-&gt;P4-&gt;P0-&gt;P2 可以响应请求。 问题二P4发出请求Request(3,3,0)。分析 Request(3,3,0) &lt;= Need(4,3,1) Request(3,3,0) &gt; Available(2,3,0)，不满足条件，让P4等待 不能响应请求。 问题三P0发出请求Request(0,2,0)分析 Request(0,2,0) &lt;= Need(7,4,3) Request(0,2,0) &lt;= Available(2,3,0) 先假设可以分配资源，那么P0资源状态变化为 表5： 表5 资源情况 Max Allocation Need Available - 进程 A B C A B C A B C A B C - P0 7 5 3 0 3 0 7 2 3 2 1 0 此时的系统资源为Available(2,1,0)，可以看到无法满足任何一个进程的Need请求。 不响应请求。 问题四P0发出请求Request(0,1,0)分析 Request(0,1,0) &lt;= Need(7,4,3) Request(0,1,0) &lt;= Available(3,3,2) 可以找到这样一条安全序列P1-&gt;P3-&gt;P4-&gt;P2-&gt;P0 表6： 表6 资源情况 Available Allocation Need Available + Allocation - 进程 A B C A B C A B C A B C - P1 3 2 2 2 0 0 1 2 2 5 2 2 - P3 5 2 2 2 1 1 0 1 1 7 3 3 - P4 7 3 3 0 0 2 4 3 1 7 3 5 - p2 7 3 5 3 0 2 6 0 0 10 3 7 - p0 10 3 7 0 2 0 7 3 3 10 5 7","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://shann.xyz/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://shann.xyz/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"数组划分游戏 HihoCoder - 1948 (二分答案)","slug":"二分/数组划分游戏 HihoCoder - 1948 （二分答案）","date":"2019-09-21T13:05:23.245Z","updated":"2019-07-28T12:51:54.000Z","comments":true,"path":"2019/09/21/二分/数组划分游戏 HihoCoder - 1948 （二分答案）/","link":"","permalink":"https://shann.xyz/2019/09/21/%E4%BA%8C%E5%88%86/%E6%95%B0%E7%BB%84%E5%88%92%E5%88%86%E6%B8%B8%E6%88%8F%20HihoCoder%20-%201948%20%EF%BC%88%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88%EF%BC%89/","excerpt":"","text":"题目https://cn.vjudge.net/problem/HihoCoder-1948 小Hi在玩一个有关数组划分的游戏。给定一个整数K和一个长度为N的数组A=[A1, A2, … AN]，小Hi需要将它划分为K个连续子数组，并对每个子数组求和。 不妨设这K个子数组的和依次是S1, S2, … SK，则小Hi的得分是其中的最小值即min(S1, S2, … SK)。 例如对于A=[1, 2, 3, 4]和K=2，小Hi可以划分成[1, 2]和[3, 4]，这样得分是3；也可以划分成[1, 2, 3]和[4]，这样得分是4。 对于给定的K和数组A，你能帮助小Hi算出他最多能得多少分吗？ Input第一行包含两个整数N和K。 第二行包含N个整数A1, A2, … AN。 对于60%的数据，1 &lt;= N &lt;= 1000 对于100%的数据，1 &lt;= K &lt;= N &lt;= 100000 1 &lt;= Ai &lt;= 1000000 Output 一个整数代表答案 Sample Input124 21 2 3 4Sample Output14 思路通过这个题总算明白了二分答案是怎么一回事了。 二分答案，即假设已经知道了答案，拿这个已知的答案去验证题目要求是否满足。二分答案就是在答案的可能选择的区间内，二分地枚举每一个答案是否满足题目要求，将最优性问题（难以解决）转化为可行性问题。 而这个题目，就是枚举每个可能地得分数，然后看按照这个得分数，数组能否被划分为指定的段数，如果能，这即是答案，如果不能，接着二分枚举。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN=1e5+10;ll arr[MAXN];ll n,m;ll Min=0x3f3f3f3f,Sum=0;ll check(ll x)&#123; ll ans=0,tmp=0; for(int i=1;i&lt;=n;i++) &#123; tmp+=arr[i]; if(tmp&gt;=x) ans++,tmp=0; &#125; return ans;&#125;int main()&#123;// cout&lt;&lt;(1&lt;&lt;30)&lt;&lt;endl&lt;&lt;(0x3f3f3f3f)&lt;&lt;endl; scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) &#123; scanf(&quot;%lld&quot;,&amp;arr[i]); Min=min(Min,arr[i]); Sum+=arr[i]; &#125; ll l=Min,r=2*Sum; while(l&lt;=r) &#123; if(l+1==r) break; ll mid=(l+r)/2; ll q=check(mid); if(q&lt;m) r=mid; else l=mid; &#125; printf(&quot;%lld\\n&quot;,l); return 0;&#125;/*3 21 2 3*/","categories":[{"name":"二分-三分-分治","slug":"二分-三分-分治","permalink":"https://shann.xyz/categories/%E4%BA%8C%E5%88%86-%E4%B8%89%E5%88%86-%E5%88%86%E6%B2%BB/"}],"tags":[{"name":"二分答案","slug":"二分答案","permalink":"https://shann.xyz/tags/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"}]}],"categories":[{"name":"Redis","slug":"Redis","permalink":"https://shann.xyz/categories/Redis/"},{"name":"Spring","slug":"Spring","permalink":"https://shann.xyz/categories/Spring/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://shann.xyz/categories/JavaWeb/"},{"name":"二分-三分-分治","slug":"二分-三分-分治","permalink":"https://shann.xyz/categories/%E4%BA%8C%E5%88%86-%E4%B8%89%E5%88%86-%E5%88%86%E6%B2%BB/"},{"name":"Java","slug":"Java","permalink":"https://shann.xyz/categories/Java/"},{"name":"操作系统","slug":"操作系统","permalink":"https://shann.xyz/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://shann.xyz/tags/Redis/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://shann.xyz/tags/Spring-Boot/"},{"name":"基础算法","slug":"基础算法","permalink":"https://shann.xyz/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"name":"笔记","slug":"笔记","permalink":"https://shann.xyz/tags/%E7%AC%94%E8%AE%B0/"},{"name":"二分答案","slug":"二分答案","permalink":"https://shann.xyz/tags/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"}]}