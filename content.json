{"meta":{"title":"GageShan's blog","subtitle":null,"description":"谨言慎行，勤思能动","author":"John Doe","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"hexo小配置","slug":"hexo小配置","date":"2018-08-10T12:00:32.068Z","updated":"2018-08-10T12:01:10.599Z","comments":true,"path":"2018/08/10/hexo小配置/","link":"","permalink":"http://yoursite.com/2018/08/10/hexo小配置/","excerpt":"","text":"#一、hexo部署本地图片把图片在hexo/blog/public/css/images目录下，其中(hexo/blog)是你博客所在文件夹。使用/css/images/at.png的方式进行链接。 #二、在首页只显示摘要信息12345这里写文章的简介&lt;!-- more --&gt;这里写文章的正文 未完待续……","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"http://yoursite.com/tags/小技巧/"}]},{"title":"二叉树的创建及其遍历","slug":"二叉树的创建及其遍历","date":"2018-08-09T15:37:26.625Z","updated":"2018-08-10T12:12:54.325Z","comments":true,"path":"2018/08/09/二叉树的创建及其遍历/","link":"","permalink":"http://yoursite.com/2018/08/09/二叉树的创建及其遍历/","excerpt":"二叉树是一种非常重要的数据结构，许多其他的数据结构都是基于二叉树发展推演过来的。用递归定义树的结构非常简洁，同样，递归遍历也非常简洁。在学习过程中，我发现递归算法往往只是一个简单的语句，虽然简洁的语句实现了功能，但在算法具体过程方面没有很好的阐述，我也很纠结为什么可以这么用，一次次调式试图弄明白内在机理，总是达不到预期效果，所以我转而写非递归的算法以此希望能够理解树的节点的构造、遍历。在这里，我写下这些天学习二叉树的历程。","text":"二叉树是一种非常重要的数据结构，许多其他的数据结构都是基于二叉树发展推演过来的。用递归定义树的结构非常简洁，同样，递归遍历也非常简洁。在学习过程中，我发现递归算法往往只是一个简单的语句，虽然简洁的语句实现了功能，但在算法具体过程方面没有很好的阐述，我也很纠结为什么可以这么用，一次次调式试图弄明白内在机理，总是达不到预期效果，所以我转而写非递归的算法以此希望能够理解树的节点的构造、遍历。在这里，我写下这些天学习二叉树的历程。 一、树的创建利用递归创建二叉树。123456789101112131415struct Btree *inputTree()//创建二叉树 &#123; int number; struct Btree *tree; scanf(&quot;%d&quot;,&amp;number); if(number==0)&#123; //当输入0时，表示左孩子或右孩子为空 tree=NULL; &#125;else&#123; tree=(struct Btree *)malloc(LEN); tree-&gt;data=number; tree-&gt;lchild=inputTree(); //递归左孩子 tree-&gt;rchild=inputTree(); //递归右孩子 &#125; return tree;&#125; 二、三种遍历递归实现1、先序遍历递归算法规则：先根节点，再左子树，后右子树，简记NLR。具体，可将整棵树分为左子树和右子树，然后再将左子树分为次左子树、次右子树123456789void preTraversal(struct Btree *tree)&#123; if(tree!=NULL)&#123; printf(&quot;%d &quot;,tree-&gt;data); //打印根节点 preTraversal(tree-&gt;lchild); //遍历左孩子树 preTraversal(tree-&gt;rchild); //遍历右孩子树 &#125; return;&#125; 2、中序遍历递归算法规则：先左子树，再根节点，后右子树，简记LNR。具体同先序。123456789void inTraversal(struct Btree *tree)&#123; if(tree!=NULL)&#123; preTraversal(tree-&gt;lchild); //遍历左孩子树 printf(&quot;%d&quot;,tree-&gt;data); //打印根节点 preTraversal(tree-&gt;rchild); //遍历右孩子树 &#125; return;&#125; 3、后序遍历递归算法规则：先左子树，再右子树，后根节点，简记LRN。具体同先序。12345678void postTraversal(struct Btree *tree)&#123; if(tree!=NULL)&#123; postTraversal(tree-&gt;lchild); //遍历左孩子树 postTraversal(tree-&gt;rchild); //遍历右孩子树 printf(&quot;%d &quot;,tree-&gt;data); //打印根节点 &#125;&#125; 三、三种遍历非递归实现1、先序遍历非递归算法算法主要步骤：1、当树不为空时，将根节点压入栈中；2、当栈不为空时，说明需要此时访问当前节点，退栈访问；3、查看该节点的右孩子(这里先查看右孩子是因为这是先序遍历，先遍历根节点其次左孩子最后右孩子，这里用到栈也是因为栈的特点，先进后出，后进先出)，若右孩子存在，则压入栈中；4、查看该节点的左孩子，同3；5、若栈不为空，转2，循环。12345678910111213141516171819202122232425void preTraversal(struct Btree *tree)&#123; struct Btree *stack[MAXSIZE]; struct Btree *temp; int top=-1; if(tree!=NULL)&#123; top++; stack[top]=tree; //将根节点进栈 while(top!=-1)&#123; temp=stack[top]; top--; printf(&quot;%d &quot;,temp-&gt;data); if(temp-&gt;rchild!=NULL)&#123; //右孩子不为空，进栈 top++; stack[top]=temp-&gt;rchild; &#125; if(temp-&gt;lchild!=NULL)&#123; //左孩子不为空，进栈 top++; stack[top]=temp-&gt;lchild; &#125; &#125; &#125; printf(&quot;\\n&quot;); return;&#125; 2、中序遍历非递归算法算法主要步骤：1、首先查看根节点，若根节点不为空，将其进栈；2、查看根节点的左孩子，若左孩子存在，将其进栈，继续访问以左孩子为根节点的次树；3、 若次树无左孩子，访问当前次树的根节点，然后查看该根节点的右孩子；4、循环。12345678910111213141516171819202122void inTraversal(struct Btree *tree)&#123; struct Btree *stack[MAXSIZE],*temp; int top=-1; if(tree!=NULL)&#123; temp=tree; while(top&gt;-1||temp!=NULL)&#123; if(temp!=NULL)&#123; top++; stack[top]=temp; temp=temp-&gt;lchild; &#125;else&#123; //此时说明当前次树已无左孩子，则访问该节点 temp=stack[top]; top--; printf(&quot;%d &quot;,temp-&gt;data); temp=temp-&gt;rchild; //查看该节点的右孩子 &#125; &#125; &#125; printf(&quot;\\n&quot;); return; &#125; 3、后序遍历非递归算法算法主要步骤：1、首先将根节点进栈，若栈不为空，循环；2、查看栈顶元素，若其有左孩子或右孩子并且左右孩子没有被访问，将其左孩子或右孩子入栈，否则，访问该节点；3、 在2步骤中，若访问完一节点，则用pre指针记录下来 。1234567891011121314151617181920212223242526void postTraversal(struct Btree *tree)&#123; struct Btree *stack[MAXSIZE],*temp,*pre=NULL; int top=-1; top++; stack[top]=tree; while(top!=-1)&#123; temp=stack[top]; if((temp-&gt;lchild==NULL&amp;&amp;temp-&gt;rchild==NULL)||\\ (pre!=NULL&amp;&amp;(temp-&gt;lchild==pre||temp-&gt;rchild==pre)))&#123; printf(&quot;%d &quot;,temp-&gt;data);//到此表明该节点无左右孩子 top--; //或者有左右孩子但已被访问输出，访问该节点 pre=temp; //pre指针用来记录上一访问过的节点 &#125;else&#123; if(temp-&gt;rchild!=NULL)&#123; //若右孩子存在，将其入栈 top++; stack[top]=temp-&gt;rchild; &#125; if(temp-&gt;lchild!=NULL)&#123; //若左孩子存在，将其入栈 top++; stack[top]=temp-&gt;lchild; &#125; &#125; &#125; printf(&quot;\\n&quot;); &#125; 四、源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define LEN sizeof(struct Btree)#define MAXSIZE 1000+10struct Btree&#123; int data; struct Btree *lchild,*rchild;&#125;;void preTraversal(struct Btree *tree);void inTraversal(struct Btree *tree);void postTraversal(struct Btree *tree);struct Btree *inputTree();int main()&#123; struct Btree *tree; tree=inputTree(); printf(&quot;先序遍历:\\n&quot;); preTraversal(tree); printf(&quot;中序遍历:\\n&quot;); inTraversal(tree); printf(&quot;后序遍历:\\n&quot;); postTraversal(tree); return 0;&#125;struct Btree *inputTree()//创建二叉树 &#123; int number; struct Btree *tree; scanf(&quot;%d&quot;,&amp;number); if(number==0)&#123; //当输入0时，表示左孩子或右孩子 为空 tree=NULL; &#125;else&#123; tree=(struct Btree *)malloc(LEN); tree-&gt;data=number; tree-&gt;lchild=inputTree(); //递归左孩子 tree-&gt;rchild=inputTree(); //递归右孩子 &#125; return tree;&#125;void preTraversal(struct Btree *tree)//先序递归&#123; if(tree!=NULL)&#123; printf(&quot;%d &quot;,tree-&gt;data); //打印根节点 preTraversal(tree-&gt;lchild); //遍历左孩子树 preTraversal(tree-&gt;rchild); //遍历右孩子树 &#125; return;&#125;void preTraversal(struct Btree *tree)//先序非递归&#123; struct Btree *stack[MAXSIZE]; struct Btree *temp; int top=-1; if(tree!=NULL)&#123; top++; stack[top]=tree; //将根节点进栈 while(top!=-1)&#123; temp=stack[top]; top--; printf(&quot;%d &quot;,temp-&gt;data); if(temp-&gt;rchild!=NULL)&#123; //右孩子不为空，进栈 top++; stack[top]=temp-&gt;rchild; &#125; if(temp-&gt;lchild!=NULL)&#123; //左孩子不为空，进栈 top++; stack[top]=temp-&gt;lchild; &#125; &#125; &#125; printf(&quot;\\n&quot;); return; &#125;void inTraversal(struct Btree *tree)//中序递归&#123; if(tree!=NULL)&#123; preTraversal(tree-&gt;lchild); //遍历左孩子树 printf(&quot;%d&quot;,tree-&gt;data); //打印根节点 preTraversal(tree-&gt;rchild); //遍历右孩子树 &#125; return;&#125;void inTraversal(struct Btree *tree)//中序非递归&#123; struct Btree *stack[MAXSIZE],*temp; int top=-1; if(tree!=NULL)&#123; temp=tree; while(top&gt;-1||temp!=NULL)&#123; if(temp!=NULL)&#123; top++; stack[top]=temp; temp=temp-&gt;lchild; &#125;else&#123; //此时说明当前次树已无左孩子，则访问该节点 temp=stack[top]; top--; printf(&quot;%d &quot;,temp-&gt;data); temp=temp-&gt;rchild; //查看该节点的右孩子 &#125; &#125; &#125; printf(&quot;\\n&quot;); return; &#125; void postTraversal(struct Btree *tree)//后序递归&#123; if(tree!=NULL)&#123; postTraversal(tree-&gt;lchild); //遍历左孩子树 postTraversal(tree-&gt;rchild); //遍历右孩子树 printf(&quot;%d &quot;,tree-&gt;data); //打印根节点 &#125; return;&#125;void postTraversal(struct Btree *tree)&#123; struct Btree *stack[MAXSIZE],*temp,*pre=NULL; int top=-1; top++; stack[top]=tree; while(top!=-1)&#123; temp=stack[top]; if((temp-&gt;lchild==NULL&amp;&amp;temp-&gt;rchild==NULL)||\\ (pre!=NULL&amp;&amp;(temp-&gt;lchild==pre||temp-&gt;rchild==pre)))&#123; printf(&quot;%d &quot;,temp-&gt;data);//到此表明该节点无左右孩子 top--; //或者有左右孩子但已被访问输出，访问该节点 pre=temp;//pre指针用来记录上一访问过的节点 &#125;else&#123; if(temp-&gt;rchild!=NULL)&#123;//若右孩子存在，将其入栈 top++; stack[top]=temp-&gt;rchild; &#125; if(temp-&gt;lchild!=NULL)&#123;//若左孩子存在，将其入栈 top++; stack[top]=temp-&gt;lchild; &#125; &#125; &#125; printf(&quot;\\n&quot;); return;&#125; 五、后记在用递归遍历二叉树时，总想搞明白递归遍历的过程是怎么样的，但每次都以头昏脑涨结尾。说实话，递归说它难，也就那样，说它简单，但……总之，用递归求解时，不要深究细节，逻辑对，递归一定对。最后若有什么想法，欢迎在评论区留言。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"http://yoursite.com/tags/c-c/"}]},{"title":"I am coming","slug":"hello-world","date":"2018-08-02T01:30:58.139Z","updated":"2018-08-10T09:32:48.802Z","comments":true,"path":"2018/08/02/hello-world/","link":"","permalink":"http://yoursite.com/2018/08/02/hello-world/","excerpt":"","text":"ONE 将学习and工作中遇到的问题记录下来，小白成长为大佬，若干年后，相必值得回味。 这是我的第一篇博客。想写博客，但会不会变成为了写博客而写博客呢，不知道。认真地想，以往遇到问题，求助知乎、csdn、博客园，大部分问题都能得到很好的解决，感慨众多大神and大佬的无私分享，遂生出想法，记录问题，待知识丰富后，再来看看这些，希望能够得到些许乐趣吧。 ——GageShan 于2018.08.02 夜","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}],"tags":[]}]}