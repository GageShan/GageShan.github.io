<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java实现批量解压zip文件</title>
    <url>/2020/02/01/java/Java%E5%AE%9E%E7%8E%B0%E8%A7%A3%E5%8E%8Bzip%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>到网上下载的教学视频一般都是经过层层压缩的，手动解压的耗时耗力，遂写了个程序自动解压。</p>
<p>主要利用了Java核心库中的ZipInputStream类。<br><span id="more"></span><br>代码：</p>
<p>其中File src为目标文件，String des为要存储到的存储路径<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unZip</span><span class="params">(File src,String des)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    ZipInputStream zipInputStream = <span class="keyword">new</span> ZipInputStream(<span class="keyword">new</span> FileInputStream(src),</span><br><span class="line">            Charset.forName(<span class="string">&quot;gbk&quot;</span>));</span><br><span class="line"></span><br><span class="line">    ZipEntry zipEntry = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((zipEntry = zipInputStream.getNextEntry()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(des + File.separator + zipEntry.getName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(zipEntry.isDirectory()) &#123;</span><br><span class="line">            file.mkdirs();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        file.getParentFile().mkdirs();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        FileOutputStream out = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>((len = zipInputStream.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            out.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">    zipInputStream.closeEntry();</span><br><span class="line">    zipInputStream.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>遇到的问题：<br>在定义ZipInputStream类时，如果不指定文件流的编码格式，则默认为utf-8。假如要解压的文件路径中包含中文，则会抛出异常：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Exception <span class="keyword">in</span> thread <span class="string">&quot;main&quot;</span> java.lang.IllegalArgumentException: malformed input off : 19, length : 1</span><br></pre></td></tr></table></figure></p>
<p>这时就要手动指定编码格式了。</p>
<p>见源码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ZipInputStream</span><span class="params">(InputStream in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(in, StandardCharsets.UTF_8);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ZipInputStream</span><span class="params">(InputStream in, Charset charset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="keyword">new</span> PushbackInputStream(in, <span class="number">512</span>), <span class="keyword">new</span> Inflater(<span class="keyword">true</span>), <span class="number">512</span>);</span><br><span class="line">    usesDefaultInflater = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (in == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;in is null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (charset == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;charset is null&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.zc = ZipCoder.get(charset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于ZipInputStream中是没有编码常量的，所以需要借助<code>Charset.forName(&quot;gbk&quot;)</code>来指定。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java Web基础（Servlet、Cookie、Session、Jsp回顾整理）</title>
    <url>/2020/02/18/java/Java%20Web%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="一、servlet"><a href="#一、servlet" class="headerlink" title="一、servlet"></a>一、servlet</h1><p>servlet是JavaWeb三大组件之一，属于动态资源</p>
<p>servlet有两种创建顺序，第一是在服务器启动时创建，第二是用户访问时创建。服务器启动时创建需要在web.xml中配置<load-on-startup>0</load-on-startup>来实现，其中，0就是创建的次序，数字越小，越先创建。<br><span id="more"></span></p>
<h3 id="实现-javax-servlet-Servlet-接口"><a href="#实现-javax-servlet-Servlet-接口" class="headerlink" title="实现 javax.servlet.Servlet  接口"></a>实现 javax.servlet.Servlet  接口</h3><p>生命周期方法：</p>
<ul>
<li>void init(ServletConfig servletconfig) servlet被创建之后立即调用，只执行1次 </li>
<li>void service(ServletRequest requset,ServletResponse servletresponse) 执行多次</li>
<li>void destory() servlet被销毁之前调用，只执行1次</li>
</ul>
<p>特性：</p>
<ul>
<li>单例，一个类只有一个对象。可以存在多个servlet</li>
<li>线程是不安全的，所以它的效率非常高</li>
</ul>
<p>servlet由我们来写，但对象由服务器来创建，方法也由服务器来调用。</p>
<h3 id="实现-javax-servlet-GenericServlet-类"><a href="#实现-javax-servlet-GenericServlet-类" class="headerlink" title="实现 javax.servlet.GenericServlet  类"></a>实现 javax.servlet.GenericServlet  类</h3><h3 id="实现-javax-servlet-HttpServlet-类"><a href="#实现-javax-servlet-HttpServlet-类" class="headerlink" title="实现 javax.servlet.HttpServlet  类"></a>实现 javax.servlet.HttpServlet  类</h3><ul>
<li>void service(ServletRequest req, ServletResponse res) </li>
<li>protected void service(HttpServletRequest req, HttpServletResponse resp)  </li>
<li>protected void doPut(HttpServletRequest req, HttpServletResponse resp)  </li>
<li>protected void doPost(HttpServletRequest req, HttpServletResponse resp)  </li>
</ul>
<p>HttpServlet类结构介绍：在实例化HttpServlet后，先调用service(ServletRequest, ServletResponse)方法，在这个方法中将ServletRequest和ServletResponse强转为HttpServletRequest和HttpServletResponse，最后根据HttpServletRequest中的参数决定调用doPost方法还是doGet方法</p>
<p>注意：如果没有覆写doPost或doGet方法，当这两个方法被调用时，浏览器会出现405错误，表示不支持该种请求方式。</p>
<h2 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h2><p>一个项目中只有一个ServletContext（也叫做application），所以可以在多个servlet中利用这个对象来传递数据。</p>
<p>服务器为每一个应用程序创建ServletContext对象，ServletContext对象在服务器启动时创建，在服务器关闭时销毁。</p>
<p>获取ServletContext</p>
<ul>
<li>ServletConfig#getServletContext()</li>
<li>GenericServlet#getServletContext()</li>
<li>HttpSession#getServletContext()</li>
<li>ServletContextEvent#getServletContext()</li>
</ul>
<h3 id="统计网页访问量小案例"><a href="#统计网页访问量小案例" class="headerlink" title="统计网页访问量小案例"></a>统计网页访问量小案例</h3><p>从ServletContext中利用getAttribute方法获取访问量count值，如果访问量值为null，说明本次访问是第一次访问，利用setAttribute方法将访问量保存下来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bservlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        ServletContext servletContext = <span class="keyword">this</span>.getServletContext();</span><br><span class="line">        Integer count = (Integer)servletContext.getAttribute(<span class="string">&quot;count&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="keyword">null</span>) &#123;</span><br><span class="line">            servletContext.setAttribute(<span class="string">&quot;count&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            servletContext.setAttribute(<span class="string">&quot;count&quot;</span>,count + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        PrintWriter pw = resp.getWriter();</span><br><span class="line">        pw.println(<span class="string">&quot;&lt;h1&gt;&quot;</span> + count + <span class="string">&quot;&lt;/h1&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PrintWriter是向网页输出的输出流，从response中获取对象。</p>
<h2 id="获取类路径资源"><a href="#获取类路径资源" class="headerlink" title="获取类路径资源"></a>获取类路径资源</h2><p>如果在文件路径前写有‘/’，那么此时对准的文件路径起始点就是classes目录下，如果不写，那么对准的文件路径起始点就是 <code>.class</code>文件目录下。</p>
<p>两种方式：</p>
<ul>
<li>ClassLoader</li>
<li>Class</li>
</ul>
<h3 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h3><p>如果资源文件存在于src目录下，那么直接使用getResourceAsStream(“a.txt”)，就可以获取文件资源；<br>如果资源文件存在于其它包目录下，假如存在于包web/day1_3下，那么将文件路径写全即可getResourceAsStream(“web/day1_3/a.txt”)。</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">       ClassLoader classLoader = <span class="keyword">this</span>.getClass().getClassLoader();</span><br><span class="line">       InputStream input = classLoader.getResourceAsStream(<span class="string">&quot;web/day1_3/a.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((len = input.read(data)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            String line = <span class="keyword">new</span> String(data,<span class="number">0</span>,len);</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">        input.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><p>Class是相对于classes文件来说的。<code>.java</code>文件会被编译成<code>.class</code>文件存放于classes目录下。</p>
<p>如果资源文件与调用该文件的<code>.class</code>文件处于同一路径，那么直接使用getResourceAsStream(“a.txt”)即可；</p>
<p>如果处于不同路径，例如存放于src目录下，那么使用getResourceAsStream(“/a.txt”)；</p>
<p>如果处于其它包下，例如存放于/web/day1_2下，而<code>.class</code>文件位于/web/day1_3下，那么使用getResourceAsStream(“/web/day1_2/a.txt”)即可。</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Class cl = <span class="keyword">this</span>.getClass();</span><br><span class="line">        InputStream input = cl.getResourceAsStream(<span class="string">&quot;/web/day1_2/a.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((len = input.read(data)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            String line = <span class="keyword">new</span> String(data,<span class="number">0</span>,len);</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">        input.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二、cookie"><a href="#二、cookie" class="headerlink" title="二、cookie"></a>二、cookie</h1><p>cookie是以键值对的形式由服务器发送给浏览器保存在客户端上的。属于Http。</p>
<p>示例代码：</p>
<p>添加cookie<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cookie cookie1 = <span class="keyword">new</span> Cookie(<span class="string">&quot;aaa&quot;</span>,<span class="string">&quot;AAA&quot;</span>);</span><br><span class="line">response.addCookie(cookie1);</span><br></pre></td></tr></table></figure><br>获取cookie的key<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cookie.getName();</span><br></pre></td></tr></table></figure><br>获取cookie的value<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cookie.getValue()</span><br></pre></td></tr></table></figure></p>
<p>设置cookie的生命周期</p>
<p>cookie#setMaxAge(int MaxAge);</p>
<ul>
<li>MaxAge &lt; 0，浏览器一旦关闭，该cookie即死亡</li>
<li>MaxAge = 0，该cookie立即被销毁</li>
<li>MaxAge &gt; 0，cookie存活时间，以秒为单位</li>
</ul>
<p>cookie的path：</p>
<p>如果访问路径包含cookie的保存路径，则会将该cookie带回给服务器</p>
<h1 id="三、HttpSession"><a href="#三、HttpSession" class="headerlink" title="三、HttpSession"></a>三、HttpSession</h1><p>HttpSession是由JavaWeb提供的，Servlet三大域对象之一。</p>
<hr>
<p>三大域对象：</p>
<ul>
<li>request，一次请求对应一个request，但一个request可以在多个servlet中传递</li>
<li>session，一个用户对应一个session，同一个用户的请求都在同一个session内</li>
<li>application（ServletContex），一个应用程序对应一个application，应用程序不死，application不死</li>
</ul>
<hr>
<p><strong>作用域范围</strong></p>
<p>session的会话范围从用户打开浏览器访问服务器开始到关闭浏览器结束。<br>生命周期：session默认存活30分钟。</p>
<p>理解：一个Session就是一个会话。一个用户可以对一个服务器发出多个request，一个session包含多个request。</p>
<p>很少出现并发请求，session保存在服务器端。</p>
<p>转发：地址栏不发生改变，写的路径不需要带项目名<br>重定向：地址栏发生改变，写的路径需要带项目名。重定向后就是两个不同的请求</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>当用户访问服务器时，服务器会创建一个session，并分配一个sessionId，这个sessionId跟创建的session对应。session会被保存在服务器端，而sessionId会被保存在cookie中。</p>
<p>创建了新的session，浏览器会得到一个包含sessionId的cookie，这个cookie的生命为-1，即只保存在内存中，当浏览器关闭时，cookie即被销毁。</p>
<p>之后请求session时，因为可以通过cookie中的sessionIs找到session，所以与上次请求的session是同一session对象。</p>
<p>服务器并不会一开始就创建session，而是第一次获取session时才会创建。</p>
<p><strong>session最大不活跃时间</strong></p>
<p>session有一个最大不活跃时间，当用户不对页面做任何操作时，session或被服务器销毁，下次就需要重新创建session，这样做可以保证用户信息安全。</p>
<h1 id="四、JSP"><a href="#四、JSP" class="headerlink" title="四、JSP"></a>四、JSP</h1><p>三种jsp脚本</p>
<p>1、&lt;% — %&gt;，方法体内能写什么就能写什么</p>
<p>2、&lt;%= — %&gt;，out.write()能写什么就写什么</p>
<p>3、&lt;%! — %&gt;，类里面能写什么就能写什么，一般不用，用了会被敲死</p>
<h2 id="jsp指令"><a href="#jsp指令" class="headerlink" title="jsp指令"></a>jsp指令</h2><p>一个jsp页面中，可以有0个或N个page指令。</p>
<p>三大指令：</p>
<ul>
<li>page</li>
<li>include</li>
<li>taglib</li>
</ul>
<hr>
<p><strong>page</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> pageEncoding=<span class="string">&quot;utf-8&quot;</span> %&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>contentType和pageEncoding是等价的，一个什么值另一个也是同样的值，所以一般只用设置一个。如果两个都没有设置，那么默认是iso。</p>
</blockquote>
<blockquote>
<p>import：导入Java包，可以使用多次</p>
</blockquote>
<blockquote>
<p>errorPage：当当前页面抛出异常，则转发到指定页面，设置状态码为200</p>
</blockquote>
<blockquote>
<p>isErrorPage：设置某个页面为处理错误页面，当属性为true时，会设置状态码为500。并且只有这个页面能使用九大内置对象中的Exception。</p>
</blockquote>
<p><strong>include</strong><br>静态包含，将多个jsp文件合并成一个文件然后被编译成.class文件，在运行之前就合并。</p>
<h2 id="九大内置对象"><a href="#九大内置对象" class="headerlink" title="九大内置对象"></a>九大内置对象</h2><ul>
<li>out（response.getWriter()），jsp的输出流，用来响应客户端</li>
<li>page，当前jsp对象，它的引用类型是Object，即真身中有以下代码：Object page = this;</li>
<li>exception（Throwable）</li>
<li>request（HttpServletRequest）</li>
<li>response（HttpServletResponse）</li>
<li>config（ServletConfig），对应真身中的ServletConfig</li>
<li>session（HttpSession）</li>
<li>pageContext，一个顶九个</li>
<li>application（ServletContext）</li>
</ul>
<p>servlet三大域对象，jsp四大域对象。</p>
<ul>
<li>ServletContext，作用于整个应用程序</li>
<li>session，整个会话，一个会话只有一个用户</li>
<li>request，一次请求，一个请求可能跨多个servlet</li>
<li>pageContext，一个jsp页面，在当前页面和当前页面所使用的标签之间共享数据。<blockquote>
<p>1、代理其它域；<br>  pageContext.setAttribute(“xxx”,”XXX”，PageContext.PAGE_SCOPE);<br>2、全域查找；<br>  pageContext.findAttribute(“xxx”);从范围较小的域查到范围大的域，小域优先于大域<br>3、获取其它域对象</p>
</blockquote>
</li>
</ul>
<h2 id="jsp动作标签"><a href="#jsp动作标签" class="headerlink" title="jsp动作标签"></a>jsp动作标签</h2><p>动作标签是由服务器来执行的，而静态的html是由浏览器的解释的。</p>
<p><a href="jsp:forward">jsp:forward</a> 请求转发<br><a href="jsp:include">jsp:include</a> 动态包含，在运行的时候调用另一个页面。与&lt;%@include&gt;不同。<br><a href="jsp:param">jsp:param</a> 作为include和forward的子标签，用来给转发和包含的页面传值。</p>
<h2 id="JavaBean规范"><a href="#JavaBean规范" class="headerlink" title="JavaBean规范"></a>JavaBean规范</h2><p>1、必须要有一个默认构造器<br>2、提供get/set方法，如果只有get方法，那么这个是可读属性<br>3、属性：有get/set方法的成员，还可以没有成员。属性名称由get/set方法来决定，即get/set方法名称去掉get/set后小写的名称。</p>
<h2 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h2><p>EL是jsp内置的表达式语言。<br>作用：</p>
<ul>
<li>替代&lt;%= … %&gt;，也就是说，EL是用来输出的</li>
<li>读取四大域对象，${xxx}，全域查找名为xxx的属性，如果不存在就输出空串而不是null。${pageScope.xxx}、${requestScope.xxx}、${sessionScope.xxx}、${applicationScope.xxx}，指定域获取属性。</li>
<li>javaBean导航，${requestScope.emp.address.street}，使用El获取request域的emp —-&gt; request.getAttribute(“emp”).getAddress().getStreet()。</li>
</ul>
<h3 id="EL函数库"><a href="#EL函数库" class="headerlink" title="EL函数库"></a>EL函数库</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;fn&quot;</span> uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/functions&quot;</span> %&gt;</span><br><span class="line"></span><br><span class="line">$&#123;fn:toLowerCase(<span class="string">&quot;Hellowosdio&quot;</span>)&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jstl"><a href="#jstl" class="headerlink" title="jstl"></a>jstl</h3><h4 id="core库"><a href="#core库" class="headerlink" title="core库"></a>core库</h4><h5 id="out标签"><a href="#out标签" class="headerlink" title="out标签"></a>out标签</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">request.setAttribute(<span class="string">&quot;code&quot;</span>,<span class="string">&quot;&lt;script&gt;alter(&#x27;helloworld&#x27;);&lt;/script&gt;&quot;</span>);</span><br><span class="line">%&gt;</span><br><span class="line">$&#123;code&#125;</span><br><span class="line">&lt;c:out value=<span class="string">&quot;$&#123;code&#125;&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>
<h5 id="set标签"><a href="#set标签" class="headerlink" title="set标签"></a>set标签</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;c:set <span class="keyword">var</span>=<span class="string">&quot;name&quot;</span> value=<span class="string">&quot;&lt;script&gt;alter(&#x27;helloworld&#x27;);&lt;/script&gt;&quot;</span> scope=<span class="string">&quot;request&quot;</span>/&gt;</span><br><span class="line">&lt;c:out value=<span class="string">&quot;$&#123;name&#125;&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>重要属性：scope：默认为page，可选值为page，request，session，application。</p>
<h5 id="remove标签"><a href="#remove标签" class="headerlink" title="remove标签"></a>remove标签</h5><p>如果不写scope，那么删除的全域中所有的属性</p>
<h5 id="url标签"><a href="#url标签" class="headerlink" title="url标签"></a>url标签</h5><p>value属性：指定一个路径名，自动在路径前面添加项目名。</p>
<p>注意：路径名必须以斜杠开头<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;c:url value=<span class="string">&quot;/Aservlet&quot;</span> /&gt;</span><br><span class="line"><span class="comment">//在页面上输出/jsp/Aservlet</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;c:url value=<span class="string">&quot;/Aservlet&quot;</span> &gt;</span><br><span class="line">    &lt;c:param name=<span class="string">&quot;name&quot;</span> value=<span class="string">&quot;gageshan&quot;</span> /&gt;</span><br><span class="line">&lt;/c:url&gt;</span><br><span class="line"><span class="comment">// 输出为 jsp/Aservlet?name=gageshan</span></span><br></pre></td></tr></table></figure>
<p>重要属性：var：指定变量名，添加这个属性后，url标签就不会输出到页面中，而是会保存到域中。<br>scope：与var一起使用，将url标签保存到域中。</p>
<h5 id="if、choose"><a href="#if、choose" class="headerlink" title="if、choose"></a>if、choose</h5><p>if对应Java中的if语句，choose对应Java中的if/else if/else</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">&quot;11&gt;4&quot;</span>&gt;</span><br><span class="line">    &lt;c:out value=<span class="string">&quot;/a&quot;</span>/&gt;</span><br><span class="line">&lt;/c:if&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;c:choose&gt;</span><br><span class="line">    &lt;c:when test=&quot;&quot;&gt;&lt;/c:when&gt;</span><br><span class="line">    &lt;c:when test=&quot;&quot;&gt;&lt;/c:when&gt;</span><br><span class="line">    &lt;c:when test=&quot;&quot;&gt;&lt;/c:when&gt;</span><br><span class="line">    &lt;c:otherwise&gt;&lt;/c:otherwise&gt;</span><br><span class="line">&lt;/c:choose&gt;</span><br></pre></td></tr></table></figure>
<h5 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h5><p>用来循环遍历数组，集合。<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;c:forEach <span class="keyword">var</span>=<span class="string">&quot;i&quot;</span> begin=<span class="string">&quot;1&quot;</span> end=<span class="string">&quot;10&quot;</span> step=<span class="string">&quot;1&quot;</span>&gt;</span><br><span class="line">$&#123;i&#125;</span><br><span class="line">&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure></p>
<p>重要的属性：items：指定要循环谁，可以是数组或者集合，items=”${…}”，不能写有空格。var：将数组或集合中的元素赋给var指定的变量。varStatus，循环状态变量。</p>
<h4 id="fmt"><a href="#fmt" class="headerlink" title="fmt"></a>fmt</h4><p>格式化库</p>
<h5 id="格式化日期"><a href="#格式化日期" class="headerlink" title="格式化日期"></a>格式化日期</h5><p>&lt;fmt:formatDate value=”” pattern=””&gt;</p>
<p>value：指定一个Date类型变量<br>pattern：指定输出的模板，”yyyy-mm-dd HH:mm:ss”</p>
<h5 id="格式化数字"><a href="#格式化数字" class="headerlink" title="格式化数字"></a>格式化数字</h5><p>&lt;fmt:formatNumber value=”${num1}” pattern=”0.00” /&gt;<br>pattern：0.00：保留小数点后两位，不足两位以0来补，并且会四舍五入。#.##，不补位。</p>
<h3 id="自定义标签"><a href="#自定义标签" class="headerlink" title="自定义标签"></a>自定义标签</h3><p>写标签类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> web.day3_2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.jsp.JspException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.jsp.tagext.JspTag;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.jsp.tagext.SimpleTagSupport;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTag1</span> <span class="keyword">extends</span> <span class="title">SimpleTagSupport</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTag</span><span class="params">()</span> <span class="keyword">throws</span> JspException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.getJspContext().getOut().write(<span class="string">&quot;hello tag&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置tld文件<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;ISO-8859-1&quot;</span>?&gt;</span><br><span class="line"></span><br><span class="line">&lt;taglib xmlns=<span class="string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span></span><br><span class="line">        xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">        xsi:schemaLocation=<span class="string">&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-jsptaglibrary_2_1.xsd&quot;</span></span><br><span class="line">        version=<span class="string">&quot;2.1&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;tlib-version&gt;1.0&lt;/tlib-version&gt;</span><br><span class="line">    &lt;short-name&gt;itcast&lt;/short-name&gt;</span><br><span class="line">    &lt;uri&gt;http:<span class="comment">//www.itcast.cn/tags/it-1.0&lt;/uri&gt;</span></span><br><span class="line"></span><br><span class="line">    &lt;!-- Invoke <span class="string">&#x27;Generate&#x27;</span> action to add tags or functions --&gt;</span><br><span class="line">    &lt;tag&gt;</span><br><span class="line">        &lt;name&gt;mytag1&lt;/name&gt;</span><br><span class="line">        &lt;tag-<span class="class"><span class="keyword">class</span>&gt;<span class="title">web</span>.<span class="title">day3_2</span>.<span class="title">MyTag1</span>&lt;/<span class="title">tag</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">body</span>-<span class="title">content</span>&gt;<span class="title">empty</span>&lt;/<span class="title">body</span>-<span class="title">content</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;/<span class="title">tag</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">taglib</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
  </entry>
  <entry>
    <title>Redis持久化方式</title>
    <url>/2021/05/04/redis/redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F%EF%BC%88rdb-aof%EF%BC%89/</url>
    <content><![CDATA[<p>[TOC]<br>redis持久化分为rdb和aof，rdb是将整个数据库保存为二进制文件，aof则是记录命令的方式保存。</p>
<h1 id="一、rdb"><a href="#一、rdb" class="headerlink" title="一、rdb"></a>一、rdb</h1><p>rdb持久化功能所生成的rdb文件是一个经过压缩的二进制文件。<br>在载入rdb文件过程中，redis服务器一直处于阻塞状态，直到载入完毕。<br><img src="https://img-blog.csdnimg.cn/20210504230640320.png" alt="在这里插入图片描述"></p>
<h2 id="创建rdb文件的两种方式"><a href="#创建rdb文件的两种方式" class="headerlink" title="创建rdb文件的两种方式"></a>创建rdb文件的两种方式</h2><p>有两个命令可以用来保存rdb文件，save和bgsave。<br>不同的是，save命令会阻塞redis服务器进程，直到rdb文件创建完成，在此期间不再处理redis命令。<br>而bgsave则是fork父进程，由子进程负责rdb文件的创建，在子进程创建rdb文件过程中，redis服务器任然会处理redis命令。</p>
<span id="more"></span>
<h2 id="1、save、bgsave、bgrewriteaof"><a href="#1、save、bgsave、bgrewriteaof" class="headerlink" title="1、save、bgsave、bgrewriteaof"></a>1、save、bgsave、bgrewriteaof</h2><p>1、为了避免产生竞争条件，在bgsave命令执行期间，redis服务器会拒绝save和bgsave命令<br>2、在bgsave命令执行过程中，客户端发送的bgrewriteaof命令会被延后到bgsave命令执行完<br>3、在bgrewriteaof命令执行过程中，客户端发送的bgsave命令会被拒绝</p>
<h2 id="2、自动间隔性保存"><a href="#2、自动间隔性保存" class="headerlink" title="2、自动间隔性保存"></a>2、自动间隔性保存</h2><p>用户可以通过设置服务器配置的save选项，让服务器每隔一段时间自动执行一次bgsave。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">save 900 1       900秒内数据库至少修改1次</span><br><span class="line">save 300 10     300秒内数据库至少修改10次</span><br><span class="line">save 60 1000    60秒内数据库至少修改1000次</span><br></pre></td></tr></table></figure>
<p>redis服务器使用saveparams数组来保存这些信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span> &#123;</span></span><br><span class="line">        <span class="keyword">time_t</span> seconds;<span class="comment">//秒数</span></span><br><span class="line">        <span class="keyword">int</span> changes;<span class="comment">//修改数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span> *<span class="title">saveprames</span>;</span><span class="comment">//记录保存条件的数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210504230601214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dhZ2VzaGFu,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="3、dirty、lastsave属性"><a href="#3、dirty、lastsave属性" class="headerlink" title="3、dirty、lastsave属性"></a>3、dirty、lastsave属性</h2><p>redis服务器维护了一个dirty计数器和lastsave属性。</p>
<ul>
<li>dirty表示自上次执行save或者bgsave命令后服务器对数据库进行了多少次更新操作（包括增加，修改，删除）</li>
<li>lastsave是一个unix时间戳，记录服务器上一次执行save或者bgsave命令<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct redisServer &#123;</span><br><span class="line">        long long dirty;&#x2F;&#x2F;计数器</span><br><span class="line">        time_t lastsave;&#x2F;&#x2F;上一次执行保存的时间</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
redis服务器周期性操作函数serverCron默认每隔100毫秒就会执行一次，这个函数就会检查save选项配置是否已经满足，如果满足就执行bgsave命令。<h1 id="二、aof"><a href="#二、aof" class="headerlink" title="二、aof"></a>二、aof</h1>aof持久化是通过保存redis服务器执行的命令来实现持久化功能的。<br><img src="https://img-blog.csdnimg.cn/20210504230711135.png" alt="在这里插入图片描述"></li>
</ul>
<h2 id="1、aof持久化实现"><a href="#1、aof持久化实现" class="headerlink" title="1、aof持久化实现"></a>1、aof持久化实现</h2><h3 id="1、命令追加"><a href="#1、命令追加" class="headerlink" title="1、命令追加"></a>1、命令追加</h3><p>redis服务器在执行完一个命令后，会以协议格式将被执行的命令追加到服务器状态的aof_buf缓冲区末尾。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">        sds aof_buf;<span class="comment">//aof缓冲区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、aof文件的写入和同步"><a href="#2、aof文件的写入和同步" class="headerlink" title="2、aof文件的写入和同步"></a>2、aof文件的写入和同步</h3><p>redis服务器实际上就是一个事件循环，这个循环中的文件事件会处理客户端的命令请求；时间事件则处理如serverCron函数这样需要定时运行的函数。<br>服务器在每次结束一个事件循环之前，都会调用flushAppendOnlyFile函数，考虑是否将aof_buf缓冲区中的内容写入和保存到aof文件里面。<br><img src="https://img-blog.csdnimg.cn/20210504230842158.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dhZ2VzaGFu,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="1、always"><a href="#1、always" class="headerlink" title="1、always"></a>1、always</h4><p>服务器在每个事件循环都要将aof_buf中的内容写入并且同步到aof文件中，always是三个选项中效率最慢的，但即使出现故障停机，aof持久化也只会丢失一个事件循环中的命令数据</p>
<h4 id="2、everysec"><a href="#2、everysec" class="headerlink" title="2、everysec"></a>2、everysec</h4><p>服务器在每个数据循环都要将aof_buf中的内容写入aof文件，并且每个一秒就要在子线程中对aof文件进行同步。everysec效率足够快，如果出现故障停机只会丢失一秒钟信息。</p>
<h4 id="3、no"><a href="#3、no" class="headerlink" title="3、no"></a>3、no</h4><p>服务器在每个事件循环中都要对aof_buf中的内容写入到aof文件中，至于何时对aof文件进行同步则要看操作系统的调度。no是三者中效率最高的，但单次同步时间最长。</p>
<h2 id="2、aof文件载入与数据还原"><a href="#2、aof文件载入与数据还原" class="headerlink" title="2、aof文件载入与数据还原"></a>2、aof文件载入与数据还原</h2><p>redis服务器读取aof文件的顺序步骤</p>
<ul>
<li>创建一个不带网络连接的伪客户端（因为redis命令只能在客户端上下文中执行）</li>
<li>从aof文件中读取一条写命令</li>
<li>使用伪客户端执行读取的命令</li>
<li>循环，直到所有的命令都被处理完毕</li>
</ul>
<h2 id="3、aof重写"><a href="#3、aof重写" class="headerlink" title="3、aof重写"></a>3、aof重写</h2><p>对于aof持久化来说，如果事无巨细的将全部命令保存下来，随着redis不间断运行，那势必会造成aof文件无比巨大，使得载入数据的时候会多很多无用功。<br>为了解决aof文件体积过大的问题，redis提供了aof文件重写的功能。通过这个功能，redis会创建一个新的aof文件来代替旧的aof文件。新旧aof文件数据库状态相同，但新aof文件不会包含冗余的命令。</p>
<h3 id="1、重写实现"><a href="#1、重写实现" class="headerlink" title="1、重写实现"></a>1、重写实现</h3><p>新的aof文件不会对旧的aof文件造成任何影响，新的aof文件由当前数据库状态得来。<br>重写前</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sadd a 1</span><br><span class="line">sadd a 2</span><br><span class="line">sadd a 3</span><br><span class="line">srem a 1</span><br></pre></td></tr></table></figure>
<p>重写后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sadd a  2 3</span><br></pre></td></tr></table></figure>
<p>值得注意的一点是，为了避免执行命令过程中造成客户端输入缓冲区溢出，重写程序在处理列表、哈希表、集合、有序集合这些可能带有多个元素的时候，会先检查元素的数量超过了redis.h/REDIS_AOF_REWRITE_LITEMS_PER_CMD（64）常量时，会使用多条命令来代替单条命令。</p>
<h3 id="2、后台重写"><a href="#2、后台重写" class="headerlink" title="2、后台重写"></a>2、后台重写</h3><p>由于aof重写程序aof_rewrite会进行大量的文件写入操作，所以调用这个函数的线程会被长时间的阻塞，redis服务器使用单线程处理命令请求，如果由服务器直接调用aof_write函数，那么在aof文件重写期间，服务器将无法处理命令请求。<br>redis将aof重写程序放到子进程中执行，子进程获得了父进程的数据副本，避免了锁的使用。同时父进程也可以继续处理命令请求。</p>
<p>由于在子进程中执行aof重写程序，子进程获取到的只是父进程的数据副本，在aof重写过程中，父进程可能会处理其它的命令请求，这就会使得数据库状态与重写后的aof文件不一致。<br>为了解决数据不一致的问题，redis服务器设置了一个aof重写缓冲区，这个缓冲区在服务器创建子进程之后才开始使用。redis服务器在执行完一个写命令后，会将这个写命令同时发送给aof缓冲区和aof重写缓冲区。</p>
<p>当子进程完成aof重写工作，子进程会向父进程发送一个信号，父进程接受到该信号后，会调用一个信号处理函数，这个函数会执行一下操作。</p>
<ul>
<li>将aof重写缓冲区内容写入到新的aof文件，这是新的aof文件所保存的数据库状态与redis服务器当前数据库状态保持一致</li>
<li>对新的aof文件进行改名，原子覆盖现有的aof文件，完成两个文件的新旧交替。<br>这个函数执行完毕后，父进程就会像往常一样接受命令请求。</li>
</ul>
<p>在整个aof后台重写过程中，只有信号处理函数执行过程中才会对父进程造成阻塞，在其它时候，aof后台重写都不会阻塞父进程。<br>aof后台重写也就是bgsavewriteaof命令。</p>
<h1 id="三、aof与rdb的不同"><a href="#三、aof与rdb的不同" class="headerlink" title="三、aof与rdb的不同"></a>三、aof与rdb的不同</h1><h2 id="1、保存格式不同"><a href="#1、保存格式不同" class="headerlink" title="1、保存格式不同"></a>1、保存格式不同</h2><p>rdb文件是一个经过压缩的二进制文件，aof文件则是记录命令。</p>
<h2 id="2、使用优先级"><a href="#2、使用优先级" class="headerlink" title="2、使用优先级"></a>2、使用优先级</h2><p>aof更新频率比rdb高，当redis服务器开启了aof持久化功能，那么服务器会优先使用aof文件来还原数据库，只有在aof持久化功能关闭时，才使用rdb文件。<br><img src="https://img-blog.csdnimg.cn/20210504230507667.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dhZ2VzaGFu,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>银行家算法实现</title>
    <url>/2019/11/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/OS%E5%AE%9E%E9%AA%8C%E4%BA%94-%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>操作系统编程小作业</p>
<p><a href="https://shann.xyz/2019/10/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81/">银行家算法详细讲解</a><br><span id="more"></span><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> process_MAXN = <span class="number">5</span>; <span class="comment">// the process number</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> resource_MAXN = <span class="number">3</span>; <span class="comment">// the resource number</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bankAlgorithm</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> Available[resource_MAXN] = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> tmpAvailable[process_MAXN][resource_MAXN]; <span class="comment">//</span></span><br><span class="line">    <span class="keyword">int</span> Max[process_MAXN][resource_MAXN] = &#123; &#123;<span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>&#125;,&#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;,&#123;<span class="number">9</span>, <span class="number">0</span>, <span class="number">2</span>&#125;,&#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>&#125;,&#123;<span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>&#125; &#125;;</span><br><span class="line">    <span class="keyword">int</span> Allocation[process_MAXN][resource_MAXN] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,&#123;<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,&#123;<span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>&#125;,&#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> Need[process_MAXN][resource_MAXN] = &#123;&#123;<span class="number">7</span>, <span class="number">4</span>, <span class="number">3</span>&#125;,&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>&#125;,&#123;<span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,&#123;<span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> processId = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> request[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> visit[process_MAXN][<span class="number">3</span>] = &#123;&#123;<span class="number">0</span>&#125;&#125;; <span class="comment">// the priority of visit</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mainCtrl</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHelloworld</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inputData</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">outputData</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">sendRequest</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tryToAskResource</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showInformation</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showError</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bankAlgorithm::mainCtrl</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">inputData</span>();</span><br><span class="line">    <span class="built_in">outputData</span>();</span><br><span class="line">    <span class="built_in">sendRequest</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bankAlgorithm::sayHelloworld</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\thello the cruel world\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bankAlgorithm::inputData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input the process id and the three request resource\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;processId,&amp;request[<span class="number">0</span>],&amp;request[<span class="number">1</span>],&amp;request[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bankAlgorithm::outputData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ProcessId：%d\nrequest：&quot;</span>,processId);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; resource_MAXN; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,request[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bankAlgorithm::sendRequest</span><span class="params">()</span> <span class="comment">//no bug</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; resource_MAXN; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(request[i] &gt; Need[processId][i]) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;The requested resource has exceeded the required resource\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(request[i] &gt; Available[i]) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;The requested resource has exceeded the Available resource\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">tryToAskResource</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bankAlgorithm::tryToAskResource</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; resource_MAXN; i++) &#123;</span><br><span class="line">        Available[i] -= request[i];</span><br><span class="line">        Need[processId][i] -= request[i];</span><br><span class="line">        Allocation[processId][i] += request[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>; <span class="comment">//the visitted priority</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; process_MAXN; i++) &#123;</span><br><span class="line">        visit[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">bool</span> judgeToRun = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; process_MAXN; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!visit[i][<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; resource_MAXN; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(Available[j] &lt; Need[i][j]) &#123;</span><br><span class="line">                        flag = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; resource_MAXN; j++) &#123;</span><br><span class="line">                        tmpAvailable[i][j] = Available[j];</span><br><span class="line">                        Available[j] += Allocation[i][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                    judgeToRun = <span class="literal">false</span>;</span><br><span class="line">                    visit[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                    visit[i][<span class="number">1</span>] = cnt++;</span><br><span class="line">                    visit[i][<span class="number">2</span>] = i;</span><br><span class="line"><span class="comment">//                    cout&lt;&lt;&quot;i = &quot;&lt;&lt;i&lt;&lt;endl;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(judgeToRun) &#123;<span class="keyword">break</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    sayHelloworld();</span></span><br><span class="line"><span class="comment">//    cout&lt;&lt;cnt&lt;&lt;&#x27; &#x27;&lt;&lt;process_MAXN&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">if</span>(cnt != process_MAXN) &#123;</span><br><span class="line">        <span class="built_in">showError</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">showInformation</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bankAlgorithm::showInformation</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Resource\tMax\tAvailable     Allocation    Need      Work\n&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> tmp[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in"><span class="keyword">sizeof</span></span>(visit[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; process_MAXN; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; process_MAXN; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(visit[i][<span class="number">1</span>] &gt; visit[j][<span class="number">1</span>]) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">memcpy</span>(tmp,visit[i],len);</span><br><span class="line">                <span class="built_in">memcpy</span>(visit[i],visit[j],len);</span><br><span class="line">                <span class="built_in">memcpy</span>(visit[j],tmp,len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; process_MAXN; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> process_id = visit[i][<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t%d &quot;</span>,process_id);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; resource_MAXN; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,Max[process_id][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t   &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; resource_MAXN; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,tmpAvailable[process_id][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; resource_MAXN; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,Allocation[process_id][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t    &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; resource_MAXN; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,Need[process_id][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; resource_MAXN; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,tmpAvailable[process_id][j] + Allocation[process_id][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bankAlgorithm::showError</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sorry,you can&#x27;t allocate resources to %d.\nBecause the Available resource can&#x27;t satisfy any of the Process\n&quot;</span>,processId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bankAlgorithm</span> <span class="title">shan</span>;</span></span><br><span class="line">    shan.<span class="built_in">mainCtrl</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>处理机调度</title>
    <url>/2019/11/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/</url>
    <content><![CDATA[<p>操作系统笔记</p>
<h1 id="层次和目标"><a href="#层次和目标" class="headerlink" title="层次和目标"></a>层次和目标</h1><p>处理机调度分为三个层次，分别为</p>
<ul>
<li>高级调度（作业调度），将处于后备队列中的作业调入内存</li>
<li>中级调度（内存调度），将暂时不能运行的进程调至外存等待</li>
<li>低级调度（进程调度），决定就绪队列中的哪个进程（或线程）得到处理机资源</li>
</ul>
<p>不同类型的操作系统采用了不同的处理机调度算法。调度算法应当使得系统资源利用率尤其是处理机的利用率尽可能地高（资源利用率），要保证每个进程都能获得合理的CPU时间（公平性），还要保证系统的各种资源使用的平衡性（平衡性），另外对制定的策略只要需要就一定要执行（策略强制执行性）。<br><span id="more"></span></p>
<h1 id="作业调度"><a href="#作业调度" class="headerlink" title="作业调度"></a>作业调度</h1><p>在多道批处理系统中，作业是用户提交给系统的一项想多独立的工作。作业不仅包含通常说的程序和数据还有配有一份作业说明书。</p>
<p>当一个作业进入系统时，相应的调度程序为其建立一个作业控制块（Job Control Block，JCB），JCB中含有该作业的有关信息（比如作业标识、类型、优先级等），之后把这个作业放入后备队列中等待后续调度。</p>
<p>作业从进入系统到运行结束经过了3个阶段。</p>
<ul>
<li>后备状态，系统建立JCB并将该作业放入后备队列等待作业调度。</li>
<li>运行阶段，作业被作业调度进程分配相关的资源后调入就绪队列。</li>
<li>完成状态，当作业完成或者发生异常情况提前结束，被系统收回已分配的资源。</li>
</ul>
<p>作业调度要根据JCB中相关信息检查系统中是否有足够的资源满足该作业的需求，之后按照相应的调度算法从外存中的后备队列中选取作业调入内存中的就绪队列，为其创建进程、分配相应的资源。</p>
<p>作业调度应该调度哪些作业呢？这取决于系统采用的调度算法。比较常用的有先来先服务算法、短作业优先算法和高响应比优先调度算法。</p>
<p>先来先服务算法（First come first served，FCFS）：FCFS算法按照作业到达系统的先后顺序来调度作业。</p>
<p>短作业优先算法（Short job first SJF）：SJF算法按照作业的估计运行时间长短来调度作业。可以发现，这种算法有不少的缺点，实际上是很难估计作业的运行时间，而且这种算法对长作业是非常不利的，长作业的周转时间会明显的增长，完全忽视长作业的等待时间，导致长作业的实际完成时间被拉长，这是用户不想得到的结果。当用户急需完成某一任务，而该任务的估计运行时间较长，该紧急长作业在后备队列中等待被调度时，这时来了一个短作业，那么，短作业先被调度，紧急作业长延后无法被调度，不能保证紧急作业得到及时处理。</p>
<p>高响应比优先调度算法（Highest response ratio next,HRRN）：HRRN算法结合了FCFS和SJF算法。为每一个作业设置一个优先级，在后备队列中作业按照优先级排序等待被调度。</p>
<p>优先权 = $\frac{等待时间 + 要求服务时间}{要求服务时间}$<br>HRRN的缺点是在进行调度之前都要进行一次响应比计算，无疑这会增加系统开销。</p>
<h1 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h1><p>在进行进程调度的时候首先要将当前正在使用处理机的进程的相关信息保存到进程的进程控制块中，比如程序计数器、寄存器中的内容。其次根据一定的调度算法选取就绪队列中的进程。最后将处理机分配给选取的进程，并将进程控制块中的相关信息填入处理机，让它从上次的断点处恢复运行。</p>
<h2 id="进程调度的机制"><a href="#进程调度的机制" class="headerlink" title="进程调度的机制"></a>进程调度的机制</h2><ul>
<li>排队器，按照一定的策略将进程排序</li>
<li>分派器，根据调度程序选出进程，将其从就绪队列中取出，将处理机分配给该进程</li>
<li>上下文切换器，在进行进程切换时，保存旧进程的相关信息，并将新进程的信息填入处理机中</li>
</ul>
<h2 id="进程调度方式"><a href="#进程调度方式" class="headerlink" title="进程调度方式"></a>进程调度方式</h2><p>1.非抢占式，一旦把处理机分配给某一进程后，除非这个进程发出中断或者异常，否则一直运行下去，直至完成。</p>
<p>2.抢占式，这种调度方式允许调度程序根据某种原则去暂停某个正在执行的程序，转而将处理机分配给其他进程。</p>
<p>注意，在分时系统中，只有抢占式才能实现人机交互。</p>
<p>抢占式也并不是一种任意的行为，它也必须遵循一定的原则。<br>1.允许优先权高的抢占优先权低的。<br>2.允许新调入就绪队列中的短进程抢占正在运行的长进程，即当前运行的长进程的尚需运行时间明显比短进程要求运行时间长时，允许抢占。<br>3.如果调度算法是基于时间片原则的，当前进程在属于它的时间片内尚未执行完毕，可被其他进程抢占。</p>
<h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><p>较常用的算法有基于时间片的轮转调度算法（Round robin，RR）。</p>
<p>RR算法让就绪队列中进程每次仅能获得一个时间片，在一个时间片用完该进程还未执行完毕就换下一个进程。由此确保每个进程在一定时间间隔内都能获得一次处理机。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>银行家算法避免死锁问题</title>
    <url>/2019/10/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81/</url>
    <content><![CDATA[<p>操作系统笔记</p>
<p><a href="https://shann.xyz/2019/11/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/OS%E5%AE%9E%E9%AA%8C%E4%BA%94-%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/">算法实现</a></p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>在死锁避免方法中，把系统的状态分为安全状态和不安全状态。系统处于安全状态，可以避免发生死锁；而当系统处于不安全状态时，则可能发生死锁。<br>死锁是要尽量避免的。<br><span id="more"></span><br>安全状态举例：</p>
<p>现有P1、P2、P3三个进程，它们需要一定的资源才能完成各自的任务，每一种资源一旦被一个进程占用，就不予许另外的进程申请，而当某一进程完成任务时，该进程占用的资源就会释放，也就是说资源可被其它的进程使用。如果三个进程都无妨申请资源以完成各自的任务，这三个进程就会发生死锁。</p>
<p>现在我们需要找到一条有效的执行序列，使得每一个进程都得以执行，不会出现无法申请资源而死锁。</p>
<table>
<thead>
<tr>
<th>进程</th>
<th>最大需求</th>
<th>已分配</th>
<th>还需要</th>
<th>可用</th>
</tr>
</thead>
<tbody>
<tr>
<td>P1</td>
<td>10</td>
<td>5</td>
<td>5</td>
<td>3</td>
</tr>
<tr>
<td>P2</td>
<td>4</td>
<td>2</td>
<td>2</td>
<td>NULL</td>
</tr>
<tr>
<td>P3</td>
<td>9</td>
<td>2</td>
<td>7</td>
<td>NULL</td>
</tr>
</tbody>
</table>
<p>注<br>最大需求：进程需要该数量资源才能执行<br>已分配：已经分配给该进程的资源数量<br>还需要：即进程一旦申请申请到该数量的资源就可以执行，也就是`还需要 = 最大需求 - 已分配<br>可用：系统中还可以的申请的资源数量，每个尚未完成的进程都可以申请</p>
<p>现在系统中还有3个资源可以被申请。此时，P1需要5个资源，P3需要7个资源，系统可分配的资源不足以分配使得它们执行，只能分配给还需资源数小于可分配数的P2进程。</p>
<p>这样，那就分配2个资源给P2进程，可分配资源还剩下1个。P2进程得到后可执行完成，接着就会释放4个资源，由此，系统可分配资源就增加到了5个。</p>
<p>P1进程还需要5个资源就可以执行完成，所以，我们就可以把可以分配的5个资源全部分配给P1进程，等P1进程执行完成释放10个资源后，可分配的资源就增加到了10个资源。</p>
<p>把可分配资源全部分配给P3进程，使得P3进程执行完成。可分配资源就增加到了12个，当然，不用去管这个问题了，因为我们的进程都已经执行完毕。</p>
<p>由此，我们可以找到一条安全的执行序列P2-&gt;P1-&gt;P3，使得三个进程得以安全的执行而不会发生死锁。</p>
<p>在分配资源给一个进程时，我们需要先尝试着是否能分配资源，如果分配资源后，剩下的资源不足以使得还未完成的进程形成一条安全的执行序列，这就说明此时我们不能分配，如果能够形成安全的序列，则可以分配。</p>
<p>某进程发出资源请求后，相应地可用资源减少，该进程的资源状态改变（也就是上面说的已分配、可用、还需资源数）。剩下的就是在所有进程中找到一条=使所有进程进入安全状态的执行序列。能找到，则可分配，否则不能。有个这个认识，我们就可以来说下<strong>银行家算法</strong>了。<br>（这段话是基于理论上的，实际上，要先确定能够分配，资源才会减少，但这并不会妨碍我们的解释）</p>
<p>当一个新进程进入系统时，它必须申明在运行过程中，可能需要的每种资源类型的最大单元数，这个数量不应该超过系统所拥有的资源总数，否则无法执行这个新进程。银行家算法来确定当这个新进程发出资源请求时，是否能够满足这个请求。</p>
<p>下面介绍下银行家算法中涉及到的数据结构。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>Available</td>
<td>一个含有M个元素的数组，每个元素代表每类资源的可用数量</td>
<td>[1,2,3,4]</td>
</tr>
<tr>
<td>Max</td>
<td>一个N*M的矩阵，Max[i][j]表示第i个进程需要的最大资源需求</td>
<td>[[1,2,3],[1,2,3],[1,2,3]]</td>
</tr>
<tr>
<td>Allocation</td>
<td>一个N*M的矩阵，Allocation[i][j]表示第i个进程已经分配了多少资源</td>
<td></td>
</tr>
<tr>
<td>Need</td>
<td>一个N*M的矩阵，Need[i][j]表示第i个进程还多少资源就可以参与执行</td>
</tr>
</tbody>
</table>
<p>事实上，这跟我们开篇所提到的安全状态举例类似，我们可以把Max看一个单个的数组，代表每个进程最大资源需求数，当然，已经从一类资源变为多种资源。Allocation和Need也是一样。在银行家算法中使用矩阵统一表示是为了方便。</p>
<p>已知：Need = Max - Allocation</p>
<p>当一个进程完成后，系统将回收该进程占用的资源，即 Available = Available + Max。</p>
<p>银行家算法是为了避免进程死锁的，也就是说，系统提出资源请求时，会有一个Request数组，表示该进程请求的每类资源的数量。</p>
<p>注意：</p>
<ul>
<li>Request &lt;= Need，否则认为出错，因为它申请的资源（Request）不能大于它实际需要的资源（Need）。</li>
<li>Request &lt;= Available，否则认为出错，因为此时申请的资源（Request）已经超过系统可分配的资源，它必须等待</li>
</ul>
<h1 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h1><p>现系统中有5个进程，分别为P0、P1、P2、P3、P4和3类资源A、B、C。各类资源的数量分别为10、5、7。</p>
<p>具体情况见下表</p>
<p>表1</p>
<table>
<thead>
<tr>
<th>表1</th>
<th>资源情况</th>
<th>Max</th>
<th>Allocation</th>
<th>Need</th>
<th>Available</th>
</tr>
</thead>
<tbody>
<tr>
<td>-</td>
<td>进程</td>
<td>A  B  C</td>
<td>A  B  C</td>
<td>A  B  C</td>
<td>A  B  C</td>
</tr>
<tr>
<td>-</td>
<td>P0</td>
<td>7   5    3</td>
<td>0   1   0</td>
<td>7   4  3</td>
<td>3    3   2</td>
</tr>
<tr>
<td>-</td>
<td>P1</td>
<td>3   2    1</td>
<td>2   0   0</td>
<td>1   2  2</td>
</tr>
<tr>
<td>-</td>
<td>P2</td>
<td>9   0    2</td>
<td>3   0   2</td>
<td>6   0  0</td>
</tr>
<tr>
<td>-</td>
<td>p3</td>
<td>2   2    2</td>
<td>2   1   1</td>
<td>0   1  1</td>
</tr>
<tr>
<td>-</td>
<td>p4</td>
<td>4   3    3</td>
<td>0   0   2</td>
<td>4   3  1</td>
</tr>
</tbody>
</table>
<p>现在我们要来找一条能够让这5个进程不发生死锁的执行序列。</p>
<p>需要知道一个进程一旦执行完毕，系统就可以收回该进程所占用的各类资源。所以或许我们可以总结出这样一条规则：总是将系统可以分配的资源全部分配给一个进程来帮助这个进程尽快执行完毕，这样等它执行完毕，系统就回收它占用的资源，从而就可以帮助其他需要资源的多的进程。也就是说，或许把资源分配给资源需求数少的进程是一种较优选择。</p>
<p>如此一来，仔细分析上述表格，我们可以推导出这样一条执行序列：</p>
<p>P1-&gt;P3-&gt;P4-&gt;P2-&gt;P0。</p>
<p>对应</p>
<p>表2：</p>
<table>
<thead>
<tr>
<th>表2</th>
<th>资源情况</th>
<th>Available</th>
<th>Allocation</th>
<th>Need</th>
<th>Available + Allocation</th>
</tr>
</thead>
<tbody>
<tr>
<td>-</td>
<td>进程</td>
<td>A  B  C</td>
<td>A  B  C</td>
<td>A  B  C</td>
<td>A  B  C</td>
</tr>
<tr>
<td>-</td>
<td>P1</td>
<td>3 3 2</td>
<td>2 0 0</td>
<td>1 2 2</td>
<td>5 3 2</td>
</tr>
<tr>
<td>-</td>
<td>P3</td>
<td>5 3 2</td>
<td>2 1 1</td>
<td>0 1 1</td>
<td>7 4 3</td>
</tr>
<tr>
<td>-</td>
<td>P4</td>
<td>7 4 3</td>
<td>0 0 2</td>
<td>4 3 1</td>
<td>7 4 5</td>
</tr>
<tr>
<td>-</td>
<td>p2</td>
<td>7 4 5</td>
<td>3 0 2</td>
<td>6 0 0</td>
<td>10 4 7</td>
</tr>
<tr>
<td>-</td>
<td>p0</td>
<td>10 4 7</td>
<td>0 1 0</td>
<td>7 4 3</td>
<td>10 5 7</td>
</tr>
</tbody>
</table>
<h2 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h2><p>此时P1请求资源，发出Request(1,0,2)，请求1个A资源，0个B资源，2个C资源。</p>
<p>分析</p>
<ul>
<li>Request(1,0,2) &lt;= Need(1,2,2)</li>
<li>Request(1,0,2) &lt;= Available(3 3 2)</li>
</ul>
<p>现在假设可以为它分配资源，那么P1的资源状态会有如下变化：<br>表3：</p>
<table>
<thead>
<tr>
<th>表3</th>
<th>资源情况</th>
<th>Max</th>
<th>Allocation</th>
<th>Need</th>
<th>Available</th>
</tr>
</thead>
<tbody>
<tr>
<td>-</td>
<td>进程</td>
<td>A  B  C</td>
<td>A  B  C</td>
<td>A  B  C</td>
<td>A  B  C</td>
</tr>
<tr>
<td>-</td>
<td>P3</td>
<td>3 2 2</td>
<td>3 0 2</td>
<td>0 2 0</td>
<td>2 3 0</td>
</tr>
</tbody>
</table>
<p>也就是Allocation中A+1，C+2，Need中A-1，C-2。</p>
<p>可以看到，此时，系统可以分配的资源就变为了Available(2,3,0)。知道了系统资源可分配量，我们就要在这5个进程中找一个安全序列。再次强调，如果可以找到，就说明<strong>假设的分配资源</strong>可以实现，否则不行。</p>
<p>接着看5个进程的Need资源量，从中我们要找到一个进程为它分配资源。</p>
<p>发现P3的Need(0,1,1) &lt;= Available(2,3,0)，如果将资源分配给他，P3进程得到资源后可立即执行，执行完毕后可释放资源，这也就意味着Available数量会增加，变化的Available(4,4 1)，就可以分配给那些资源需求量大的进程。直到全部进程执行完毕。</p>
<p>表4：</p>
<table>
<thead>
<tr>
<th>表4</th>
<th>资源情况</th>
<th>Available</th>
<th>Allocation</th>
<th>Need</th>
<th>Available + Allocation</th>
</tr>
</thead>
<tbody>
<tr>
<td>-</td>
<td>进程</td>
<td>A  B  C</td>
<td>A  B  C</td>
<td>A  B  C</td>
<td>A  B  C</td>
</tr>
<tr>
<td>-</td>
<td>P1</td>
<td>2 3 0</td>
<td>3 0 2</td>
<td>0 2 0</td>
<td>5 3 2</td>
</tr>
<tr>
<td>-</td>
<td>P3</td>
<td>5 3 2</td>
<td>2 1 1</td>
<td>0 1 1</td>
<td>7 4 3</td>
</tr>
<tr>
<td>-</td>
<td>P4</td>
<td>7 4 3</td>
<td>0 0 2</td>
<td>4 3 1</td>
<td>7 4 5</td>
</tr>
<tr>
<td>-</td>
<td>p2</td>
<td>7 4 5</td>
<td>3 0 2</td>
<td>6 0 0</td>
<td>10 4 7</td>
</tr>
<tr>
<td>-</td>
<td>p0</td>
<td>10 4 7</td>
<td>0 1 0</td>
<td>7 4 3</td>
<td>10 5 7</td>
</tr>
</tbody>
</table>
<p>安全序列：</p>
<ul>
<li>P1-&gt;P3-&gt;P4-&gt;P2-P0</li>
<li>P1-&gt;P3-&gt;P4-&gt;P0-&gt;P2</li>
</ul>
<p>可以响应请求。</p>
<h2 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h2><p>P4发出请求Request(3,3,0)。<br>分析</p>
<ul>
<li>Request(3,3,0) &lt;= Need(4,3,1)</li>
<li>Request(3,3,0) &gt; Available(2,3,0)，不满足条件，让P4等待</li>
</ul>
<p>不能响应请求。</p>
<h2 id="问题三"><a href="#问题三" class="headerlink" title="问题三"></a>问题三</h2><p>P0发出请求Request(0,2,0)<br>分析</p>
<ul>
<li>Request(0,2,0) &lt;= Need(7,4,3)</li>
<li>Request(0,2,0) &lt;= Available(2,3,0)</li>
</ul>
<p>先假设可以分配资源，那么P0资源状态变化为</p>
<p>表5：</p>
<table>
<thead>
<tr>
<th>表5</th>
<th>资源情况</th>
<th>Max</th>
<th>Allocation</th>
<th>Need</th>
<th>Available</th>
</tr>
</thead>
<tbody>
<tr>
<td>-</td>
<td>进程</td>
<td>A  B  C</td>
<td>A  B  C</td>
<td>A  B  C</td>
<td>A  B  C</td>
</tr>
<tr>
<td>-</td>
<td>P0</td>
<td>7 5 3</td>
<td>0 3 0</td>
<td>7 2 3</td>
<td>2 1 0</td>
</tr>
</tbody>
</table>
<p>此时的系统资源为Available(2,1,0)，可以看到无法满足任何一个进程的Need请求。</p>
<p>不响应请求。</p>
<h2 id="问题四"><a href="#问题四" class="headerlink" title="问题四"></a>问题四</h2><p>P0发出请求Request(0,1,0)<br>分析</p>
<ul>
<li>Request(0,1,0) &lt;= Need(7,4,3)</li>
<li>Request(0,1,0) &lt;= Available(3,3,2)</li>
</ul>
<p>可以找到这样一条安全序列<br>P1-&gt;P3-&gt;P4-&gt;P2-&gt;P0</p>
<p>表6：</p>
<table>
<thead>
<tr>
<th>表6</th>
<th>资源情况</th>
<th>Available</th>
<th>Allocation</th>
<th>Need</th>
<th>Available + Allocation</th>
</tr>
</thead>
<tbody>
<tr>
<td>-</td>
<td>进程</td>
<td>A  B  C</td>
<td>A  B  C</td>
<td>A  B  C</td>
<td>A  B  C</td>
</tr>
<tr>
<td>-</td>
<td>P1</td>
<td>3 2 2</td>
<td>2 0 0</td>
<td>1 2 2</td>
<td>5 2 2</td>
</tr>
<tr>
<td>-</td>
<td>P3</td>
<td>5 2 2</td>
<td>2 1 1</td>
<td>0 1 1</td>
<td>7 3 3</td>
</tr>
<tr>
<td>-</td>
<td>P4</td>
<td>7 3 3</td>
<td>0 0 2</td>
<td>4 3 1</td>
<td>7 3 5</td>
</tr>
<tr>
<td>-</td>
<td>p2</td>
<td>7 3 5</td>
<td>3 0 2</td>
<td>6 0 0</td>
<td>10 3 7</td>
</tr>
<tr>
<td>-</td>
<td>p0</td>
<td>10 3 7</td>
<td>0 2 0</td>
<td>7 3 3</td>
<td>10 5 7</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>数组划分游戏 HihoCoder - 1948 (二分答案)</title>
    <url>/2019/09/21/%E4%BA%8C%E5%88%86/%E6%95%B0%E7%BB%84%E5%88%92%E5%88%86%E6%B8%B8%E6%88%8F%20HihoCoder%20-%201948%20%EF%BC%88%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://cn.vjudge.net/problem/HihoCoder-1948">https://cn.vjudge.net/problem/HihoCoder-1948</a></p>
<p>小Hi在玩一个有关数组划分的游戏。给定一个整数K和一个长度为N的数组A=[A1, A2, … AN]，小Hi需要将它划分为K个连续子数组，并对每个子数组求和。</p>
<p>不妨设这K个子数组的和依次是S1, S2, … SK，则小Hi的得分是其中的最小值即min(S1, S2, … SK)。  </p>
<p>例如对于A=[1, 2, 3, 4]和K=2，小Hi可以划分成[1, 2]和[3, 4]，这样得分是3；也可以划分成[1, 2, 3]和[4]，这样得分是4。</p>
<p>对于给定的K和数组A，你能帮助小Hi算出他最多能得多少分吗？</p>
<p>Input<br>第一行包含两个整数N和K。  </p>
<p>第二行包含N个整数A1, A2, … AN。  </p>
<p>对于60%的数据，1 &lt;= N &lt;= 1000  </p>
<p>对于100%的数据，1 &lt;= K &lt;= N &lt;= 100000  1 &lt;= Ai &lt;= 1000000</p>
<p>Output</p>
<p>一个整数代表答案</p>
<p>Sample Input<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 2</span><br><span class="line">1 2 3 4</span><br></pre></td></tr></table></figure><br>Sample Output<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>通过这个题总算明白了<strong>二分答案</strong>是怎么一回事了。</p>
<p>二分答案，即假设已经知道了答案，拿这个已知的答案去验证题目要求是否满足。二分答案就是在答案的可能选择的区间内，二分地枚举每一个答案是否满足题目要求，将最优性问题（难以解决）转化为可行性问题。</p>
<p>而这个题目，就是枚举每个可能地得分数，然后看按照这个得分数，数组能否被划分为指定的段数，如果能，这即是答案，如果不能，接着二分枚举。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">ll arr[MAXN];</span><br><span class="line">ll n,m;</span><br><span class="line">ll Min=<span class="number">0x3f3f3f3f</span>,Sum=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">check</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>,tmp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        tmp+=arr[i];</span><br><span class="line">        <span class="keyword">if</span>(tmp&gt;=x) ans++,tmp=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    cout&lt;&lt;(1&lt;&lt;30)&lt;&lt;endl&lt;&lt;(0x3f3f3f3f)&lt;&lt;endl;</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;arr[i]);</span><br><span class="line">        Min=<span class="built_in">min</span>(Min,arr[i]);</span><br><span class="line">        Sum+=arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ll l=Min,r=<span class="number">2</span>*Sum;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r) &#123;</span><br><span class="line">        <span class="keyword">if</span>(l+<span class="number">1</span>==r) <span class="keyword">break</span>;</span><br><span class="line">        ll mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">        ll q=<span class="built_in">check</span>(mid);</span><br><span class="line">        <span class="keyword">if</span>(q&lt;m) r=mid;</span><br><span class="line">        <span class="keyword">else</span> l=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3 2</span></span><br><span class="line"><span class="comment">1 2 3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>二分-三分-分治</category>
      </categories>
      <tags>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot使用@Autowired注入对象为null</title>
    <url>/2020/05/08/java/springboot%E4%BD%BF%E7%94%A8@autowried%E6%B3%A8%E5%85%A5%E5%AF%B9%E8%B1%A1%E4%B8%BAnull/</url>
    <content><![CDATA[<p>在做项目的时候，在某类使用@Autowired注入了一个Service层的对象，但在使用的时候，却发现这个Service层实例为null值。</p>
<p>原因：当使用new关键字创建对象时，虽然使用了@Autowired对这个对象进行装配，但实际上Spring不会这样做。因为Spring不会对任何一个new出来的对象进行自动装配，只有当一个对象也是一个在Spring中注册过的Bean，才会获得自动装配的功能<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Configuration</span>：指明当前类是一个配置类；就是来替代之前的Spring配置文件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在配置文件中用&lt;bean&gt;&lt;bean/&gt;标签添加组件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HelloService <span class="title">helloService02</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;配置类@Bean给容器中添加组件了...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HelloService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>@Configuration会告知Spring这是一个配置类，会为Spring上下文提供bean。@Bean标注的方法表明这些方法返回的对象会以bean的形式添加到Spring的应用上下文中（默认情况下，bean所对应的bean Id就是定义的方法名称）。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>第二讲 二分与前缀和</title>
    <url>/2020/02/04/%E4%BA%8C%E5%88%86/%E7%AC%AC%E4%BA%8C%E8%AE%B2%20%E4%BA%8C%E5%88%86%E4%B8%8E%E5%89%8D%E7%BC%80%E5%92%8C/</url>
    <content><![CDATA[<h1 id="数的范围"><a href="#数的范围" class="headerlink" title="数的范围"></a>数的范围</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个按照升序排列的长度为n的整数数组，以及 q 个查询。</p>
<p>对于每个查询，返回一个元素k的起始位置和终止位置（位置从0开始计数）。</p>
<p>如果数组中不存在该元素，则返回“-1 -1”。<br><span id="more"></span><br>输入格式<br>第一行包含整数n和q，表示数组长度和询问个数。</p>
<p>第二行包含n个整数（均在1~10000范围内），表示完整数组。</p>
<p>接下来q行，每行包含一个整数k，表示一个询问元素。</p>
<p>输出格式<br>共q行，每行包含两个整数，表示所求元素的起始位置和终止位置。</p>
<p>如果数组中不存在该元素，则返回“-1 -1”。</p>
<p>数据范围<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1≤n≤100000</span><br><span class="line">1≤q≤10000</span><br><span class="line">1≤k≤10000</span><br></pre></td></tr></table></figure><br>输入样例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 3</span><br><span class="line">1 2 2 3 3 4</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 4</span><br><span class="line">5 5</span><br><span class="line">-1 -1</span><br></pre></td></tr></table></figure></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>整数二分模板题。<br><img src="https://img-blog.csdnimg.cn/20200204160012747.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dhZ2VzaGFu,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span>[] q = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100100</span>];</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">int</span> n,m;</span><br><span class="line">		n = sc.nextInt();</span><br><span class="line">		m = sc.nextInt();</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			q[i] = sc.nextInt();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(m-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">int</span> x = sc.nextInt();</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">				<span class="keyword">int</span> mid = (l + r) /<span class="number">2</span>;</span><br><span class="line">				<span class="keyword">if</span>(q[mid] &gt;= x) &#123;</span><br><span class="line">					r = mid;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					l = mid + <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(q[l] == x) &#123;</span><br><span class="line">				System.out.print(l + <span class="string">&quot; &quot;</span>);</span><br><span class="line">				r = n - <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">					<span class="keyword">int</span> mid = (l + r + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">					<span class="keyword">if</span>(q[mid] &lt;= x) &#123;</span><br><span class="line">						l = mid;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						r = mid - <span class="number">1</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(q[l] == x) &#123;</span><br><span class="line">					System.out.println(l);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;-1 -1&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="数的三次方根"><a href="#数的三次方根" class="headerlink" title="数的三次方根"></a>数的三次方根</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>给定一个浮点数n，求它的三次方根。</p>
<p>输入格式<br>共一行，包含一个浮点数n。</p>
<p>输出格式<br>共一行，包含一个浮点数，表示问题的解。</p>
<p>注意，结果保留6位小数。</p>
<p>数据范围<br>−10000≤n≤10000<br>输入样例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1000.00</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.000000</span><br></pre></td></tr></table></figure></p>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>实数二分。<br>要注意的点是当题目指出要保留多少位小数时，在计算时一般多指定两位参与运算。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DecimalFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">double</span> n = sc.nextDouble();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">double</span> l = -<span class="number">10000d</span>,r = <span class="number">10000d</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(r - l &gt; <span class="number">1e-8</span>) &#123;</span><br><span class="line">			<span class="keyword">double</span> mid = (r + l) / <span class="number">2</span>;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(mid * mid * mid &lt; n)  &#123;</span><br><span class="line">				l = mid;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> r = mid;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="keyword">new</span> DecimalFormat(<span class="string">&quot;#.000000&quot;</span>).format(l));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="子矩阵的和"><a href="#子矩阵的和" class="headerlink" title="子矩阵的和"></a>子矩阵的和</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>输入一个n行m列的整数矩阵，再输入q个询问，每个询问包含四个整数x1, y1, x2, y2，表示一个子矩阵的左上角坐标和右下角坐标。</p>
<p>对于每个询问输出子矩阵中所有数的和。</p>
<p>输入格式<br>第一行包含三个整数n，m，q。</p>
<p>接下来n行，每行包含m个整数，表示整数矩阵。</p>
<p>接下来q行，每行包含四个整数x1, y1, x2, y2，表示一组询问。</p>
<p>输出格式<br>共q行，每行输出一个询问的结果。</p>
<p>数据范围<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1≤n,m≤1000,</span><br><span class="line">1≤q≤200000,</span><br><span class="line">1≤x1≤x2≤n,</span><br><span class="line">1≤y1≤y2≤m,</span><br><span class="line">−1000≤矩阵内元素的值≤1000</span><br></pre></td></tr></table></figure></p>
<p>输入样例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 4 3</span><br><span class="line">1 7 2 4</span><br><span class="line">3 6 2 8</span><br><span class="line">2 1 2 3</span><br><span class="line">1 1 2 2</span><br><span class="line">2 1 3 4</span><br><span class="line">1 3 3 4</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">17</span><br><span class="line">27</span><br><span class="line">21</span><br></pre></td></tr></table></figure></p>
<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>二维数组前缀和模板题。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mg[i][j] += mg[i - <span class="number">1</span>][j] + mg[i][j] - mg[i - <span class="number">1</span>][j -<span class="number">1</span>]</span><br></pre></td></tr></table></figure></p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span>[][] row = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span>[][] col = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line">	<span class="keyword">static</span> BufferedReader sc = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		String line = sc.readLine();</span><br><span class="line">		String src[] = line.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">		<span class="keyword">int</span> n = Integer.parseInt(src[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">int</span> m = Integer.parseInt(src[<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">int</span> q = Integer.parseInt(src[<span class="number">2</span>]);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			 line = sc.readLine();</span><br><span class="line">			src = line.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">			<span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span>(String str : src) &#123;</span><br><span class="line">				</span><br><span class="line">				row[i][j] = Integer.parseInt(str);</span><br><span class="line">				col[i][j] = col[i - <span class="number">1</span>][j] + col[i][j - <span class="number">1</span>] - col[i - <span class="number">1</span>][j - <span class="number">1</span>] + row[i][j];</span><br><span class="line">				</span><br><span class="line">				j++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(q--  &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			line = sc.readLine();</span><br><span class="line">			</span><br><span class="line">			src = line.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">			<span class="keyword">int</span> a = Integer.parseInt(src[<span class="number">0</span>]);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">int</span> b = Integer.parseInt(src[<span class="number">1</span>]);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">int</span> c = Integer.parseInt(src[<span class="number">2</span>]);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">int</span> d = Integer.parseInt(src[<span class="number">3</span>]);</span><br><span class="line">			System.out.println(col[c][d] - col[c][b - <span class="number">1</span>] - col[a - <span class="number">1</span>][d] + col[a - <span class="number">1</span>][b  - <span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="机器人跳跃问题"><a href="#机器人跳跃问题" class="headerlink" title="机器人跳跃问题"></a>机器人跳跃问题</h1><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h2><p>机器人正在玩一个古老的基于DOS的游戏。</p>
<p>游戏中有N+1座建筑——从0到N编号，从左到右排列。</p>
<p>编号为0的建筑高度为0个单位，编号为 i 的建筑高度为H(i)个单位。</p>
<p>起初，机器人在编号为0的建筑处。</p>
<p>每一步，它跳到下一个（右边）建筑。</p>
<p>假设机器人在第k个建筑，且它现在的能量值是E，下一步它将跳到第k+1个建筑。</p>
<p>如果H(k+1)&gt;E，那么机器人就失去H(k+1)-E的能量值，否则它将得到E-H(k+1)的能量值。</p>
<p>游戏目标是到达第N个建筑，在这个过程中能量值不能为负数个单位。</p>
<p>现在的问题是机器人以多少能量值开始游戏，才可以保证成功完成游戏？</p>
<p>输入格式<br>第一行输入整数N。</p>
<p>第二行是N个空格分隔的整数，H(1),H(2),…,H(N)代表建筑物的高度。</p>
<p>输出格式<br>输出一个整数，表示所需的最少单位的初始能量值。</p>
<p>数据范围<br>1≤N,H(i)≤10^5,</p>
<p>输入样例1：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">3 4 3 2 4</span><br></pre></td></tr></table></figure><br>输出样例1：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><br>输入样例2：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">4 4 4</span><br></pre></td></tr></table></figure><br>输出样例2：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><br>输入样例3：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 6 4</span><br></pre></td></tr></table></figure><br>输出样例3：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure></p>
<h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>二分答案。</p>
<p>二分初始能量值（即0-10^5），将每次得到的数带入题中所给的条件，看能否满足要求，不断地缩小答案数量。</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXN = <span class="number">100005</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">long</span>[] q = <span class="keyword">new</span> <span class="keyword">long</span>[MAXN];</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> n;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">check1</span><span class="params">(<span class="keyword">long</span> mid)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(q[i] &gt; mid) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">long</span> mid)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(check1(mid)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(mid &lt; q[i]) &#123;</span><br><span class="line">				mid = mid - (q[i] - mid);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				mid = mid + (mid - q[i]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(mid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		</span><br><span class="line">		n = sc.nextInt();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			q[i] = sc.nextLong();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">long</span> l = <span class="number">0</span>, r = MAXN;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">			<span class="keyword">long</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(check(mid)) &#123;</span><br><span class="line">				r = mid;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				l = mid + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(l);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>
<h1 id="四平方和"><a href="#四平方和" class="headerlink" title="四平方和"></a>四平方和</h1><h2 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h2><p>四平方和定理，又称为拉格朗日定理：</p>
<p>每个正整数都可以表示为至多 4 个正整数的平方和。</p>
<p>如果把 0 包括进去，就正好可以表示为 4 个数的平方和。</p>
<p>比如：</p>
<p>5=0^2+0^2+1^2+2^2</p>
<p>7=1^2+1^2+1^2+2^2</p>
<p>对于一个给定的正整数，可能存在多种平方和的表示法。</p>
<p>要求你对 4 个数排序：</p>
<p>0≤a≤b≤c≤d</p>
<p>并对所有的可能表示法按 a,b,c,d 为联合主键升序排列，最后输出第一个表示法。</p>
<p>输入格式<br>输入一个正整数 N。</p>
<p>输出格式<br>输出4个非负整数，按从小到大排序，中间用空格分开。</p>
<p>数据范围</p>
<p>0&lt;N&lt;5∗10^6</p>
<p>输入样例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 0 1 2</span><br></pre></td></tr></table></figure></p>
<h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>对于这样的题目，如果一开始找不出思路，那就开始想一个暴力的解法。</p>
<p>可以看到，任意找4个数使得它们的平方的和等于给定的数，首先想到的就是4个循环解决。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; ; i++) &#123;</span><br><span class="line">	<span class="keyword">for</span>(j = i; ; j++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(t = j; ; t++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(k = t; ; k++) &#123;</span><br><span class="line">				i*i+j*j+k*k+t*t;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>明显的会超出时间。</p>
<p>其实不妨这样想，假如现在已经求得了两个数的平方和了（记为a），那么另外两个数的平方和就是n-a=b。</p>
<p>b可以怎么求呢？</p>
<p>可以知道，如果a+b能够组成n，b一定要能够分成两个数的平方和，如果不能，那么说明组成a的两个整数不是答案。</p>
<p>提前算好b的每种可能组合，之后查找即可。</p>
<p>又因为只要字典序最小的答案，利用map的特性，只保存第一次组合即可。</p>
<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> n ;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		n = sc.nextInt();</span><br><span class="line">		Map&lt;Integer,String&gt; map = <span class="keyword">new</span> HashMap&lt;Integer,String&gt;();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i * i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = i; i * i + j * j &lt;= n; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(!map.containsKey(i * i + j * j)) &#123;</span><br><span class="line">					map.put(i * i + j * j, i + <span class="string">&quot; &quot;</span> + j);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i * i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = i; i * i + j * j &lt;= n; j++) &#123;</span><br><span class="line">				<span class="keyword">int</span> t = n - (i * i + j * j);</span><br><span class="line">				<span class="keyword">if</span>(map.containsKey(t)) &#123;</span><br><span class="line">					String ans = i + <span class="string">&quot; &quot;</span> + j + <span class="string">&quot; &quot;</span> +map.get(t);</span><br><span class="line">					System.out.println(ans);</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="分巧克力"><a href="#分巧克力" class="headerlink" title="分巧克力"></a>分巧克力</h1><h2 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h2><p>儿童节那天有 K 位小朋友到小明家做客。</p>
<p>小明拿出了珍藏的巧克力招待小朋友们。</p>
<p>小明一共有 N 块巧克力，其中第 i 块是 Hi×Wi 的方格组成的长方形。</p>
<p>为了公平起见，小明需要从这 N 块巧克力中切出 K 块巧克力分给小朋友们。</p>
<p>切出的巧克力需要满足：</p>
<p>形状是正方形，边长是整数<br>大小相同<br>例如一块 6×5 的巧克力可以切出 6 块 2×2 的巧克力或者 2 块 3×3 的巧克力。</p>
<p>当然小朋友们都希望得到的巧克力尽可能大，你能帮小明计算出最大的边长是多少么？</p>
<p>输入格式<br>第一行包含两个整数 N 和 K。</p>
<p>以下 N 行每行包含两个整数 Hi 和 Wi。</p>
<p>输入保证每位小朋友至少能获得一块 1×1 的巧克力。</p>
<p>输出格式<br>输出切出的正方形巧克力最大可能的边长。</p>
<p>数据范围<br>1≤N,K≤105,<br>1≤Hi,Wi≤105<br>输入样例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 10</span><br><span class="line">6 5</span><br><span class="line">5 6</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure></p>
<h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>二分答案。</p>
<p>二分正方形的边长，将枚举的边长带入看能否满足题目条件。不断缩小答案。</p>
<h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n, k;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] H = <span class="keyword">new</span> <span class="keyword">int</span>[MAXN];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] W = <span class="keyword">new</span> <span class="keyword">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            cnt += (H[i] / mid) * (W[i] / mid);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cnt &lt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        n = sc.nextInt();</span><br><span class="line">        k = sc.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            H[i] = sc.nextInt();</span><br><span class="line">            W[i] = sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = MAXN;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> mid = (l + r + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(check(mid)) &#123;</span><br><span class="line">                l = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(r);</span><br><span class="line">        sc.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="K倍区间"><a href="#K倍区间" class="headerlink" title="K倍区间"></a>K倍区间</h1><h2 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h2><p>给定一个长度为 N 的数列，A1,A2,…AN，如果其中一段连续的子序列 Ai,Ai+1,…Aj 之和是 K 的倍数，我们就称这个区间 [i,j] 是 K 倍区间。</p>
<p>你能求出数列中总共有多少个 K 倍区间吗？</p>
<p>输入格式<br>第一行包含两个整数 N 和 K。</p>
<p>以下 N 行每行包含一个整数 Ai。</p>
<p>输出格式<br>输出一个整数，代表 K 倍区间的数目。</p>
<p>数据范围</p>
<p>1≤N,K≤100000,</p>
<p>1≤Ai≤100000</p>
<p>输入样例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 2</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure></p>
<h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>可以很容易的想到一个方法：枚举一段区间，求得这段区间和，能整除k即是一个答案。而快速求区间和可以利用前缀和算法。</p>
<p>很快的写出暴力解法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(len = <span class="number">1</span>; len &lt;= n ; len++) &#123;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;=n ; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>((arr[i + len - <span class="number">1</span>] - arr[i - <span class="number">1</span>]) % k == <span class="number">0</span>) &#123;</span><br><span class="line">			ans++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中arr为前缀和数组。<br>推导算式<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(arr[i + len - <span class="number">1</span>] - arr[i - <span class="number">1</span>]) % k == <span class="number">0</span>，</span><br><span class="line"></span><br><span class="line">(arr[i] - arr[j]) % k == <span class="number">0</span>，</span><br><span class="line"></span><br><span class="line">arr[i] % k == arr[j] % k</span><br></pre></td></tr></table></figure></p>
<p>说明，在前缀和数组中，只要后面的数模k余数与前面的数模k余数相等，即满足答案。</p>
<h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> n,k;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">long</span>[] q = <span class="keyword">new</span> <span class="keyword">long</span>[MAXN];</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">long</span>[] p = <span class="keyword">new</span> <span class="keyword">long</span>[MAXN];</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		n = sc.nextInt();</span><br><span class="line">		k = sc.nextInt();</span><br><span class="line">		<span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			q[i] = sc.nextInt();</span><br><span class="line">			q[i] = (q[i - <span class="number">1</span>] + q[i]) % k;</span><br><span class="line"></span><br><span class="line">			ans += p[(<span class="keyword">int</span>)q[i]];</span><br><span class="line">			p[(<span class="keyword">int</span>)q[i]]++;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(ans + p[<span class="number">0</span>]);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>二分-三分-分治</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
</search>
