<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[第二讲 二分与前缀和]]></title>
    <url>%2F2020%2F02%2F04%2F%E4%BA%8C%E5%88%86%2F%E7%AC%AC%E4%BA%8C%E8%AE%B2%20%E4%BA%8C%E5%88%86%E4%B8%8E%E5%89%8D%E7%BC%80%E5%92%8C%2F</url>
    <content type="text"><![CDATA[数的范围题目给定一个按照升序排列的长度为n的整数数组，以及 q 个查询。 对于每个查询，返回一个元素k的起始位置和终止位置（位置从0开始计数）。 如果数组中不存在该元素，则返回“-1 -1”。 输入格式第一行包含整数n和q，表示数组长度和询问个数。 第二行包含n个整数（均在1~10000范围内），表示完整数组。 接下来q行，每行包含一个整数k，表示一个询问元素。 输出格式共q行，每行包含两个整数，表示所求元素的起始位置和终止位置。 如果数组中不存在该元素，则返回“-1 -1”。 数据范围1231≤n≤1000001≤q≤100001≤k≤10000 输入样例：123456 31 2 2 3 3 4345 输出样例：1233 45 5-1 -1 思路整数二分模板题。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.util.Scanner;public class Main &#123; static int[] q = new int[100100]; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n,m; n = sc.nextInt(); m = sc.nextInt(); for(int i = 0; i &lt; n; i++) &#123; q[i] = sc.nextInt(); &#125; while(m-- &gt; 0) &#123; int x = sc.nextInt(); int l = 0, r = n - 1; while(l &lt; r) &#123; int mid = (l + r) /2; if(q[mid] &gt;= x) &#123; r = mid; &#125; else &#123; l = mid + 1; &#125; &#125; if(q[l] == x) &#123; System.out.print(l + " "); r = n - 1; while(l &lt; r) &#123; int mid = (l + r + 1) / 2; if(q[mid] &lt;= x) &#123; l = mid; &#125; else &#123; r = mid - 1; &#125; &#125; if(q[l] == x) &#123; System.out.println(l); &#125; &#125; else &#123; System.out.println("-1 -1"); &#125; &#125; &#125;&#125; 数的三次方根题目给定一个浮点数n，求它的三次方根。 输入格式共一行，包含一个浮点数n。 输出格式共一行，包含一个浮点数，表示问题的解。 注意，结果保留6位小数。 数据范围−10000≤n≤10000输入样例：11000.00 输出样例：110.000000 思路实数二分。要注意的点是当题目指出要保留多少位小数时，在计算时一般多指定两位参与运算。 代码123456789101112131415161718192021222324import java.text.DecimalFormat;import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); double n = sc.nextDouble(); double l = -10000d,r = 10000d; while(r - l &gt; 1e-8) &#123; double mid = (r + l) / 2; if(mid * mid * mid &lt; n) &#123; l = mid; &#125; else r = mid; &#125; System.out.println(new DecimalFormat("#.000000").format(l)); &#125;&#125; 子矩阵的和题目输入一个n行m列的整数矩阵，再输入q个询问，每个询问包含四个整数x1, y1, x2, y2，表示一个子矩阵的左上角坐标和右下角坐标。 对于每个询问输出子矩阵中所有数的和。 输入格式第一行包含三个整数n，m，q。 接下来n行，每行包含m个整数，表示整数矩阵。 接下来q行，每行包含四个整数x1, y1, x2, y2，表示一组询问。 输出格式共q行，每行输出一个询问的结果。 数据范围123451≤n,m≤1000,1≤q≤200000,1≤x1≤x2≤n,1≤y1≤y2≤m,−1000≤矩阵内元素的值≤1000 输入样例：12345673 4 31 7 2 43 6 2 82 1 2 31 1 2 22 1 3 41 3 3 4 输出样例：123172721 思路二维数组前缀和模板题。1mg[i][j] += mg[i - 1][j] + mg[i][j] - mg[i - 1][j -1] 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.Scanner;public class Main &#123; static int[][] row = new int[1005][1005]; static int[][] col = new int[1005][1005]; static BufferedReader sc = new BufferedReader(new InputStreamReader(System.in)); public static void main(String[] args) throws Exception &#123; String line = sc.readLine(); String src[] = line.split(" "); int n = Integer.parseInt(src[0]); int m = Integer.parseInt(src[1]); int q = Integer.parseInt(src[2]); for(int i = 1; i &lt;= n; i++) &#123; line = sc.readLine(); src = line.split(" "); int j = 1; for(String str : src) &#123; row[i][j] = Integer.parseInt(str); col[i][j] = col[i - 1][j] + col[i][j - 1] - col[i - 1][j - 1] + row[i][j]; j++; &#125; &#125; while(q-- &gt; 0) &#123; line = sc.readLine(); src = line.split(" "); int a = Integer.parseInt(src[0]); int b = Integer.parseInt(src[1]); int c = Integer.parseInt(src[2]); int d = Integer.parseInt(src[3]); System.out.println(col[c][d] - col[c][b - 1] - col[a - 1][d] + col[a - 1][b - 1]); &#125; &#125;&#125; 机器人跳跃问题题目机器人正在玩一个古老的基于DOS的游戏。 游戏中有N+1座建筑——从0到N编号，从左到右排列。 编号为0的建筑高度为0个单位，编号为 i 的建筑高度为H(i)个单位。 起初，机器人在编号为0的建筑处。 每一步，它跳到下一个（右边）建筑。 假设机器人在第k个建筑，且它现在的能量值是E，下一步它将跳到第k+1个建筑。 如果H(k+1)&gt;E，那么机器人就失去H(k+1)-E的能量值，否则它将得到E-H(k+1)的能量值。 游戏目标是到达第N个建筑，在这个过程中能量值不能为负数个单位。 现在的问题是机器人以多少能量值开始游戏，才可以保证成功完成游戏？ 输入格式第一行输入整数N。 第二行是N个空格分隔的整数，H(1),H(2),…,H(N)代表建筑物的高度。 输出格式输出一个整数，表示所需的最少单位的初始能量值。 数据范围1≤N,H(i)≤10^5, 输入样例1：1253 4 3 2 4 输出样例1：14 输入样例2：1234 4 4 输出样例2：14 输入样例3：1231 6 4 输出样例3：13 思路二分答案。 二分初始能量值（即0-10^5），将每次得到的数带入题中所给的条件，看能否满足要求，不断地缩小答案数量。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import java.util.Scanner;public class Main &#123; static final int MAXN = 100005; static long[] q = new long[MAXN]; static int n; private static boolean check1(long mid) &#123; for(int i = 0; i &lt; n; i++) &#123; if(q[i] &gt; mid) &#123; return false; &#125; &#125; return true; &#125; public static boolean check(long mid) &#123; for(int i = 0; i &lt; n; i++) &#123; if(check1(mid)) &#123; return true; &#125; if(mid &lt; q[i]) &#123; mid = mid - (q[i] - mid); &#125; else &#123; mid = mid + (mid - q[i]); &#125; if(mid &lt; 0) &#123; return false; &#125; &#125; return true; &#125; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); n = sc.nextInt(); for(int i = 0; i &lt; n; i++) &#123; q[i] = sc.nextLong(); &#125; long l = 0, r = MAXN; while(l &lt; r) &#123; long mid = (l + r) / 2; if(check(mid)) &#123; r = mid; &#125; else &#123; l = mid + 1; &#125; &#125; System.out.println(l); &#125;&#125; 四平方和题目四平方和定理，又称为拉格朗日定理： 每个正整数都可以表示为至多 4 个正整数的平方和。 如果把 0 包括进去，就正好可以表示为 4 个数的平方和。 比如： 5=0^2+0^2+1^2+2^2 7=1^2+1^2+1^2+2^2 对于一个给定的正整数，可能存在多种平方和的表示法。 要求你对 4 个数排序： 0≤a≤b≤c≤d 并对所有的可能表示法按 a,b,c,d 为联合主键升序排列，最后输出第一个表示法。 输入格式输入一个正整数 N。 输出格式输出4个非负整数，按从小到大排序，中间用空格分开。 数据范围 0&lt;N&lt;5∗10^6 输入样例：15 输出样例：10 0 1 2 思路对于这样的题目，如果一开始找不出思路，那就开始想一个暴力的解法。 可以看到，任意找4个数使得它们的平方的和等于给定的数，首先想到的就是4个循环解决。123456789for(i = 0; ; i++) &#123; for(j = i; ; j++) &#123; for(t = j; ; t++) &#123; for(k = t; ; k++) &#123; i*i+j*j+k*k+t*t; &#125; &#125; &#125;&#125; 明显的会超出时间。 其实不妨这样想，假如现在已经求得了两个数的平方和了（记为a），那么另外两个数的平方和就是n-a=b。 b可以怎么求呢？ 可以知道，如果a+b能够组成n，b一定要能够分成两个数的平方和，如果不能，那么说明组成a的两个整数不是答案。 提前算好b的每种可能组合，之后查找即可。 又因为只要字典序最小的答案，利用map的特性，只保存第一次组合即可。 代码1234567891011121314151617181920212223242526272829303132import java.util.HashMap;import java.util.Map;import java.util.Scanner;public class Main &#123; static int n ; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); n = sc.nextInt(); Map&lt;Integer,String&gt; map = new HashMap&lt;Integer,String&gt;(); for(int i = 0; i * i &lt;= n; i++) &#123; for(int j = i; i * i + j * j &lt;= n; j++) &#123; if(!map.containsKey(i * i + j * j)) &#123; map.put(i * i + j * j, i + " " + j); &#125; &#125; &#125; for(int i = 0; i * i &lt;= n; i++) &#123; for(int j = i; i * i + j * j &lt;= n; j++) &#123; int t = n - (i * i + j * j); if(map.containsKey(t)) &#123; String ans = i + " " + j + " " +map.get(t); System.out.println(ans); return; &#125; &#125; &#125; &#125;&#125; 分巧克力题目儿童节那天有 K 位小朋友到小明家做客。 小明拿出了珍藏的巧克力招待小朋友们。 小明一共有 N 块巧克力，其中第 i 块是 Hi×Wi 的方格组成的长方形。 为了公平起见，小明需要从这 N 块巧克力中切出 K 块巧克力分给小朋友们。 切出的巧克力需要满足： 形状是正方形，边长是整数大小相同例如一块 6×5 的巧克力可以切出 6 块 2×2 的巧克力或者 2 块 3×3 的巧克力。 当然小朋友们都希望得到的巧克力尽可能大，你能帮小明计算出最大的边长是多少么？ 输入格式第一行包含两个整数 N 和 K。 以下 N 行每行包含两个整数 Hi 和 Wi。 输入保证每位小朋友至少能获得一块 1×1 的巧克力。 输出格式输出切出的正方形巧克力最大可能的边长。 数据范围1≤N,K≤105,1≤Hi,Wi≤105输入样例：1232 106 55 6 输出样例：12 思路二分答案。 二分正方形的边长，将枚举的边长带入看能否满足题目条件。不断缩小答案。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.util.Scanner;public class Main &#123; static final int MAXN = 100000 + 5; static int n, k; static int[] H = new int[MAXN]; static int[] W = new int[MAXN]; public static boolean check(int mid) &#123; int cnt = 0; for(int i = 1; i &lt;= n; i++) &#123; cnt += (H[i] / mid) * (W[i] / mid); &#125; if(cnt &lt; k) &#123; return false; &#125; return true; &#125; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); n = sc.nextInt(); k = sc.nextInt(); for(int i = 1; i &lt;= n; i++) &#123; H[i] = sc.nextInt(); W[i] = sc.nextInt(); &#125; int l = 1, r = MAXN; while(l &lt; r) &#123; int mid = (l + r + 1) / 2; if(check(mid)) &#123; l = mid; &#125; else &#123; r = mid - 1; &#125; &#125; System.out.println(r); sc.close(); &#125;&#125; K倍区间题目给定一个长度为 N 的数列，A1,A2,…AN，如果其中一段连续的子序列 Ai,Ai+1,…Aj 之和是 K 的倍数，我们就称这个区间 [i,j] 是 K 倍区间。 你能求出数列中总共有多少个 K 倍区间吗？ 输入格式第一行包含两个整数 N 和 K。 以下 N 行每行包含一个整数 Ai。 输出格式输出一个整数，代表 K 倍区间的数目。 数据范围 1≤N,K≤100000, 1≤Ai≤100000 输入样例：1234565 212345 输出样例：16 思路可以很容易的想到一个方法：枚举一段区间，求得这段区间和，能整除k即是一个答案。而快速求区间和可以利用前缀和算法。 很快的写出暴力解法：1234567for(len = 1; len &lt;= n ; len++) &#123; for(i = 1; i &lt;=n ; i++) &#123; if((arr[i + len - 1] - arr[i - 1]) % k == 0) &#123; ans++; &#125; &#125;&#125; 其中arr为前缀和数组。推导算式12345(arr[i + len - 1] - arr[i - 1]) % k == 0，(arr[i] - arr[j]) % k == 0，arr[i] % k == arr[j] % k 说明，在前缀和数组中，只要后面的数模k余数与前面的数模k余数相等，即满足答案。 代码1234567891011121314151617181920212223242526import java.util.Scanner;public class Main &#123; static final int MAXN = 100000 + 5; static int n,k; static long[] q = new long[MAXN]; static long[] p = new long[MAXN]; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); n = sc.nextInt(); k = sc.nextInt(); long ans = 0; for(int i = 1; i &lt;= n; i++) &#123; q[i] = sc.nextInt(); q[i] = (q[i - 1] + q[i]) % k; ans += p[(int)q[i]]; p[(int)q[i]]++; &#125; System.out.println(ans + p[0]); &#125;&#125;]]></content>
      <categories>
        <category>二分-三分-分治</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java实现批量解压zip文件]]></title>
    <url>%2F2020%2F02%2F01%2Fjava%2FJava%E5%AE%9E%E7%8E%B0%E8%A7%A3%E5%8E%8Bzip%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[到网上下载的教学视频一般都是经过层层压缩的，手动解压的耗时耗力，遂写了个程序自动解压。 主要利用了Java核心库中的ZipInputStream类。 代码： 其中File src为目标文件，String des为要存储到的存储路径12345678910111213141516171819202122232425262728public void unZip(File src,String des) throws Exception &#123; ZipInputStream zipInputStream = new ZipInputStream(new FileInputStream(src), Charset.forName("gbk")); ZipEntry zipEntry = null; while((zipEntry = zipInputStream.getNextEntry()) != null) &#123; File file = new File(des + File.separator + zipEntry.getName()); if(zipEntry.isDirectory()) &#123; file.mkdirs(); continue; &#125; file.getParentFile().mkdirs(); int len; FileOutputStream out = new FileOutputStream(file); while((len = zipInputStream.read(buffer)) != -1) &#123; out.write(buffer,0,len); &#125; out.close(); &#125; zipInputStream.closeEntry(); zipInputStream.close();&#125; 遇到的问题：在定义ZipInputStream类时，如果不指定文件流的编码格式，则默认为utf-8。假如要解压的文件路径中包含中文，则会抛出异常：1Exception in thread "main" java.lang.IllegalArgumentException: malformed input off : 19, length : 1 这时就要手动指定编码格式了。 见源码：123public ZipInputStream(InputStream in) &#123; this(in, StandardCharsets.UTF_8); &#125; 12345678910public ZipInputStream(InputStream in, Charset charset) &#123; super(new PushbackInputStream(in, 512), new Inflater(true), 512); usesDefaultInflater = true; if (in == null) &#123; throw new NullPointerException("in is null"); &#125; if (charset == null) throw new NullPointerException("charset is null"); this.zc = ZipCoder.get(charset);&#125; 由于ZipInputStream中是没有编码常量的，所以需要借助Charset.forName(&quot;gbk&quot;)来指定。]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[第一讲 递归与递推]]></title>
    <url>%2F2020%2F01%2F28%2F%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2%2F%E7%AC%AC%E4%B8%80%E8%AE%B2%20%E9%80%92%E5%BD%92%E4%B8%8E%E9%80%92%E6%8E%A8%2F</url>
    <content type="text"><![CDATA[递归实现排列型枚举题目把 1~n 这 n 个整数排成一行后随机打乱顺序，输出所有可能的次序。 输入格式一个整数n。 输出格式按照从小到大的顺序输出所有方案，每行1个。 首先，同一行相邻两个数用一个空格隔开。 其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面。 数据范围1≤n≤9输入样例：13 输出样例：1234561 2 31 3 22 1 32 3 13 1 23 2 1 思路这个题实际上就是对1-n进行全排列。 现在可以想象有n个位置，一个位置只可以放入一个数字（1-n）。 从第一个位置开始枚举每一个数字，当一个位置放入数字后就递归下一个位置的放置情况。直到所有情况处理完。 代码1234567891011121314151617181920212223242526272829303132333435363738import java.io.BufferedWriter;import java.io.FileWriter;import java.io.IOException;import java.io.OutputStreamWriter;import java.io.Writer;import java.util.ArrayList;import java.util.Scanner;public class Main &#123; static ArrayList&lt;Integer&gt; ay = new ArrayList&lt;Integer&gt;(); static int[] visit = new int[10]; static int n = 0; static BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out)); static void dfs(int v) throws Exception &#123; if(v == n) &#123; for(int i : ay) &#123; out.write(i + " "); &#125; out.write('\n'); &#125; for(int i = 1; i &lt;= n; i++) &#123; if(visit[i] == 0) &#123; ay.add(i); visit[i] = 1; dfs(v + 1); ay.remove(ay.size() - 1); visit[i] = 0; &#125; &#125; &#125; public static void main(String[] args) throws Exception&#123; Scanner sc = new Scanner(System.in); n = sc.nextInt(); dfs(0); out.flush(); &#125;&#125; 递归实现指数型枚举题目从 1~n 这 n 个整数中随机选取任意多个，输出所有可能的选择方案。 输入格式输入一个整数n。 输出格式每行输出一种方案。 同一行内的数必须升序排列，相邻两个数用恰好1个空格隔开。 对于没有选任何数的方案，输出空行。 本题有自定义校验器（SPJ），各行（不同方案）之间的顺序任意。 数据范围1≤n≤15输入样例：13 输出样例：1234567322 311 31 21 2 3 思路这个题目思路大致与上一题相同，要注意的是对于每一组答案，前面的数字必须小于后面的数字。可以发现，在递归函数中循环遍历1-n，那么循环起始值以上一次取得的数值加1就可以了。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.io.BufferedWriter;import java.io.OutputStreamWriter;import java.util.ArrayList;import java.util.Scanner;public class Main &#123; static ArrayList&lt;Integer&gt; ay = new ArrayList&lt;Integer&gt;(); static int[] visit = new int[16]; static int n = 0; static BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out)); public static void dfs(int v,int p) throws Exception&#123; if(v == p) &#123; for(int i : ay) &#123; out.write(i + " "); &#125; out.write('\n'); &#125; for(int i = n; i &gt;= 1; i--) &#123; if(visit[i] == 0) &#123; if(!ay.isEmpty() &amp;&amp; ay.get(ay.size() - 1) &gt; i) &#123; return; &#125; ay.add(i); visit[i] = 1; dfs(v,p + 1); ay.remove(ay.size() - 1); visit[i] = 0; &#125; &#125; &#125; public static void main(String[] args) throws Exception &#123; out.write('\n'); Scanner sc = new Scanner(System.in); n = sc.nextInt(); for(int i = 1; i &lt;= n; i++) &#123; dfs(i,0); &#125; out.flush(); &#125;&#125; 费解的开关题目你玩过“拉灯”游戏吗？25盏灯排成一个5x5的方形。每一个灯都有一个开关，游戏者可以改变它的状态。每一步，游戏者可以改变某一个灯的状态。游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。 我们用数字“1”表示一盏开着的灯，用数字“0”表示关着的灯。下面这种状态123451011101101101111000011011 在改变了最左上角的灯的状态后将变成：123450111111101101111000011011 再改变它正中间的灯后状态将变成：123450111111001110011010011011 给定一些游戏的初始状态，编写程序判断游戏者是否可能在6步以内使所有的灯都变亮。 输入格式 第一行输入正整数n，代表数据中共有n个待解决的游戏初始状态。 以下若干行数据分为n组，每组数据有5行，每行5个字符。每组数据描述了一个游戏的初始状态。各组数据间用一个空行分隔。 输出格式 一共输出n行数据，每行有一个小于等于6的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。 对于某一个游戏初始状态，若6步以内无法使所有灯变亮，则输出“-1”。 数据范围0&lt;n≤500输入样例：1234567891011121314151617183001110101110001110101110011101111011111011111111110111111111111111111111111 输出样例：12332-1 思路对于这种开灯关灯问题（改变一个位置的状态会影响其它位置的状态）或许可以发现这样一种现象，那就是按一下再按一下相当于没有按。 可以推出来，每一个位置最多可以按一下。 现在来模拟一下状态。 对于第一行的开关，如果有一个开关处于关的状态，那么能影响到这个开关的只能是它左边、右边、下边的开关。而像前面提到的每个开关只能按一次，当第一行的开关前面4个都处于开的状态，第5个处于关的状态，那么能影响到它的只能是它下面的开关，因为左边开关一旦按下势必会影响前面已经处理好的开关，而右边又没有开关了。 此时就可以设定当第一行的开关处于关的状态，就按一下它下面的开关来改变它的状态。 这样，对于第二行来说，第三行开关决定它的开关状态，以此类推。 此时，就可以枚举第一行开关的所有情况，有了第一行开关的状态，就可以推出来整个开关矩阵的情况。 求出最小步骤数。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.util.Scanner;public class Acwing95 &#123; static int n; static final int MAXN = 10; static int[][] mg = new int[MAXN][MAXN]; static int ans = Integer.MAX_VALUE; static int[][] tp = new int[MAXN][MAXN]; private static void inverse(int[][] ay,int i,int v) &#123; ay[i][v] = (ay[i][v] + 1) % 2; ay[i][v - 1] = (ay[i][v - 1] + 1) % 2; ay[i][v + 1] = (ay[i][v + 1] + 1) % 2; ay[i + 1][v] = (ay[i + 1][v] + 1) % 2; ay[i - 1][v] = (ay[i - 1][v] + 1) % 2; &#125; private static int check() &#123; int p = 0; for(int i = 1; i &lt;= 5; i++) &#123; for(int j = 1; j &lt;= 5; j++) &#123; tp[i][j] = mg[i][j]; &#125; &#125; for(int i = 2; i &lt;= 5; i++) &#123; for(int j = 1; j &lt;= 5; j++) &#123; if(tp[i - 1][j] == 0) &#123; inverse(tp,i,j); p++; &#125; &#125; &#125; for(int i = 1; i &lt;= 5; i++) &#123; if(tp[5][i] == 0) &#123; return -1; &#125; &#125; return p; &#125; public static void dfs(int v,int p) &#123; if(v == 6) &#123; int cnt = check(); if(cnt == -1) &#123; return; &#125; ans = Math.min(ans, cnt + p); return; &#125; dfs(v + 1,p); inverse(mg,1,v); dfs(v + 1,p + 1); inverse(mg,1,v); &#125; public static void main(String[] args) throws Exception&#123; Scanner sc = new Scanner(System.in); n = sc.nextInt(); while(n-- &gt; 0) &#123; ans = Integer.MAX_VALUE; for(int i = 1; i &lt;= 5; i++) &#123; String line = sc.next(); for(int j = 0; j &lt; line.length(); j++) &#123; mg[i][j + 1] = (int)line.charAt(j) - 48; &#125; &#125; dfs(1,0); if(ans == Integer.MAX_VALUE || ans &gt; 6) &#123; ans = -1; &#125; System.out.println(ans); &#125; &#125;&#125; 递归实现组合型枚举题目从 1~n 这 n 个整数中随机选出 m 个，输出所有可能的选择方案。 输入格式两个整数 n,m ,在同一行用空格隔开。 输出格式按照从小到大的顺序输出所有方案，每行1个。 首先，同一行内的数升序排列，相邻两个数用一个空格隔开。 其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面（例如1 3 5 7排在1 3 6 8前面）。 数据范围n&gt;0 ,0≤m≤n ,n+(n−m)≤25输入样例：15 3 输出样例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556571 2 3 1 2 4 1 2 5 1 3 4 1 3 5 1 4 5 2 3 4 2 3 5 2 4 5 3 4 5``` ## 思路与全排列做法类似。指定递归函数出口为规定的数即可。## 代码 ```Javaimport java.io.BufferedWriter;import java.io.OutputStreamWriter;import java.util.ArrayList;import java.util.Scanner;public class Main &#123; static int n,m; static BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out)); static ArrayList&lt;Integer&gt; ay = new ArrayList&lt;Integer&gt;(); static int[] visit = new int[30]; public static void dfs(int v,int state) throws Exception&#123; if(v == m) &#123; for(int i : ay) &#123; out.write(i + &quot; &quot;); &#125; out.write(&apos;\n&apos;); &#125; for(int i = state + 1; i &lt;= n; i++) &#123; if(visit[i] == 0) &#123; ay.add(i); visit[i] = 1; dfs(v + 1, i); ay.remove(ay.size() - 1); visit[i] = 0; &#125; &#125; &#125; public static void main(String[] args) throws Exception&#123; Scanner sc = new Scanner(System.in); n = sc.nextInt(); m = sc.nextInt(); dfs(0,0); out.flush(); &#125;&#125; 带分数题目100 可以表示为带分数的形式：100=3+69258/714还可以表示为：100=82+3546/197注意特征：带分数中，数字 1∼9 分别出现且只出现一次（不包含 0）。 类似这样的带分数，100 有 11 种表示法。 输入格式一个正整数。 输出格式输出输入数字用数码 1∼9 不重复不遗漏地组成带分数表示的全部种数。 数据范围1≤N&lt;10^6 输入样例1：1100 输出样例1：111 输入样例2：1105 输出样例2：16 思路这个题目要求1-9数字使用并且仅使用一次。 把a、b、c三个数字当成字符串连接到一起，即是一组答案。可以发现，对于每一个由1-9数字组成的字符串都可以对其进行拆分，之后判断是否可以构成n。 枚举字符串（即求全排列1-9），对于每一个字符串进行拆分，分成三部分，将这三部分换成整数，判断等式(n - a) * c = b（由n=a+b/c推导得来）是否成立。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.util.Scanner;public class Acwing1209 &#123; static long n; static String line = ""; static int[] visit = new int[10]; static int ans = 0; private static long toLong(String str) &#123; long value = 0; for(int i = 0; i &lt; str.length(); i++) &#123; value = value * 10 + (int)str.charAt(i) - 48; &#125; return value; &#125; private static void check() &#123; for(int i = 1; i &lt;= 9; i++) &#123; for(int j = 1; j &lt;= 9; j++) &#123; int t = 9 - i - j; if(t &lt;= 0) &#123; break; &#125; long a = toLong(line.substring(0, i)); long b = toLong(line.substring(i,i + j)); long c = toLong(line.substring(i + j)); if((n - a) * c == b) &#123; ans++; return; &#125; &#125; &#125; &#125; public static void dfs(int v) &#123; if(v == 9) &#123; check(); &#125; for(int i = 1; i &lt;= 9; i++) &#123; if(visit[i] == 0) &#123; line += i; visit[i] = 1; dfs(v + 1); visit[i] = 0; line = line.substring(0, line.length() - 1); &#125; &#125; &#125; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); n = sc.nextLong(); dfs(0); System.out.println(ans); &#125;&#125; 翻硬币题目小明正在玩一个“翻硬币”的游戏。 桌上放着排成一排的若干硬币。我们用 * 表示正面，用 o 表示反面（是小写字母，不是零）。 比如，可能情形是：oo*oooo 如果同时翻转左边的两个硬币，则变为：oooo***oooo 现在小明的问题是：如果已知了初始状态和要达到的目标状态，每次只能同时翻转相邻的两个硬币,那么对特定的局面，最少要翻动多少次呢？ 我们约定：把翻动相邻的两个硬币叫做一步操作。 输入格式两行等长的字符串，分别表示初始状态和要达到的目标状态。 输出格式一个整数，表示最小操作步数 数据范围输入字符串的长度均不超过100。数据保证答案一定有解。 输入样例1：12**********o****o**** 输出样例1：15 输入样例2：12*o**o***o****o***o**o*** 输出样例2：11 思路类似于开灯问题。 可以发现，对于一个硬币来说，翻两次相当于没翻，也就是说，一个硬币最多只能翻一次。 对于最左边的硬币：能影响它状态的只有它自己和它右边第一个硬币。如果某一时刻它翻动一次，它自己和它右边的硬币状态改变。此时，对第二个硬币来讲，就不能翻动它自身，能影响它的只有它右边的硬币，以此类推，后边的硬币只能被它后一位影响。 这样就好办了，对比目标串做出相应变化就行了。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.util.Scanner;public class Main &#123; static String src = ""; static String des = ""; static int ans = Integer.MAX_VALUE; static int len = 0; private static int check() &#123; int p = 0; String str = src; for(int i = 0; i &lt; len; i++) &#123; if(des.charAt(i) != str.charAt(i)) &#123; str = inverse(str,i); p++; &#125; &#125; if(!des.equals(str)) &#123; p = -1; &#125; return p; &#125; private static String inverse(String str,int index) &#123; if(index == len) &#123; return str; &#125; char[] ch = str.toCharArray(); if(ch[index] == '*') &#123; ch[index] = 'o'; &#125; else &#123; ch[index] = '*'; &#125; if(ch[index + 1] == '*') &#123; ch[index + 1] = 'o'; &#125; else &#123; ch[index + 1] = '*'; &#125; return str = new String(ch); &#125; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); src = sc.next(); len = src.length(); des = sc.next(); int cnt = check(); System.out.println(cnt); sc.close(); &#125;&#125; 飞行员兄弟题目“飞行员兄弟”这个游戏，需要玩家顺利的打开一个拥有16个把手的冰箱。 已知每个把手可以处于以下两种状态之一：打开或关闭。 只有当所有把手都打开时，冰箱才会打开。 把手可以表示为一个4х4的矩阵，您可以改变任何一个位置[i,j]上把手的状态。 但是，这也会使得第i行和第j列上的所有把手的状态也随着改变。 请你求出打开冰箱所需的切换把手的次数最小值是多少。 输入格式输入一共包含四行，每行包含四个把手的初始状态。 符号“+”表示把手处于闭合状态，而符号“-”表示把手处于打开状态。 至少一个手柄的初始状态是关闭的。 输出格式第一行输出一个整数N，表示所需的最小切换把手次数。 接下来N行描述切换顺序，每行输入两个整数，代表被切换状态的把手的行号和列号，数字之间用空格隔开。 注意：如果存在多种打开冰箱的方式，则按照优先级整体从上到下，同行从左到右打开。 数据范围1≤i,j≤4输入样例：1234-+-----------+-- 输出样例：123456761 11 31 44 14 34 4 思路对于每一个把手，都有两种状态，一个是开，一个是关。枚举所有的状态，对每种状态判断是不是全打开就行了。 注意，题目要求将改变的把手位置打印出来并且有顺序要求，那么只需要从最后往前面递归就行了。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798import java.util.ArrayDeque;import java.util.ArrayList;import java.util.Deque;import java.util.Scanner;class Node &#123; int x,y; Node(int x,int y) &#123; this.x = x; this.y = y; &#125;&#125;public class Main &#123; static int[][] mg = new int[5][5]; static int ans = Integer.MAX_VALUE; static Deque&lt;Node&gt; stack = new ArrayDeque&lt;Node&gt;(); static ArrayList&lt;Node&gt; ay = new ArrayList&lt;Node&gt;(); static ArrayList&lt;Node&gt; cur = new ArrayList&lt;Node&gt;(); private static boolean check() &#123; for(int i = 0; i &lt; 4; i++) &#123; for(int j = 0; j &lt; 4; j++) &#123; if(mg[i][j] == 1) &#123; return false; &#125; &#125; &#125; return true; &#125; private static void inverse(int x,int y) &#123; for(int i = 0; i &lt; 4; i++) &#123; if(i != y) &#123; mg[x][i] = (mg[x][i] + 1) % 2; &#125; &#125; for(int i = 0; i &lt; 4; i++) &#123; if(i != x) &#123; mg[i][y] = (mg[i][y] + 1) % 2; &#125; &#125; mg[x][y] = (mg[x][y] + 1) % 2; &#125; private static void judge(int p) &#123; if(p &lt;= ans) &#123; ans = p; ay.clear(); for(Node node : cur) &#123; ay.add(node); &#125; &#125; &#125; public static void dfs(int v,int p) &#123; if(v == -1) &#123; if(check()) &#123; judge(p); &#125; return; &#125; int x = v / 4; int y = v % 4; dfs(v - 1,p); inverse(x,y); cur.add(new Node(x + 1,y + 1)); dfs(v - 1,p + 1); cur.remove(cur.size() - 1); inverse(x,y); &#125; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); for(int i = 0; i &lt; 4; i++) &#123; String line = sc.next(); for(int j = 0; j &lt; line.length(); j++) &#123; if(line.charAt(j) == '+') &#123; mg[i][j] = 1; &#125; else &#123; mg[i][j] = 0; &#125; &#125; &#125; dfs(15,0); System.out.println(ans); for(int i = ay.size() - 1; i &gt;= 0; i--) &#123; System.out.println(ay.get(i).x + " " + ay.get(i).y); &#125; &#125;&#125;]]></content>
      <categories>
        <category>简单搜索</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[处理机调度]]></title>
    <url>%2F2019%2F11%2F15%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[操作系统笔记 层次和目标处理机调度分为三个层次，分别为 高级调度（作业调度），将处于后备队列中的作业调入内存 中级调度（内存调度），将暂时不能运行的进程调至外存等待 低级调度（进程调度），决定就绪队列中的哪个进程（或线程）得到处理机资源 不同类型的操作系统采用了不同的处理机调度算法。调度算法应当使得系统资源利用率尤其是处理机的利用率尽可能地高（资源利用率），要保证每个进程都能获得合理的CPU时间（公平性），还要保证系统的各种资源使用的平衡性（平衡性），另外对制定的策略只要需要就一定要执行（策略强制执行性）。 作业调度在多道批处理系统中，作业是用户提交给系统的一项想多独立的工作。作业不仅包含通常说的程序和数据还有配有一份作业说明书。 当一个作业进入系统时，相应的调度程序为其建立一个作业控制块（Job Control Block，JCB），JCB中含有该作业的有关信息（比如作业标识、类型、优先级等），之后把这个作业放入后备队列中等待后续调度。 作业从进入系统到运行结束经过了3个阶段。 后备状态，系统建立JCB并将该作业放入后备队列等待作业调度。 运行阶段，作业被作业调度进程分配相关的资源后调入就绪队列。 完成状态，当作业完成或者发生异常情况提前结束，被系统收回已分配的资源。 作业调度要根据JCB中相关信息检查系统中是否有足够的资源满足该作业的需求，之后按照相应的调度算法从外存中的后备队列中选取作业调入内存中的就绪队列，为其创建进程、分配相应的资源。 作业调度应该调度哪些作业呢？这取决于系统采用的调度算法。比较常用的有先来先服务算法、短作业优先算法和高响应比优先调度算法。 先来先服务算法（First come first served，FCFS）：FCFS算法按照作业到达系统的先后顺序来调度作业。 短作业优先算法（Short job first SJF）：SJF算法按照作业的估计运行时间长短来调度作业。可以发现，这种算法有不少的缺点，实际上是很难估计作业的运行时间，而且这种算法对长作业是非常不利的，长作业的周转时间会明显的增长，完全忽视长作业的等待时间，导致长作业的实际完成时间被拉长，这是用户不想得到的结果。当用户急需完成某一任务，而该任务的估计运行时间较长，该紧急长作业在后备队列中等待被调度时，这时来了一个短作业，那么，短作业先被调度，紧急作业长延后无法被调度，不能保证紧急作业得到及时处理。 高响应比优先调度算法（Highest response ratio next,HRRN）：HRRN算法结合了FCFS和SJF算法。为每一个作业设置一个优先级，在后备队列中作业按照优先级排序等待被调度。 优先权 = $\frac{等待时间 + 要求服务时间}{要求服务时间}$HRRN的缺点是在进行调度之前都要进行一次响应比计算，无疑这会增加系统开销。 进程调度在进行进程调度的时候首先要将当前正在使用处理机的进程的相关信息保存到进程的进程控制块中，比如程序计数器、寄存器中的内容。其次根据一定的调度算法选取就绪队列中的进程。最后将处理机分配给选取的进程，并将进程控制块中的相关信息填入处理机，让它从上次的断点处恢复运行。 进程调度的机制 排队器，按照一定的策略将进程排序 分派器，根据调度程序选出进程，将其从就绪队列中取出，将处理机分配给该进程 上下文切换器，在进行进程切换时，保存旧进程的相关信息，并将新进程的信息填入处理机中 进程调度方式1.非抢占式，一旦把处理机分配给某一进程后，除非这个进程发出中断或者异常，否则一直运行下去，直至完成。 2.抢占式，这种调度方式允许调度程序根据某种原则去暂停某个正在执行的程序，转而将处理机分配给其他进程。 注意，在分时系统中，只有抢占式才能实现人机交互。 抢占式也并不是一种任意的行为，它也必须遵循一定的原则。1.允许优先权高的抢占优先权低的。2.允许新调入就绪队列中的短进程抢占正在运行的长进程，即当前运行的长进程的尚需运行时间明显比短进程要求运行时间长时，允许抢占。3.如果调度算法是基于时间片原则的，当前进程在属于它的时间片内尚未执行完毕，可被其他进程抢占。 调度算法较常用的算法有基于时间片的轮转调度算法（Round robin，RR）。 RR算法让就绪队列中进程每次仅能获得一个时间片，在一个时间片用完该进程还未执行完毕就换下一个进程。由此确保每个进程在一定时间间隔内都能获得一次处理机。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[银行家算法实现]]></title>
    <url>%2F2019%2F11%2F13%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2FOS%E5%AE%9E%E9%AA%8C%E4%BA%94-%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[操作系统编程小作业 银行家算法详细讲解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int process_MAXN = 5; // the process numberconst int resource_MAXN = 3; // the resource numberstruct bankAlgorithm&#123;private: int Available[resource_MAXN] = &#123;2,3,0&#125;; int tmpAvailable[process_MAXN][resource_MAXN]; // int Max[process_MAXN][resource_MAXN] = &#123; &#123;7, 5, 3&#125;,&#123;3, 2, 1&#125;,&#123;9, 0, 2&#125;,&#123;2, 2, 2&#125;,&#123;4, 3, 3&#125; &#125;; int Allocation[process_MAXN][resource_MAXN] = &#123;&#123;0, 1, 0&#125;,&#123;2, 0, 0&#125;,&#123;3, 0, 2&#125;,&#123;2,1,1&#125;,&#123;0, 0, 2&#125;&#125;; int Need[process_MAXN][resource_MAXN] = &#123;&#123;7, 4, 3&#125;,&#123;1, 2, 2&#125;,&#123;6, 0, 0&#125;,&#123;0, 1, 1&#125;,&#123;4, 3, 1&#125;&#125;; int processId = 1; int request[3] = &#123;1,0,2&#125;; int visit[process_MAXN][3] = &#123;&#123;0&#125;&#125;; // the priority of visitpublic: void mainCtrl(); void sayHelloworld(); void inputData(); void outputData(); bool sendRequest(); void tryToAskResource(); void showInformation(); void showError();&#125;;void bankAlgorithm::mainCtrl()&#123; inputData(); outputData(); sendRequest();&#125;void bankAlgorithm::sayHelloworld()&#123; printf("\thello the cruel world\n");&#125;void bankAlgorithm::inputData()&#123; printf("input the process id and the three request resource\n"); scanf("%d%d%d%d",&amp;processId,&amp;request[0],&amp;request[1],&amp;request[2]);&#125;void bankAlgorithm::outputData()&#123; printf("ProcessId：%d\nrequest：",processId); for(int i = 0; i &lt; resource_MAXN; i++) &#123; printf("%d ",request[i]); &#125; printf("\n");&#125;bool bankAlgorithm::sendRequest() //no bug&#123; for(int i = 0; i &lt; resource_MAXN; i++) &#123; if(request[i] &gt; Need[processId][i]) &#123; printf("The requested resource has exceeded the required resource\n"); return false; &#125; if(request[i] &gt; Available[i]) &#123; printf("The requested resource has exceeded the Available resource\n"); return false; &#125; &#125; tryToAskResource();&#125;void bankAlgorithm::tryToAskResource()&#123; for(int i = 0; i &lt; resource_MAXN; i++) &#123; Available[i] -= request[i]; Need[processId][i] -= request[i]; Allocation[processId][i] += request[i]; &#125; int cnt = 0; //the visitted priority for(int i = 0; i &lt; process_MAXN; i++) &#123; visit[i][0] = 0; &#125; while(true) &#123; bool judgeToRun = true; for(int i = 0; i &lt; process_MAXN; i++) &#123; if(!visit[i][0]) &#123; bool flag = true; for(int j = 0; j &lt; resource_MAXN; j++) &#123; if(Available[j] &lt; Need[i][j]) &#123; flag = false; break; &#125; &#125; if(flag) &#123; for(int j = 0; j &lt; resource_MAXN; j++) &#123; tmpAvailable[i][j] = Available[j]; Available[j] += Allocation[i][j]; &#125; judgeToRun = false; visit[i][0] = 1; visit[i][1] = cnt++; visit[i][2] = i;// cout&lt;&lt;"i = "&lt;&lt;i&lt;&lt;endl; &#125; &#125; &#125; if(judgeToRun) &#123;break;&#125; &#125;// sayHelloworld();// cout&lt;&lt;cnt&lt;&lt;' '&lt;&lt;process_MAXN&lt;&lt;endl; if(cnt != process_MAXN) &#123; showError(); return; &#125; showInformation();&#125;void bankAlgorithm::showInformation()&#123; printf("Resource\tMax\tAvailable Allocation Need Work\n"); int tmp[3]; int len = sizeof(visit[0]); for(int i = 0; i &lt; process_MAXN; i++) &#123; for(int j = i + 1; j &lt; process_MAXN; j++) &#123; if(visit[i][1] &gt; visit[j][1]) &#123; memcpy(tmp,visit[i],len); memcpy(visit[i],visit[j],len); memcpy(visit[j],tmp,len); &#125; &#125; &#125; for(int i = 0; i &lt; process_MAXN; i++) &#123; int process_id = visit[i][2]; printf("\t%d ",process_id); printf("\t"); for(int j = 0; j &lt; resource_MAXN; j++) &#123; printf("%d ",Max[process_id][j]); &#125; printf("\t "); for(int j = 0; j &lt; resource_MAXN; j++) &#123; printf("%d ",tmpAvailable[process_id][j]); &#125; printf("\t"); for(int j = 0; j &lt; resource_MAXN; j++) &#123; printf("%d ",Allocation[process_id][j]); &#125; printf("\t "); for(int j = 0; j &lt; resource_MAXN; j++) &#123; printf("%d ",Need[process_id][j]); &#125; printf("\t"); for(int j = 0; j &lt; resource_MAXN; j++) &#123; printf("%d ",tmpAvailable[process_id][j] + Allocation[process_id][j]); &#125; printf("\n"); &#125;&#125;void bankAlgorithm::showError()&#123; printf("Sorry,you can't allocate resources to %d.\nBecause the Available resource can't satisfy any of the Process\n",processId);&#125;int main()&#123; struct bankAlgorithm shan; shan.mainCtrl(); return 0;&#125;]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[sql经典练习题]]></title>
    <url>%2F2019%2F10%2F22%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2Fmysql%E8%AF%AD%E6%B3%95%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[网上流传已久的sql语法练习题，找来练练。 相关表结构course表 CId Cname TId 01 语文 02 02 数学 01 03 英语 03 sc表 skey SId CId score 1 01 01 80.0 2 01 02 90.0 3 01 03 99.0 4 02 01 70.0 5 02 02 60.0 6 02 03 80.0 7 03 01 80.0 8 03 02 80.0 9 03 03 80.0 10 04 01 50.0 11 04 02 30.0 12 04 03 20.0 13 05 01 76.0 14 05 02 87.0 15 06 01 31.0 16 06 03 34.0 17 07 02 89.0 18 07 03 98.0 teacher表 TId Tname 01 张三 02 李四 03 王五 student表 SId Sname Sage Ssex 01 赵雷 1990-01-01 00:00:00 男 02 钱电 1990-12-21 00:00:00 男 03 孙风 1990-12-20 00:00:00 男 04 李云 1990-12-06 00:00:00 男 05 周梅 1991-12-01 00:00:00 女 06 吴兰 1992-01-01 00:00:00 女 07 郑竹 1989-01-01 00:00:00 女 09 张三 2017-12-20 00:00:00 女 10 李四 2017-12-25 00:00:00 女 11 李四 2012-06-06 00:00:00 女 12 赵六 2013-06-13 00:00:00 女 13 孙七 2014-06-01 00:00:00 女 习题1、查询” 01 “课程比” 02 “课程成绩高的学生的信息及课程分数12345select student.sname,a.sid,a.scorefrom (select sc.sid,sc.cid,sc.score from sc where cid = '01') a,(select sc.sid,sc.cid,sc.score from sc where cid = '02') b,studentwhere a.score &gt; b.score and a.sid = b.sid and student.sid = a.sid; 2、查询同时存在” 01 “课程和” 02 “课程的情况123456select student.*from student,scwhere student.sid = sc.sid and '01' in (select cid from sc where student.sid = sc.sid group by sid) and '02' in (select cid from sc where student.sid = sc.sid group by sid)group by sc.sid; 3、查询存在” 01 “课程但可能不存在” 02 “课程的情况1select * from sc where cid = '01'; 4、查询不存在” 01 “课程但存在” 02 “课程的情况123456select student.*from student,scwhere student.sid = sc.sid and '01' not in (select cid from sc where student.sid = sc.sid group by sid) and '02' in (select cid from sc where student.sid = sc.sid group by sid)group by sc.sid; 5、查询平均成绩大于等于 60 分的同学的学生编号和学生姓名和平均成绩123456select student.sid,student.sname,avg(sc.score)from student,scwhere student.sid = sc.sidgroup by sc.sidhaving avg(sc.score) &gt;= 60; 首先从sc表中以sid分组，从而找出每位同学的平均成绩，平局成绩大于等于60分的就可以与student表进行连接组成一条新纪录，同时会将该同学的平均成绩求出来。 6、查询在 SC 表存在成绩的学生信息123select distinct student.* from student,sc where student.sid = sc.sid and sc.score is not null; 7、查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩(没成绩的显示为 null )12345select student.sid 学号,student.sname 姓名,count(sc.cid) 选课总数,sum(sc.score) 总成绩from studentleft join sc on(student.sid = sc.sid)group by student.sid; 左外连接加以sid分组。 8、查有成绩的学生信息123select distinct student.* from student,sc where student.sid = sc.sid and sc.score is not null; 9、查询「李」姓老师的数量1select count(tid) from teacher where tname like "李%"; 10、查询学过「张三」老师授课的同学的信息123456select student.*from student,sc,course,teacherwhere student.sid = sc.sid and sc.cid = course.cid and course.tid = teacher.tid and teacher.tname = '张三'； 从teacher中获取张三老师的tid，之后再从course中找到他教学的课程id，这样就可以知道cid，借助sc.cid和course.cid将这两张表连接起来，又借助student.sid和sc.sid将它们二者连接起来查询。 11、查询没有学全所有课程的同学的信息123456789select student.*from student,scwhere student.sid = sc.sidgroup by sc.sidhaving count(sc.cid) &lt; ( select count(distinct cid) from course ); 在sc表中以sid分组，统计出每组选修的课程数，这也就是每个学生选修的课程。判断哪些同学选修的课程少于course表中的课程总数，将student表和sc表连接起来输出即可。 12、查询至少有一门课与学号为” 01 “的同学所学相同的同学的信息12345select distinct student.*from student,scwhere student.sid = sc.sid and sc.cid in (select cid from sc where sid = '01'); 13、查询和” 01 “号的同学学习的课程完全相同的其他同学的信息123456789select student.* from student where student.sid in( select sid from sc where sid not in (select sid from sc where cid not in (select cid from sc where sid = '01')) group by sid having count(*) = (select count(*) from sc where sid = '01') and sid != '01'); 14、查询没学过”张三”老师讲授的任一门课程的学生姓名12345678select student.sname from student where sid in( select sid from sc where sid not in (select sid from sc where cid in (select cid from course where tid = (select tid from teacher where tname = '张三')))); 15、查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩123456select student.sid,student.sname,avg(sc.score)from student,sc sc1group by sc1.sidhaving count( select cid from sc sc2 where score &lt; 60) &gt;=2; 16、检索” 01 “课程分数小于 60，按分数降序排列的学生信息1234567select student.*from student,scwhere student.sid = sc.sid and sc.cid = '01' and sc.score &lt; 60order by sc.score desc; 17、按平均成绩从高到低显示所有学生的所有课程的成绩以及平均成绩123456select student.sid 学号,student.sname 姓名,sum(sc.score) 总成绩,avg(sc.score) 平均成绩from student,scwhere student.sid = sc.sidgroup by sc.sidorder by avg(sc.score) desc; 18、查询各科成绩最高分、最低分和平均分：以如下形式显示：课程 ID，课程 name，最高分，最低分，平均分，及格率，中等率，优良率，优秀率；及格为：&gt;=60，中等为：70-80，优良为：80-90，优秀为：&gt;=90。 要求输出课程号和选修人数，查询结果按人数降序排列，若人数相同，按课程号升序排列1234567891011select sc.cid ID,course.cname 课程名,max(sc.score) 最高分,min(sc.score) 最低分,avg(sc.score) 平均分,count(sc.sid) 人数,sum(case when sc.score between 0 and 59 then 1 else 0 end) / count(sc.sid) 不及格率,sum(case when sc.score between 60 and 69 then 1 else 0 end) / count(sc.sid) 及格率,sum(case when sc.score between 70 and 79 then 1 else 0 end) / count(sc.sid) 中等率,sum(case when sc.score between 80 and 89 then 1 else 0 end) / count(sc.sid) 优良率,sum(case when sc.score between 90 and 100 then 1 else 0 end) / count(sc.sid) 优秀率率from sc,coursewhere sc.cid = course.cidgroup by sc.cidorder by count(sc.sid); 19、按各科成绩进行排序，并显示排名， Score 重复时保留名次空缺12345select a.cid,a.sid,a.score,count(b.sid) + 1from sc a left join sc b on(a.cid = b.cid and a.score &lt; b.score)group by a.cid,a.sidorder by a.cid,count(b.sid) + 1; sc表自身连接。首先可以明确a表连接b表是以相等的cid为条件，那么得到的新表以相同cid，sid为条件分组，这样每一个分组是一个同学对应多个成绩比他高的同学，统计成绩高的同学的个数即可。 20、按各科成绩进行排序，并显示排名， Score 重复时合并名次12 21、查询学生的总成绩，并进行排名，总分重复时保留名次空缺123456select student.*,sum(sc.score)from student,scwhere student.sid = sc.sidgroup by sc.sidorder by sum(sc.score) desc; 22、查询学生的总成绩，并进行排名，总分重复时不保留名次空缺12 23、统计各科成绩各分数段人数：课程编号，课程名称，[100-85]，[85-70]，[70-60]，[60-0] 及所占百分比123456789select sc.cid,course.cname,count(distinct sc.sid) 人数,sum(case when sc.score between 85 and 100 then 1 else 0 end)/count(distinct sc.sid) as '[85-100]',sum(case when sc.score between 70 and 84 then 1 else 0 end)/count(distinct sc.sid) as '[70-84]',sum(case when sc.score between 60 and 69 then 1 else 0 end)/count(distinct sc.sid) as '[60-69]',sum(case when sc.score between 0 and 59 then 1 else 0 end)/count(distinct sc.sid) as '[0-59]'from sc,coursewhere sc.cid = course.cidgroup by sc.cid; 24、查询各科成绩前三名的记录12345678select a.cid,a.sid,a.score,count(b.sid) + 1from sc aleft join sc b on (a.cid = b.cid and a.score &lt; b.score)group by a.sid,a.cidhaving count(b.sid) &lt; 3order by a.cid,count(b.sid) + 1; 25、查询每门课程被选修的学生数1234select course.cname 课程名称,count(sc.cid) 人数 from course,sc where sc.cid = course.cid group by sc.cid; 26、查询出只选修两门课程的学生学号和姓名123456select student.sid,student.snamefrom student,scwhere student.sid = sc.sidgroup by sc.sidhaving count(sc.cid) = 2; 在sc表中以sid作为分组条件，将每位同学选修的课程数找出来，挑选满足条件的与student表进行连接就可以了。 27、查询男生、女生人数1select ssex,count(sid) from student group by ssex; group by 将查询结果按某一列或多列的值分组，值相等的为一组。在这题中，Ssex就是参照列了。此外，group by 还可搭配having短语指定筛选条件。 28、查询名字中含有「风」字的学生信息1select * from student where sname like '%风%'; 29、查询同名同性学生名单，并统计同名人数12345select a.sname,count(a.sid)from student agroup by a.snamehaving count(a.sid) &gt;=2; 以名字分组，同名人数大于2就可以了。 30、查询 1990 年出生的学生名单1select * from student where year(Sage) = 1990; 考察标量函数year的用法。意思是返回Sage中的年分值（year）。类似的还有month，day。 31、查询每门课程的平均成绩，结果按平均成绩降序排列，平均成绩相同时，按课程编号升序排列12345select avg(score)from scgroup by cidorder by avg(score) desc,cid asc; 按cid分组求平均数。 32、查询平均成绩大于等于 85 的所有学生的学号、姓名和平均成绩123456select student.sid,student.sname,avg(sc.score)from student,scwhere student.sid = sc.sidgroup by sc.sidhaving avg(sc.score) &gt;= 85; 有个题目差不多，分组后求平均数，满足条件的就连接。 33、查询课程名称为「数学」，且分数低于 60 的学生姓名和分数123456select student.sname,sc.scorefrom student,sc,coursewhere course.cname = '数学' and course.cid = sc.cid and sc.score &lt; 60 and student.sid = sc.sid; 34、查询所有学生的课程及分数情况（存在学生没成绩，没选课的情况）12345select student.sid 学号,student.sname 姓名,course.cname 课程名称,sc.score 分数from studentleft outer join sc on student.sid = sc.sidleft outer join course on sc.cid = course.cid; 要使得学生没选课的记录也显示出来，这时候要用到外连接。可以看到，学生的基本信息是已知的，未知的是选课信息，所以student表是主体，要做的是把student的悬浮数组保存起来，可以用左外连接来实现。 拓展： 左外连接 left join table on (连接条件)或 left outer join table on (连接条件)右外连接 right join table on (连接条件)或 right outer join table on (连接条件)完全连接 full join 或 full outer join 内连接 join 或 inner join交叉连接 cross join多张表的外连接：123from table1 left outer join table2 on(连接条件) left outer join table3 on(连接条件) ····· 35、查询任何一门课程成绩在 70 分以上的姓名、课程名称和分数1234567select student.sname 姓名,course.cname 课程名称,sc.score 分数from student,sc,coursewhere student.sid = sc.sid and sc.cid = course.cid group by sc.sidhaving max(score) &gt; 70; 36、查询不及格的课程12345select distinct course.cname 课程名称from sc,coursewhere sc.cid = course.cid and sc.score &lt; 60; 37、查询课程编号为 01 且课程成绩在 80 分以上的学生的学号和姓名1234select student.sid,sname from student,sc where student.sid = sc.sid and sc.cid = '01' and sc.score &gt; 80; 38、求每门课程的学生人数1234select course.cname 课程名称,count(sc.sid) 人数 from course,sc where course.cid = sc.cid group by sc.cid; 39、成绩不重复，查询选修「张三」老师所授课程的学生中，成绩最高的学生信息及其成绩123456789select student.*,sc.scorefrom student,sc,course,teacherwhere student.sid = sc.sid andsc.cid = course.cid andcourse.tid = teacher.tid andteacher.tname = '张三'order by sc.score desclimit 1; 40、成绩有重复的情况下，查询选修「张三」老师所授课程的学生中，成绩最高的学生信息及其成绩123456789101112select student.*,sc.scorefrom student,sc,course,teacherwhere student.sid = sc.sid andsc.cid = course.cid andcourse.tid = teacher.tid andteacher.tname = '张三' andsc.score = (select max(score) from sc,course,teacherwhere sc.cid = course.cid andcourse.tid = teacher.tid andteacher.tname = '张三'); 可能有多个最高分，要把所有的最高分找出来，那么可以先找出一个最高分，再把所有与最高分相等的分数找出来。 41、查询不同课程成绩相同的学生的学生编号、课程编号、学生成绩12345select a.sid,a.cid,a.scorefrom sc a ,sc bwhere (a.sid = b.sid and a.cid != b.cid and a.score = b.score)group by a.sid,a.cid; 每个同学有多门课程，找出这些课程中成绩相同的。题目意思都没理解。。。 42、查询每门功成绩最好的前两名123456select a.cid,a.sid,count(b.sid) + 1from sc a left join sc b on(a.cid = b.cid and a.score &lt; b.score)group by a.cid,a.sidhaving count(b.sid) &lt; 2order by a.cid; 43、统计每门课程的学生选修人数（超过 5 人的课程才统计）123456select course.cname 课程,count(sc.sid) 选修人数from sc,coursewhere sc.cid = course.cidgroup by sc.cidhaving count(sc.sid) &gt;=5; 44、检索至少选修两门课程的学生学号12345select sidfrom scgroup by sidhaving count(cid) &gt;= 2; 水题。 45、查询选修了全部课程的学生信息123456789select student.*from student,scwhere student.sid = sc.sidgroup by sc.sidhaving count(sc.cid) &gt;= ( select count(*) from course ); 嵌套一个用来查course表中总课程数。 46、查询各学生的年龄，只按年份来算1select sid 学号,sname 姓名,year(curdate()) - year(sage) 年龄 from student; 47、按照出生日期来算，当前月日 &lt; 出生年月的月日则，年龄减一1234select sid,sname,year(curdate()) - year(sage) -(case when format(now(),'%m%d') &gt; format(sage,'%m%d') then 0 else 1 end) agefrom student; 条件选择，case when () then num else num end。 48、查询本周过生日的学生123select * from studentwhere week(curdate()) = week(sage); 49、查询下周过生日的学生123select * from studentwhere week(curdate()) + 1 = week(sage); 50、查询本月过生日的学生123select * from studentwhere month(curdate()) = month(sage); 51、查询下月过生日的学生123select * from studentwhere month(curdate()) + 1= month(sage); 时间过的好快啊，不知不觉，半个学期没了。我的学生生涯还有多久呢？]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[银行家算法避免死锁问题]]></title>
    <url>%2F2019%2F10%2F13%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81%2F</url>
    <content type="text"><![CDATA[操作系统笔记 算法实现 介绍在死锁避免方法中，把系统的状态分为安全状态和不安全状态。系统处于安全状态，可以避免发生死锁；而当系统处于不安全状态时，则可能发生死锁。死锁是要尽量避免的。 安全状态举例： 现有P1、P2、P3三个进程，它们需要一定的资源才能完成各自的任务，每一种资源一旦被一个进程占用，就不予许另外的进程申请，而当某一进程完成任务时，该进程占用的资源就会释放，也就是说资源可被其它的进程使用。如果三个进程都无妨申请资源以完成各自的任务，这三个进程就会发生死锁。 现在我们需要找到一条有效的执行序列，使得每一个进程都得以执行，不会出现无法申请资源而死锁。 进程 最大需求 已分配 还需要 可用 P1 10 5 5 3 P2 4 2 2 NULL P3 9 2 7 NULL 注最大需求：进程需要该数量资源才能执行已分配：已经分配给该进程的资源数量还需要：即进程一旦申请申请到该数量的资源就可以执行，也就是`还需要 = 最大需求 - 已分配可用：系统中还可以的申请的资源数量，每个尚未完成的进程都可以申请 现在系统中还有3个资源可以被申请。此时，P1需要5个资源，P3需要7个资源，系统可分配的资源不足以分配使得它们执行，只能分配给还需资源数小于可分配数的P2进程。 这样，那就分配2个资源给P2进程，可分配资源还剩下1个。P2进程得到后可执行完成，接着就会释放4个资源，由此，系统可分配资源就增加到了5个。 P1进程还需要5个资源就可以执行完成，所以，我们就可以把可以分配的5个资源全部分配给P1进程，等P1进程执行完成释放10个资源后，可分配的资源就增加到了10个资源。 把可分配资源全部分配给P3进程，使得P3进程执行完成。可分配资源就增加到了12个，当然，不用去管这个问题了，因为我们的进程都已经执行完毕。 由此，我们可以找到一条安全的执行序列P2-&gt;P1-&gt;P3，使得三个进程得以安全的执行而不会发生死锁。 在分配资源给一个进程时，我们需要先尝试着是否能分配资源，如果分配资源后，剩下的资源不足以使得还未完成的进程形成一条安全的执行序列，这就说明此时我们不能分配，如果能够形成安全的序列，则可以分配。 某进程发出资源请求后，相应地可用资源减少，该进程的资源状态改变（也就是上面说的已分配、可用、还需资源数）。剩下的就是在所有进程中找到一条=使所有进程进入安全状态的执行序列。能找到，则可分配，否则不能。有个这个认识，我们就可以来说下银行家算法了。（这段话是基于理论上的，实际上，要先确定能够分配，资源才会减少，但这并不会妨碍我们的解释） 当一个新进程进入系统时，它必须申明在运行过程中，可能需要的每种资源类型的最大单元数，这个数量不应该超过系统所拥有的资源总数，否则无法执行这个新进程。银行家算法来确定当这个新进程发出资源请求时，是否能够满足这个请求。 下面介绍下银行家算法中涉及到的数据结构。 名称 含义 例子 Available 一个含有M个元素的数组，每个元素代表每类资源的可用数量 [1,2,3,4] Max 一个N*M的矩阵，Max[i][j]表示第i个进程需要的最大资源需求 [[1,2,3],[1,2,3],[1,2,3]] Allocation 一个N*M的矩阵，Allocation[i][j]表示第i个进程已经分配了多少资源 Need 一个N*M的矩阵，Need[i][j]表示第i个进程还多少资源就可以参与执行 事实上，这跟我们开篇所提到的安全状态举例类似，我们可以把Max看一个单个的数组，代表每个进程最大资源需求数，当然，已经从一类资源变为多种资源。Allocation和Need也是一样。在银行家算法中使用矩阵统一表示是为了方便。 已知：Need = Max - Allocation 当一个进程完成后，系统将回收该进程占用的资源，即 Available = Available + Max。 银行家算法是为了避免进程死锁的，也就是说，系统提出资源请求时，会有一个Request数组，表示该进程请求的每类资源的数量。 注意： Request &lt;= Need，否则认为出错，因为它申请的资源（Request）不能大于它实际需要的资源（Need）。 Request &lt;= Available，否则认为出错，因为此时申请的资源（Request）已经超过系统可分配的资源，它必须等待 举例说明现系统中有5个进程，分别为P0、P1、P2、P3、P4和3类资源A、B、C。各类资源的数量分别为10、5、7。 具体情况见下表 表1 表1 资源情况 Max Allocation Need Available - 进程 A B C A B C A B C A B C - P0 7 5 3 0 1 0 7 4 3 3 3 2 - P1 3 2 1 2 0 0 1 2 2 - P2 9 0 2 3 0 2 6 0 0 - p3 2 2 2 2 1 1 0 1 1 - p4 4 3 3 0 0 2 4 3 1 现在我们要来找一条能够让这5个进程不发生死锁的执行序列。 需要知道一个进程一旦执行完毕，系统就可以收回该进程所占用的各类资源。所以或许我们可以总结出这样一条规则：总是将系统可以分配的资源全部分配给一个进程来帮助这个进程尽快执行完毕，这样等它执行完毕，系统就回收它占用的资源，从而就可以帮助其他需要资源的多的进程。也就是说，或许把资源分配给资源需求数少的进程是一种较优选择。 如此一来，仔细分析上述表格，我们可以推导出这样一条执行序列： P1-&gt;P3-&gt;P4-&gt;P2-&gt;P0。 对应 表2： 表2 资源情况 Available Allocation Need Available + Allocation - 进程 A B C A B C A B C A B C - P1 3 3 2 2 0 0 1 2 2 5 3 2 - P3 5 3 2 2 1 1 0 1 1 7 4 3 - P4 7 4 3 0 0 2 4 3 1 7 4 5 - p2 7 4 5 3 0 2 6 0 0 10 4 7 - p0 10 4 7 0 1 0 7 4 3 10 5 7 问题一此时P1请求资源，发出Request(1,0,2)，请求1个A资源，0个B资源，2个C资源。 分析 Request(1,0,2) &lt;= Need(1,2,2) Request(1,0,2) &lt;= Available(3 3 2) 现在假设可以为它分配资源，那么P1的资源状态会有如下变化：表3： 表3 资源情况 Max Allocation Need Available - 进程 A B C A B C A B C A B C - P3 3 2 2 3 0 2 0 2 0 2 3 0 也就是Allocation中A+1，C+2，Need中A-1，C-2。 可以看到，此时，系统可以分配的资源就变为了Available(2,3,0)。知道了系统资源可分配量，我们就要在这5个进程中找一个安全序列。再次强调，如果可以找到，就说明假设的分配资源可以实现，否则不行。 接着看5个进程的Need资源量，从中我们要找到一个进程为它分配资源。 发现P3的Need(0,1,1) &lt;= Available(2,3,0)，如果将资源分配给他，P3进程得到资源后可立即执行，执行完毕后可释放资源，这也就意味着Available数量会增加，变化的Available(4,4 1)，就可以分配给那些资源需求量大的进程。直到全部进程执行完毕。 表4： 表4 资源情况 Available Allocation Need Available + Allocation - 进程 A B C A B C A B C A B C - P1 2 3 0 3 0 2 0 2 0 5 3 2 - P3 5 3 2 2 1 1 0 1 1 7 4 3 - P4 7 4 3 0 0 2 4 3 1 7 4 5 - p2 7 4 5 3 0 2 6 0 0 10 4 7 - p0 10 4 7 0 1 0 7 4 3 10 5 7 安全序列： P1-&gt;P3-&gt;P4-&gt;P2-P0 P1-&gt;P3-&gt;P4-&gt;P0-&gt;P2 可以响应请求。 问题二P4发出请求Request(3,3,0)。分析 Request(3,3,0) &lt;= Need(4,3,1) Request(3,3,0) &gt; Available(2,3,0)，不满足条件，让P4等待 不能响应请求。 问题三P0发出请求Request(0,2,0)分析 Request(0,2,0) &lt;= Need(7,4,3) Request(0,2,0) &lt;= Available(2,3,0) 先假设可以分配资源，那么P0资源状态变化为 表5： 表5 资源情况 Max Allocation Need Available - 进程 A B C A B C A B C A B C - P0 7 5 3 0 3 0 7 2 3 2 1 0 此时的系统资源为Available(2,1,0)，可以看到无法满足任何一个进程的Need请求。 不响应请求。 问题四P0发出请求Request(0,1,0)分析 Request(0,1,0) &lt;= Need(7,4,3) Request(0,1,0) &lt;= Available(3,3,2) 可以找到这样一条安全序列P1-&gt;P3-&gt;P4-&gt;P2-&gt;P0 表6： 表6 资源情况 Available Allocation Need Available + Allocation - 进程 A B C A B C A B C A B C - P1 3 2 2 2 0 0 1 2 2 5 2 2 - P3 5 2 2 2 1 1 0 1 1 7 3 3 - P4 7 3 3 0 0 2 4 3 1 7 3 5 - p2 7 3 5 3 0 2 6 0 0 10 3 7 - p0 10 3 7 0 2 0 7 3 3 10 5 7]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sql_select_queries实操]]></title>
    <url>%2F2019%2F09%2F23%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2Fsql_select%2F</url>
    <content type="text"><![CDATA[Lesson 1基本语法1select col,another col from tables; 练习idtitledirectoryearlength_minutes1Toy StoryJohn Lasseter1995812A Bug’s LifeJohn Lasseter1998953Toy Story 2John Lasseter1999934Monsters, Inc.Pete Docter2001925Finding NemoAndrew Stanton20031076The IncrediblesBrad Bird20041167CarsJohn Lasseter20061178RatatouilleBrad Bird20071159WALL-EAndrew Stanton200810410UpPete Docter200910111Toy Story 3Lee Unkrich201010312Cars 2John Lasseter201112013BraveBrenda Chapman201210214Monsters UniversityDan Scanlon2013110 1、Find the title of each film1SELECT title FROM movies; 2、Find the director of each film1SELECT director FROM movies; 3、Find the title and director of each film1SELECT title,director FROM movies; 4、Find the title and year of each film1SELECT title,year FROM movies; 5、Find all the information about each film1SELECT * FROM movies; Lesson 2基本语法12select col from tableswhere some conditions; 练习idtitledirectoryearlength_minutes1Toy StoryJohn Lasseter1995812A Bug’s LifeJohn Lasseter1998953Toy Story 2John Lasseter1999934Monsters, Inc.Pete Docter2001925Finding NemoAndrew Stanton20031076The IncrediblesBrad Bird20041167CarsJohn Lasseter20061178RatatouilleBrad Bird20071159WALL-EAndrew Stanton200810410UpPete Docter200910111Toy Story 3Lee Unkrich201010312Cars 2John Lasseter201112013BraveBrenda Chapman201210214Monsters UniversityDan Scanlon2013110 1、Find the movie with a row id of 61SELECT * FROM movies where id=6; 2、Find the movies released in the years between 2000 and 2010\1SELECT * FROM movies where year between 2000 and 2010; 3、Find the movies not released in the years between 2000 and 20101SELECT * FROM movies where year not between 2000 and 2010; 4、Find the first 5 Pixar movies and their release year1SELECT * FROM movies where id in (1,2,3,4,5); Lesson 3练习idtitledirectoryearlength_minutes1Toy StoryJohn Lasseter1995812A Bug’s LifeJohn Lasseter1998953Toy Story 2John Lasseter1999934Monsters, Inc.Pete Docter2001925Finding NemoAndrew Stanton20031076The IncrediblesBrad Bird20041167CarsJohn Lasseter20061178RatatouilleBrad Bird20071159WALL-EAndrew Stanton200810410UpPete Docter200910111Toy Story 3Lee Unkrich201010312Cars 2John Lasseter201112013BraveBrenda Chapman201210214Monsters UniversityDan Scanlon201311087WALL-GBrenda Chapman204297 1、Find all the Toy Story movies1SELECT * FROM movies where title like &quot;%Toy Story%&quot;; 2、Find all the movies directed by John Lasseter1SELECT * FROM movies where director = &quot;John Lasseter&quot;; 3、Find all the movies (and director) not directed by John Lasseter1SELECT * FROM movies where director != &quot;John Lasseter&quot;; 4、Find all the WALL-* movies1SELECT * FROM movies where title like &quot;%WALL-%&quot;; Lesson 4基本语法1234567891011SELECT DISTINCT column, another_column, …FROM mytableWHERE condition(s)ORDER BY column ASC/DESCLIMIT num_limit OFFSET num_offset;//DISTINCT 在查询结果中删除重复的行//ASC 升序//DESC 降序//limit 表示限制查询后显示的数量//offset 表示从哪一行开始计数 练习idtitledirectoryearlength_minutes1Toy Story 2John Lasseter1999932RatatouilleBrad Bird20071153Toy StoryJohn Lasseter1995814WALL-EAndrew Stanton20081045The IncrediblesBrad Bird20041166Monsters UniversityDan Scanlon20131107Finding NemoAndrew Stanton20031078Cars 2John Lasseter20111209A Bug’s LifeJohn Lasseter19989510CarsJohn Lasseter200611711UpPete Docter200910112BraveBrenda Chapman201210213Toy Story 3Lee Unkrich201010314Monsters, Inc.Pete Docter200192 1、List all directors of Pixar movies (alphabetically), without duplicates123SELECT distinct director FROM movies order by director ASC; 2、List the last four Pixar movies released (ordered from most recent to least)1234SELECT * FROM movies order by year DESClimit 4; 3、List the first five Pixar movies sorted alphabetically1234SELECT * FROM movies order by title ASClimit 5; 4、List the next five Pixar movies sorted alphabetically1234SELECT * FROM movies order by title ASClimit 5 offset 5; Lesson 5基本语法12345SELECT column, another_column, …FROM mytableWHERE condition(s)ORDER BY column ASC/DESCLIMIT num_limit OFFSET num_offset; 练习citycountrypopulationlatitudelongitudeGuadalajaraMexico150080020.659699-103.349609TorontoCanada279506043.653226-79.383184HoustonUnited States219591429.760427-95.369803New YorkUnited States840583740.712784-74.005941PhiladelphiaUnited States155316539.952584-75.165222HavanaCuba210614623.05407-82.345189Mexico CityMexico855550019.432608-99.133208PhoenixUnited States151336733.448377-112.074037Los AngelesUnited States388430734.052234-118.243685Ecatepec de MorelosMexico174200019.601841-99.050674MontrealCanada171776745.501689-73.567256ChicagoUnited States271878241.878114-87.629798 1、List all the Canadian cities and their populations123SELECT * FROM north_american_citieswhere country=&quot;Canada&quot;; 2、Order all the cities in the United States by their latitude from north to south1234SELECT * FROM north_american_citieswhere country=&quot;United States&quot;order by Latitude DESC; 3、List all the cities west of Chicago, ordered from west to east1234SELECT * FROM north_american_citieswhere longitude &lt; -87.629798order by longitude ASC; 4、List the two largest cities in Mexico (by population)12345SELECT * FROM north_american_citieswhere country = &quot;Mexico&quot;order by population DESClimit 2; 5、List the third and fourth largest cities (by population) in the United States and their population12345SELECT * FROM north_american_citieswhere country = &quot;United States&quot;order by population DESClimit 2 offset 2;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[类与对象实训]]></title>
    <url>%2F2019%2F09%2F21%2Fjava%2F%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%AE%9E%E8%AE%AD%2F</url>
    <content type="text"><![CDATA[任务描述模拟银行ATM机，编写一具有简单操作界面的JAVA程序，实现包括存款、取款、查询等功能在内的简单应用 任务分析相关操作涉及的实体：123用户类(Account) 属性：姓名、银行卡号、密码、余额。操作：、存款、取款 123ATM类属性：登陆系统的用户操作：登录、显示、存款、取款、查询余额 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; ATM atm = new ATM(); atm.load_Sys(); &#125;&#125;class Account &#123; private String Password; private String Name; private double Balance; private String Number; Account() &#123;&#125;; Account(String Name,String Number,String Password,double Balance) &#123; this.Name = Name; this.Password = Password; this.Number = Number; this.Balance = Balance; &#125; public String getName() &#123; return this.Name; &#125; public void setName(String Name) &#123; this.Name = Name; &#125; public String getPassword() &#123; return this.Password; &#125; public void setPassword(String Password) &#123; this.Password = Password; &#125; public String getNumber() &#123; return this.Number; &#125; public void setNumber(String Number) &#123; this.Number = Number; &#125; public double getBalance() &#123; return this.Balance; &#125; public void setBalance(double Balance) &#123; this.Balance = Balance; &#125; public void add_Balance(double balance) &#123; this.Balance += balance; &#125; public void sub_Balance(double balance) &#123; this.Balance -= balance; &#125; public void show_balance() &#123; System.out.println("卡上余额为：" + this.Balance); &#125;&#125;class ATM &#123; Account act; public ATM() &#123; act = new Account("gageshan","****","****",50000000); &#125; private void welcome() &#123; System.out.println("---------------------------------"); System.out.println("1-取款"); System.out.println("2-存款"); System.out.println("3-查询"); System.out.println("4-推出"); System.out.println("---------------------------------"); &#125; public void load_Sys() &#123; String card ; String password ; Scanner sc = new Scanner(System.in); System.out.print("请输入您的银行卡号："); card = sc.next(); System.out.print("请输入您的密码："); password = sc.next(); int cnt = 1; while(!check_sys(card,password)) &#123; if(cnt &gt; 3) System.exit(0); cnt++; System.out.print("密码错误，请重新输入："); password = sc.next(); &#125; System.out.println("密码正确"); while(true) &#123; welcome(); System.out.print("请输入你想进行的操作："); int op = sc.nextInt(); if(op == 1) &#123; bet_balance(); &#125; else if(op == 2) &#123; add_balance(); &#125; else if(op == 3) &#123; query_balance(); &#125; else &#123; System.exit(0); &#125; &#125; &#125; private boolean check_sys(String card,String password) &#123; if(act.getNumber().equals(card) &amp;&amp; act.getPassword().equals(password)) &#123; // System.out.println("hello the cruel world"); return true; &#125; else return false; &#125; private boolean check_balance(double money) &#123; if(money &gt;= act.getBalance()) return true; return false; &#125; private void bet_balance() &#123; Scanner sc = new Scanner(System.in); System.out.print("请输入您取款的金额："); double money = sc.nextDouble(); if(check_balance(money)) &#123; System.out.println("余额不足！"); return ; &#125; else &#123; act.sub_Balance(money); System.out.println("取款成功！"); &#125; &#125; private void add_balance() &#123; System.out.print("请输入您存款的金额："); Scanner sc = new Scanner(System.in); double money = sc.nextDouble(); act.add_Balance(money); System.out.println("存款成功！"); &#125; private void query_balance() &#123; System.out.println("当前余额为：" + act.getBalance()); &#125;&#125;]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[鎕鎕鎕 HihoCoder - 1838 (贪心+思维)]]></title>
    <url>%2F2019%2F09%2F12%2F%E8%B4%AA%E5%BF%83%2F%E9%8E%95%E9%8E%95%E9%8E%95%20HihoCoder%20-%201838%20%EF%BC%88%E8%B4%AA%E5%BF%83%2B%E6%80%9D%E7%BB%B4%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目https://cn.vjudge.net/problem/HihoCoder-1838 鎕鎕有 2n + 1 张卡片，每张卡片上都有两个数字，第 i 张卡片上的两个数字分别是 Ai 与 Bi。 现在鎕鎕要从所有卡片中选出恰好 n + 1 张卡片，然后计算他选出的所有卡片中 Ai 的和与 Bi 的和。他的目的是要使他选出的卡片的Ai 的和与 Bi 的和，都要分别大于剩下 n 张没选的卡片的 Ai 的和与 Bi 的和。 鎕鎕最近沉迷于玩 Switch，所以他希望你能帮他解决这个问题。 Input输入第一行是一个整数 n，意义如以上所示。 接下来有 2n + 1 行，每行为两个正整数，第 i 行的两个正整数分别代表 Ai 和 Bi。 数据保证 1 ≤ n ≤ 100000，1 ≤ Ai, Bi ≤ 109。 Output如果无法选出 n + 1 张卡片满足鎕鎕的要求，输出一个数 -1。否则输出 n + 1 行，每行有一个正整数，表示选出的卡片编号（从 1 开始）。如果有多解，输出任意一组解均可。 Sample Input12345624 29 45 37 58 1 Sample Output123342 思路刚开始写还脑残似的写了个爆搜，我是个zz。 题目要求：选出n+1个元素使得这n+1个元素a值和b值总和分别大于其余的n个元素a值总和、b值总和。 其实对于n+1个元素或n个元素我们并不需要真的把a值总和、b值总和求出来，我们可以把问题转化成为只要对于n个元素中每个元素来说，我们都能在n+1个元素中找到一个不同的的元素，使得该元素的b的值大于那n个元素中的某元素的b的值就可以满足b的总和这一条件了。a的总和同理。 那么实际上，就可以以a值为排序的关键值对整个数组排序，接着对每两个相邻的元素，取那个b值较大的元素就可以了。 代码1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=5e5+10;struct node &#123; int a,b; int index;&#125;;int n;node arr[MAXN];bool cmp(node x,node y)&#123; return x.a&lt;y.a;&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=2*n+1;i++) &#123; scanf("%d%d",&amp;arr[i].a,&amp;arr[i].b); arr[i].index=i; &#125; sort(arr+1,arr+2*n+2,cmp); int st[MAXN]; int cnt=0; for(int i=1;i&lt;=n;i++) if(arr[2*i].b&lt;arr[2*i-1].b) st[cnt++]=(arr[2*i-1].index); else st[cnt++]=(arr[2*i].index); st[cnt++]=(arr[2*n+1].index); for(int i=0;i&lt;cnt;i++) printf("%d\n",st[i]); return 0;&#125;]]></content>
      <categories>
        <category>贪心算法</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[金银岛]]></title>
    <url>%2F2019%2F09%2F12%2F%E8%B4%AA%E5%BF%83%2F%E9%87%91%E9%93%B6%E5%B2%9B%2F</url>
    <content type="text"><![CDATA[题目某天KID利用飞行器飞到了一个金银岛上，上面有许多珍贵的金属，KID虽然更喜欢各种宝石的艺术品，可是也不拒绝这样珍贵的金属。但是他只带着一个口袋，口袋至多只能装重量为w的物品。岛上金属有s个种类, 每种金属重量不同，分别为n 1, n 2, … , n s，同时每个种类的金属总的价值也不同，分别为v 1,v 2, …, v s。KID想一次带走价值尽可能多的金属，问他最多能带走价值多少的金属。注意到金属是可以被任意分割的，并且金属的价值和其重量成正比。Input第1行是测试数据的组数k，后面跟着k组输入。 每组测试数据占3行，第1行是一个正整数w (1 &lt;= w &lt;= 10000)，表示口袋承重上限。第2行是一个正整数s (1 &lt;= s &lt;=100)，表示金属种类。第3行有2s个正整数，分别为n 1, v 1, n 2, v 2, … , n s, v s分别为第一种，第二种，…，第s种金属的总重量和总价值(1 &lt;= n i &lt;= 10000, 1 &lt;= v i &lt;= 10000)。Outputk行，每行输出对应一个输入。输出应精确到小数点后2位。Sample Input1234567250410 100 50 30 7 34 87 1001000051 43 43 323 35 45 43 54 87 43 Sample Output12171.93508.00 题解该题跟圣诞老人题类似传送，单位重量内价值越高优先选择。 代码12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;algorithm&gt;const int MAXSIZE=10000+5;using namespace std;struct Node&#123; int weight; int value; double single;&#125;;bool cmp(struct Node a,struct Node b)&#123;return a.single&gt;b.single;&#125;int main()&#123; int Case; cin&gt;&gt;Case; while(Case--)&#123; int w; cin&gt;&gt;w; int s; cin&gt;&gt;s; struct Node arr[MAXSIZE]; for(int i=0;i&lt;s;i++)&#123; cin&gt;&gt;arr[i].weight&gt;&gt;arr[i].value; arr[i].single=arr[i].value*1.0/arr[i].weight; &#125; sort(arr,arr+s,cmp); int sum=0; int i=0; double allVal=0; for(i=0;i&lt;s&amp;&amp;(sum+arr[i].weight)&lt;=w;i++)&#123; sum+=arr[i].weight; allVal+=arr[i].value; &#125; if(i&lt;s) allVal=allVal+(w-sum)*arr[i].single; printf(&quot;%.2lf\n&quot;,allVal); &#125; return 0;&#125;]]></content>
      <categories>
        <category>贪心算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[老人是真饿了 HDU - 2187]]></title>
    <url>%2F2019%2F09%2F12%2F%E8%B4%AA%E5%BF%83%2F%E8%80%81%E4%BA%BA%E6%98%AF%E7%9C%9F%E9%A5%BF%E4%BA%86%20HDU%20-%202187%20%2F</url>
    <content type="text"><![CDATA[题目时间：2008年5月16日（震后第4天）地点：汶川县牛脑寨人物：羌族老奶奶 【转载整理】牛脑寨是一个全村600多人的羌族寨子，震后几天，这里依然能常常听到隆隆的声音，那是对面山上石头不断滑落的声音。在完成整个突击队的抢修移动基站的任务后，我提着相机开始记录这里的受创情况。突然，我的视线里出现一个羌族老人，这让我无比的震惊，要知道，那是一个极陡的坡，这个佝偻着腰的老人是怎么艰难地爬上来的？她上来做什么？ 老人背后是极陡的坡，她只有一只眼睛有依稀的视力，望着满地废墟，她徘徊了很久。家在哪里，她极力地用很低的视力找寻着。她曾经的家就在旁边，但是满目废墟已经让老人看不出来。她举目远眺，期望那里能看到家的一点点痕迹。原来家就在旁边，左手抓住一个房橼，努力让自己站住，地震过去三天了，她第一次回到曾经的家。 一个倒塌的柜子，里面装着一丝希望，老人很吃力地搬动掩盖在柜子上的薪柴。老人找到一把木匠用的刨子，老泪纵横，或许有哪个逝去的亲人是木匠。睹物思人，逝者已矣。 继续找，一把散碎的挂面出现在我的眼前。她颤颤巍巍地捞起铺满灰尘的挂面，再次流出了眼泪……看着她仔细地把挂面放进胸前的围腰里，我顿然感觉到，这是老人在得到外援之前赖以生存的口粮了，如果不是交通中断，外部救援进不来，老人家又何必拖着80多岁的躯体，强忍失去亲人的痛苦，重新回到这夺取她亲人生命的废墟，寻找这点点挂面？老人是真饿了…… 老人佝偻着腰，低声喃喃地念着那两句话“你们走了，我可怎么活”，拿着那对我们身处城市的人们微不足道的挂面，远去了…… PS: 拍完这组照片后我才知道，5月14号军用运输飞机第一次给汶川空投救援物资就掉在牛脑寨，受灾的村民们没有占为己有，而是汗流浃背地走了两个小时背到山下的县城交给政府。 对于幸存的灾民来说，最急待解决的显然是温饱问题，救灾部队一边在组织人员全力打通交通，一边在组织采购粮食。现在假设下拨了一定数量的救灾经费要去市场采购大米（散装）。如果市场有m种大米，各种大米的单价和重量已知，请问，为了满足更多灾民的需求，最多能采购多少重量的大米呢？Input输入数据首先包含一个正整数C，表示有C组测试用例，每组测试用例的第一行是两个整数n和m（0&lt;n&lt;=1000,0&lt;m&lt;=1000）,分别表示经费的金额和大米的种类，然后是m行数据，每行包含2个整数p和h(1&lt;=p&lt;=25,1&lt;=h&lt;=100)，分别表示单价和对应大米的重量。Output对于每组测试数据，请输出能够购买大米的最多重量（你可以假设经费买不光所有的大米）。每个实例的输出占一行，保留2位小数。Sample Input123417 23 34 4 Sample Output12.33 题解对大米的价格从低到高排序，再贪心过一遍 代码1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;algorithm&gt; using namespace std;const int MAXSIZE=1000+5;struct Node&#123; int p; int h;&#125;;bool cmp(struct Node a,struct Node b)&#123; return a.p&lt;b.p;&#125;int main()&#123; int Case; cin&gt;&gt;Case; while(Case--)&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; struct Node arr[MAXSIZE]; for(int i=0;i&lt;m;i++) cin&gt;&gt;arr[i].p&gt;&gt;arr[i].h; sort(arr,arr+m,cmp); int i=0; int sum=0; double allVal=0; int S=0; for(i=0;i&lt;m&amp;&amp;((sum+arr[i].p*arr[i].h)&lt;=n);i++)&#123; sum+=arr[i].p*arr[i].h; S+=arr[i].h; &#125; if(i&lt;m) allVal=(n-sum)/arr[i].p+(n-sum)%arr[i].p*1.0/arr[i].p; printf(&quot;%.2lf\n&quot;,allVal+S); &#125; return 0;&#125;]]></content>
      <categories>
        <category>贪心算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第五届新疆省ACM-ICPC程序设计竞赛（重现赛）D - O(n!）（贪心）]]></title>
    <url>%2F2019%2F09%2F12%2F%E8%B4%AA%E5%BF%83%2F%E7%AC%AC%E4%BA%94%E5%B1%8A%E6%96%B0%E7%96%86%E7%9C%81ACM-ICPC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B-D%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目链接：https://ac.nowcoder.com/acm/contest/911/D来源：牛客网 有 n件商品，第 i件商品价格为 a[i]，购买后，其它所有未购买的商品价格乘上 p[i]，现在要买下所有商品，输出最小耗费。输入描述:第一行一个整数 n(n≤105)，接下来 n 行，第 i 行两个数字a[i],p[i]，其中 a[i] 为整数，p[i] 为浮点数，1≤a[i]≤105,0≤p[i]≤1。输出描述:保留六位小数输出。示例1输入12321 0.510 1 输出16.000000 示例2输入1234327545 0.7977924 0.164441 0.66 输出185769.339000 备注: 样例 1：先买 1 号商品，再买 2 号商品。 样例 2：先买 2 号商品，再买 1 号，最后买 3 号。 思路首先对于两个物品，有物品1(v1,p1),物品2(v2,p2)；先取第一个物品：ans1=v1+p1v2；先取第二个物品：ans2=v2+p2v1； 要使得ans1&lt;ans2,则有v1+p1v2&lt;v2+p2v1,化简后：v1/(1-p1)&lt;v2/(1-p2) 对于两个物品是如此，三个乃至更多的物品就是从局部解推及到最优解。 代码123456789101112131415161718192021222324252627282930313233343536373839404142/*https://ac.nowcoder.com/acm/contest/911/DAC*/#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=1e5+10;struct node &#123; double value; double price; double x;&#125;;node arr[MAXN];bool cmp(node a,node b)&#123; return a.x&lt;b.x;&#125;int main() &#123; int N; scanf("%d",&amp;N); for(int i=1;i&lt;=N;i++) &#123; scanf("%lf%lf",&amp;arr[i].value,&amp;arr[i].price); arr[i].x=arr[i].value/(1-arr[i].price); &#125; sort(arr+1,arr+N+1,cmp); // for(int i=1;i&lt;=N;i++)// cout&lt;&lt;arr[i].value&lt;&lt;' '&lt;&lt;arr[i].price&lt;&lt;' '&lt;&lt;arr[i].x&lt;&lt;endl; long double sum=0; long double p=1.0; for(int i=1;i&lt;=N;i++) &#123; sum+=arr[i].value*p; p*=arr[i].price; &#125; printf("%.6Lf\n",sum); return 0;&#125;]]></content>
      <categories>
        <category>贪心算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最少拦截系统 HDU - 1257]]></title>
    <url>%2F2019%2F09%2F12%2F%E8%B4%AA%E5%BF%83%2F%E6%9C%80%E5%B0%91%E6%8B%A6%E6%88%AA%E7%B3%BB%E7%BB%9F%20HDU%20-%201257%20%2F</url>
    <content type="text"><![CDATA[题目某国为了防御敌国的导弹袭击,发展出一种导弹拦截系统.但是这种导弹拦截系统有一个缺陷:虽然它的第一发炮弹能够到达任意的高度,但是以后每一发炮弹都不能超过前一发的高度.某天,雷达捕捉到敌国的导弹来袭.由于该系统还在试用阶段,所以只有一套系统,因此有可能不能拦截所有的导弹.怎么办呢?多搞几套系统呗!你说说倒蛮容易,成本呢?成本是个大问题啊.所以俺就到这里来求救了,请帮助计算一下最少需要多少套拦截系统.Input输入若干组数据.每组数据包括:导弹总个数(正整数),导弹依此飞来的高度(雷达给出的高度数据是不大于30000的正整数,用空格分隔)Output对应每组数据输出拦截所有导弹最少要配备多少套这种导弹拦截系统.Sample Input18 389 207 155 300 299 170 158 65 Sample Output12 题解导弹是依次飞来的并且每一发都不能超过前一发的高度，可知当后一个导弹的高度高于前一个时，就需要一个新的拦截系统。如果仅仅是这么想，就会被坑了。因为之前的拦截系统的最后一发炮弹的高度可能比新的拦截系统的高度要高。比如这组数据 389 207 155 300 299 170 158 65 100，不想清楚后一种可能那么就需要三套，实际上两套就行了。 代码123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int MAXSIZE=50000;int main()&#123; int n; while(cin&gt;&gt;n)&#123; int sum=0; int arr[MAXSIZE]; for(int i=0;i&lt;n;i++) cin&gt;&gt;arr[i]; int check=1; for(int i=0;i&lt;n;)&#123; if(check==i) break; check=i; int first=arr[i]; int flag=1; for(int j=i+1;j&lt;n;j++)&#123; if(first&gt;arr[j]&amp;&amp;arr[j]!=0)&#123; first=arr[j]; arr[j]=0; &#125; if(flag==1&amp;&amp;first&lt;arr[j])&#123; flag=0; i=j; &#125; &#125; &#125; for(int i=0;i&lt;n;i++) if(arr[i]!=0) sum++; cout&lt;&lt;sum&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>贪心算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小新整数]]></title>
    <url>%2F2019%2F09%2F12%2F%E8%B4%AA%E5%BF%83%2F%E6%9C%80%E5%B0%8F%E6%96%B0%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目给定一个十进制正整数n(0 &lt; n &lt; 1000000000)，每个数位上数字均不为0。n的位数为m。现在从m位中删除k位(0&lt;k &lt; m)，求生成的新整数最小为多少？例如: n = 9128456, k = 2, 则生成的新整数最小为12456Input第一行t, 表示有t组数据；接下来t行，每一行表示一组测试数据，每组测试数据包含两个数字n, k。Outputt行，每行一个数字，表示从n中删除k位后得到的最小整数。Sample Input12329128456 21444 3 Sample Output12124561 题解前一位数与后一位数比较，若大于后一位就删掉它。 代码123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int main()&#123; int Case; cin&gt;&gt;Case; while(Case--)&#123; char str[20]; int k; cin&gt;&gt;str&gt;&gt;k; while(k--)&#123; for(int i=0;i&lt;strlen(str);i++)&#123; if(str[i]&gt;str[i+1])&#123; for(int j=i;j&lt;strlen(str);j++) str[j]=str[j+1]; break; &#125; &#125; &#125; cout&lt;&lt;str&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>贪心算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[圣诞老人的礼物-Santa Clau’s Gifts]]></title>
    <url>%2F2019%2F09%2F12%2F%E8%B4%AA%E5%BF%83%2F%E5%9C%A3%E8%AF%9E%E8%80%81%E4%BA%BA%E7%9A%84%E7%A4%BC%E7%89%A9-Santa%20Clau%E2%80%99s%20Gifts%20%2F</url>
    <content type="text"><![CDATA[题目圣诞节来临了，在城市A中圣诞老人准备分发糖果，现在有多箱不同的糖果，每箱糖果有自己的价值和重量，每箱糖果都可以拆分成任意散装组合带走。圣诞老人的驯鹿最多只能承受一定重量的糖果，请问圣诞老人最多能带走多大价值的糖果。Input第一行由两个部分组成，分别为糖果箱数正整数n(1 &lt;= n &lt;= 100)，驯鹿能承受的最大重量正整数w（0 &lt; w &lt; 10000），两个数用空格隔开。其余n行每行对应一箱糖果，由两部分组成，分别为一箱糖果的价值正整数v和重量正整数w，中间用空格隔开。Output输出圣诞老人能带走的糖果的最大总价值，保留1位小数。输出为一行，以换行符结束。Sample Input123454 15100 4412 8266 7591 2 Sample Output11193.0 题解由一箱糖果的总价值和它的总重量可以算出每一份重量所对应的价值，记为份重量=总价值/总重量。要尽可能地带走价值大的糖果，那么在载重允许范围内，份重量对应的糖果价值越大带走的糖果价值就越高。对份重量从高到底排序，选择即可 代码1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;algorithm&gt;const int MAXSIZE=100+5;using namespace std;struct Santa&#123; int value; int weight; double single;&#125;;bool cmp(struct Santa a,struct Santa b)&#123;return a.single&gt;b.single;&#125;int main()&#123; struct Santa arr[MAXSIZE]; int n,w; while(cin&gt;&gt;n&gt;&gt;w)&#123; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;arr[i].value&gt;&gt;arr[i].weight; arr[i].single=(arr[i].value*1.0)/(arr[i].weight*1.0); &#125; sort(arr,arr+n,cmp); int sum=0; double allVal=0; int i=0; while((arr[i].weight+sum)&lt;=w)&#123; allVal=allVal+arr[i].value; sum+=arr[i].weight; i++; if(i&gt;=n) break; &#125; if(i&lt;n) allVal=allVal+arr[i].single*(w-sum); printf(&quot;%.1lf\n&quot;,allVal); &#125; return 0;&#125;//AC]]></content>
      <categories>
        <category>贪心算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[今年暑假不AC HDU - 2037]]></title>
    <url>%2F2019%2F09%2F12%2F%E8%B4%AA%E5%BF%83%2F%E4%BB%8A%E5%B9%B4%E6%9A%91%E5%81%87%E4%B8%8DAC%20HDU%20-%202037%20%2F</url>
    <content type="text"><![CDATA[题目“今年暑假不AC？”“是的。”“那你干什么呢？”“看世界杯呀，笨蛋！”“@#$%^&amp;*%…” 确实如此，世界杯来了，球迷的节日也来了，估计很多ACMer也会抛开电脑，奔向电视了。作为球迷，一定想看尽量多的完整的比赛，当然，作为新时代的好青年，你一定还会看一些其它的节目，比如新闻联播（永远不要忘记关心国家大事）、非常6+7、超级女生，以及王小丫的《开心辞典》等等，假设你已经知道了所有你喜欢看的电视节目的转播时间表，你会合理安排吗？（目标是能看尽量多的完整节目）Input输入数据包含多个测试实例，每个测试实例的第一行只有一个整数n(n&lt;=100)，表示你喜欢看的节目的总数，然后是n行数据，每行包括两个数据Ti_s,Ti_e (1&lt;=i&lt;=n)，分别表示第i个节目的开始和结束时间，为了简化问题，每个时间都用一个正整数表示。n=0表示输入结束，不做处理。Output对于每个测试实例，输出能完整看到的电视节目的个数，每个测试实例的输出占一行。Sample Input1234567891011121314121 33 40 73 815 1915 2010 158 186 125 104 142 90 Sample Output15 思路简单题。对节目的结束时间从低到高排序，再贪心 代码1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int MAXSIZE=100+5;struct Time&#123; int begin; int end;&#125;;bool cmp(struct Time a,struct Time b)&#123; return a.end&lt;b.end;&#125;int main()&#123; int N; while(cin&gt;&gt;N)&#123; if(N==0) break; struct Time arr[MAXSIZE]; for(int i=0;i&lt;N;i++) cin&gt;&gt;arr[i].begin&gt;&gt;arr[i].end; sort(arr,arr+N,cmp); int ans=1; int j=0; for(int i=1;i&lt;N;i++) if(arr[i].begin&gt;=arr[j].end)&#123; ans++; j=i; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>贪心算法</category>
      </categories>
      <tags>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Saving HDU HDU - 2111]]></title>
    <url>%2F2019%2F09%2F12%2F%E8%B4%AA%E5%BF%83%2FSaving%20HDU%20HDU%20-%202111%20%2F</url>
    <content type="text"><![CDATA[题目话说上回讲到海东集团面临内外交困，公司的元老也只剩下XHD夫妇二人了。显然，作为多年拼搏的商人，XHD不会坐以待毙的。 一天，当他正在苦思冥想解困良策的时候，突然想到了自己的传家宝，那是公司成立的时候，父亲作为贺礼送来的一个锦囊，徐父当时交代，不到万不得已的时候，不要打开它。“现在不正是最需要的时候吗？”，一边想，XHD一边找到了这个精心保管的锦囊，打开一看，里面只有一句话“杭城北麓千人洞有宝”。 二话不说，XHD拿起一个大口袋就出发了，这个千人洞他是知道的，小的时候，爸爸曾经带他来过这个隐蔽的路口，并告诉他，这是千人洞。他现在才明白爸爸当初这句话的含义。 尽管有点印象，XHD还是花了很大的精力才找到这个异常隐蔽的洞口，走进一看，几乎惊呆了，真的是眼花缭乱！不过尽管宝贝的种类不少，但是每种宝贝的量并不多，当然，每种宝贝单位体积的价格也不一样，为了挽救HDU，现在请你帮忙尽快计算出来XHD最多能带回多少价值的宝贝？（假设宝贝可以分割，分割后的价值和对应的体积成正比）Input输入包含多个测试实例，每个实例的第一行是两个整数v和n(v,n&lt;100)，分别表示口袋的容量和宝贝的种类，接着的n行每行包含2个整数pi和mi(0&lt;pi,mi&lt;10)，分别表示某种宝贝的单价和对应的体积，v为0的时候结束输入。Output对于每个测试实例，请输出XHD最多能取回多少价值的宝贝，每个实例的输出占一行。Sample Input12342 23 12 30 Sample Output15 经过锦囊相助，HDU会脱离危机吗？欲知后事如何，且听下回分解—— 题解对宝贝的价值从高到底排序，再贪心 代码12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int MAXSIZE=500+5;struct Node&#123; int pi; int mi;&#125;;bool cmp(struct Node a,struct Node b)&#123; return a.pi&gt;b.pi;&#125;int main()&#123; int v,n; while(cin&gt;&gt;v)&#123; if(v==0) break; cin&gt;&gt;n; struct Node arr[MAXSIZE]; for(int i=0;i&lt;n;i++) cin&gt;&gt;arr[i].pi&gt;&gt;arr[i].mi; sort(arr,arr+n,cmp); int sum=0; int allVal=0; int i=0; for(i=0;i&lt;n&amp;&amp;((sum+arr[i].mi)&lt;=v);i++)&#123; sum+=arr[i].mi; allVal+=arr[i].pi*arr[i].mi; //if(i&gt;=n) break; &#125; if(i&lt;n) allVal+=(v-sum)*arr[i].pi; cout&lt;&lt;allVal&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>贪心算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Repair the Wall HDU - 2124]]></title>
    <url>%2F2019%2F09%2F12%2F%E8%B4%AA%E5%BF%83%2FRepair%20the%20Wall%20HDU%20-%202124%20%2F</url>
    <content type="text"><![CDATA[题目Long time ago , Kitty lived in a small village. The air was fresh and the scenery was very beautiful. The only thing that troubled her is the typhoon. When the typhoon came, everything is terrible. It kept blowing and raining for a long time. And what made the situation worse was that all of Kitty’s walls were made of wood.One day, Kitty found that there was a crack in the wall. The shape of the crack isa rectangle with the size of 1×L (in inch). Luckly Kitty got N blocks and a saw(锯子) from her neighbors.The shape of the blocks were rectangle too, and the width of all blocks were 1 inch. So, with the help of saw, Kitty could cut down some of the blocks(of course she could use it directly without cutting) and put them in the crack, and the wall may be repaired perfectly, without any gap. Now, Kitty knew the size of each blocks, and wanted to use as fewer as possible of the blocks to repair the wall, could you help her ?InputThe problem contains many test cases, please process to the end of file( EOF ).Each test case contains two lines.In the first line, there are two integers L(0&lt;L&lt;1000000000) and N(0&lt;=N&lt;600) whichmentioned above.In the second line, there are N positive integers. The i th integer Ai(0&lt;Ai&lt;1000000000 ) means that the i th block has the size of 1×Ai (in inch).OutputFor each test case , print an integer which represents the minimal number of blocks are needed.If Kitty could not repair the wall, just print “impossible” instead.Sample Input12345 33 2 15 22 1 Sample Output122impossible 思路这道题的大致意思是有个长为Len的缺口，要用尽可能少的砖去补上它，题目告诉了砖的长度。对砖的长度从大到小排序再贪心即可 代码123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int MAXSIZE=600+6;bool cmp(int a,int b)&#123;return a&gt;b;&#125;int main()&#123; int Len,N; while(cin&gt;&gt;Len&gt;&gt;N)&#123; int arr[MAXSIZE]; for(int i=0;i&lt;N;i++) scanf(&quot;%d&quot;,&amp;arr[i]); sort(arr,arr+N,cmp); int ans=0; int sum=0; for(int i=0;i&lt;N;i++)&#123; if(sum&lt;Len)&#123; ans++; sum+=arr[i]; &#125; &#125; if(sum&lt;Len) cout&lt;&lt;&quot;impossible&quot;&lt;&lt;endl; else cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>贪心算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nyoj-71-独木舟上的旅行（贪心入门]]></title>
    <url>%2F2019%2F09%2F12%2F%E8%B4%AA%E5%BF%83%2Fnyoj71%E7%8B%AC%E6%9C%A8%E8%88%9F%E4%B8%8A%E7%9A%84%E6%97%85%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[描述独木舟上的旅行时间限制：3000 ms | 内存限制：65535 KB难度：2描述进行一次独木舟的旅行活动，独木舟可以在港口租到，并且之间没有区别。一条独木舟最多只能乘坐两个人，且乘客的总重量不能超过独木舟的最大承载量。我们要尽量减少这次活动中的花销，所以要找出可以安置所有旅客的最少的独木舟条数。现在请写一个程序，读入独木舟的最大承载量、旅客数目和每位旅客的重量。根据给出的规则，计算要安置所有旅客必须的最少的独木舟条数，并输出结果。输入第一行输入s,表示测试数据的组数；每组数据的第一行包括两个整数w，n，80&lt;=w&lt;=200,1&lt;=n&lt;=300，w为一条独木舟的最大承载量,n为人数；接下来的一组数据为每个人的重量（不能大于船的承载量）；输出每组人数所需要的最少独木舟的条数。样例输入1234567385 65 84 85 80 84 8390 390 45 60100 550 50 90 40 60 样例输出123533 题解以最小的体重为基准，再从最大体重中往下找，满足承载重就说明两者可以搭乘同一船，否则就只有最小的那一个独自搭船。然后依次选择剩下的最小体重。说明：一条船只能坐两人。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;//--const int MAXSIZE=300+5;//--int main()&#123; int Case; cin&gt;&gt;Case; while(Case--)&#123; int weith,people; cin&gt;&gt;weith&gt;&gt;people; int a[MAXSIZE]; for(int i=0;i&lt;people;i++) cin&gt;&gt;a[i]; sort(a,a+people); int ans=0; for(int i=0;i&lt;people;i++)&#123; if(a[i]!=0)&#123; int value=weith-a[i]; for(int j=people-1;j&gt;i;j--)&#123; if(value&gt;=a[j]&amp;&amp;a[j]!=0)&#123; value=value-a[j]; a[j]=0; break; &#125; &#125; ans++; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; /*385 65 84 85 80 84 8390 390 45 60100 550 50 90 40 60*/]]></content>
      <categories>
        <category>贪心算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nyoj-13-会场安排问题（贪心入门]]></title>
    <url>%2F2019%2F09%2F12%2F%E8%B4%AA%E5%BF%83%2Fnyoj14%E4%BC%9A%E5%9C%BA%E5%AE%89%E6%8E%92%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[描述会场安排问题学校的小礼堂每天都会有许多活动，有时间这些活动的计划时间会发生冲突，需要选择出一些活动进行举办。小刘的工作就是安排学校小礼堂的活动，每个时间最多安排一个活动。现在小刘有一些活动计划的时间表，他想尽可能的安排更多的活动，请问他该如何安排。输入第一行是一个整型数m(m&lt;100)表示共有m组测试数据。每组测试数据的第一行是一个整数n(1&lt;n&lt;10000)表示该测试数据共有n个活动。随后的n行，每行有两个正整数Bi,Ei(0&lt;=Bi,Ei&lt;10000),分别表示第i个活动的起始与结束时间（Bi&lt;=Ei)输出对于每一组输入，输出最多能够安排的活动数量。每组的输出占一行样例输入12345678221 1010 1131 1010 1111 20 样例输出1212 提示注意：如果上一个活动在t时间结束，下一个活动最早应该在t+1时间开始 题解活动越早结束，剩余的时间就越多。那么每次找最早结束的活动，然后继续在剩下的活动中找最小的。当然这些满足一个条件，即如提示说明。 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;//--const int MAXSIZE=10000+5;class node&#123; public: int Bi; int Ei;&#125;;node a[MAXSIZE];//--bool cmp(node a,node b)&#123; return a.Ei&lt;b.Ei;&#125;int main()&#123; int Case; cin&gt;&gt;Case; while(Case--)&#123; int n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i].Bi&gt;&gt;a[i].Ei; sort(a,a+n,cmp); int ans=1; int t=0; for(int i=1;i&lt;n;i++)&#123; if(a[i].Bi&gt;a[t].Ei)&#123; ans++; t=i; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>贪心算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Crossing River POJ - 1700 （经典题）]]></title>
    <url>%2F2019%2F09%2F12%2F%E8%B4%AA%E5%BF%83%2FCrossing%20River%20POJ%20-%201700%20%EF%BC%88%E7%BB%8F%E5%85%B8%E9%A2%98%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目A group of N people wishes to go across a river with only one boat, which can at most carry two persons. Therefore some sort of shuttle arrangement must be arranged in order to row the boat back and forth so that all people may cross. Each person has a different rowing speed; the speed of a couple is determined by the speed of the slower one. Your job is to determine a strategy that minimizes the time for these people to get across.InputThe first line of the input contains a single integer T (1 &lt;= T &lt;= 20), the number of test cases. Then T cases follow. The first line of each case contains N, and the second line contains N integers giving the time for each people to cross the river. Each case is preceded by a blank line. There won’t be more than 1000 people and nobody takes more than 100 seconds to cross.OutputFor each test case, print a line containing the total number of seconds required for all the N people to cross the river.Sample Input123141 2 5 10 Sample Output117 思路刚开始看到这题时，脑海里首先想到的是让速度最快的的人一趟趟地来回接送，这样就可以使得回来的时间最少，从而总时间最少。然而，却发现这种方法连样列都过不了，那么这种方法肯定是有问题。接着忽然想到，如果先把最快和次快的先运过去，让最快的回来，再让最慢和次慢的过去，让次快的回来，这样子，就把最慢和次慢的运过去，其中运最慢和次慢的时间为{最慢}，而不是像第一段中的为{最慢+次慢}。再一次写好，交上去，WA。。。。又想到，这不是贪心吗！贪心肯定是每次着眼于当前最有利的吗？明白了。1、最快和最慢运过去，最快回来；再，最快和次慢过去，最快回来。2、最快和次快运过去，最快回来；再，最慢和次慢过去，次快回来。这两种方案都可以把最慢和次慢运过去，即取两者所花时间最少方案。 代码12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=1e6;int n;int arr[MAXN];bool cmp(int a,int b) &#123; return a&lt;b;&#125;int main() &#123; // freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); int Case; cin&gt;&gt;Case; while(Case--) &#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;arr[i]; sort(arr+1,arr+n+1,cmp); int ans=0; int i; for(i=n;i&gt;3;i-=2) &#123; int MIN=min(arr[i]+arr[i-1]+2*arr[1],arr[1]+2*arr[2]+arr[i]); ans+=MIN; &#125; if(i==3) ans+=arr[1]+arr[2]+arr[3]; else if(i==2) ans+=arr[2]; else ans+=arr[1]; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>贪心算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bookshelf]]></title>
    <url>%2F2019%2F09%2F12%2F%E8%B4%AA%E5%BF%83%2Fbookshelf%2F</url>
    <content type="text"><![CDATA[题目Farmer John recently bought a bookshelf for cow library, but the shelf is getting filled up quite quickly, and now the only available space is at the top. Each of the N cows (1 &lt;= N &lt;= 20,000) has some height of H_i (1 &lt;= H_i &lt;= 10,000) and a total height summed across all N cows of S. The bookshelf has a height of B (1 &lt;= B &lt;= S &lt; 2,000,000,007). To reach the top of the bookshelf taller than the tallest cow, one or more of the cows can stand on top of each other in a stack, so that their total height is the sum of each of their individual heights. This total height must be no less than the height of the bookshelf. Since more cows than necessary in the stack can be dangerous, your job is to find the set of cows that produces a stack of the smallest number of cows possible such that the stack can reach the bookshelf.Input Line 1: Two space-separated integers: N and B Lines 2..N+1: Line i+1 contains a single integer: H_iOutput Line 1: A single integer representing the size of the smallest set of cows that can reach the bookshelf.Sample Input12345676 4061811131911 Sample Output13 Hint1234567INPUT DETAILS: Six cows; bookshelf height 40. Cow heights fall in the range 6..19. OUTPUT DETAILS: One way to reach 40 with 3 cows is 18+11+13; many others exist 题解不断贪最大高度直到高于height即可。 代码1234567891011121314151617181920212223#include&lt;iostream&gt;#include&lt;algorithm&gt;const int MAXSIZE=20000+5;using namespace std;bool cmp(int a,int b)&#123;return a&gt;b;&#125;int main()&#123; int N,height; while(cin&gt;&gt;N&gt;&gt;height)&#123; int arr[MAXSIZE]; for(int i=0;i&lt;N;i++) cin&gt;&gt;arr[i]; sort(arr,arr+N,cmp); int sum=0; int i=0; for(i=0;i&lt;N;i++)&#123; sum+=arr[i]; if(sum&gt;=height) break; &#125; cout&lt;&lt;i&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>贪心算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迷宫寻路可视化]]></title>
    <url>%2F2019%2F09%2F12%2F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%2F%E8%BF%B7%E5%AE%AB%E5%AF%BB%E8%B7%AF%E5%8F%AF%E8%A7%86%E5%8C%96%2F</url>
    <content type="text"><![CDATA[学了数据结构，一直想做个东西出来玩。八皇后？五子棋？贪吃蛇？推箱子？二叉树？来个我最熟悉的迷宫求解吧。函数说明：设置背景颜色：setbkcolor(RED);画线算法：line(x1,y1,x2,y2);画矩阵算法：rectangle(left,top,right,bottom);字体颜色：settextcolor(YELLOW);输出字符串：RECT r = { left,top,right,bottom}; drawtext(_T(“退出”), &amp;r, DT_CENTER | DT_VCENTER | DT_SINGLELINE);编译环境：Visual Studio 2017123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577#include &lt;iostream&gt;#include &lt;graphics.h&gt;#include&lt;malloc.h&gt;#include &lt;time.h&gt;#include &lt;conio.h&gt;//在控制台输入输出文件using namespace std;#define MAXSIZE 1000+10void MEUN2(struct Stack *&amp;stack, struct Queue *&amp;queue);void MEUN1(struct Stack *&amp;stack, struct Queue *&amp;queue);void init();void PrintLine();void FillColor();void QueueRoad(struct Queue *&amp;queue);void StackRoad(struct Stack *&amp;stack);//栈寻找迷宫路径struct Box&#123; int x; int y; int di;//方位值&#125;;struct Stack&#123; struct Box data[MAXSIZE]; int top;&#125;;//队列寻找迷宫路径struct Box1&#123; int x; int y; int pre;&#125;;struct Queue&#123; struct Box1 data[MAXSIZE]; int rear; int front;&#125;;int px1 = 0, px2 = 0, py1 = 0, py2 = 0;int flag1 = 0;//迷宫数组int mg[14][22] = &#123; 0 &#125;;//设置迷宫的边界void init() &#123; for (int i = 0; i &lt; 14; i++) for (int j = 0; j &lt; 22; j++) mg[i][j] = 0; for (int i = 0; i &lt; 14; i++) mg[i][21] = 1; for (int i = 0; i &lt; 14; i++) mg[i][0] = 1; for (int i = 0; i &lt; 22; i++) mg[13][i] = 1; for (int i = 0; i &lt; 22; i++) mg[0][i] = 1;&#125;//栈寻找路径bool StackFind(struct Stack *&amp;stack, int x1, int y1, int x2, int y2)&#123; int i = 0; int j = 0; struct Box box; //di的用来记录方位值，如果要退回的话，就不用再一次的重新来找一遍了 box.x = x1; box.y = y1; box.di = -1; stack-&gt;top++; stack-&gt;data[stack-&gt;top] = box; mg[x1][y1] = -1; //solidrectangle((box.y-1) * 50, (box.x-1) * 50, (box.y-1) * 50 + 50, (box.x-1) * 50 + 50); while (stack-&gt;top != -1) &#123; box = stack-&gt;data[stack-&gt;top]; int x = box.x; int y = box.y; int di = box.di; if (x == x2 &amp;&amp; y == y2) return true; else &#123; while (di &lt; 4) &#123; di++; switch (di) &#123; case 0: i = x - 1; j = y; break; case 1: i = x; j = y + 1; break; case 2: i = x + 1; j = y; break; case 3: i = x; j = y - 1; break; &#125; if (mg[i][j] == 0) break; &#125; if (di &lt; 4) &#123; stack-&gt;data[stack-&gt;top].di = di; box.x = i; box.y = j; box.di = -1; stack-&gt;top++; stack-&gt;data[stack-&gt;top] = box; mg[i][j] = -1; &#125; else &#123; stack-&gt;top--; mg[x][y] = 0; &#125; &#125; &#125; return false;&#125;//队列寻找路径bool QueueFind(struct Queue *&amp;queue, int x1, int y1, int x2, int y2)&#123; int i = 0; int j = 0; //pre的用来记录上一个可走方块在 struct Box1 box1; box1.x = x1; box1.y = y1; box1.pre = -1; queue-&gt;rear++; queue-&gt;data[queue-&gt;rear] = box1; mg[x1][y1] = -1; while (queue-&gt;rear != queue-&gt;front) &#123; queue-&gt;front++; box1 = queue-&gt;data[queue-&gt;front]; int x = box1.x; int y = box1.y; if (x == x2 &amp;&amp; y == y2) &#123; return true; &#125; else &#123; int di = -1; while (di &lt; 4) &#123; di++; switch (di) &#123; case 0: i = x - 1; j = y; break; case 1: i = x; j = y + 1; break; case 2: i = x + 1; j = y; break; case 3: i = x; j = y - 1; break; &#125; if (mg[i][j] == 0) &#123; box1.x = i; box1.y = j; box1.pre = queue-&gt;front; queue-&gt;rear++; queue-&gt;data[queue-&gt;rear] = box1; mg[i][j] = -1; &#125; &#125; &#125; &#125;&#125;//画迷宫图形void PrintLine()&#123; setbkcolor(WHITE); cleardevice(); //画迷宫图形 setlinecolor(BLACK); for (int i = 0; i &lt;= 1000; i += 50) line(i, 0, i, 1000); for (int i = 0; i &lt;= 600; i += 50) line(0, i, 1000, i);&#125;//填充颜色void FillColor()&#123; setfillcolor(RED); //填充颜色，以分别可走路径和不可走路径 int flag = 1; for (int i = 0; i &lt; 1000; i += 50) &#123; for (int j = 0; j &lt; 600; j += 50) &#123; //随机设置位置为不可走状态 flag = rand(); if (flag % 2 != 0 &amp;&amp; flag % 3 != 0) &#123; solidrectangle(i, j, i + 50, j + 50); mg[(j + 50) / 50][(i + 50) / 50] = 1; Sleep(10); &#125; &#125; &#125;&#125;void QueueRoad(struct Queue *&amp;queue)&#123; if (QueueFind(queue, px1, py1, px2, py2) == true) &#123; int root = queue-&gt;front; while (root != 0) &#123; int pre = queue-&gt;data[root].pre; queue-&gt;data[root].pre = -1; root = pre; &#125; struct Box1 box1; for (int i = 1; i &lt; queue-&gt;front; i++)&#123; if (queue-&gt;data[i].pre == -1) &#123; setfillcolor(GREEN); box1 = queue-&gt;data[i]; solidrectangle((box1.y - 1) * 50, (box1.x - 1) * 50, (box1.y - 1) * 50 + 50, (box1.x - 1) * 50 + 50); Sleep(1000); &#125; &#125; &#125;&#125;void StackRoad(struct Stack *&amp;stack)&#123; struct Box box; if (StackFind(stack, px1, py1, px2, py2) == true) &#123; for (int i = 1; i &lt; stack-&gt;top; i++) &#123; setfillcolor(GREEN); box = stack-&gt;data[i]; solidrectangle((box.y - 1) * 50, (box.x - 1) * 50, (box.y - 1) * 50 + 50, (box.x - 1) * 50 + 50); //暂停0.1s钟以便于观察路径过程 Sleep(1000); &#125; &#125;&#125;void MEUN1(struct Stack *&amp;stack,struct Queue *&amp;queue)&#123; initgraph(1300, 600); setbkmode(TRANSPARENT);//透明字体 HWND hwnd = GetHWnd();//获取当前窗口句柄 setbkcolor(RED); cleardevice(); setlinecolor(GREEN); settextcolor(GREEN);//字体颜色 LOGFONT f; gettextstyle(&amp;f); // 获取当前字体设置 f.lfHeight = 48; // 设置字体高度为 48 _tcscpy_s(f.lfFaceName, _T(&quot;微软雅黑&quot;)); // 设置字体为“黑体”(高版本 VC 推荐使用 _tcscpy_s 函数) //f.lfQuality = ANTIALIASED_QUALITY; // 设置输出效果为抗锯齿 settextstyle(&amp;f); // 设置字体样式 rectangle(550, 300, 750, 400); rectangle(550, 400, 750, 500); rectangle(550, 500, 750, 600); RECT r1 = &#123; 550, 300, 750, 400 &#125;; drawtext(_T(&quot;栈寻路&quot;), &amp;r1, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r2 = &#123; 550, 400, 750, 500 &#125;; drawtext(_T(&quot;队列寻路&quot;), &amp;r2, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r3 = &#123; 550,500,750,600 &#125;; drawtext(_T(&quot;退出&quot;), &amp;r3, DT_CENTER | DT_VCENTER | DT_SINGLELINE); MOUSEMSG Mou; BeginBatchDraw(); bool flag = true; while (flag) &#123; Mou = GetMouseMsg(); switch (Mou.uMsg) &#123; case WM_MOUSEMOVE: EndBatchDraw(); if ((Mou.y &gt;= 300 &amp;&amp; Mou.y &lt;= 400) &amp;&amp; (Mou.x &lt;= 750 &amp;&amp; Mou.x &gt;= 550)) &#123; settextcolor(YELLOW); rectangle(550, 300, 750, 400); RECT r1 = &#123; 550, 300, 750, 400 &#125;; drawtext(_T(&quot;栈寻路&quot;), &amp;r1, DT_CENTER | DT_VCENTER | DT_SINGLELINE); settextcolor(GREEN); rectangle(550, 400, 750, 500); RECT r2 = &#123; 550,400,750,500 &#125;; drawtext(_T(&quot;队列寻路&quot;), &amp;r2, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r3 = &#123; 550, 750, 500, 600 &#125;; drawtext(_T(&quot;退出&quot;), &amp;r3, DT_CENTER | DT_VCENTER | DT_SINGLELINE); &#125; else if (Mou.y &gt;= 400 &amp;&amp; Mou.y &lt;= 500 &amp;&amp; Mou.x &lt;= 750 &amp;&amp; Mou.x &gt;= 550) &#123; settextcolor(YELLOW); RECT r2 = &#123; 550,400,750,500 &#125;; drawtext(_T(&quot;队列寻路&quot;), &amp;r2, DT_CENTER | DT_VCENTER | DT_SINGLELINE); settextcolor(GREEN); rectangle(550, 300, 750, 400); RECT r1 = &#123; 550, 300, 750, 400 &#125;; drawtext(_T(&quot;栈寻路&quot;), &amp;r1, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r3 = &#123; 550, 750, 500, 600 &#125;; drawtext(_T(&quot;退出&quot;), &amp;r3, DT_CENTER | DT_VCENTER | DT_SINGLELINE); &#125; else if (Mou.x &gt;= 550 &amp;&amp; Mou.x &lt;= 750 &amp;&amp; Mou.y &gt;= 500 &amp;&amp; Mou.y &lt;= 600) &#123; settextcolor(YELLOW); RECT r3 = &#123; 550, 500, 750, 600 &#125;; drawtext(_T(&quot;退出&quot;), &amp;r3, DT_CENTER | DT_VCENTER | DT_SINGLELINE); settextcolor(GREEN); rectangle(550, 300, 750, 400); rectangle(550, 400, 750, 500); RECT r1 = &#123; 550, 300, 750, 400 &#125;; drawtext(_T(&quot;栈寻路&quot;), &amp;r1, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r2 = &#123; 550, 400, 750, 500 &#125;; drawtext(_T(&quot;队列寻路&quot;), &amp;r2, DT_CENTER | DT_VCENTER | DT_SINGLELINE); &#125; else &#123; settextcolor(GREEN); rectangle(550, 300, 750, 400); rectangle(550, 400, 750, 500); rectangle(550, 500, 750, 600); RECT r1 = &#123; 550, 300, 750, 400 &#125;; drawtext(_T(&quot;栈寻路&quot;), &amp;r1, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r2 = &#123; 550, 400, 750, 500 &#125;; drawtext(_T(&quot;队列寻路&quot;), &amp;r2, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r3 = &#123; 550,500,750,600 &#125;; drawtext(_T(&quot;退出&quot;), &amp;r3, DT_CENTER | DT_VCENTER | DT_SINGLELINE); &#125; break; case WM_LBUTTONDOWN: EndBatchDraw(); if (Mou.x &gt;= 550 &amp;&amp; Mou.x &lt;= 750 &amp;&amp; Mou.y &lt;= 400 &amp;&amp; Mou.y &gt;= 300) &#123; flag1 = 1; closegraph(); MEUN2(stack,queue); &#125; else if (Mou.x &gt;= 550 &amp;&amp; Mou.x &lt;= 750 &amp;&amp; Mou.y &gt;= 400 &amp;&amp; Mou.y &lt;= 500)&#123; flag1 = 2; closegraph(); MEUN2(stack,queue); &#125; else if (Mou.x &gt;= 550 &amp;&amp; Mou.x &lt;= 750 &amp;&amp; Mou.y &gt;= 500 &amp;&amp; Mou.y &lt;= 600) &#123; closegraph(); flag = false; &#125; break; &#125; &#125;&#125;void MEUN2(struct Stack *&amp;stack, struct Queue *&amp;queue)&#123; initgraph(1300, 600); setbkcolor(WHITE); cleardevice(); PrintLine(); settextcolor(GREEN);//字体颜色 LOGFONT f; gettextstyle(&amp;f); // 获取当前字体设置 f.lfHeight = 48; // 设置字体高度为 48 _tcscpy_s(f.lfFaceName, _T(&quot;微软雅黑&quot;)); // 设置字体为“黑体”(高版本 VC 推荐使用 _tcscpy_s 函数) f.lfQuality = ANTIALIASED_QUALITY; // 设置输出效果为抗锯齿 settextstyle(&amp;f); // 设置字体样式 rectangle(1050, 100, 1250, 150);//设置起点 rectangle(1050, 150, 1250, 200);//设置终点 rectangle(1050, 200, 1250, 250);//随机障碍 rectangle(1050, 250, 1250, 300);//开始寻路 rectangle(1050, 300, 1250, 350);//退出迷宫 RECT r1 = &#123; 1050, 100, 1250, 150 &#125;; drawtext(_T(&quot;设置起点&quot;), &amp;r1, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r2 = &#123; 1050, 150, 1250, 200 &#125;; drawtext(_T(&quot;设置终点&quot;), &amp;r2, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r3 = &#123; 1050, 200, 1250, 250 &#125;; drawtext(_T(&quot;随机障碍&quot;), &amp;r3, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r4 = &#123; 1050, 250, 1250, 300 &#125;; drawtext(_T(&quot;开始寻路&quot;), &amp;r4, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r5 = &#123; 1050, 300, 1250, 350 &#125;; drawtext(_T(&quot;退出迷宫&quot;), &amp;r5, DT_CENTER | DT_VCENTER | DT_SINGLELINE); MOUSEMSG Mou; while (true) &#123; Mou = GetMouseMsg(); BeginBatchDraw(); switch (Mou.uMsg) &#123; case WM_MOUSEMOVE: EndBatchDraw(); if ((Mou.x &gt;= 1050 &amp;&amp; Mou.x &lt;= 1250) &amp;&amp; (Mou.y &gt;= 100 &amp;&amp; Mou.y &lt;= 150)) &#123; settextcolor(YELLOW); rectangle(1050, 100, 1250, 150); RECT r1 = &#123; 1050, 100, 1250, 150 &#125;; drawtext(_T(&quot;设置起点&quot;), &amp;r1, DT_CENTER | DT_VCENTER | DT_SINGLELINE); settextcolor(GREEN); rectangle(1050, 150, 1250, 200);//设置终点 rectangle(1050, 200, 1250, 250);//随机障碍 rectangle(1050, 250, 1250, 300);//开始寻路 rectangle(1050, 300, 1250, 350);//退出迷宫 RECT r2 = &#123; 1050, 150, 1250, 200 &#125;; drawtext(_T(&quot;设置终点&quot;), &amp;r2, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r3 = &#123; 1050, 200, 1250, 250 &#125;; drawtext(_T(&quot;随机障碍&quot;), &amp;r3, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r4 = &#123; 1050, 250, 1250, 300 &#125;; drawtext(_T(&quot;开始寻路&quot;), &amp;r4, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r5 = &#123; 1050, 300, 1250, 350 &#125;; drawtext(_T(&quot;退出迷宫&quot;), &amp;r5, DT_CENTER | DT_VCENTER | DT_SINGLELINE); &#125; else if (Mou.x &gt;= 1050 &amp;&amp; Mou.x &lt;= 1250 &amp;&amp; Mou.y &gt;= 150 &amp;&amp; Mou.y &lt;= 200) &#123; settextcolor(YELLOW); rectangle(1050, 150, 1250, 200); RECT r2 = &#123; 1050, 150, 1250, 200 &#125;; drawtext(_T(&quot;设置终点&quot;), &amp;r2, DT_CENTER | DT_VCENTER | DT_SINGLELINE); settextcolor(GREEN); rectangle(1050, 100, 1250, 150);//设置起点 rectangle(1050, 200, 1250, 250);//随机障碍 rectangle(1050, 250, 1250, 300);//开始寻路 rectangle(1050, 300, 1250, 350);//退出迷宫 RECT r1 = &#123; 1050, 100, 1250, 150 &#125;; drawtext(_T(&quot;设置起点&quot;), &amp;r1, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r3 = &#123; 1050, 200, 1250, 250 &#125;; drawtext(_T(&quot;随机障碍&quot;), &amp;r3, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r4 = &#123; 1050, 250, 1250, 300 &#125;; drawtext(_T(&quot;开始寻路&quot;), &amp;r4, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r5 = &#123; 1050, 300, 1250, 350 &#125;; drawtext(_T(&quot;退出迷宫&quot;), &amp;r5, DT_CENTER | DT_VCENTER | DT_SINGLELINE); &#125; else if (Mou.x &gt;= 1050 &amp;&amp; Mou.x &lt;= 1250 &amp;&amp; Mou.y &gt;= 200 &amp;&amp; Mou.y &lt;= 250) &#123; stack-&gt;top = -1; queue-&gt;front = queue-&gt;rear = -1; settextcolor(YELLOW); rectangle(1050, 200, 1250, 250); RECT r3 = &#123; 1050, 200, 1250, 250 &#125;; drawtext(_T(&quot;随机障碍&quot;), &amp;r3, DT_CENTER | DT_VCENTER | DT_SINGLELINE); settextcolor(GREEN); rectangle(1050, 100, 1250, 150);//设置起点 rectangle(1050, 150, 1250, 200);//设置终点 rectangle(1050, 250, 1250, 300);//开始寻路 rectangle(1050, 300, 1250, 350);//退出迷宫 RECT r1 = &#123; 1050, 100, 1250, 150 &#125;; drawtext(_T(&quot;设置起点&quot;), &amp;r1, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r2 = &#123; 1050, 150, 1250, 200 &#125;; drawtext(_T(&quot;设置终点&quot;), &amp;r2, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r4 = &#123; 1050, 250, 1250, 300 &#125;; drawtext(_T(&quot;开始寻路&quot;), &amp;r4, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r5 = &#123; 1050, 300, 1250, 350 &#125;; drawtext(_T(&quot;退出迷宫&quot;), &amp;r5, DT_CENTER | DT_VCENTER | DT_SINGLELINE); &#125; else if (Mou.x &gt;= 1050 &amp;&amp; Mou.x &lt;= 1250 &amp;&amp; Mou.y &lt;= 300 &amp;&amp; Mou.y &gt;= 250) &#123; settextcolor(YELLOW); rectangle(1050, 250, 1250, 300); RECT r4 = &#123; 1050, 250, 1250, 300 &#125;; drawtext(_T(&quot;开始寻路&quot;), &amp;r4, DT_CENTER | DT_VCENTER | DT_SINGLELINE); settextcolor(GREEN); rectangle(1050, 100, 1250, 150);//设置起点 rectangle(1050, 150, 1250, 200);//设置终点 rectangle(1050, 200, 1250, 250);//随机障碍 rectangle(1050, 300, 1250, 350);//退出迷宫 RECT r1 = &#123; 1050, 100, 1250, 150 &#125;; drawtext(_T(&quot;设置起点&quot;), &amp;r1, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r2 = &#123; 1050, 150, 1250, 200 &#125;; drawtext(_T(&quot;设置终点&quot;), &amp;r2, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r3 = &#123; 1050, 200, 1250, 250 &#125;; drawtext(_T(&quot;随机障碍&quot;), &amp;r3, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r5 = &#123; 1050, 300, 1250, 350 &#125;; drawtext(_T(&quot;退出迷宫&quot;), &amp;r5, DT_CENTER | DT_VCENTER | DT_SINGLELINE); &#125; else if (Mou.x &gt;= 1050 &amp;&amp; Mou.x &lt;= 1250 &amp;&amp; Mou.y &gt;= 300 &amp;&amp; Mou.y &lt;= 350) &#123; settextcolor(YELLOW); rectangle(1050, 250, 1250, 300); RECT r5 = &#123; 1050, 300, 1250, 350 &#125;; drawtext(_T(&quot;退出迷宫&quot;), &amp;r5, DT_CENTER | DT_VCENTER | DT_SINGLELINE); settextcolor(GREEN); rectangle(1050, 100, 1250, 150);//设置起点 rectangle(1050, 150, 1250, 200);//设置终点 rectangle(1050, 200, 1250, 250);//随机障碍 rectangle(1050, 250, 1250, 300);//开始寻路 RECT r1 = &#123; 1050, 100, 1250, 150 &#125;; drawtext(_T(&quot;设置起点&quot;), &amp;r1, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r2 = &#123; 1050, 150, 1250, 200 &#125;; drawtext(_T(&quot;设置终点&quot;), &amp;r2, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r3 = &#123; 1050, 200, 1250, 250 &#125;; drawtext(_T(&quot;随机障碍&quot;), &amp;r3, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r4 = &#123; 1050, 250, 1250, 300 &#125;; drawtext(_T(&quot;开始寻路&quot;), &amp;r4, DT_CENTER | DT_VCENTER | DT_SINGLELINE); &#125; else &#123; settextcolor(GREEN); rectangle(1050, 100, 1250, 150);//设置起点 rectangle(1050, 150, 1250, 200);//设置终点 rectangle(1050, 200, 1250, 250);//随机障碍 rectangle(1050, 250, 1250, 300);//开始寻路 rectangle(1050, 300, 1250, 350);//退出迷宫 RECT r1 = &#123; 1050, 100, 1250, 150 &#125;; drawtext(_T(&quot;设置起点&quot;), &amp;r1, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r2 = &#123; 1050, 150, 1250, 200 &#125;; drawtext(_T(&quot;设置终点&quot;), &amp;r2, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r3 = &#123; 1050, 200, 1250, 250 &#125;; drawtext(_T(&quot;随机障碍&quot;), &amp;r3, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r4 = &#123; 1050, 250, 1250, 300 &#125;; drawtext(_T(&quot;开始寻路&quot;), &amp;r4, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r5 = &#123; 1050, 300, 1250, 350 &#125;; drawtext(_T(&quot;退出迷宫&quot;), &amp;r5, DT_CENTER | DT_VCENTER | DT_SINGLELINE); &#125; break; case WM_LBUTTONDOWN: EndBatchDraw(); if (Mou.x &gt;= 1050 &amp;&amp; Mou.x &lt;= 1250 &amp;&amp; Mou.y &gt;= 100 &amp;&amp; Mou.y &lt;= 150) &#123; bool flag = true; while (flag) &#123; //FlushMouseMsgBuffer(); Mou = GetMouseMsg(); BeginBatchDraw(); switch (Mou.uMsg) &#123; case WM_LBUTTONDOWN: EndBatchDraw(); py1 = Mou.x / 50; px1 = Mou.y / 50; if (mg[py1 + 1][px1 + 1] != 1) &#123; setfillcolor(BLUE); fillrectangle(Mou.x / 50 * 50, Mou.y / 50 * 50, Mou.x / 50 * 50 + 50, Mou.y / 50 * 50 + 50); flag = false; &#125; py1 += 1; px1 += 1; break; &#125; &#125; &#125; else if (Mou.x &gt;= 1050 &amp;&amp; Mou.x &lt;= 1250 &amp;&amp; Mou.y &gt;= 150 &amp;&amp; Mou.y &lt;= 200) &#123; bool flag = true; while (flag) &#123; //FlushMouseMsgBuffer(); Mou = GetMouseMsg(); BeginBatchDraw(); switch (Mou.uMsg) &#123; case WM_LBUTTONDOWN: EndBatchDraw(); py2 = Mou.x / 50; px2 = Mou.y / 50; if (mg[py2 + 1][px2 + 1] != 1) &#123; setfillcolor(YELLOW); fillrectangle(Mou.x / 50 * 50, Mou.y / 50 * 50, Mou.x / 50 * 50 + 50, Mou.y / 50 * 50 + 50); flag = false; &#125; py2 += 1; px2 += 1; break; &#125; &#125; &#125; else if (Mou.x &gt;= 1050 &amp;&amp; Mou.x &lt;= 1250 &amp;&amp; Mou.y &gt;= 200 &amp;&amp; Mou.y &lt;= 250) &#123; stack-&gt;top = -1; queue-&gt;front = queue-&gt;rear = -1; init(); cleardevice(); PrintLine(); FillColor(); &#125; else if (Mou.x &gt;= 1050 &amp;&amp; Mou.x &lt;= 1250 &amp;&amp; Mou.y &lt;= 300 &amp;&amp; Mou.y &gt;= 250) &#123; if (flag1 == 1) &#123; cout &lt;&lt; px1 &lt;&lt; &apos; &apos; &lt;&lt; py1 &lt;&lt; endl; cout &lt;&lt; px2 &lt;&lt; &apos; &apos; &lt;&lt; py2 &lt;&lt; endl; StackRoad(stack); &#125; else if (flag1 == 2) &#123; cout &lt;&lt; px1 &lt;&lt; &apos; &apos; &lt;&lt; py1 &lt;&lt; endl; cout &lt;&lt; px2 &lt;&lt; &apos; &apos; &lt;&lt; py2 &lt;&lt; endl; QueueRoad(queue); &#125; &#125; else if (Mou.x &gt;= 1050 &amp;&amp; Mou.x &lt;= 1250 &amp;&amp; Mou.y &gt;= 300 &amp;&amp; Mou.y &lt;= 350) &#123; closegraph(); stack-&gt;top = -1; queue-&gt;front = queue-&gt;rear = -1; flag1 = 0; init(); MEUN1(stack,queue); &#125; &#125; &#125;&#125;int main()&#123; //栈 struct Stack *stack; stack = (struct Stack *)malloc(sizeof(struct Stack)); stack-&gt;top = -1; //队列 struct Queue *queue; queue = (struct Queue *)malloc(sizeof(struct Queue)); queue-&gt;rear = queue-&gt;front = -1; //设置迷宫边界值 init(); //Sleep(1000); MEUN1(stack,queue); return 0;&#125; 编译完整版本：链接：https://pan.baidu.com/s/1RrWjaRj_w47mxJy3aWdBhw提取码：0dy0 下个目标：五子棋？]]></content>
      <categories>
        <category>课程设计</category>
      </categories>
      <tags>
        <tag>小玩具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux课设-用gcc实现Linux简单命令]]></title>
    <url>%2F2019%2F09%2F12%2F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%2FLinux%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[说明利用gcc实现 ls , cp, pwd, cd 常用的linux命令功能用gcc实现一些常用的linux命令功能，具体实现如下如下命令： mkdir 创建目录 rm 删除文件或目录 cp 复制文件 cd 更改路径 exit 退出系统 pwd 打印当前路径 ll 列出当前路径的所有文件或目录 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;math.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;#include &lt;dirent.h&gt;#include &lt;fcntl.h&gt;#define MAXN 1024void mkdirs(char dir[]) &#123; char str[MAXN]; strcpy(str,dir); int len = strlen(str); for(int i = 0;i &lt; len; i++) &#123; if(str[i] == '/') &#123; str[i] = '\0'; if(access(str,0) != 0) mkdir(str,0777); str[i] = '/'; &#125; &#125; if(len &gt; 0 &amp;&amp; access(str,0) != 0) mkdir(str,07770); return;&#125;void rmdirs(char dir[]) &#123; char dirname[MAXN]; strcpy(dirname,dir); int ans = rmdir(dirname); if(ans) printf("rm:can't remove %s: No such file or directory\n",dirname); return;&#125;void exits() &#123; exit(0);&#125;char pwds(int op) &#123; char buf[MAXN]; getcwd(buf,sizeof(buf)); if(op == 1) printf("[%s]$ ",buf); else printf("%s\n",buf);&#125;void cps(char file1[],char file2[]) &#123; int f1 = open(file1,O_RDWR|O_CREAT,0777); int f2 = open(file2,O_RDWR|O_CREAT,0777); char buff[MAXN]; read(f1,buff,MAXN); int len = strlen(buff); write(f2,buff,len); close(f1); close(f2);&#125;void cds(char dirname[]) &#123; char name[MAXN]; strcpy(name,dirname); if(chdir(name) != 0) &#123; printf("cd: %s :No such directory\n",dirname); &#125; return;&#125;void lists(char dirname[]) &#123; char name[MAXN]; strcpy(name,dirname);// if(strcmp(dirname,"test") == 0) // printf("Hello world"); //strcpy(name,"test"); DIR *dirp = NULL; struct dirent *entry; dirp = opendir(name); if(dirp == NULL) &#123; printf("ll: %s: No such directory\n",name); return; &#125; else &#123; int i = 1; while(entry = readdir(dirp)) &#123; printf("filename %d = %s\n",i,entry-&gt;d_name); i++; &#125; closedir(dirp); &#125;&#125;void menu() &#123; bool running = true; while(running) &#123; pwds(1); char fun[MAXN]; scanf("%s",fun); if(strcmp(fun,"exit") == 0) exits(); else if(strcmp(fun,"mkdir") == 0) &#123; char filename[MAXN]; scanf("%s",filename); int len = strlen(filename); if(len &gt; 512) &#123; printf("filename is too long\n"); &#125; else &#123; mkdirs(filename); &#125; &#125; else if(strcmp(fun,"pwd") == 0) pwds(0); else if(strcmp(fun,"rm") == 0) &#123; char dirname[MAXN]; scanf("%s",dirname); int len = strlen(dirname); if(len &gt; 512) printf("dirname is too long\n"); else rmdirs(dirname); &#125; else if(strcmp(fun,"cd") == 0) &#123; char dirname[MAXN]; scanf("%s",dirname); int len = strlen(dirname); if(len &gt; 512) printf("dirname is too long\n"); else cds(dirname); &#125; else if(strcmp(fun,"ll") == 0) &#123; char dirname[MAXN]; scanf("%s",dirname); int len = strlen(dirname); if(len &gt; 512) printf("dirname is too long\n"); else lists(dirname); &#125; else if(strcmp(fun,"cp") == 0) &#123; char file1[MAXN],file2[MAXN]; scanf("%s%s",file1,file2); int len1 = strlen(file1); int len2 = strlen(file2); if(len1 &gt; 512) &#123; printf("%s filename is too long\n",file1); continue; &#125; else if(len2 &gt; 512) &#123; printf("%s filename is too long\n",file2); continue; &#125; else cps(file1,file2); &#125; else printf("Instruction error\n"); &#125;&#125;int main() &#123; menu(); return 0;&#125; 体会写代码就是为了快乐呀。 在刚开始学linux时，基本是对着那个小黑框发呆，把书上的命令一个字符一个字符的敲进去，看着路径转换，列出所有目录或文件名，感觉大不同于之前接触到的windows的图形界面，以前在Windows上看到什么点击就可以了，而在命令行上，基本上用不到鼠标。用cd命令改变路径时，也在想这是怎么实现的，可能跟做C语言课设有点类似，在一个死循环内不断地输入字符，这些字符又被拿去匹配，看是执行什么命令。也有过疑惑，这么多的命令，这么多次的匹配，执行的速度感觉还不算太慢，是用到了什么算法，疑是字典树，哈哈，可能这就是只搞了ACM的通病吧。其实，也在网上找过，在百度上搜索了一些命令的实现源码，也幻想过能有一天自己写的代码能够被加到Linux系统里面，哈哈。这次课程设计刚好就有一个实现Linux一些简单命令的任务，所以不用思考就选了这个了，模仿了Linux系统的输入格式界面，让当前路径在最前面显示，还抄了Linux系统的\$符号，囧rz。首先模仿的命令就是pwd命令，打印当前文件路径，往实现pwd命令的函数里传入一个用于选择的参数，分别为在$前打印路径名和就单纯的pwd命令。在重现这些命令过程中，最疑惑的就是ll命令了，输出当前路径下所有目录和文件，刚开始写的时候，一直把传入的目录名用“”括起来当成字符串处理了，这就造成了“dirname”这样一种情况，而实际上应该是dirname就可以了，在这里浪费了好多时间！最终还是完成了啊，看着在Linux系统上运行的仿Linux命令，莫名的喜感。]]></content>
      <categories>
        <category>课程设计</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[P1019 单词接龙]]></title>
    <url>%2F2019%2F09%2F12%2F%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2%2F%E6%B4%9B%E8%B0%B7P1019%20%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99%2F</url>
    <content type="text"><![CDATA[题目https://www.luogu.org/problemnew/show/P1019 思路单词接龙，如果一个单词的末尾与另一个单词的开头有重叠的部分，那么这两个单词就可以连接起来。这道题要求，在给定单词“龙头”的情况下求最长的“龙”的长度。对于这样的题目，很容易地可以想到全局搜一遍，记录最长地即可。但在做这道题过程中，有3个我没有注意到地地方： 题目中说每个单词可以被使用两次，我的处理方法是，将给的所有的单词复制一份，这样对每个单词去搜就行了，但交上去却RE了，可能是递归层次太深，而每次递归都要申请空间造成内存超限。解决方法是用个计数数组统计访问次数。 题中说“相邻的两部分不能存在包含关系，例如atat 和 atideatide 间不能相连。”，在这个地方，我一直在想该怎么判断它们是否有包含关系，但实际上是不要的，因为如果前一个单词能被后一个单词包含，那么直接与后一个单词相连就好了；再者，如果后一个单词被前一个单词包含，那么在连接后可以发现前一个单词的长度是不会发生改变的，这样就可以把这条递归线剪掉。 在两个单词相连时，其重合部分合为一部分。这句话我理解的意思是将最长的重合部分求出来，但实际上是不对的，求的应该是最小的重叠部分。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/*https://www.luogu.org/problemnew/show/P1019AC*/#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=1e5+10;int visit[100];char str[100][MAXN];int n;int ans;void DFS(char t[]) &#123; for(int i=1;i&lt;=n;i++) &#123; if(visit[i]==2) continue; int j=0; int len1=strlen(t); int len2=strlen(str[i]); ans=max(ans,len1); bool flag=false; for(int key=1;key&lt;len2;key++) &#123;// cout&lt;&lt;"KKK"&lt;&lt;endl; char tmpx[1000],tmpy[1000]; int x,y; for(x=0;x&lt;key;x++) tmpx[x]=str[i][x]; tmpx[x]='\0'; int cnt=0; for(y=len1-key;y&lt;len1;y++) tmpy[cnt++]=t[y]; tmpy[cnt]='\0'; if(strcmp(tmpx,tmpy)==0) &#123; char p[MAXN]; strcpy(p,t); int tmpLen=len1; for(int q=key;q&lt;len2;q++) p[len1++]=str[i][q]; p[len1]='\0';// printf("%s %d\n",t,len1);// if(tmpLen==len1) // continue; ans=max(ans,len1); visit[i]++; flag=true; DFS(p); visit[i]--; &#125;// if(flag) break; &#125; &#125;&#125;int main() &#123;// freopen("in.txt","r",stdin); scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%s",str[i]); char head[3]; scanf("%s",head); ans=0; memset(visit,0,sizeof(visit)); DFS(head); printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>简单搜索</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[棋盘问题 POJ - 1321]]></title>
    <url>%2F2019%2F09%2F12%2F%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2%2F%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98%20POJ%20-%201321%2F</url>
    <content type="text"><![CDATA[题目在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。Input输入含有多组测试数据。每组数据的第一行是两个正整数，n k，用一个空格隔开，表示了将在一个n*n的矩阵内描述棋盘，以及摆放棋子的数目。 n &lt;= 8 , k &lt;= n当为-1 -1时表示输入结束。随后的n行描述了棋盘的形状：每行有n个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。Output对于每一组数据，给出一行输出，输出摆放的方案数目C （数据保证C&lt;2^31）。Sample Input1234567892 1#..#4 4...#..#..#..#...-1 -1 Sample Output1221 思路遇到 # 时，检查该位置是否可以放置棋子，若可以则以这个位置为递归的起始点搜索下一行，同时将这个位置状态改为 @ ，表明这个位置已经放置了棋子。当摆放的棋子数满足要求时，就回溯到上一个棋子的位置，将状态改回来。方案数加一 代码1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;const int M=9;string str[M];int n,k;int ans=0;int cnt=0;bool check(int x,int y)&#123; for(int i=0;i&lt;x;i++) if(str[i][y]==&apos;@&apos;) return false; for(int j=0;j&lt;y;j++) if(str[x][j]==&apos;@&apos;) return false; return true;&#125;void DFS(int x,int y)&#123; if(cnt==k) ans++; if(cnt&gt;=k) return; for(int i=x;i&lt;n;i++) for(int j=0;j&lt;n;j++)&#123; if(str[i][j]==&apos;#&apos;&amp;&amp;check(i,j))&#123; cnt++; str[i][j]=&apos;@&apos;; DFS(i+1,j); cnt--; str[i][j]=&apos;#&apos;; &#125; &#125; &#125;int main()&#123; while(cin&gt;&gt;n&gt;&gt;k)&#123; if(n==-1&amp;&amp;k==-1) break; ans=cnt=0; for(int i=0;i&lt;n;i++) cin&gt;&gt;str[i]; DFS(0,0); cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>简单搜索</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tempter of the Bone HDU - 1010]]></title>
    <url>%2F2019%2F09%2F12%2F%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2%2FTempter%20of%20the%20Bone%20HDU%20-%201010%2F</url>
    <content type="text"><![CDATA[题目The doggie found a bone in an ancient maze, which fascinated him a lot. However, when he picked it up, the maze began to shake, and the doggie could feel the ground sinking. He realized that the bone was a trap, and he tried desperately to get out of this maze.The maze was a rectangle with sizes N by M. There was a door in the maze. At the beginning, the door was closed and it would open at the T-th second for a short period of time (less than 1 second). Therefore the doggie had to arrive at the door on exactly the T-th second. In every second, he could move one block to one of the upper, lower, left and right neighboring blocks. Once he entered a block, the ground of this block would start to sink and disappear in the next second. He could not stay at one block for more than one second, nor could he move into a visited block. Can the poor doggie survive? Please help him.InputThe input consists of multiple test cases. The first line of each test case contains three integers N, M, and T (1 &lt; N, M &lt; 7; 0 &lt; T &lt; 50), which denote the sizes of the maze and the time at which the door will open, respectively. The next N lines give the maze layout, with each line containing M characters. A character is one of the following: ‘X’: a block of wall, which the doggie cannot enter;‘S’: the start point of the doggie;‘D’: the Door; or‘.’: an empty block. The input is terminated with three 0’s. This test case is not to be processed.OutputFor each test case, print in one line “YES” if the doggie can survive, or “NO” otherwise.Sample Input123456789104 4 5S.X...X...XD....3 4 5S.X...X....D0 0 0 Sample Output12NOYES 思路这道题原先每看清题意，以为是在规定的时间内到门那里就行了，一直用BFS求最短路径，WA到自闭~实际上是要准时在门那里出现才有一线生机。用DFS写就要考虑时间复杂度了。到网上查了别人的题解，用奇偶减枝来优化代码。剪枝是关键,奇偶剪枝.奇偶剪枝原理: 要理解奇偶剪枝,先了解一下曼哈顿距离,从一个点到达另外一个点的最短路径长度(时间)可以根据两点坐标求出,路径长度(非最短)与最短路径的长度同奇偶,它们的差一定是偶数!举个例子,就像两个偶数的差差是偶数,两个个数的差也是偶数. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cmath&gt;using namespace std;const int MAXSIZE=7;string str[MAXSIZE];int N,M,K;int dx[]=&#123;1,0,0,-1&#125;;int dy[]=&#123;0,1,-1,0&#125;;bool flag=false;int ex,ey;int visit[MAXSIZE][MAXSIZE]=&#123;0&#125;;void DFS(int x,int y,int cnt)&#123; if(flag==true) return; if(ex==x&amp;&amp;ey==y) if(cnt==K)&#123; flag=true; return; &#125; int temp=(K-cnt)-(fabs(x-ex)+fabs(y-ey)); //奇偶减枝判断 if(temp&lt;0||temp%2!=0) return; for(int i=0;i&lt;4;i++)&#123; int tx=x+dx[i]; int ty=y+dy[i]; if(tx&gt;=0&amp;&amp;tx&lt;N&amp;&amp;ty&gt;=0&amp;&amp;ty&lt;M&amp;&amp;visit[tx][ty]==0&amp;&amp;str[tx][ty]!=&apos;X&apos;)&#123; visit[tx][ty]=1; DFS(tx,ty,cnt+1); visit[tx][ty]=0; &#125; &#125;&#125;int main()&#123; while(cin&gt;&gt;N&gt;&gt;M&gt;&gt;K)&#123; if(N==0&amp;&amp;M==0&amp;&amp;K==0) break; int startX=0; int startY=0; flag=false; int sum=0; for(int i=0;i&lt;N;i++) for(int j=0;j&lt;M;j++)&#123; cin&gt;&gt;str[i][j]; visit[i][j]=0; if(str[i][j]==&apos;X&apos;) sum++; if(str[i][j]==&apos;S&apos;)&#123; startX=i; startY=j; str[i][j]=&apos;X&apos;; &#125; if(str[i][j]==&apos;D&apos;)&#123; ex=i; ey=j; &#125; &#125; if(N*M-sum&lt;=K)&#123; cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; continue; &#125; DFS(startX,startY,0); if(flag)cout&lt;&lt;&quot;YES&quot;; else cout&lt;&lt;&quot;NO&quot;; cout&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>简单搜索</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rescue HDU - 1242]]></title>
    <url>%2F2019%2F09%2F12%2F%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2%2FRescue%20HDU%20-%201242%20%2F</url>
    <content type="text"><![CDATA[题目Angel was caught by the MOLIGPY! He was put in prison by Moligpy. The prison is described as a N * M (N, M &lt;= 200) matrix. There are WALLs, ROADs, and GUARDs in the prison.Angel’s friends want to save Angel. Their task is: approach Angel. We assume that “approach Angel” is to get to the position where Angel stays. When there’s a guard in the grid, we must kill him (or her?) to move into the grid. We assume that we moving up, down, right, left takes us 1 unit time, and killing a guard takes 1 unit time, too. And we are strong enough to kill all the guards. You have to calculate the minimal time to approach Angel. (We can move only UP, DOWN, LEFT and RIGHT, to the neighbor grid within bound, of course.)InputFirst line contains two integers stand for N and M. Then N lines follows, every line has M characters. “.” stands for road, “a” stands for Angel, and “r” stands for each of Angel’s friend. Process to the end of the file.OutputFor each test case, your program should output a single integer, standing for the minimal time needed. If such a number does no exist, you should output a line containing “Poor ANGEL has to stay in the prison all his life.”Sample Input123456787 8#.#####.#.a#..r.#..#x.....#..#.##...##...#.............. Sample Output113 思路这道题有几个需要注意的地方。1、有多个朋友，也就是说有多个起点，需要进行多次bfs，最后求最短路径。2、在路上，有守卫的地方，所花费的时间为2（击杀守卫通过路径），需要利用一个优先队列，先遍历花费时间为1的再遍历花费时间为2的。优先队列比较算子定义方法，tql。1234567#include&lt;queue&gt;struct node&#123; int x,y,dep; node(int x,int y,int dep):x(x),y(y),dep(dep)&#123;&#125; bool operator &lt; (const node &amp;a) const &#123;return dep&gt;a.dep;&#125;&#125;;priority_queue&lt;node&gt; qu; 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;const int MAXSIZE=210;int visit[MAXSIZE][MAXSIZE];int sx[MAXSIZE]=&#123;0&#125;,sy[MAXSIZE]=&#123;0&#125;,ex=0,ey=0;string str[MAXSIZE];int dx[]=&#123;1,0,0,-1&#125;;int dy[]=&#123;0,1,-1,0&#125;;int N,M;int ans=0x3f3f3f3f;struct node&#123; int x,y,dep; node(int x,int y,int dep):x(x),y(y),dep(dep)&#123;&#125; bool operator &lt; (const node &amp;a) const &#123;return dep&gt;a.dep;&#125;&#125;;void BFS(int x,int y)&#123; memset(visit,0,sizeof(visit)); priority_queue&lt;node&gt; qu; qu.push(node(x,y,0)); visit[x][y]=1; while(!qu.empty())&#123; node t=qu.top();qu.pop(); for(int i=0;i&lt;4;i++)&#123; int tx=t.x+dx[i]; int ty=t.y+dy[i]; if(tx&lt;0||tx&gt;=N||ty&lt;0||ty&gt;=M||visit[tx][ty]==1||str[tx][ty]==&apos;#&apos;)continue; visit[tx][ty]=1; if(tx==ex&amp;&amp;ty==ey)&#123;ans=min(t.dep+1,ans);return;&#125; if(str[tx][ty]==&apos;x&apos;) qu.push(node(tx,ty,t.dep+2)); else qu.push(node(tx,ty,t.dep+1)); &#125; &#125;&#125;int main()&#123; while(cin&gt;&gt;N&gt;&gt;M)&#123; ans=0x3f3f3f3f; vector&lt;node&gt; vc; for(int i=0;i&lt;N;i++) cin&gt;&gt;str[i]; for(int i=0;i&lt;N;i++)&#123; for(int j=0;j&lt;M;j++)&#123; if(str[i][j]==&apos;r&apos;)&#123;vc.push_back(node(i,j,0));&#125; if(str[i][j]==&apos;a&apos;)&#123;ex=i;ey=j;&#125; &#125; &#125; for(int i=0;i&lt;vc.size();i++) BFS(vc[i].x,vc[i].y); //cout&lt;&lt;sx&lt;&lt;&apos; &apos;&lt;&lt;sy&lt;&lt;&apos; &apos;&lt;&lt;ex&lt;&lt;&apos; &apos;&lt;&lt;ey&lt;&lt;endl; if(ans==0x3f3f3f3f) cout&lt;&lt;&quot;Poor ANGEL has to stay in the prison all his life.&quot;&lt;&lt;endl; else cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>简单搜索</category>
      </categories>
      <tags>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Red and Black HDU - 1312]]></title>
    <url>%2F2019%2F09%2F12%2F%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2%2FRed%20and%20Black%20HDU%20-%201312%2F</url>
    <content type="text"><![CDATA[题目There is a rectangular room, covered with square tiles. Each tile is colored either red or black. A man is standing on a black tile. From a tile, he can move to one of four adjacent tiles. But he can’t move on red tiles, he can move only on black tiles.Write a program to count the number of black tiles which he can reach by repeating the moves described above.InputThe input consists of multiple data sets. A data set starts with a line containing two positive integers W and H; W and H are the numbers of tiles in the x- and y- directions, respectively. W and H are not more than 20. There are H more lines in the data set, each of which includes W characters. Each character represents the color of a tile as follows. ‘.’ - a black tile‘#’ - a red tile‘@’ - a man on a black tile(appears exactly once in a data set)OutputFor each data set, your program should output a line which contains the number of tiles he can reach from the initial tile (including itself).Sample Input1234567891011121314151617181920212223242526272829303132333435366 9....#......#..............................#@...#.#..#.11 9.#..........#.#######..#.#.....#..#.#.###.#..#.#..@#.#..#.#####.#..#.......#..#########............11 6..#..#..#....#..#..#....#..#..###..#..#..#@...#..#..#....#..#..#..7 7..#.#....#.#..###.###...@...###.###..#.#....#.#..0 0 Sample Output12344559613 思路dfs简单应用。从起点出发，搜索上下左右可走的位置。当找到位置后，又以该元素为起点来搜索。 代码123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;const int MAXSIZE=20+4;string str[MAXSIZE];int ans=0;int N,M;void DFS(int x,int y)&#123; ans++; str[x][y]=&apos;#&apos;; //cout&lt;&lt;x&lt;&lt;&apos; &apos;&lt;&lt;y&lt;&lt;endl; for(int i=x-1;i&lt;=x+1;i++)&#123; if(i&gt;=0&amp;&amp;i&lt;M&amp;&amp;str[i][y]==&apos;.&apos;) DFS(i,y); &#125; for(int j=y-1;j&lt;=y+1;j++) if(j&gt;=0&amp;&amp;j&lt;N&amp;&amp;str[x][j]==&apos;.&apos;) DFS(x,j);&#125;int main()&#123; while(cin&gt;&gt;N&gt;&gt;M)&#123; if(N==0&amp;&amp;M==0) break; ans=0; int startX=0; int startY=0; for(int i=0;i&lt;M;i++) for(int j=0;j&lt;N;j++)&#123; cin&gt;&gt;str[i][j]; if(str[i][j]==&apos;@&apos;)&#123; startX=i; startY=j; &#125; &#125; DFS(startX,startY); cout&lt;&lt;ans&lt;&lt;endl; // cout&lt;&lt;startX&lt;&lt;&apos; &apos;&lt;&lt;startY&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>简单搜索</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lake Counting POJ - 2386]]></title>
    <url>%2F2019%2F09%2F12%2F%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2%2FLake%20Counting%20POJ%20-%202386%2F</url>
    <content type="text"><![CDATA[题目Due to recent rains, water has pooled in various places in Farmer John’s field, which is represented by a rectangle of N x M (1 &lt;= N &lt;= 100; 1 &lt;= M &lt;= 100) squares. Each square contains either water (‘W’) or dry land (‘.’). Farmer John would like to figure out how many ponds have formed in his field. A pond is a connected set of squares with water in them, where a square is considered adjacent to all eight of its neighbors.Given a diagram of Farmer John’s field, determine how many ponds he has.Input Line 1: Two space-separated integers: N and M Lines 2..N+1: M characters per line representing one row of Farmer John’s field. Each character is either ‘W’ or ‘.’. The characters do not have spaces between them.Output Line 1: The number of ponds in Farmer John’s field.Sample Input123456789101110 12W........WW..WWW.....WWW....WW...WW..........WW..........W....W......W...W.W.....WW.W.W.W.....W..W.W......W...W.......W. Sample Output13 HintOUTPUT DETAILS:There are three ponds: one in the upper left, one in the lower left,and one along the right side. 思路dfs算法的简单应用。对整张图来说 遍历整个图 每遇到一个W，这水池数加1，同时将它改为. 以上一步遇到的W为起点，搜索与它相连的位置，若发现W，则将它改为.，然后又搜索这个点周围的位置 代码1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;const int MAXSIZE=100+5;string str[MAXSIZE];int N,M;void DFS(int x,int y)&#123; str[x][y]=&apos;.&apos;; for(int i=x-1;i&lt;=x+1;i++) for(int j=y-1;j&lt;=y+1;j++)&#123; if(i&gt;=0&amp;&amp;i&lt;N&amp;&amp;j&gt;=0&amp;&amp;j&lt;M&amp;&amp;str[i][j]==&apos;W&apos;) DFS(i,j); &#125;&#125;int main()&#123; while(cin&gt;&gt;N&gt;&gt;M)&#123; for(int i=0;i&lt;N;i++) cin&gt;&gt;str[i]; int ans=0; for(int i=0;i&lt;N;i++)&#123; for(int j=0;j&lt;M;j++)&#123; if(str[i][j]==&apos;W&apos;)&#123; ans++; DFS(i,j); &#125; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>简单搜索</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Knight Moves ZOJ - 1091]]></title>
    <url>%2F2019%2F09%2F12%2F%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2%2FKnight%20Moves%20ZOJ%20-%201091%2F</url>
    <content type="text"><![CDATA[题目A friend of you is doing research on the Traveling Knight Problem (TKP) where you are to find the shortest closed tour of knight moves that visits each square of a given set of n squares on a chessboard exactly once. He thinks that the most difficult part of the problem is determining the smallest number of knight moves between two given squares and that, once you have accomplished this, finding the tour would be easy.Of course you know that it is vice versa. So you offer him to write a program that solves the “difficult” part.Your job is to write a program that takes two squares a and b as input and then determines the number of knight moves on a shortest route from a to b. Input SpecificationThe input file will contain one or more test cases. Each test case consists of one line containing two squares separated by one space. A square is a string consisting of a letter (a-h) representing the column and a digit (1-8) representing the row on the chessboard.Output SpecificationFor each test case, print one line saying “To get from xx to yy takes n knight moves.”.Sample Input12345678e2 e4a1 b2b2 c3a1 h8a1 h7h8 a1b1 c3f6 f6 Sample Output12345678To get from e2 to e4 takes 2 knight moves.To get from a1 to b2 takes 4 knight moves.To get from b2 to c3 takes 2 knight moves.To get from a1 to h8 takes 6 knight moves.To get from a1 to h7 takes 5 knight moves.To get from h8 to a1 takes 6 knight moves.To get from b1 to c3 takes 1 knight moves.To get from f6 to f6 takes 0 knight moves. 思路简单bfs，从出发点开始到结束点搜索最短路径。用map算出出发点容易点吧。马走日字形。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;int mp[9][9];int visit[9][9];map&lt;char,int&gt; map1;map&lt;char,int&gt; map2;int sx=0,sy=0,ex=0,ey=0;int dx[]=&#123;-1,-2,-2,-1,1,2,2,1&#125;;int dy[]=&#123;-2,-1,1,2,2,1,-1,-2&#125;; struct node&#123; int x,y,dep; node(int x,int y,int dep):x(x),y(y),dep(dep)&#123;&#125;&#125;;int ans=0;void BFS(int x,int y)&#123; memset(visit,0,sizeof(visit)); queue&lt;node&gt; qu; qu.push(node(x,y,0)); visit[x][y]=1; while(!qu.empty())&#123; node t=qu.front();qu.pop(); for(int i=0;i&lt;8;i++)&#123; int tx=t.x+dx[i]; int ty=t.y+dy[i]; if(tx&lt;1||tx&gt;8||ty&lt;1||ty&gt;8||visit[tx][ty]==1) continue; qu.push(node(tx,ty,t.dep+1)); if(tx==ex&amp;&amp;ty==ey) &#123;ans=t.dep+1;return;&#125; visit[tx][ty]=1; &#125; &#125;&#125;int main()&#123; string str1=&quot; abcdefgh&quot;; string str2=&quot; 12345678&quot;; for(int i=1;i&lt;9;i++)&#123; map1[str1[i]]=i; map2[str2[i]]=i; &#125;// for(map&lt;char,int&gt;::iterator it=map2.begin();it!=map2.end();it++)// cout&lt;&lt;it-&gt;first&lt;&lt;&apos; &apos;&lt;&lt;it-&gt;second&lt;&lt;endl; while(cin&gt;&gt;str1&gt;&gt;str2)&#123; ans=0; sx=map1[str1[0]]; sy=map2[str1[1]]; ex=map1[str2[0]]; ey=map2[str2[1]];// cout&lt;&lt;sx&lt;&lt;&apos; &apos;&lt;&lt;sy&lt;&lt;&apos; &apos;&lt;&lt;ex&lt;&lt;&apos; &apos;&lt;&lt;ey&lt;&lt;endl; BFS(sx,sy); cout&lt;&lt;&quot;To get from &quot;&lt;&lt;str1&lt;&lt;&quot; to &quot;&lt;&lt;str2&lt;&lt;&quot; takes &quot;&lt;&lt;ans&lt;&lt;&quot; knight moves.&quot;&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>简单搜索</category>
      </categories>
      <tags>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KATHTHI SPOJ - KATHTHI （BFS+deque）]]></title>
    <url>%2F2019%2F09%2F12%2F%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2%2FKATHTHI%20SPOJ%20-%20KATHTHI%20%EF%BC%88BFS%2Bdeque%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目Kathiresan is initially locked at cell (0,0) in a highly guarded rectangular prison of order RxC. He must reach the gate at (R-1,C-1) in order to escape from the prison. Kathiresan can move from any cell, to any of it’s 4 adjacent cells (North, East, West and South). If Kathiresan is currently at (x1,y1), then he can move to (x2,y2) if and only if abs(x2-x1)+abs(y2-y1) == 1 and 0&lt;=x2&lt;R and 0&lt;=y2&lt;C Kathiresan somehow manages to get the map of the prison.If map[x1][y1] == map[x2][y2] then Kathiresan can move from (x1,y1) to (x2,y2) without killing any guards.If map[x1][y1] != map[x2][y2], then Kathiresan can move from (x1,y1) to (x2,y2) by killing a guard.Given the map of the prison, find the minimum number of guards Kathiresan must kill in order to escape from the prison.Input: The first line consists of an integer t, the number of test cases. For each test case, the first line consists of two integers R and C representing the order of the rectangular prison followed by R strings representing the map of the rectangular prison. Output: For each test case find the minimum number of guards Kathiresan must kill in order to escape from the prison. Input Constraints: 1 &lt;= t &lt;= 10 2 &lt;= R &lt;= 1000 2 &lt;= C &lt;= 1000 ‘a’ &lt;= map[i][j] &lt;= ‘z’ Sample Input:123456789101112131415161718192042 2aaaa2 3abcdef6 6akacccaaacfcamdfccaokhddzyxwdpzyxwdd5 5abbbcabaccaaaccaefcicdgdd Sample Output: 12340322 思路题意为求最少杀人数，如果周围的字母与当前所在位置字母相同，则可以直接走过去，如果不相同就需要杀掉一个守卫。那么可以用一个双端队列来维护当前所走路径。如果周围字母与当前字母相同，就推到队头，否则推到队尾。不过在写这个题目时，发现有个地方跟以前我写搜索时有点不一样。那就是visit数组的应用，以前写搜索在将位置推入队列时直接将这个位置变为已访问状态，而这个题是当这个位置被拿出来使用时才变成已访问状态。这样做的好处在于，可能在某种情况下，其他位置先访问到终点时将终点变为不可访问后，最优位置就无法访问了，从而无法求得最优解，又学到一招qwq。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=1e3+10;struct node&#123; int x,y,dep; node(int x,int y,int dep):x(x),y(y),dep(dep)&#123;&#125;&#125;;deque&lt;node&gt; qu;int visit[MAXN][MAXN];string str[MAXN];int n,m;int ans;int dx[]=&#123;0,0,1,-1&#125;;int dy[]=&#123;1,-1,0,0&#125;;void BFS() &#123; memset(visit,0,sizeof(visit)); while(!qu.empty()) qu.pop_front(); qu.push_front(node(0,0,0));// visit[0][0]=1; int cnt=0; while(!qu.empty()) &#123; node t=qu.front();qu.pop_front(); if(t.x==n-1&amp;&amp;t.y==m-1) ans=min(ans,t.dep); if(visit[t.x][t.y])continue; visit[t.x][t.y]=1; for(int i=0;i&lt;4;i++) &#123; int tx=t.x+dx[i]; int ty=t.y+dy[i]; if(tx&gt;=0&amp;&amp;tx&lt;n&amp;&amp;ty&gt;=0&amp;&amp;ty&lt;m&amp;&amp;!visit[tx][ty]) &#123; if(str[tx][ty]==str[t.x][t.y]) qu.push_front(node(tx,ty,t.dep)); else qu.push_back(node(tx,ty,t.dep+1)); &#125; &#125; &#125;&#125;int main() &#123;// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); ios::sync_with_stdio(false); int T; cin&gt;&gt;T; while(T--) &#123; cin&gt;&gt;n&gt;&gt;m; ans=0x3f3f3f3f; for(int i=0;i&lt;n;i++) cin&gt;&gt;str[i]; BFS(); cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>简单搜索</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Find a way HDU - 2612]]></title>
    <url>%2F2019%2F09%2F12%2F%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2%2FFind%20a%20way%20HDU%20-%202612%20%20%2F</url>
    <content type="text"><![CDATA[题目Pass a year learning in Hangzhou, yifenfei arrival hometown Ningbo at finally. Leave Ningbo one year, yifenfei have many people to meet. Especially a good friend Merceki.Yifenfei’s home is at the countryside, but Merceki’s home is in the center of city. So yifenfei made arrangements with Merceki to meet at a KFC. There are many KFC in Ningbo, they want to choose one that let the total time to it be most smallest.Now give you a Ningbo map, Both yifenfei and Merceki can move up, down ,left, right to the adjacent road by cost 11 minutes.InputThe input contains multiple test cases.Each test case include, first two integers n, m. (2&lt;=n,m&lt;=200).Next n lines, each line included m character.‘Y’ express yifenfei initial position.‘M’ express Merceki initial position.‘#’ forbid road;‘.’ Road.‘@’ KCFOutputFor each test case output the minimum total time that both yifenfei and Merceki to arrival one of KFC.You may sure there is always have a KFC that can let them meet.Sample Input123456789101112131415164 4Y.#@.....#..@..M4 4Y.#@.....#..@#.M5 5Y..@..#....#...@..M.#...# Sample Output123668866 思路对于Y和M，以其坐标为起点，用BFS对每一kfc搜索，记录最短距离，最后相加取最少的。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;const int MAXSIZE=200+5;int N,M;string str[MAXSIZE];int visit[MAXSIZE][MAXSIZE]=&#123;0&#125;;int dx[]=&#123;1,0,0,-1&#125;;int dy[]=&#123;0,1,-1,0&#125;;struct node&#123; int x; int y; int dis; node(int x,int y,int dis):x(x),y(y),dis(dis)&#123;&#125;&#125;;int kfc[MAXSIZE][MAXSIZE];int time[2][MAXSIZE*200];void BFS(int x,int y,int flag)&#123; memset(visit,0,sizeof(visit)); queue&lt;node&gt; qu; qu.push(node(x,y,0)); visit[x][y]=1; while(!qu.empty())&#123; node t=qu.front(); qu.pop(); for(int i=0;i&lt;4;i++)&#123; int tx=t.x+dx[i]; int ty=t.y+dy[i]; if(tx&lt;0||tx&gt;=N||ty&lt;0||ty&gt;=M||visit[tx][ty]==1||str[tx][ty]==&apos;#&apos;) continue; if(str[tx][ty]==&apos;@&apos;) time[flag][kfc[tx][ty]]=t.dis+1; visit[tx][ty]=1; qu.push(node(tx,ty,t.dis+1)); &#125; &#125; &#125;int main()&#123; while(cin&gt;&gt;N&gt;&gt;M)&#123; int sx=0,sy=0,ex=0,ey=0; int cnt=0; for(int i=0;i&lt;N;i++)cin&gt;&gt;str[i]; for(int i=0;i&lt;N;i++) for(int j=0;j&lt;M;j++)&#123;// cin&gt;&gt;str[i][j]; if(str[i][j]==&apos;Y&apos;)&#123; sx=i;sy=j; &#125; if(str[i][j]==&apos;M&apos;)&#123; ex=i;ey=j; &#125; if(str[i][j]==&apos;@&apos;) kfc[i][j]=cnt++; &#125; int ans=0x3f3f3f3f; memset(time,0x3f,sizeof(time)); BFS(sx,sy,0); BFS(ex,ey,1); for(int i=0;i&lt;cnt;i++) ans=min(ans,time[0][i]+time[1][i]); cout&lt;&lt;ans*11&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>简单搜索</category>
      </categories>
      <tags>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北信科第十一届程序设计竞赛（重现赛）J andy的树被砍了]]></title>
    <url>%2F2019%2F09%2F12%2F%E6%AF%94%E8%B5%9B%2F%E5%8C%97%E4%BF%A1%E7%A7%91%E7%AC%AC%E5%8D%81%E4%B8%80%E5%B1%8A%E7%AB%9E%E8%B5%9B%2F%E5%8C%97%E4%BF%A1%E7%A7%91%E5%8D%81%E4%B8%80%E5%B1%8A%E7%AB%9E%E8%B5%9B-J%2F</url>
    <content type="text"><![CDATA[题目链接：https://ac.nowcoder.com/acm/contest/940/J来源：牛客网 andy又开始种树了，他觉得老用魔法不太好，这次他决定老老实实地每天种一棵树，第i天种一颗高度为hi的树，按理说老老实实种树就完事了，哪有那么多问题呢？但是他们学校有个叫kotori的人，非常爱砍树，每天都会把所有andy已经种下的树砍掉ci，如果第i天的时候某棵树的高度已经小于等于ci了，那么这棵树就会死亡，以后再也不会被砍了。并且如果到了第n天，有一些树还没被砍，那么kotori就会在第n + 1天把这些树全部砍死。 输入描述:第一行输入一个整数n，表示andy会种n天的树。 第二行含有n个数hi，表示andy在第i天种的树的高度为hi米。 第三行含有n个ci，表示kotori在第i天把所有andy已经种下的树砍掉ci。1 &lt;= n, hi, ci &lt;= 105输出描述:输出一行n个数di，每个数后面有一个空格(包括最后一个数)，最后需要换行。 表示andy第i天种的树会在第di天死亡，如果第n天这棵树还没有死亡，则输出n + 1。 示例1输入123105 7 5 4 1 7 4 3 10 6 6 4 2 4 1 8 5 7 3 5 输出11 4 4 4 5 6 7 8 11 11 说明第1天andy种的树高度为5，这天kotori要把andy已经种下的所有树砍掉6，所以第1棵树在第1天就死掉了。 第2天andy种的树高度为7，第2天被kotori砍掉了4，还剩3，第3天被kotori砍掉了2，还剩1。第4天被砍掉4，所以它在第4天死亡。 第10天andy种下的数高度为6，第10天被kotori砍掉了5，还剩1，也就是说它在第10天还没有死亡，所以它会在第11天被kotori砍死（参见题目描述最后一句）。 思路首先求下砍树高度的前缀和，那么对于前缀数组的每个数就是每天所要砍掉树的长度总和。就可以将问题转化为：对于每棵树来讲，它的总长度就是前一天所要砍掉的长度加上现存的长度，然后就是求出总长度在哪一天能全部砍完了。 代码1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN=1e6+10;ll arr[MAXN];ll brr[MAXN];int main()&#123;// freopen("in.txt","r",stdin); int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;arr[i]); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;brr[i]); for(int i=1;i&lt;=n;i++) brr[i]+=brr[i-1]; for(int i=1;i&lt;=n;i++) &#123; ll tmp=arr[i]+brr[i-1]; ll pos=lower_bound(brr+1,brr+n+1,tmp)-brr; if(pos&gt;=1&amp;&amp;pos&lt;=n) printf("%lld ",pos); else printf("%lld ",n+1); &#125; printf("\n"); return 0;&#125;]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北信科第十一届程序设计竞赛（重现赛）I andy种树]]></title>
    <url>%2F2019%2F09%2F12%2F%E6%AF%94%E8%B5%9B%2F%E5%8C%97%E4%BF%A1%E7%A7%91%E7%AC%AC%E5%8D%81%E4%B8%80%E5%B1%8A%E7%AB%9E%E8%B5%9B%2F%E5%8C%97%E4%BF%A1%E7%A7%91%E5%8D%81%E4%B8%80%E5%B1%8A%E7%AB%9E%E8%B5%9B-I%2F</url>
    <content type="text"><![CDATA[题目链接：https://ac.nowcoder.com/acm/contest/940/I来源：牛客网 题目描述andy在他的庄园里种了n棵树，排列成一排，标号为1到n。最开始的时候n棵树的高度都是0，也就是种子刚刚被埋下，树还没有长出来。 andy会一种魔法，他每使用一次魔法，就可以让树标号落在连续区间[l, r]里的树的高度增加1。他可以使用q次这种魔法，然后他很好奇，在使用了q次魔法之后，他的所有树的高度分别是多少呢？ 输入描述:第一行输入两个整数n，q。(1&lt;= n, q &lt;= 1e5) 接下来q行，每行输入两个整数l, r(l &lt;= r)，表示andy让标号落在区间[l, r]里的数高度都加1输出描述:输出有一行n个整数，每个整数后面有空格。输出末尾没有换行 第i个数表示第i棵树的高度示例1输入123410 31 32 43 3 输出11 2 3 1 0 0 0 0 0 0 说明12345678910111213141516171819andy种了10棵树第一次使用魔法使得1、2、3棵树的高度增加1,所有树的高度为1 1 1 0 0 0 0 0 0 0第二次使用魔法使得2、3、4棵树的高度增加1，所有树的高度为1 2 2 1 0 0 0 0 0 0第三次使用魔法使得第3棵树的高度增加1所有树的高度为1 2 3 1 0 0 0 0 0 0 思路前缀和。每次使用魔法对区间[l,r]内的数加1，那么可以让[l,n]中的数都加1，同时让[r+1,n]内的数减1，这样就相当于区间[l,r]内的数加1了。 代码1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN=1e6+10;ll arr[MAXN];ll brr[MAXN];int main() &#123;// freopen("in.txt","r",stdin); int n,q; scanf("%d%d",&amp;n,&amp;q); memset(arr,0,sizeof(arr)); memset(brr,0,sizeof(brr)); while(q--) &#123; int l,r; scanf("%d%d",&amp;l,&amp;r); arr[l]++; brr[r+1]--; &#125; for(int i=1;i&lt;=n;i++) arr[i]+=arr[i-1]; for(int i=1;i&lt;=n;i++) brr[i]+=brr[i-1]; for(int i=1;i&lt;=n;i++) printf("%lld ",arr[i]+brr[i]); return 0;&#125;]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北信科第十一届程序设计竞赛（重现赛）H andy和购物]]></title>
    <url>%2F2019%2F09%2F12%2F%E6%AF%94%E8%B5%9B%2F%E5%8C%97%E4%BF%A1%E7%A7%91%E7%AC%AC%E5%8D%81%E4%B8%80%E5%B1%8A%E7%AB%9E%E8%B5%9B%2F%E5%8C%97%E4%BF%A1%E7%A7%91%E5%8D%81%E4%B8%80%E5%B1%8A%E7%AB%9E%E8%B5%9B-H%2F</url>
    <content type="text"><![CDATA[题目链接：https://ac.nowcoder.com/acm/contest/940/H来源：牛客网 andy要去市场买n件货物，每件货物的价格为ai。商家为了吸引顾客，给每个买N件货物的顾客一个折扣清单，清单上有N个小于1的小数bj表示折扣。对于每个折扣bj，由用户自行决定用它使哪个货物的价格变成bj * ai，并且只能用一次。andy想让你帮他算一下他最少的花费。 输入描述:先输入一个正整数t，代表样例的组数。（1≤t≤10） 对于每个样例： 第一行，输入一个正整数n（1≤n≤1000）。 第二行包含n个整数，第i个整数a[i]代表第i个商品的原价。（1≤a[i]≤1e9） 第三行包含n个小数b[i]，含义如题目描述。（0≤b[i]≤1）输出描述:对于每个样例，输出一个实数s，保留3位小数，表示最小的花费。示例1输入1234151 2 3 4 50.1 0.2 0.3 0.4 0.5 输出13.500 思路简单贪心。拿最高价格对应最大折扣即可。 代码1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;typedef long double lb;const int MAXN=1e3+10;lb arr[MAXN];lb brr[MAXN];int main()&#123; int t; scanf("%d",&amp;t); while(t--) &#123; int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%Lf",&amp;arr[i]); for(int i=1;i&lt;=n;i++) scanf("%Lf",&amp;brr[i]); sort(arr+1,arr+n+1); sort(brr+1,brr+n+1); lb ans=0; for(int i=1,j=n;i&lt;=n;i++,j--) ans+=arr[i]*brr[j]; printf("%.3Lf\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北信科第十一届程序设计竞赛（重现赛）F kotori和n皇后]]></title>
    <url>%2F2019%2F09%2F12%2F%E6%AF%94%E8%B5%9B%2F%E5%8C%97%E4%BF%A1%E7%A7%91%E7%AC%AC%E5%8D%81%E4%B8%80%E5%B1%8A%E7%AB%9E%E8%B5%9B%2F%E5%8C%97%E4%BF%A1%E7%A7%91%E5%8D%81%E4%B8%80%E5%B1%8A%E7%AB%9E%E8%B5%9B-F%2F</url>
    <content type="text"><![CDATA[题目链接：https://ac.nowcoder.com/acm/contest/940/F来源：牛客网 kotori最近在研究n皇后的问题。 所谓n皇后问题是这样的：一个n*n的地图，上面一共放n个皇后，保证任意两个皇后都不能互相攻击（每个皇后可以攻击同一行、同一列以及同一45度角斜线和135度角斜线上的所有其他皇后）。 kotori思考了很久都无法得出答案，整个人都变成琴梨了。她于是拿了一堆皇后在一个无穷大的棋盘上模拟，按照次序一共放了k个皇后。 但是，皇后的站位太复杂了，kotori甚至不知道是否存在两个皇后会互相攻击。于是她想问问聪明的你，在第i个皇后放置在棋盘上之后，是否存在两个皇后可以互相攻击？ 输入描述:第一行输入一个正整数k，代表总共放置的皇后的个数。（1&lt;=k&lt;=1e5） 接下来的k行，每行两个正整数xi和yi，代表每个皇后的坐标。（1&lt;=xi,yi&lt;=1e9） 之后输入一个正整数t，代表t次询问。（1&lt;=t&lt;=1e5） 接下来的t行，每行一个正整数i，代表询问第i个皇后放置后，是否存在互相攻击的情况。（1&lt;=i&lt;=k） 保证不存在两个皇后放置的位置相同。输出描述:共t行。每行对应当前的询问是否存在两个皇后可以互相攻击，若是则输出“Yes”，否则输出“No”示例1输入12345678951 22 53 16 74 8224 输出12NoYes 说明第四个皇后放置后，第四个和第一个皇后可以互相攻击。 思路这道题我一开始没看清题意，我认成，每当放置一个皇后后，这个皇后是否会跟其他皇后相互攻击，而实际上是，每放置一个皇后，询问这个棋盘是否会有两个皇后相互攻击。所以当放置一个皇后后，如果这个皇后与其他皇后相互工作，那么此后整个棋盘都存在相互攻击的皇后。 判断两个皇后能否相互攻击，只需要记录横、纵、45$^。$对角线、135$^。$对角线即可。也就分别是x、y、x+y、x-y+MAXN。 代码123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXM=1e5+10;map&lt;ll,bool&gt; mp[6];int judge[MAXM]=&#123;0&#125;;ll a[MAXM],b[MAXM];int main()&#123;// freopen("in.txt","r",stdin); int T; scanf("%d",&amp;T); int ans=0x3f3f3f3f; for(int i=1;i&lt;=T;i++) &#123; scanf("%lld%lld",&amp;a[i],&amp;b[i]); if(mp[0][a[i]]||mp[1][b[i]]||mp[2][a[i]+b[i]]||mp[3][a[i]-b[i]]) &#123; ans=min(ans,i); &#125; mp[0][a[i]]=true; mp[1][b[i]]=true; mp[2][a[i]+b[i]]=true; mp[3][a[i]-b[i]]=true;; &#125; int n; scanf("%d",&amp;n); while(n--) &#123; int i; scanf("%d",&amp;i); if(i&gt;=ans) printf("Yes\n"); else printf("No\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北信科第十一届程序设计竞赛（重现赛）E kotori和素因子]]></title>
    <url>%2F2019%2F09%2F12%2F%E6%AF%94%E8%B5%9B%2F%E5%8C%97%E4%BF%A1%E7%A7%91%E7%AC%AC%E5%8D%81%E4%B8%80%E5%B1%8A%E7%AB%9E%E8%B5%9B%2F%E5%8C%97%E4%BF%A1%E7%A7%91%E5%8D%81%E4%B8%80%E5%B1%8A%E7%AB%9E%E8%B5%9B-E%2F</url>
    <content type="text"><![CDATA[题目链接：https://ac.nowcoder.com/acm/contest/940/E来源：牛客网 kotori拿到了一些正整数。她决定从每个正整数取出一个素因子。但是，kotori有强迫症，她不允许两个不同的正整数取出相同的素因子。 她想知道，最终所有取出的数的和的最小值是多少？ 注：若a%k==0，则称k是a的因子。若一个数有且仅有两个因子，则称其是素数。显然1只有一个因子，不是素数。 输入描述:第一行一个正整数n，代表kotori拿到正整数的个数。 第二行共有n个数ai，表示每个正整数的值。 保证不存在两个相等的正整数。 1&lt;=n&lt;=10 2&lt;=ai&lt;=1000输出描述:一个正整数，代表取出的素因子之和的最小值。若不存在合法的取法，则输出-1。示例1输入12412 15 28 22 输出117 说明分别取3，5，7，2，可保证取出的数之和最小示例2输入1254 5 6 7 8 输出1-1 备注:1231&lt;=n&lt;=102&lt;=ai&lt;=1000 思路简单DFS。把每个数的质因子求出来后，把所有答案搜一遍即可，注意不能从两个不同的数取相同的质因子。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=2e3+10;vector&lt;int&gt; vt[12];int arr[12];int n;int ans;int qu[12];bool isprime(int t) &#123; int p=sqrt(t); for(int i=2;i&lt;=p;i++) if(t%i==0) return false; return true;&#125;void init() &#123; for(int i=1;i&lt;=n;i++) &#123; int tmp=sqrt(arr[i]); for(int j=2;j&lt;=arr[i];j++) &#123; if(arr[i]%j==0&amp;&amp;isprime(j)) vt[i].push_back(j); &#125; &#125; // for(int i=1;i&lt;=n;i++) &#123;// cout&lt;&lt;arr[i]&lt;&lt;": ";// for(int j=0;j&lt;vt[i].size();j++)// cout&lt;&lt;vt[i][j]&lt;&lt;' ';// cout&lt;&lt;endl;// &#125;&#125;bool judge(int cnt,int x) &#123; for(int i=0;i&lt;cnt;i++) if(qu[i]==x) return false; return true;&#125; void DFS(int cnt,int sum,int p) &#123; if(cnt&gt;=n) &#123; ans=min(ans,sum); return; &#125; for(int i=0;i&lt;vt[p].size();i++) &#123; if(judge(cnt,vt[p][i])) &#123; qu[cnt]=vt[p][i]; DFS(cnt+1,sum+vt[p][i],p+1); &#125; &#125;&#125;int main() &#123;// freopen("in.txt","r",stdin); scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;arr[i]); init(); ans=0x3f3f3f3f; DFS(0,0,1); if(ans==0x3f3f3f3f) ans=-1; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北信科第十一届程序设计竞赛（重现赛）D kotori和迷宫]]></title>
    <url>%2F2019%2F09%2F12%2F%E6%AF%94%E8%B5%9B%2F%E5%8C%97%E4%BF%A1%E7%A7%91%E7%AC%AC%E5%8D%81%E4%B8%80%E5%B1%8A%E7%AB%9E%E8%B5%9B%2F%E5%8C%97%E4%BF%A1%E7%A7%91%E5%8D%81%E4%B8%80%E5%B1%8A%E7%AB%9E%E8%B5%9B-D%2F</url>
    <content type="text"><![CDATA[题目链接：https://ac.nowcoder.com/acm/contest/940/D来源：牛客网 kotori在一个n*m迷宫里，迷宫的最外层被岩浆淹没，无法涉足，迷宫内有k个出口。kotori只能上下左右四个方向移动。她想知道有多少出口是她能到达的，最近的出口离她有多远？ 输入描述:第一行为两个整数n和m，代表迷宫的行和列数 (1≤n,m≤30) 后面紧跟着n行长度为m的字符串来描述迷宫。’k’代表kotori开始的位置，’.’代表道路，’*’代表墙壁，’e’代表出口。保证输入合法。输出描述:若有出口可以抵达，则输出2个整数，第一个代表kotori可选择的出口的数量，第二个代表kotori到最近的出口的步数。（注意，kotori到达出口一定会离开迷宫） 若没有出口可以抵达，则输出-1。示例1输入12345676 8e.*.*e.*.**.*.*e..*k**..***.*.e*.**.*.***......e 输出12 7 说明可供选择坐标为[4,7]和[6,8]，到kotori的距离分别是8和7步。 思路简单BFS，需要注意的是，一遇到出口就离开迷宫了，所以出口不能当作通道走，不能以此走到其他位置。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=40;struct node &#123; int x,y,dep; node(int x,int y,int dep):x(x),y(y),dep(dep)&#123;&#125;&#125;;int n,m;int cnt;int ans;char str[MAXN][MAXN];bool visit[MAXN][MAXN];int dx[]=&#123;1,-1,0,0&#125;;int dy[]=&#123;0,0,1,-1&#125;;bool flag;void BFS(int x,int y) &#123; queue&lt;node&gt; qu; qu.push(node(x,y,0)); memset(visit,false,sizeof(visit)); while(!qu.empty()) &#123; node t=qu.front();qu.pop(); if(str[t.x][t.y]=='e') &#123; cnt++; ans=min(ans,t.dep); return; &#125; visit[t.x][t.y]=true; for(int i=0;i&lt;4;i++) &#123; int tx=t.x+dx[i]; int ty=t.y+dy[i]; if(tx&gt;=0&amp;&amp;tx&lt;n&amp;&amp;ty&gt;=0&amp;&amp;ty&lt;m&amp;&amp;!visit[tx][ty]&amp;&amp;str[tx][ty]!='*') qu.push(node(tx,ty,t.dep+1)); &#125; &#125; flag=true; &#125;int main() &#123;// freopen("in.txt","r",stdin); scanf("%d%d",&amp;n,&amp;m); int sx,sy; for(int i=0;i&lt;n;i++) &#123; scanf("%s",str[i]); for(int j=0;j&lt;m;j++) if(str[i][j]=='k') &#123; sx=i; sy=j; &#125; &#125; flag=false; cnt=0; ans=0x3f3f3f3f; while(!flag) &#123; BFS(sx,sy); &#125; if(ans==0x3f3f3f3f) printf("-1\n"); else printf("%d %d\n",cnt,ans); return 0; &#125;]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北信科第十一届程序设计竞赛（重现赛）B kotori和气球]]></title>
    <url>%2F2019%2F09%2F12%2F%E6%AF%94%E8%B5%9B%2F%E5%8C%97%E4%BF%A1%E7%A7%91%E7%AC%AC%E5%8D%81%E4%B8%80%E5%B1%8A%E7%AB%9E%E8%B5%9B%2F%E5%8C%97%E4%BF%A1%E7%A7%91%E5%8D%81%E4%B8%80%E5%B1%8A%E7%AB%9E%E8%B5%9B-B%2F</url>
    <content type="text"><![CDATA[题目链接：https://ac.nowcoder.com/acm/contest/940/B来源：牛客网 题目描述kotori最近迷上了摆气球的游戏。她一共有n种气球，每种气球有无数个。她要拿出若干个气球摆成一排。 但是，由于气球被施放了魔法，同样种类的气球如果相邻会发生爆炸，因此若两个相邻的气球种类相同被视为不合法的。 kotori想知道，摆成一排m个一共有多少种不同的方案？ 由于该数可能过大，只需要输出其对109取模的结果。 输入描述:输入仅有一行，为两个整数n和m(1≤n,m≤100)输出描述:输出一个整数，为方案数对109取模的结果。 示例1 输入13 2 输出16 说明 假设3种气球标记为1、2、3，那么共有以下6种方案：[1,2] [1,3] [2,1] [2,3] [3,1] [3,2]。 思路相邻的位置不能放置相同的气球，易得这是各排列组合问题，也就是第一个位置有n种摆法，剩下的就是n-1种了。其实，这道题还是数据规模太小了，稍微大点就要用到快速幂了。 代码123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main()&#123; ll n,m; scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m); ll ans=n; for(int i=2;i&lt;=m;i++) ans=ans*(n-1)%109; printf(&quot;%lld\n&quot;,ans); return 0;&#125;]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019牛客暑期多校一 J-Fraction Comparision（取模技巧）]]></title>
    <url>%2F2019%2F09%2F12%2F%E6%AF%94%E8%B5%9B%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5%EF%BC%88%E7%AC%AC%E4%B8%80%E5%9C%BA%EF%BC%89%2FJ-Fraction%20Comparision%2F</url>
    <content type="text"><![CDATA[题目Bobo has two fractions ${x} \over {a}$ and ${y} \over {b}$. He wants to compare them. Find the result.输入描述:The input consists of several test cases and is terminated by end-of-file. Each test case contains four integers x, a, y, b. 0≤x,y≤1018 1≤a,b≤109 There are at most 105105 test cases. 输出描述:For each test case, print = if ${x} \over {a}$=${y} \over {b}$. Print &lt; if x/a&lt;y/b. Print &gt; otherwise.示例1输入1231 2 1 11 1 1 21 1 1 1 输出123&lt;&gt;= 思路${x} \over {a}$ 和 ${y} \over {b}$比较大小，可以转化为x*b和y*a比较大小。而数据是很大的，直接乘肯定会爆精度，所以可以将x*b转化为n\*10&lt;sup&gt;9&lt;/sup&gt;+c这样一种形式。将两者都转化为这样的，就可以通过比较n和c的值来比较两者大小。不过要注意的是，n1大于n2时不能说明x*b就一定大于y*a，因为当n1=2，n2=1，而c1=3*109，c2=109时，实际上前者小于后者，所以就要把c1和c2的值除以109放入n1和n2中，再比较。 代码1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std; typedef long long ll;const ll MOD=1e9;int main() &#123; ll x,y,a,b; while(scanf("%lld%lld%lld%lld",&amp;x,&amp;a,&amp;y,&amp;b)!=EOF) &#123; ll n1=x/MOD; n1*=b; ll c1=x%MOD; c1*=b; n1+=c1/MOD; c1%=MOD; ll n2=y/MOD;n2*=a; ll c2=y%MOD;c2*=a; n2+=c2/MOD; c2%=MOD; // cout&lt;&lt;n1&lt;&lt;' '&lt;&lt;n2&lt;&lt;' '&lt;&lt;c1&lt;&lt;' '&lt;&lt;c2&lt;&lt;endl; if(n1==n2) &#123; if(c1==c2) puts("="); else if(c1&lt;c2) puts("&lt;"); else puts("&gt;"); &#125; else if(n1&lt;n2) puts("&lt;"); else puts("&gt;"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>比赛</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019牛客暑期多校一 E-ABBA(dp)]]></title>
    <url>%2F2019%2F09%2F12%2F%E6%AF%94%E8%B5%9B%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5%EF%BC%88%E7%AC%AC%E4%B8%80%E5%9C%BA%EF%BC%89%2FE-ABBA%2F</url>
    <content type="text"><![CDATA[题目Bobo has a string of length 2(n + m) which consists of characters A and B. The string also has a fascinating property: it can be decomposed into (n + m) subsequences of length 2, and among the (n + m) subsequences n of them are AB while other m of them are BA. Given n and m, find the number of possible strings modulo (109+7).输入描述:The input consists of several test cases and is terminated by end-of-file. Each test case contains two integers n and m. 0≤n,m≤1030≤n,m≤103 There are at most 2019 test cases, and at most 20 of them has max{n,m}&gt;50max{n,m}&gt;50. 输出描述:For each test case, print an integer which denotes the result.示例1输入1231 21000 10000 0 输出123134362404101 思路这道题看了题解才会。题意为，分别有n+m个A，B，问能够构造多少种字符串使得该字符串有n个AB，m个BA。 贪心，前n个A一定来自AB的A，前m个B一定来自BA的B。因为前n个A有一个来自BA的A，那么后面任意一个A都可以跟这个B组合。也就是能放AB的A就放，不能放再放BA的A，B同理。假设dp[i][j]表示i个A和j个B所构成的满足条件的字符串数量。那么当i+1&lt;=n时，放AB中的A，当i&gt;=n时放BA的A，B同理。 代码123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN=2e3+10;const ll MOD=1e9+7;ll dp[MAXN][MAXN];int main()&#123; ll n,m; while(scanf("%lld%lld",&amp;n,&amp;m)!=EOF) &#123; for(ll i=0;i&lt;=n+m;i++) for(ll j=0;j&lt;=n+m;j++) dp[i][j]=0; dp[0][0]=1; for(ll i=0;i&lt;=n+m;i++) &#123; for(ll j=0;j&lt;=n+m;j++) &#123; if(i+1&lt;=n||j&gt;=i+1-n) dp[i+1][j]=(dp[i+1][j]+dp[i][j])%MOD; if(j+1&lt;=m||i&gt;=j+1-m) dp[i][j+1]=(dp[i][j+1]+dp[i][j])%MOD; &#125; &#125; for(int i=0;i&lt;=n+m;i++,cout&lt;&lt;endl) for(int j=0;j&lt;=n+m;j++) cout&lt;&lt;dp[i][j]&lt;&lt;' '; printf("%lld\n",dp[n+m][n+m]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019牛客暑期多校一 A-Equivalent Prefixes(单调栈)]]></title>
    <url>%2F2019%2F09%2F12%2F%E6%AF%94%E8%B5%9B%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5%EF%BC%88%E7%AC%AC%E4%B8%80%E5%9C%BA%EF%BC%89%2FA-Equivalent%20Prefixes%2F</url>
    <content type="text"><![CDATA[题目链接：https://ac.nowcoder.com/acm/contest/881/A来源：牛客网题目描述Two arrays u and v each with m distinct elements are called equivalent if and only if RMQ(u,l,r)=RMQ(v,l,r) for all 1≤l≤r≤mwhere RMQ(w,l,r) denotes the index of the minimum element among wl,wl+1,…,wr.Since the array contains distinct elements, the definition of minimum is unambiguous. Bobo has two arrays a and b each with n distinct elements. Find the maximum number p≤np≤n where {a1,a2,…,ap} and {b1,b2,…,bp} are equivalent.输入描述:The input consists of several test cases and is terminated by end-of-file. The first line of each test case contains an integer n.The second line contains n integers a1,a2,…,ana1,a2,…,an.The third line contains n integers b1,b2,…,bnb1,b2,…,bn. 1≤n≤105 1≤ai,bi≤n {a1,a2,…,an} are distinct. {b1,b2,…,bn} are distinct. The sum of n does not exceed 5×105. 输出描述:For each test case, print an integer which denotes the result.示例1输入12345678921 22 132 1 33 1 253 1 5 2 45 2 4 3 1 输出 123134 思路题目求最大p使得在区间[1,p]间，对于所有的区间段都有rmq(a)==rmq(b)。 可以用两个栈分别记录两个数组的相关信息。栈底就记录该数组在当前区间也就是[1,L]间最小的元素，它上面的值都比它大。那么用栈顶元素与数组中还未访问的元素（记该元素在数组中的位置为n）比较，如果栈顶元素大于未访问元素，表明在区间[n-1,n]内已经确定谁是最小的（也就是下标为n的元素）。栈顶元素出栈，继续比较，直到碰到栈顶数比arr[n]小，就表明在区间[1,n]间，栈顶元素是最小的，从而不需要拿栈顶所在数组位置（记位置为m）前的数与arr[n]比较了，因为之前已经确定区间[m,n]的情况，而不管在包含m的区间段内（如[1,m],[2,m]）,arr[m]是最小的。 这样，分别统计两个栈的出栈情况，就可以求出最长的p了。 代码1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std; const int MAXN=1e5+100;int arr[MAXN],brr[MAXN];int n;int main()&#123; while(~scanf("%d",&amp;n)) &#123; for(int i=1;i&lt;=n;i++) scanf("%d",&amp;arr[i]); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;brr[i]); stack&lt;int&gt; s1,s2; int f=0; int ans=n; for(int i=1;i&lt;=n;i++) &#123; int t1=0,t2=0; while(s1.size()&amp;&amp;arr[s1.top()]&gt;arr[i]) &#123; s1.pop(); t1++; &#125; while(s2.size()&amp;&amp;brr[s2.top()]&gt;brr[i]) &#123; s2.pop(); t2++; &#125; if(t1!=t2) &#123; ans=i-1; break; &#125; s1.push(i); s2.push(i); &#125; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客练习赛49-A-筱玛爱地理]]></title>
    <url>%2F2019%2F09%2F12%2F%E6%AF%94%E8%B5%9B%2F%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B49-A-%E7%AD%B1%E7%8E%9B%E7%88%B1%E5%9C%B0%E7%90%86%2F</url>
    <content type="text"><![CDATA[题目链接：https://ac.nowcoder.com/acm/contest/946/A来源：牛客网 筱玛是一个热爱地理的好筱玛。最近，在《地理II》作业本上，筱玛学到了“贝塔指数”的概念：在经济地理学中，交通的联结度表示交通网络的发达程度，通常用贝塔指数来计算与比较。若用V表示一个交通网络中结点的数量，用E表示边的数量，则贝塔指数的计算方式为：β=E/V.“实践是检验真理的唯一标准”。作为一个热爱地理的好筱玛，她马上就把新学的知识应用到实践当中去。筱玛一口气出了n张交通网络规划图，其中第i张交通网络Gi有Vi个结点和Ei条边。筱玛一眼就看出了哪张图好、哪张图坏。但是作为一个负责任的好筱玛，她必须带领同学们一起进步。因此，她需要你将所有的n张图按照贝塔指数排序，并求出它们各自的贝塔指数在模109+7意义下的值。 输入描述:第一行一个整数n，表示交通网络规划图的数量。接下来n行，每行两个整数Vi和Ei，分别表示图Gi中的结点数量和边的量。输出描述:输出共n行，每行一个数，表示贝塔指数第i大的交通网络的贝塔指数在模109+7意义下的值。如果不能整除，输出分数取模后的结果。示例1输入1211 3 输出13 说明显然此时β=E/V=3。备注:对于100%的数据，保证1≤n≤2×105，1≤Vi,Ei≤109 思路我真的是太菜了。看到这个题，其实也想过精度问题，但我用了long double应该问题不大吧，事实证明我太菜了。直接算的话，是会爆精度的，而且题目还说明了是要取在模109+7意义下的值，所以要用到逆元。之前学长讲逆元的时候，没有这个意识，完全不知道有什么用处，现在知道了，因为这个题WA了21次，我菜。 不多说了，还要注意在排序的时候，不能直接除，会有精度损失的，要将除法转化为乘法排序。 代码12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll MOD=1e9+7;const int MAXN=2e5+10;ll arr[MAXN],brr[MAXN];ll index1[MAXN];bool cmp(int i,int j) &#123; return arr[i]*brr[j]&lt;arr[j]*brr[i];&#125;ll fastPow(ll a,ll b) &#123; ll ans=1; while(b) &#123; if(b&amp;1) ans=ans*a%MOD; b&gt;&gt;=1; a=a*a%MOD; &#125; return ans;&#125;int main() &#123; int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf("%lld%lld",&amp;arr[i],&amp;brr[i]); index1[i]=i; &#125; sort(index1+1,index1+n+1,cmp);// for(int i=1;i&lt;=n;i++)// cout&lt;&lt;arr[index[i]]&lt;&lt;' '&lt;&lt;brr[index[i]]&lt;&lt;endl; for(int i=1;i&lt;=n;i++) &#123; printf("%lld\n",brr[index1[i]]*ll(fastPow(arr[index1[i]],MOD-2))%MOD); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中矿大-G-毕业生的纪念礼物(map+priority_queue)]]></title>
    <url>%2F2019%2F09%2F12%2F%E6%AF%94%E8%B5%9B%2F%E5%8D%8E%E4%B8%BA%E6%9D%AF-%E4%B8%AD%E7%9F%BF%E5%A4%A7%E7%AB%9E%E8%B5%9B-G%2F</url>
    <content type="text"><![CDATA[题目链接：https://ac.nowcoder.com/acm/contest/948/G来源：牛客网 现在有n个纪念品，每个纪念品都有一个种类r[i]，现在要求对每个毕业生分发三个种类不同的纪念品，现在需要你来计算下共可以发给多少个毕业生？输入描述:第一行一个整数n，1≤n≤100000，代表纪念品的个数；第二行包含n个整数，分别是r[1], r[2], r[3]……r[n]，1≤r[i]≤1e9，表示每个纪念品所属的种类。输出描述:输出一个整数，代表最多能够分发给的毕业生人数。示例1输入12141 1 2 2 3 3 4 4 4 4 5 5 5 5 输出14 示例2输入1271 2 3 4 5 6 7 输出12 思路每个毕业生需要发三种不同纪念品，问最多能发的人数。首先需要明确的是，数量少的纪念品一旦发完就没有了，三种不同的数量少的纪念品组合在一起发下去，反而没有一种数量少组合两种数量多的可发给毕业生的人数多。（样例一侧正了这一猜想）想到这，既然数量少的可以与任意数量的组合，到最后数量多的可能会有剩余，那么就让数量多得组合数量多的。 一开始没想到的：对数量多的组合，我一开始是取数量最多的三个，取它们中的最小值，也就是这三种物品组合在一起可发给毕业生的数量。但实际上这是有缺陷的，因为前面已经提到，要让数量最多的组合在一起，而当取三者最小值，各物品数量再减去最小数量时（此时，那个三者最小数量的物品已经耗尽），可能会有其他物品的数量已经大于前三者数量了，正确的做法是，每取三个数，让他们减1，ans加1，接着在继续取最大的三者。这样就可以保证，每次取得的物品数都是已有的物品中数量最多的。 错误代码1234567891011121314151617ll res(ll a,ll b,ll c) &#123; ll tmp=min(min(a,b),c); ans+=tmp; return tmp;&#125;void solve() &#123; while(qu.size()&gt;=3) &#123; int t1=qu.top();qu.pop(); int t2=qu.top();qu.pop(); int t3=qu.top();qu.pop(); int tmp=res(t1,t2,t3); t1-=tmp,t2-=tmp,t3-=tmp; if(t1) qu.push(t1); if(t2) qu.push(t2); if(t3) qu.push(t3); &#125;&#125; 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN=1e5+10;map&lt;ll,ll&gt; mp;priority_queue&lt;int&gt; qu;ll n;ll ans;void read() &#123; scanf("%lld",&amp;n); for(ll i=1;i&lt;=n;i++) &#123; ll a; scanf("%lld",&amp;a); mp[a]++; &#125;&#125;void init() &#123; map&lt;ll,ll&gt;::iterator it; for(it=mp.begin();it!=mp.end();it++) qu.push(it-&gt;second);&#125;ll res(ll a,ll b,ll c) &#123; ll tmp=min(min(a,b),c); ans+=tmp; return tmp; &#125;void solve() &#123; while(qu.size()&gt;=3) &#123; int t1=qu.top();qu.pop(); int t2=qu.top();qu.pop(); int t3=qu.top();qu.pop(); int tmp=1; t1-=tmp,t2-=tmp,t3-=tmp; ans++; if(t1) qu.push(t1); if(t2) qu.push(t2); if(t3) qu.push(t3); &#125;&#125;int main() &#123; read(); init(); solve(); printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The 16th Zhejiang Provincial Collegiate Programming]]></title>
    <url>%2F2019%2F09%2F12%2F%E6%AF%94%E8%B5%9B%2FThe%2016th%20Zhejiang%20Provincial%20Collegiate%20Programming%2F</url>
    <content type="text"><![CDATA[A - Sequence in the Pocket ZOJ - 4104题目https://cn.vjudge.net/problem/ZOJ-4104DreamGrid has just found an integer sequence in his right pocket. As DreamGrid is bored, he decides to play with the sequence. He can perform the following operation any number of times (including zero time): select an element and move it to the beginning of the sequence. What’s the minimum number of operations needed to make the sequence non-decreasing?InputThere are multiple test cases. The first line of the input contains an integer , indicating the number of test cases. For each test case: The first line contains an integer (), indicating the length of the sequence. The second line contains integers (), indicating the given sequence. It’s guaranteed that the sum of of all test cases will not exceed . OutputFor each test case output one line containing one integer, indicating the answer. Sample Input12345241 3 2 452 3 3 5 5 Sample Output1220 HintFor the first sample test case, move the 3rd element to the front (so the sequence become {2, 1, 3, 4}), then move the 2nd element to the front (so the sequence become {1, 2, 3, 4}). Now the sequence is non-decreasing. For the second sample test case, as the sequence is already sorted, no operation is needed. 思路将一个数移到最左端，使得最终数组元素为单调递增，问最少要移动多少次。初次碰到这种问题，不免都要在脑海中模拟一遍过程，在数据量较少时可能还好说，当数据非常大时，脑子都是晕乎乎的。其实可以发现，最终结果都是要求数组元素单调递增，那么就只需要观察，一个已经是单调递增状态的数组对于原数组来说，哪些数的位置发生了变化，统计这些位置变化的元素即可。当然这里需要注意到，当一个数移动到最左边时，那么这个数原先位置的左边的数的位置都要往右边移一位。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/*https://cn.vjudge.net/problem/ZOJ-4104*/#include&lt;bits/stdc++.h&gt;using namespace std;/*misson 使命，任务，使团 occur 发生 attain 获得 magnificent 壮丽的，华丽的，极好的 adverse 不利的，有害的 stray 走失，迷路，分心，走神，离题 remedy 补救办法，纠正办法，补救，纠正 potential 潜力，潜能，潜在的，可能的 mob 暴民，乌合之众 cane 手杖，藤、竹的茎 */const int misson=1e6+10;int occur[misson];int remedy[misson];int main() &#123; ios::sync_with_stdio(false); int attain; cin&gt;&gt;attain; while(attain--) &#123; int magnificent; cin&gt;&gt;magnificent; for(int stray=1;stray&lt;=magnificent;stray++) &#123; cin&gt;&gt;occur[stray]; remedy[stray]=occur[stray]; &#125; sort(remedy+1,remedy+magnificent+1); int potential=0; for(int stray=magnificent;stray&gt;=1;stray--) &#123; if(occur[stray]!=remedy[potential+stray]) potential++; &#125; cout&lt;&lt;potential&lt;&lt;endl; &#125; return 0;&#125; B - Abbreviation ZOJ - 4105题目In the Test of English as a Foreign Language (TOEFL), the listening part is very important but also very hard for most students since it is usually quite hard for them to remember the whole passage. To help themselves memorize the content, students can write down some necessary details. However, it is not easy to write down the complete word because of its length. That’s why we decide to use the abbreviation to express the whole word. It is very easy to get the abbreviation, all we have to do is to keep the consonant letters and erase the vowel. In the English alphabet, we regard ‘a’, ‘e’, ‘i’, ‘y’, ‘o’, ‘u’ as the vowels and the other letters as the consonants. For example, “subconscious” will be expressed as “sbcnscs”. However, there is one exception: if the vowel appears as the first letter, they should be kept instead of thrown away. For example, “oipotato” should be expressed as “optt”. Since you have learned how to use the abbreviation method, it’s time for some exercises. We now present you words in total, it’s your task to express them in their abbreviation form. InputThere are multiple test cases. The first line of the input contains an integer (about 100), indicating the number of test cases. For each test case: The only line contains a string () consisting of lowercase English letters, indicating the word which needs to be abbreviated. OutputFor each test case output one line containing one string, which is the correct abbreviation of the given word. Sample Input1234565subconsciousoipotatowordsymbolapple Sample Output12345sbcnscsopttwrdsmblappl 思路水题 代码123456789101112131415161718192021222324252627282930313233/*https://cn.vjudge.net/problem/ZOJ-4105*/#include&lt;bits/stdc++.h&gt;using namespace std;set&lt;char&gt; st;int main() &#123; int t;// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); st.insert(&apos;a&apos;); st.insert(&apos;i&apos;); st.insert(&apos;e&apos;); st.insert(&apos;y&apos;); st.insert(&apos;o&apos;); st.insert(&apos;u&apos;); cin&gt;&gt;t; while(t--) &#123; string str; cin&gt;&gt;str; string t=&quot;&quot;; t+=str[0]; for(int i=1;i&lt;str.size();i++) &#123; if(!st.count(str[i])) t+=str[i]; &#125; cout&lt;&lt;t&lt;&lt;endl; &#125; return 0;&#125; C - Lucky 7 in the Pocket ZOJ - 4106题目BaoBao loves number 7 but hates number 4, so he refers to an integer as a “lucky integer” if is divisible by 7 but not divisible by 4. For example, 7, 14 and 21 are lucky integers, but 1, 4 and 28 are not. Today BaoBao has just found an integer in his left pocket. As BaoBao dislikes large integers, he decides to find a lucky integer such that and is as small as possible. Please help BaoBao calculate the value of . InputThere are multiple test cases. The first line of the input is an integer (about 100), indicating the number of test cases. For each test case: The first and only line contains an integer (), indicating the integer in BaoBao’s left pocket. OutputFor each test case output one line containing one integer, indicating the value of . Sample Input123454172028 Sample Output1234772135 思路水题 代码12345678910111213141516171819202122/*https://cn.vjudge.net/problem/ZOJ-4106*/#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=1e9;int main() &#123; int t; cin&gt;&gt;t; while(t--) &#123; int n; cin&gt;&gt;n; for(int i=n;i&lt;=MAXN;i++) if(i%7==0&amp;&amp;i%4!=0) &#123; cout&lt;&lt;i&lt;&lt;endl; break; &#125; &#125; return 0;&#125; D - Singing Everywhere ZOJ - 4107题目Baobao loves singing very much and he really enjoys a game called Singing Everywhere, which allows players to sing and scores the players according to their performance. Consider the song performed by Baobao as an integer sequence , where indicates the -th note in the song. We say a note is a “voice crack” if , and . The more voice cracks BaoBao sings, the lower score he gets. To get a higher score, BaoBao decides to delete at most one note in the song. What’s the minimum number of times BaoBao sings a voice crack after this operation? InputThere are multiple test cases. The first line of the input contains an integer (about 100), indicating the number of test cases. For each test case: The first line contains one integer (), indicating the length of the song. The second line contains integers (), indicating the song performed by BaoBao. It’s guaranteed that at most 5 test cases have . OutputFor each test case output one line containing one integer, indicating the answer. Sample Input1234567361 1 4 5 1 471 9 1 9 8 1 0102 1 4 7 4 8 3 6 4 7 Sample Output123102 HintFor the first sample test case, BaoBao does not need to delete a note. Because if he deletes no note, he will sing 1 voice crack (the 4th note), and no matter which note he deletes, he will also always sing 1 voice crack. For the second sample test case, BaoBao can delete the 3rd note, and no voice cracks will be performed. Yay! For the third sample test case, BaoBao can delete the 4th note, so that only 2 voice cracks will be performed (4 8 3 and 3 6 4). 思路首先可以确定是，每一个位置的状态都会影响它左右两个相邻位置的状态（假设左右两边有元素）。那么只需要枚举每一个位置当它消失时，对左右相邻的元素的影响，求出最大的影响即可。 ##1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/*https://cn.vjudge.net/problem/ZOJ-4107*/#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=1e5+10;int arr[MAXN];int visit[MAXN];int main() &#123; ios::sync_with_stdio(false);// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); int t; cin&gt;&gt;t; while(t--) &#123; int n; cin&gt;&gt;n; memset(visit,0,sizeof(visit)); for(int i=1;i&lt;=n;i++) cin&gt;&gt;arr[i]; int ans=0; for(int i=2;i&lt;n;i++) if(arr[i]&gt;arr[i-1]&amp;&amp;arr[i]&gt;arr[i+1]) &#123; ans++; visit[i]=1; &#125; int sum=0; for(int i=1;i&lt;=n;i++) &#123; int cnt=0; if(i-1&gt;=1&amp;&amp;i+1&lt;=n) &#123; if(i+2&lt;=n&amp;&amp;arr[i+1]&gt;arr[i+2]&amp;&amp;arr[i+1]&gt;arr[i-1]) &#123; cnt++; &#125; if(i-2&gt;=1&amp;&amp;arr[i-1]&gt;arr[i+1]&amp;&amp;arr[i-1]&gt;arr[i-2]) &#123; cnt++; &#125; if(arr[i-1]+arr[i]+arr[i+1]&gt;cnt) &#123; sum=max(sum,visit[i-1]+visit[i]+visit[i+1]-cnt); &#125; &#125; &#125;// cout&lt;&lt;ans&lt;&lt;&apos; &apos;&lt;&lt;sum&lt;&lt;endl; ans=ans-sum; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; E - Fibonacci in the Pocket ZOJ - 4108题目https://cn.vjudge.net/problem/ZOJ-4108 思路求斐波那契数列第a项到第b项的和是奇数还是偶数。通过对斐波那契数列的观察可以发现数列奇偶性有这样的规律奇奇偶奇奇偶奇奇偶奇奇偶奇奇偶奇奇偶奇奇偶奇奇偶奇奇偶奇奇偶，可以看到以3为基准，奇奇偶相加一定为偶数，那么问题就转化为区间[a,b]内有多少个不成对的奇数。将a，b的数位加起来mod3，可以得到在第a项是奇数还是偶数，同理，可以得到第b项。也转化为在第a项的右边有多少不成对的奇数，在第b项左边有多少不成对的奇数，将他们加起来判断是奇还是偶。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/*https://cn.vjudge.net/problem/ZOJ-4108*/#include&lt;bits/stdc++.h&gt;using namespace std;string str1,str2;int solve(string str) &#123; int ans=0; for(int i=0;i&lt;str.size();i++) &#123; ans+=str[i]-48; ans%=3; &#125; return ans;&#125;int main() &#123; ios::sync_with_stdio(false); int t;// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;str1&gt;&gt;str2; int len1=solve(str1); int len2=solve(str2);// cout&lt;&lt;len1&lt;&lt;&apos; &apos;&lt;&lt;len2&lt;&lt;endl; int odd=0,even=0; if(len1==1) odd=2; else if(len1==2) odd=1; else if(len1==0) odd=0; if(len2==1) even=1; else if(len2==2) even=2; else if(len2==0) even=0; if((odd+even)%2==0) cout&lt;&lt;0&lt;&lt;endl; else cout&lt;&lt;1&lt;&lt;endl; &#125; return 0;&#125; F - Welcome Party ZOJ - 4109 (并查集+优先队列)题目https://cn.vjudge.net/problem/ZOJ-4109 思路本场我能解决的问题中最有价值的题目。求进入party的最少不开心人数同时使得进入次序字典序最小。虽然题目中说朋友的朋友不能算作朋友，如果相信这句话就不太好解了。虽然不能算作朋友，但却可以通过一个共同的朋友进入party从而不会不开心。所以通过并查集来分析哪些人会被其他人影响，例如，如果有两个集合没有任何关系，那么这两个集合的人任意谁先进去都可以，只不过考虑下字典序就行了。要让字典序最小，用一个优先队列来维护出队顺序即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include&lt;bits/stdc++.h&gt;using namespace std;//WAconst int MAXN=1e6+10;struct node &#123; int to; int next; &#125;edge[MAXN*4];priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; qu;int parent[MAXN];int visit[MAXN];int n,m;int head[MAXN];int tol;void init() &#123; tol=0; memset(head,-1,sizeof(head)); &#125;inline void add(int v,int u) &#123; tol++; edge[tol].to=u; edge[tol].next=head[v]; head[v]=tol++;&#125;inline int find(int x) &#123; if(x==parent[x]) return x; return parent[x]=find(parent[x]);&#125; inline void join(int x,int y) &#123; x=find(x); y=find(y); if(x!=y) if(x&lt;y) parent[y]=x; else parent[x]=y;&#125;inline void BFS() &#123; int ans=0;// memset(visit,0,sizeof(visit)); for(int i=1;i&lt;=n;i++) if(parent[i]==i) &#123; qu.push(i); visit[i]=1; ans++; &#125; printf(&quot;%d\n&quot;,ans); int cnt=0; while(!qu.empty()) &#123; int t=qu.top();qu.pop(); cnt++; if(cnt!=n) printf(&quot;%d &quot;,t); else &#123; printf(&quot;%d\n&quot;,t); break; &#125; for(int i=head[t];i!=-1;i=edge[i].next) &#123; int v=edge[i].to; if(!visit[v]) &#123; qu.push(v); visit[v]=1; &#125; &#125; &#125;&#125;int main() &#123; ios::sync_with_stdio(false);// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m);// init(); tol=0; while(!qu.empty()) qu.pop(); for(int i=1;i&lt;=n;i++) &#123; visit[i]=0; parent[i]=i; head[i]=-1; &#125; for(int i=1;i&lt;=m;i++) &#123; int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); add(a,b); add(b,a); join(a,b); &#125; BFS(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces-516-Div.2]]></title>
    <url>%2F2019%2F09%2F12%2F%E6%AF%94%E8%B5%9B%2FCodeforces-516-Div.%202%2F</url>
    <content type="text"><![CDATA[A Make a triangle!题目Masha has three sticks of length a, b and c centimeters respectively. In one minute Masha can pick one arbitrary stick and increase its length by one centimeter. She is not allowed to break sticks. What is the minimum number of minutes she needs to spend increasing the stick’s length in order to be able to assemble a triangle of positive area. Sticks should be used as triangle’s sides (one stick for one side) and their endpoints should be located at triangle’s vertices.InputThe only line contains tree integers a, b and c (1≤a,b,c≤100) — the lengths of sticks Masha possesses. OutputPrint a single integer — the minimum number of minutes that Masha needs to spend in order to be able to make the triangle of positive area from her sticks. ExamplesInput13 4 5 Output10 Input12 5 3 Output11 Input1100 10 10 Output181 NoteIn the first example, Masha can make a triangle from the sticks without increasing the length of any of them. In the second example, Masha can’t make a triangle of positive area from the sticks she has at the beginning, but she can spend one minute to increase the length 2 centimeter stick by one and after that form a triangle with sides 3, 3 and 5 centimeters. In the third example, Masha can take 33 minutes to increase one of the 10 centimeters sticks by 33 centimeters, and after that take 48 minutes to increase another 10 centimeters stick by 48 centimeters. This way she can form a triangle with lengths 43, 58 and 100 centimeters in 81 minutes. One can show that it is impossible to get a valid triangle faster. 思路题意为求让两条小边最少增加多少才能够与第三条边构成三角形。而三条边能够构成三角形的条件很简单，那么让最大的边加1减去两条小边长即可。当然，如果直接就满足构成三角形的条件直接输出0就行了。 代码12345678910111213141516#include&lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int arr[3]; cin&gt;&gt;arr[0]&gt;&gt;arr[1]&gt;&gt;arr[2]; sort(arr,arr+3); if((arr[0]+arr[1]&gt;arr[2])&amp;&amp;(arr[1]+arr[2]&gt;arr[0])&amp;&amp;(arr[0]+arr[2]&gt;arr[1]))&#123; cout&lt;&lt;0&lt;&lt;endl; return 0; &#125; int ans=arr[2]+1-(arr[0]+arr[1]); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; B Equations of Mathematical Magic题目Colossal! — exclaimed Hawk-nose. — A programmer! That’s exactly what we are looking for.Arkadi and Boris Strugatsky. Monday starts on SaturdayReading the book “Equations of Mathematical Magic” Roman Oira-Oira and Cristobal Junta found an interesting equation: a−(a⊕x)−x=0 for some given a, where ⊕ stands for a bitwise exclusive or (XOR) of two integers (this operation is denoted as ^ or xor in many modern programming languages). Oira-Oira quickly found some x, which is the solution of the equation, but Cristobal Junta decided that Oira-Oira’s result is not interesting enough, so he asked his colleague how many non-negative solutions of this equation exist. This task turned out to be too difficult for Oira-Oira, so he asks you to help. InputEach test contains several possible values of a and your task is to find the number of equation’s solution for each of them. The first line contains an integer t (1≤t≤1000) — the number of these values. The following t lines contain the values of parameter a, each value is an integer from 0 to 2^30−1 inclusive. OutputFor each value of a print exactly one integer — the number of non-negative solutions of the equation for the given value of the parameter. Print answers in the same order as values of a appear in the input. One can show that the number of solutions is always finite. ExampleInput12343021073741823 Output123121073741824 NoteLet’s define the bitwise exclusive OR (XOR) operation. Given two integers x and y, consider their binary representations (possibly with leading zeroes): xk…x2x1x0 and yk…y2y1y0. Here, xi is the i-th bit of the number x and yi is the i-th bit of the number y. Let r=x⊕y be the result of the XOR operation of x and y. Then r is defined as rk…r2r1r0 where: 12ri=&#123;1, if xi≠yi；0, if xi=yi For the first value of the parameter, only x=0 is a solution of the equation. For the second value of the parameter, solutions are x=0 and x=2. 思路转换一下公式a−(a⊕x)−x=0 =&gt;a-x=a⊕x。假设a的二进制表示为1011011011，a减去一个数x（x&gt;=0）必然会使得a减小，那么就要看a与哪些数异或会使得a会减小相同数的值。异或为不进位的加法，比如1101^0001，结果为1100；让1101-0001，结果为1100。可以发现，只要x的二进制串上的1与a的二进制串上的1有对应的（x的1不与a上的0对应），那么就满足a-x=a⊕x。举例子，a=1011011011，x可为1，11，1011，11011……。所以只需统计a的二进制串有多少位是1，又对于每一位的1选择是取还是不取，答案为2^n。 代码123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;long long fast_pow(int a,int b) &#123; long long ans=1; while(b) &#123; if(b&amp;1) ans=ans*a; a*=a; b&gt;&gt;=1; &#125; return ans;&#125;int main() &#123; int t; cin&gt;&gt;t; while(t--) &#123; long long n; cin&gt;&gt;n; int sum=0; while(n) &#123; if(n&amp;1) sum++; n&gt;&gt;=1; &#125; cout&lt;&lt;fast_pow(2,sum)&lt;&lt;endl; &#125; return 0;&#125; C Oh Those Palindromes题目A non-empty string is called palindrome, if it reads the same from the left to the right and from the right to the left. For example, “abcba”, “a”, and “abba” are palindromes, while “abab” and “xy” are not. A string is called a substring of another string, if it can be obtained from that string by dropping some (possibly zero) number of characters from the beginning and from the end of it. For example, “abc”, “ab”, and “c” are substrings of the string “abc”, while “ac” and “d” are not. Let’s define a palindromic count of the string as the number of its substrings that are palindromes. For example, the palindromic count of the string “aaa” is 6 because all its substrings are palindromes, and the palindromic count of the string “abc” is 3 because only its substrings of length 1 are palindromes. You are given a string s. You can arbitrarily rearrange its characters. You goal is to obtain a string with the maximum possible value of palindromic count. InputThe first line contains an integer n (1≤n≤100000) — the length of string s. The second line contains string s that consists of exactly n lowercase characters of Latin alphabet. OutputPrint string t, which consists of the same set of characters (and each characters appears exactly the same number of times) as string s. Moreover, t should have the maximum possible value of palindromic count among all such strings strings. If there are multiple such strings, print any of them. ExamplesInput125oolol Output1ololo Input1216gagadbcgghhchbdf Output1abccbaghghghgdfd NoteIn the first example, string “ololo” has 9 palindromic substrings: “o”, “l”, “o”, “l”, “o”, “olo”, “lol”, “olo”, “ololo”. Note, that even though some substrings coincide, they are counted as many times as they appear in the resulting string. In the second example, the palindromic count of string “abccbaghghghgdfd” is 29. 思路给定一个字符串，求能组回文子串的最多种数。其实这个题目考思维。对于字符串abccba，如果能看到aabbcc所组成的回文子串的数量一样多的话，就简洁明了了。 代码12345678910111213#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=100000+10;char str[MAXN]; int main() &#123; int n; cin&gt;&gt;n; cin&gt;&gt;str; sort(str,str+n); cout&lt;&lt;str&lt;&lt;endl; return 0;&#125; D Labyrinth CodeForces题目You are playing some computer game. One of its levels puts you in a maze consisting of n lines, each of which contains m cells. Each cell either is free or is occupied by an obstacle. The starting cell is in the row r and column c. In one step you can move one square up, left, down or right, if the target cell is not occupied by an obstacle. You can’t move beyond the boundaries of the labyrinth. Unfortunately, your keyboard is about to break, so you can move left no more than x times and move right no more than y times. There are no restrictions on the number of moves up and down since the keys used to move up and down are in perfect condition. Now you would like to determine for each cell whether there exists a sequence of moves that will put you from the starting cell to this particular one. How many cells of the board have this property? InputThe first line contains two integers n, m (1 ≤ n, m ≤ 2000) — the number of rows and the number columns in the labyrinth respectively. The second line contains two integers r, c (1 ≤ r ≤ n, 1 ≤ c ≤ m) — index of the row and index of the column that define the starting cell. The third line contains two integers x, y (0 ≤ x, y ≤ 109) — the maximum allowed number of movements to the left and to the right respectively. The next n lines describe the labyrinth. Each of them has length of m and consists only of symbols ‘.’ and ‘“.The j-th character of the i-th line corresponds to the cell of labyrinth at row i and column j. Symbol ‘.’ denotes the free cell, while symbol ““ denotes the cell with an obstacle. It is guaranteed, that the starting cell contains no obstacles. OutputPrint exactly one integer — the number of cells in the labyrinth, which are reachable from starting cell, including the starting cell itself. ExamplesInput12345674 53 21 2......***....***.... Output110 Input12345674 42 20 1......*......... Output17 NoteCells, reachable in the corresponding example, are marked with ‘+’. First example:1234+++..+***.+++***+++. Second example:1234.++..+*..++..++. 思路由起点出发，在向左向右转有次数限制的条件下问能到达最大的位置。先是用传统的BFS写了一遍，WA，后来发现某个位置可由不同的位置到达，这些位置带来的状态转变也不一定相同。例如，12345678910...*******.*.*******.*.*******.*.*******.*.*******.*.*.......*.*@*****.*.........********........... 在某个关键位置@，假如由位置1带来的状态是左右转次数都为0，就导致这个点无法向左或向右转造成的结果是后面可能会有更多可达到的位置但是由于这个点@已经无法访问，使得就算有另外的位置达到这里的左右转次数不为零也没有用。所以需要定义一种谁先访问谁后访问的顺序来避免这种情况。 双端队列解法由题知，上下移动不消耗次数，左右移动消耗次数，那么就可以只要能向上或向下就向上或向下移动，当无法上下移动时才左右移动。使用双端队列，将能上下移动的位置放在队头，左右移动的位置放在队尾。 优先队列解法其实优先队列解法与双端队列解法思想是一样的，那就是能上下移动就上下移动，而上下移动不会消耗左右移动次数，也就是说左移动次数加上右移动次数大的优先访问。 代码（deque）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=2e3+10;struct node&#123; int x,y,dep; int left,right; node(int x,int y,int dep,int left,int right):x(x),y(y),dep(dep),left(left),right(right)&#123;&#125;// bool operator &lt; (const node &amp;a) const &#123;return (right)&gt;(a.right);&#125;&#125;; deque&lt;node&gt; qu;int n,m;int r,c;int leftCount,rightCount;int visit[MAXN][MAXN];string str[MAXN]; int ans;int dx[]=&#123;1,-1,0,0&#125;;int dy[]=&#123;0,0,1,-1&#125;;void BFS(int x,int y,int left,int right) &#123; while(!qu.empty()) qu.pop_back(); memset(visit,0,sizeof(visit)); qu.push_front(node(x,y,0,left,right)); visit[x][y]=1; while(!qu.empty()) &#123; node t=qu.front();qu.pop_front(); for(int i=0;i&lt;4;i++) &#123; int tx=t.x+dx[i]; int ty=t.y+dy[i]; if(tx&gt;=0&amp;&amp;tx&lt;n&amp;&amp;ty&gt;=0&amp;&amp;ty&lt;m&amp;&amp;!visit[tx][ty]&amp;&amp;str[tx][ty]==&apos;.&apos;) &#123; // visit[t.x][t.y]=0; if(0==i||1==i) &#123; qu.push_front(node(tx,ty,t.dep+1,t.left,t.right)); visit[tx][ty]=1; ans++; &#125; else if(2==i) &#123; if(t.right&gt;0) &#123; qu.push_back(node(tx,ty,t.dep+1,t.left,t.right-1)); visit[tx][ty]=1; ans++; &#125; &#125; else if(3==i) &#123; if(t.left&gt;0) &#123; qu.push_back(node(tx,ty,t.dep+1,t.left-1,t.right)); visit[tx][ty]=1; ans++; &#125; &#125; &#125; &#125; &#125;&#125;int main() &#123; ios::sync_with_stdio(false); ans=1; cin&gt;&gt;n&gt;&gt;m; cin&gt;&gt;r&gt;&gt;c; cin&gt;&gt;leftCount&gt;&gt;rightCount; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;str[i]; &#125; BFS(r-1,c-1,leftCount,rightCount); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 代码（priority_queue）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=2e3+10;struct node&#123; int x,y,dep; int left,right; node(int x,int y,int dep,int left,int right):x(x),y(y),dep(dep),left(left),right(right)&#123;&#125; bool operator &lt; (const node &amp;a) const &#123;return (left+right)&lt;(a.left+a.right);&#125;&#125;; priority_queue&lt;node&gt; qu;int n,m;int r,c;int leftCount,rightCount;int visit[MAXN][MAXN];string str[MAXN]; int ans;int dx[]=&#123;1,-1,0,0&#125;;int dy[]=&#123;0,0,1,-1&#125;;void BFS(int x,int y,int left,int right) &#123; while(!qu.empty()) qu.pop(); memset(visit,0,sizeof(visit)); qu.push(node(x,y,0,left,right)); visit[x][y]=1; while(!qu.empty()) &#123; node t=qu.top();qu.pop(); for(int i=0;i&lt;4;i++) &#123; int tx=t.x+dx[i]; int ty=t.y+dy[i]; if(tx&gt;=0&amp;&amp;tx&lt;n&amp;&amp;ty&gt;=0&amp;&amp;ty&lt;m&amp;&amp;!visit[tx][ty]&amp;&amp;str[tx][ty]==&apos;.&apos;) &#123; // visit[t.x][t.y]=0; if(0==i||1==i) &#123; qu.push(node(tx,ty,t.dep+1,t.left,t.right)); visit[tx][ty]=1; ans++; &#125; else if(2==i) &#123; if(t.right&gt;0) &#123; qu.push(node(tx,ty,t.dep+1,t.left,t.right-1)); visit[tx][ty]=1; ans++; &#125; &#125; else if(3==i) &#123; if(t.left&gt;0) &#123; qu.push(node(tx,ty,t.dep+1,t.left-1,t.right)); visit[tx][ty]=1; ans++; &#125; &#125; &#125; &#125; &#125;&#125;int main() &#123; ios::sync_with_stdio(false); ans=1; cin&gt;&gt;n&gt;&gt;m; cin&gt;&gt;r&gt;&gt;c; cin&gt;&gt;leftCount&gt;&gt;rightCount; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;str[i]; &#125; BFS(r-1,c-1,leftCount,rightCount); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCPC2018-湖南全国邀请赛-重现赛]]></title>
    <url>%2F2019%2F09%2F12%2F%E6%AF%94%E8%B5%9B%2FCCPC2018-%E6%B9%96%E5%8D%97%E5%85%A8%E5%9B%BD%E9%82%80%E8%AF%B7%E8%B5%9B-%E9%87%8D%E7%8E%B0%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[A - Easy $h$-index HDU - 6276题目：比赛题目：http://acm.hdu.edu.cn/downloads/2018ccpc_hn.pdf The h-index of an author is the largest h where he has at least h papers with citations not less than h. Bobo has published many papers.Given a0,a1,a2,…,an which means Bobo has published ai papers with citations exactly i, find the h-index of Bobo.InputThe input consists of several test cases and is terminated by end-of-file. The first line of each test case contains an integer n.The second line contains (n+1) integers a0,a1,…,an.OutputFor each test case, print an integer which denotes the result. Constraint 1≤n≤2⋅105 0≤ai≤109 The sum of n does not exceed 250,000. Sample Input12345611 221 2 330 0 0 0 Sample Output123120 思路题目意思有点绕，大意是，发表了h篇文章索引量不少于h，然后求最大的h那么只需要将索引量多的文章数加到索引量少的文章数就可以了。 代码12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=1e6+10;int n;int arr[MAXN];int main() &#123; ios::sync_with_stdio(false); while(~scanf(&quot;%d&quot;,&amp;n)) &#123; for(int i=0;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;arr[i]); for(int i=n-1;i&gt;=0;i--) arr[i]+=arr[i+1]; int ans=0; for(int i=1;i&lt;=n+1;i++) if(i&lt;=arr[i]) ans=max(ans,i); cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; F - Sorting HDU - 6281题目Bobo has n tuples (a1,b1,c1),(a2,b2,c2),…,(an,bn,cn).He would like to find the lexicographically smallest permutation p1,p2,…,pn of 1,2,…,n such that for i∈{2,3,…,n} it holds that(a[pi−1]+b[pi−1])/(a[pi−1]+b[pi−1]+c[pi−1])≤(a[pi]+b[pi])/(a[pi]+b[pi]+c[pi]). InputThe input consists of several test cases and is terminated by end-of-file. The first line of each test case contains an integer n.The i-th of the following n lines contains 3 integers ai, bi and ci.OutputFor each test case, print n integers p1,p2,…,pn seperated by spaces.DO NOT print trailing spaces. Constraint 1≤n≤103 1≤ai,bi,ci≤2×109 The sum of n does not exceed 104. Sample Input1234567891021 1 11 1 221 1 21 1 131 3 12 2 13 1 1 Sample Output1232 11 21 2 3 思路求p1-pn间最小的字典序使其满足上面那个不等式。关键在于进行long long 型整数除法时，long double可能都无法保证浮点数精度，所以最好要交换下，但很奇怪的是long double就过了，数据挺弱的吧。 代码12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=3e4+10;struct node&#123; long double a,b,c; int index; long double cost;&#125;;node arr[MAXN];node value[MAXN];int n;bool cmp(node a,node b) &#123; if(a.cost==b.cost) return a.index&lt;b.index; return a.cost&lt;b.cost;&#125;int main() &#123;// cout&lt;&lt;10/3*30&lt;&lt;endl; ios::sync_with_stdio(false); while(cin&gt;&gt;n) &#123; for(int i=1;i&lt;=n;i++) cin&gt;&gt;arr[i].a&gt;&gt;arr[i].b&gt;&gt;arr[i].c; for(int i=1;i&lt;=n;i++) &#123; value[i].cost=(arr[i].a+arr[i].b)*1.0/(arr[i].a+arr[i].b+arr[i].c)*1.0; value[i].index=i; &#125; sort(value+1,value+n+1,cmp); for(int i=1;i&lt;n;i++) cout&lt;&lt;value[i].index&lt;&lt;&apos; &apos;; cout&lt;&lt;value[n].index&lt;&lt;endl; &#125; return 0;&#125; G - String Transformation HDU - 6282题目Bobo has a string S=s1s2…sn consists of letter a, b and c.He can transform the string by inserting or deleting substrings aa, bb and abab. Formally, A=u∘w∘v (∘’’ denotes string concatenation) can be transformed into A′=u∘v and vice versa where u, v are (possibly empty) strings and w∈{aa,bb,abab}. Given the target string T=t1t2…tm, determine if Bobo can transform the string S into T.InputThe input consists of several test cases and is terminated by end-of-file. The first line of each test case contains a string s1s2…sn.The second line contains a string t1t2…tm.OutputFor each test case, print Yes if Bobo can. Print No otherwise. Constraint 1≤n,m≤104 s1,s2,…,sn,t1,t2,…,tm∈{a,b,c} The sum of n and m does not exceed 250,000. Sample Input123456abbaaccaaab Sample Output123YesNoNo Hint For the first sample, Bobo can transform as ab =&gt; aababb =&gt; babb =&gt; ba. 思路题意为第一个字符串能不能变成第二个字符串。首先由第一个样列看到ab经过一系列变化可以转变为ba，同理ba也能转变为ab，得ab与ba能相互转换。再者，经过转换，最后可得到的字符串可以是：a的个数为奇数得到a，b的个数为奇数b，a的个数与b的个数同奇得到ab或ba，a的个数与b的个数同偶得到空串；利用这几点统计两个串的a、b个数的奇偶性即可。其次，对于任何一个串，如果a与a相邻，b与b相邻，那么可以直接删去相邻得相同得字符；如果有abab之类，由ab=&gt;ba得abba可直接删去。对于字符c，无法删除或转化，所以c是一个分隔符，将ab组成的字符串分隔开即c左边的不会影响右边的，得出结论：如果两个串的c不相等，即无法转换。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=1e4+10;struct node&#123; int Counta,Countb; &#125;;int main() &#123; string str1,str2; while(cin&gt;&gt;str1&gt;&gt;str2) &#123; node arr[MAXN]; node brr[MAXN]; memset(arr,0,sizeof(arr)); memset(brr,0,sizeof(brr)); // for(int i=0;i&lt;=10;i++)// cout&lt;&lt;arr[i].Counta&lt;&lt;&apos; &apos;&lt;&lt;arr[i].Countb&lt;&lt;endl;// cout&lt;&lt;endl; int cnt1=0; int cnt2=0; for(int i=0;i&lt;str1.size();i++) &#123; if(&apos;a&apos;==str1[i]) arr[cnt1].Counta++; if(&apos;b&apos;==str1[i]) arr[cnt1].Countb++; if(&apos;c&apos;==str1[i]) cnt1++; &#125; for(int i=0;i&lt;str2.size();i++) &#123; if(&apos;a&apos;==str2[i]) brr[cnt2].Counta++; if(&apos;b&apos;==str2[i]) brr[cnt2].Countb++; if(&apos;c&apos;==str2[i]) cnt2++; &#125; if(cnt1!=cnt2) &#123; cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; continue; &#125; bool flag=true; while(cnt1!=-1) &#123; if((arr[cnt1].Counta+arr[cnt1].Countb)%2!=(brr[cnt2].Counta+brr[cnt2].Countb)%2) &#123; flag=false; break; &#125; if((arr[cnt1].Counta%2!=brr[cnt2].Counta%2)||(arr[cnt1].Countb%2!=brr[cnt2].Countb%2)) &#123; flag=false; break; &#125; cnt1--; cnt2--; &#125; if(flag) cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; &#125; return 0; &#125; K - 2018 HDU - 6286题目Given a,b,c,d, find out the number of pairs of integers (x,y) where a≤x≤b,c≤y≤d and x⋅y is a multiple of 2018.InputThe input consists of several test cases and is terminated by end-of-file. Each test case contains four integers a,b,c,d.OutputFor each test case, print an integer which denotes the result. Constraint 1≤a≤b≤109,1≤c≤d≤109 The number of tests cases does not exceed 104. Sample Input1231 2 1 20181 2018 1 20181 1000000000 1 1000000000 Sample Output123360511485883320325200 思路给定两个区间，问在这两个区间内各取一个数，使其乘积是2018的倍数的取法有多少种。首先想到，要得到2018的倍数，只能通过两种方法得到，1、2018乘以大于0的任意数2、1009乘以大于0的偶数分别统计[a,b]，[c,d]区间内1009的倍数的个数，2018的倍数的个数，2的倍数的个数，总元素个数。拿[a,b]区间1009的倍数个数乘以[c,d]区间内偶数的个数，2018的倍数的个数乘以[c,d]区间内所有元素的个数。[c,d]区间对[a,b]区间也是如此。到这里，可以发现，在统计1009的倍数时会统计到一部分2018的倍数方案，这里需要借助到容斥原理来去重。即1009的倍数加上2018的倍数减去既是2018的倍数又是2的倍数。[c,d]区间也是如此。 代码123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;long long a,b,c,d;long long ans;int main() &#123; while(cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d) &#123; ans=0; long long Counta=b-a+1; long long Countb=d-c+1; long long tmpa=b/2018-(a-1)/2018;//a-b 2018 long long tmpb=d/2018-(c-1)/2018;//c-d 2018 long long tmpx=b/1009-(a-1)/1009;//a-b 1009 long long tmpy=d/1009-(c-1)/1009;//c-d 1009 long long tmpq=b/2-(a-1)/2;//a-b 2 long long tmpp=d/2-(c-1)/2;//c-d 2 // cout&lt;&lt;Counta&lt;&lt;&apos; &apos;&lt;&lt;Countb&lt;&lt;&apos; &apos;&lt;&lt;tmpa&lt;&lt;&apos; &apos;&lt;&lt;tmpb&lt;&lt;&apos; &apos;&lt;&lt;tmpx&lt;&lt;&apos; &apos;&lt;&lt;tmpy&lt;&lt;&apos; &apos;&lt;&lt;tmpq&lt;&lt;&apos; &apos;&lt;&lt;tmpp&lt;&lt;endl; ans=tmpa*Countb+tmpb*Counta-tmpa*tmpb; ans+=(tmpx-tmpa)*(tmpp-tmpb); ans+=(tmpy-tmpb)*(tmpq-tmpa); cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;//AC]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆优化prim模板]]></title>
    <url>%2F2019%2F09%2F12%2F%E6%A8%A1%E6%9D%BF%2F%E5%A0%86%E4%BC%98%E5%8C%96prim%E6%A8%A1%E6%9D%BF%20%20%2F</url>
    <content type="text"><![CDATA[数据过大导致开大数组不实际时，用vector。123456789101112131415161718192021222324252627282930313233343536373839const int MAXN=100000+10;const int inf=10e7;struct Node&#123; int x,cost; Node(int x,int cost):x(x),cost(cost)&#123;&#125; friend bool operator &lt; (const Node &amp;a,const Node &amp;b) &#123;return a.cost&gt;b.cost;&#125;&#125;;priority_queue&lt;Node&gt; qu;int n,m;vector&lt;Node&gt; mp[MAXN];int visit[MAXN];int ans=0;void prim(int v) &#123; memset(visit,0,sizeof(visit)); visit[v]=1; int k=v; for(int i=0;i&lt;mp[k].size();i++) &#123; Node tmp=mp[k][i]; if(!visit[tmp.x]) qu.push(Node(tmp.x,tmp.cost)); &#125; while(!qu.empty()) &#123; Node tmp=qu.top(); qu.pop(); if(visit[tmp.x]) continue; ans+=tmp.cost; k=tmp.x; visit[k]=1; for(int i=0;i&lt;mp[k].size();i++) &#123; tmp=mp[k][i]; if(!visit[tmp.x]) qu.push(Node(tmp.x,tmp.cost)); &#125; &#125;&#125; 较小数据量时12345678910111213141516171819202122232425262728293031323334353637const int inf=1000000;const int MAXN=500+5;struct Node&#123; int x,y,cost; Node(int x,int y,int cost):x(x),y(y),cost(cost)&#123;&#125; friend bool operator &lt; (const Node &amp;a,const Node &amp;b) &#123;return a.cost&gt;b.cost;&#125;&#125;;int ans=0; int n,m;int mp[MAXN][MAXN];priority_queue&lt;Node&gt; qu;int visit[MAXN*MAXN];void prim(int v) &#123; memset(visit,0,sizeof(visit)); while(!qu.empty())qu.pop(); visit[v]=1; int k=v; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=n;j++) if(!visit[j]) qu.push(Node(i,j,mp[k][j])); while(!qu.empty()&amp;&amp;visit[qu.top().y]) qu.pop(); if(qu.empty()) break; Node now=qu.top(); ans+=now.cost; k=now.y; visit[k]=1; qu.pop(); &#125; &#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>堆优化prim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[int，long，long long范围]]></title>
    <url>%2F2019%2F09%2F12%2F%E6%A8%A1%E6%9D%BF%2Flong%20long%E8%8C%83%E5%9B%B4%2F</url>
    <content type="text"><![CDATA[原文地址：ACM博客_kuangbin unsigned int 0～4294967295 int 2147483648～2147483647 unsigned long 0～4294967295 long 2147483648～2147483647 long long的最大值：9223372036854775807 long long的最小值：-9223372036854775808 unsigned long long的最大值：18446744073709551615 __int64的最大值：9223372036854775807 __int64的最小值：-9223372036854775808 unsigned __int64的最大值：18446744073709551615]]></content>
  </entry>
  <entry>
    <title><![CDATA[银行排队]]></title>
    <url>%2F2019%2F09%2F12%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E9%93%B6%E8%A1%8C%E6%8E%92%E9%98%9F%2F</url>
    <content type="text"><![CDATA[数据结构，化腐朽为神奇的力量 问题描述3970: 银行排队时间限制: 1 Sec 内存限制: 32 MB提交: 5 解决: 5题目描述我们大多都有在银行排队的经历，唉，那坑爹的排队啊！现在就让我们来算算我们这些客户平均需要等多久吧。每天刚开始时银行会开m个窗口来为我们total个客户办理业务，当有客户需要办理业务时，先选择可以办理业务的窗口，如果有多个窗口可以办理业务就选择空闲时间最长的窗口，如果有多个窗口空闲的时间一样长，则选择序号小的窗口办理业务。假设我们每个人来到的时间和办理业务所需要的时间（为了简化问题，采用整数表示时间）都知道了。现在请你算算我们平均需要等待多久呢？ 输入有多组测试数据，每组数据开始有两个正整数m(&lt;20)和total(&lt;200)，后面有total对整数，对应客户先后到来的时间以及办理业务所需的时间。 输出平均等待的时间，保留两位小数。 样例输入1232 6 1 3 4 1 5 3 9 2 13 4 13 33 14 0 3 2 2 2 4 5 4 7 2 11 3 12 3 12 4 12 1 13 3 15 4 19 1 22 3 23 22 5 0 6 0 5 0 6 7 1 7 2 样例输出1230.000.291.20 题解利用数组来模拟队列，序号从小到大每一个数组元素表示一个窗口。首先分析一个人处理业务后的时间，假设只有一个窗口。来到的时间：x1；办理业务的时间为y1；那么这个窗口在x1+y1时间后才能被下一个人使用，即此人的离开时间 ；如果另一个人（来到时间x2，办理业务时间y2）在[x1,y1]时间段内到达，就意味着他必须等待的时间为y1-x2。 可分为两种情况：1、后者[x1,y1]的到达时间比前者[x2,y2]的离开时间晚。这个窗口的可使用时间为x1+y1；2、后者[x1,y1]来了，前者[x2,y2]还未离开。先记下这个窗口的编号，再遍历所有的窗口，若有窗口空闲，则取办理业务。否则，找到最早离开的人所在的窗口，计算等待时间，即为y1-x2。 代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt; const int MAXSIZE = 20; //定义10*10的矩阵大小using namespace std; double run(int m, int total) &#123; int countTime = 0; int a, b; int num[MAXSIZE] = &#123; 0 &#125;; while (total--) &#123; cin &gt;&gt; a &gt;&gt; b; int min = 0; int minTime = 1000; for (int i = 1; i &lt;= m; i++) &#123; if (a &gt;= num[i]) &#123; num[i] = a + b; min = 0; minTime = 1000; break; &#125; if (a &lt; num[i]&amp;&amp;minTime&gt;num[i]) &#123; min = i; minTime = num[i]; &#125; &#125; if (min != 0) &#123; countTime = countTime + num[min] - a; num[min] = num[min] + b; &#125; &#125; return countTime;&#125;int main()&#123; int m, total; while (cin &gt;&gt; m &gt;&gt; total) &#123; double countTime = run(m, total); printf(&quot;%.2lf\n&quot;, countTime/(1.0*total)); &#125; return 0;&#125; 关于 cout 浮点数输出头文件1#include&lt;iomanip&gt; 输出格式1cout&lt;&lt;setprecision(2)&lt;&lt;x&lt;&lt;endl;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>模拟队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迷宫求解]]></title>
    <url>%2F2019%2F09%2F12%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E8%BF%B7%E5%AE%AB%E6%B1%82%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[想不到迷宫求解还困惑我这么久久久？搞清楚了吧？做下笔记防止遗忘？去补点题？let’s go! 一、问题描述给定一个10*10的迷宫图，求一条从指定路口到指定出口的路径。在这里可以定义一个二维数组，用0来代表迷宫路径可走，用1代表路径不可走。迷宫问题可以用两种数据结构来解决（我暂时只会两种，囧rz），分别为栈、队列。栈只能简单地求出从指定路口到制定出口的路径，也就是说并不能考虑路径长短问题；而用队列来求解的话，可以求出一条最短路径。 二、栈实现1、解决方案说实话，不喜欢用栈来求解，耗时耗力还得不到最优解。就这样吧。从指定路口开始，将指定入口入栈。然后查找与栈头相邻且可走的路口。需要说明是首先要制定一个选择路口的方案，不然计算机怎么知道往哪走呢？我选择的是顺时针查看，即先查看上再右其次下最后左方。若找到，则将其入栈，在这里有一个非常关键的地方，就是需要记住处于栈头相对于前一个路口的方位值，所谓方位值，简单来讲，用0代表上，1代表右，2代表下，3代表左。接着再次查找相邻可走路口。为避免查找到的路口是已经走过的，在设计程序的时候，每一个路口入栈后，都将该路口的状态改变，比如，前面用0代表路径可走，那么可以设置入栈的入口状态值为-1，为区分起始条件不可走的状态值1。若没有找到，也就是说处于当前路口时，上下左右都不可走，不要怕，退一步。退一步就是退回到上一路口。那么整个栈中的元素就是从入口到出口的迷宫路径了。如此直到找到出口，若没有出口，就。。。 2、代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define MAXSIZE 10000int mg[10][10]=&#123; //迷宫数组 &#123;1,1,1,1,1,1,1,1,1,1&#125;, &#123;1,0,0,1,0,0,0,1,0,1&#125;, &#123;1,0,0,1,0,0,0,1,0,1&#125;, &#123;1,0,0,0,0,1,1,0,0,1&#125;, &#123;1,0,1,1,1,0,0,0,0,1&#125;, &#123;1,0,0,0,1,0,0,0,0,1&#125;, &#123;1,0,1,0,0,0,1,0,0,1&#125;, &#123;1,0,1,1,1,0,1,1,0,1&#125;, &#123;1,1,0,0,0,0,0,0,0,1&#125;, &#123;1,1,1,1,1,1,1,1,1,1&#125; &#125;;struct Box&#123; int i; int j; int di; //表示方位值&#125;;struct Type&#123; struct Box data[MAXSIZE]; int top;&#125;;bool findRode(int m,int n,int it,int yt);int main()&#123; if(findRode(1,1,8,8)==false) printf(&quot;failed\n&quot;); return 0;&#125;bool findRode(int m,int n,int it,int yt)&#123; int i,j,di,k=0; Box e; struct Type *stack; stack=(struct Type *)malloc(sizeof(struct Type)); stack-&gt;top=-1; e.i=m;e.j=n;e.di=0; stack-&gt;top++; //将第一个路口入栈 stack-&gt;data[stack-&gt;top]=e; mg[e.i][e.j]=-1; while(stack-&gt;top!=-1)&#123; e=stack-&gt;data[stack-&gt;top]; i=e.i;j=e.j;k=e.di; if(i==it&amp;&amp;j==yt)&#123; while(stack-&gt;top!=-1)&#123; e=stack-&gt;data[stack-&gt;top]; printf(&quot;(%d,%d) &quot;,e.i,e.j); mg[e.i][e.j]=0; stack-&gt;top--; &#125; free(stack); return true; &#125; bool find=false; while(k&lt;4&amp;&amp;find!=true)&#123; k++; switch(k)&#123; case 0: i=e.i-1;j=e.j;break; case 1: i=e.i;j=e.j+1;break; case 2: i=e.i+1;j=e.j;break; case 3: i=e.i;j=e.j-1;break; &#125; if(mg[i][j]==0) find=true; &#125; if(k&lt;4)&#123; stack-&gt;data[stack-&gt;top].di=k; e.i=i;e.j=j;e.di=-1; stack-&gt;top++; stack-&gt;data[stack-&gt;top]=e; mg[i][j]=-1; &#125;else&#123; //如果当前路口没有相邻可走且不是出口，则退栈回到上一路口 stack-&gt;top--; mg[e.i][e.j]=0; //将该路口状态值重置，表示可走 &#125; &#125; free(stack); return false;&#125; 三、队列实现1、解决方案为什么说用队列来解可以求得最短路径呢？与栈不同的是，队列在查看相邻可走路口时，是将全部相邻可走路口进队；首先将入口进队，队列中就记录下该路口的信息了。将队首元素出队，（注意此时队伍中还记录有路口的信息），以该路口为中心查看相邻路口，使全部相邻可走路口记下该路口在队列中的位置，然后将它们进队。比如起点为A，进队。此时队列为A-&gt;NULL；此时A在队列中的位置就是0（记0是开始），出队，B、C、D是A的相邻可走路口，则B、C、D的前导值就是0，通过查询前导值，就可以清楚地知道A的位置（说明下，第一个路口的前导值记为-1）。此时队列为a-&gt;B-&gt;C-&gt;D-&gt;NULL；（A已出队，但A的信息保留着，所以用a代替）注意队首为B（B在队列中的位置是1），然后将B出队，执行与出队A类似的步骤。直到找到出口。找到出口后，那么通过出口的前导值可以知道它前面的路口（记为M）在哪（将M在队列中的状态值记为-1，后面皆是如此），通过M的前导值又可以知道M前面的路口在哪，直到与入口联系起来。从队首信息开始扫描整个队列，若队列中的元素的状态值为-1，则将该元素记录的坐标输出。求解完成。 2、代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define MAXSIZE 10000#define LEN sizeof(struct Type )int mg[10][10]=&#123; &#123;1,1,1,1,1,1,1,1,1,1&#125;, &#123;1,0,0,1,0,0,0,1,0,1&#125;, &#123;1,0,0,1,0,0,0,1,0,1&#125;, &#123;1,0,0,0,0,1,1,0,0,1&#125;, &#123;1,0,1,1,1,0,0,0,0,1&#125;, &#123;1,0,0,0,1,0,0,0,0,1&#125;, &#123;1,0,1,0,0,0,1,0,0,1&#125;, &#123;1,0,1,1,1,0,1,1,0,1&#125;, &#123;1,1,0,0,0,0,0,0,0,1&#125;, &#123;1,1,1,1,1,1,1,1,1,1&#125; &#125;;struct Box&#123; int i; int j; int pre;//记录上一路口的前导值,所谓前导值，就是可走路口在队列中的位置&#125;;struct Type&#123; struct Box data[MAXSIZE]; int front,rear;&#125;;bool findRoad(int m,int n,int it,int yt);int main()&#123; if(findRoad(1,1,8,8)==false) printf(&quot;failed\n&quot;); return 0;&#125;bool findRoad(int m,int n,int it,int yt)&#123; int i,j; Box e; struct Type *queue; queue=(struct Type *)malloc(LEN); e.i=m;e.j=n;e.pre=-1; queue-&gt;front=queue-&gt;rear=-1; queue-&gt;rear++; queue-&gt;data[queue-&gt;rear]=e; mg[e.i][e.j]=-1; while(queue-&gt;rear!=queue-&gt;front)&#123; queue-&gt;front++; e=queue-&gt;data[queue-&gt;front]; i=e.i;j=e.j; if(i==it&amp;&amp;j==yt)&#123; int temp=queue-&gt;front; int num=0; while(temp!=0)&#123; num=queue-&gt;data[temp].pre; queue-&gt;data[temp].pre=-1; temp=num; &#125; temp=0; int count=1; while(temp&lt;=queue-&gt;rear)&#123; if(queue-&gt;data[temp].pre==-1)&#123; printf(&quot;(%d,%d)&quot;,queue-&gt;data[temp].i,queue-&gt;data[temp].j); if(count%5==0) printf(&quot;\n&quot;); count++; &#125; temp++; &#125; return true; &#125; int x,y; int k=0; while(k&lt;4)&#123; switch(k)&#123; case 0: x=i-1;y=j;break; case 1: x=i;y=j+1;break; case 2: x=i+1;y=j;break; case 3: x=i;y=j-1;break; &#125; k++; if(mg[x][y]==0)&#123; /*只要该路口可走，就将其进队 *并且记录上一路口的前导值 */ queue-&gt;rear++; e.i=x;e.j=y;e.pre=queue-&gt;front; queue-&gt;data[queue-&gt;rear]=e; mg[i][j]=-1; &#125; &#125; &#125; return false;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迷宫城堡 HDU - 1269]]></title>
    <url>%2F2019%2F09%2F12%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E8%BF%B7%E5%AE%AB%E5%9F%8E%E5%A0%A1%20HDU%20-%201269%20%2F</url>
    <content type="text"><![CDATA[题目为了训练小希的方向感，Gardon建立了一座大城堡，里面有N个房间(N&lt;=10000)和M条通道(M&lt;=100000)，每个通道都是单向的，就是说若称某通道连通了A房间和B房间，只说明可以通过这个通道由A房间到达B房间，但并不说明通过它可以由B房间到达A房间。Gardon需要请你写个程序确认一下是否任意两个房间都是相互连通的，即：对于任意的i和j，至少存在一条路径可以从房间i到房间j，也存在一条路径可以从房间j到房间i。Input输入包含多组数据，输入的第一行有两个数：N和M，接下来的M行每行有两个数a和b，表示了一条通道可以从A房间来到B房间。文件最后以两个0结束。Output对于输入的每组数据，如果任意两个房间都是相互连接的，输出”Yes”，否则输出”No”。Sample Input1234567893 31 22 33 13 31 22 33 20 0 Sample Output12YesNo 思路用vector来表示邻接表，对每个元素深搜一遍。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;vector&gt;using namespace std;const int MAXSIZE=10000+5;vector&lt;int &gt; edge[MAXSIZE];int visit[MAXSIZE];void DFS(int count)&#123; visit[count]=1; for(int i=0;i&lt;int(edge[count].size());i++)&#123; int x=edge[count][i]; if(visit[x]==0) DFS(x); &#125;&#125;int main()&#123; int N,M; while(cin&gt;&gt;N&gt;&gt;M)&#123; if(N==0&amp;&amp;M==0) break; for(int i=1;i&lt;=N;i++) edge[i].clear(); for(int i=1;i&lt;=M;i++)&#123; int a,b; cin&gt;&gt;a&gt;&gt;b; edge[a].push_back(b); &#125; int flag=1; for(int i=1;i&lt;=N;i++)&#123; memset(visit,0,sizeof(visit)); DFS(i); for(int j=1;j&lt;=N;j++) if(visit[j]==0)&#123; flag=0; break; &#125; if(flag==0) break; &#125; if(flag==0) cout&lt;&lt;&quot;No&quot;; else cout&lt;&lt;&quot;Yes&quot;; cout&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[走迷宫（迷宫问题补题）]]></title>
    <url>%2F2019%2F09%2F12%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E8%B5%B0%E8%BF%B7%E5%AE%AB%2F</url>
    <content type="text"><![CDATA[一、题目描述 一个迷宫由R行C列格子组成，有的格子里有障碍物，不能走；有的格子是空地，可以走。给定一个迷宫，求从左上角走到右下角最少需要走多少步(数据保证一定能走到)。只能在水平方向或垂直方向走，不能斜着走。Input第一行是两个整数，Ｒ和Ｃ，代表迷宫的长和宽。（ 1&lt;= R，C &lt;= 40)接下来是Ｒ行，每行Ｃ个字符，代表整个迷宫。 空地格子用’.’表示，有障碍物的格子用’#’表示。迷宫左上角和右下角都是’.’。Output输出从左上角走到右下角至少要经过多少步（即至少要经过多少个空地格子）。计算步数要包括起点和终点。 样列输入1234565 5..####....#.#.##.#.##.#.. 样列输出19 二、题解本题方法跟前一篇写的《迷宫求解》队列实现方法一致，传送门需要注意的是二维字符数组的输入问题，可以单个字符的输入，但这就要考虑回车键对数组的影响；而采用字符串形式输入则不会有这个问题，具体见代码。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt;const int MAXSIZE=10000+10;struct Box&#123; int i; int j; int pre;&#125;;struct Type&#123; struct Box data[MAXSIZE]; int front,rear;&#125;;const int LEN=sizeof(struct Type);int findRoad(int a,int b,int c,int d,char mg[42][42]);int main()&#123; char mg[42][42],mgtemp[42][42]; int N,M; scanf(&quot;%d%d&quot;,&amp;N,&amp;M); for(int i=1;i&lt;=N;i++)&#123; scanf(&quot;%s&quot;,mgtemp[i]); //采用临时数组，注意列行从0开始而不是需要的从1开始 &#125; for(int i=1;i&lt;=N;i++)&#123; int t=1; for(int j=0;j&lt;M;j++) mg[i][t++]=mgtemp[i][j];//用此转换 &#125; int ans=findRoad(1,1,N,M,mg); printf(&quot;%d\n&quot;,ans); return 0; &#125; int findRoad(int a,int b,int c,int d,char mg[42][42])&#123; Box e; struct Type *queue; queue=(struct Type *)malloc(LEN); queue-&gt;front=queue-&gt;rear=-1; int i,j; e.i=a;e.j=b;e.pre=-1; mg[a][b]=&apos;/&apos;; queue-&gt;rear++; queue-&gt;data[queue-&gt;rear]=e; while(queue-&gt;rear!=queue-&gt;front)&#123; queue-&gt;front++; e=queue-&gt;data[queue-&gt;front]; i=e.i;j=e.j; if(i==c&amp;&amp;j==d)&#123; int temp=queue-&gt;front; while(temp!=0)&#123; int num=queue-&gt;data[temp].pre; queue-&gt;data[temp].pre=-1; temp=num; &#125; temp=0; int count=0; while(temp&lt;=queue-&gt;front)&#123; if(queue-&gt;data[temp].pre==-1) count++; temp++; &#125; return count; &#125; int x,y; for(int k=0;k&lt;4;k++)&#123; switch(k)&#123; case 0: x=i-1;y=j;break; case 1: x=i;y=j+1;break; case 2: x=i+1;y=j;break; case 3: x=i;y=j-1;break; &#125; if(mg[x][y]==&apos;.&apos;)&#123; e.i=x;e.j=y;e.pre=queue-&gt;front; queue-&gt;rear++; queue-&gt;data[queue-&gt;rear]=e; mg[x][y]=&apos;/&apos;; &#125; &#125; &#125;&#125; 继续补题ing…]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[确定比赛名次 HDU - 1285（拓扑）]]></title>
    <url>%2F2019%2F09%2F12%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E7%A1%AE%E5%AE%9A%E6%AF%94%E8%B5%9B%E5%90%8D%E6%AC%A1%20HDU%20-%201285%EF%BC%88%E6%8B%93%E6%89%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目有N个比赛队（1&lt;=N&lt;=500），编号依次为1，2，3，。。。。，N进行比赛，比赛结束后，裁判委员会要将所有参赛队伍从前往后依次排名，但现在裁判委员会不能直接获得每个队的比赛成绩，只知道每场比赛的结果，即P1赢P2，用P1，P2表示，排名时P1在P2之前。现在请你编程序确定排名。Input输入有若干组，每组中的第一行为二个数N（1&lt;=N&lt;=500），M；其中N表示队伍的个数，M表示接着有M行的输入数据。接下来的M行数据中，每行也有两个整数P1，P2表示即P1队赢了P2队。Output给出一个符合要求的排名。输出时队伍号之间有空格，最后一名后面没有空格。 其他说明：符合条件的排名可能不是唯一的，此时要求输出时编号小的队伍在前；输入数据保证是正确的，即输入数据确保一定能有一个符合要求的排名。Sample Input12344 31 22 34 3 Sample Output11 2 4 3 思路priority_queue&lt;int,vector&lt; int&gt;,greater&lt; int&gt; &gt; qu;优先队列使用。用优先队列记录出度为0的点。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;stack&gt;#include&lt;queue&gt;using namespace std;const int MAXSIZE=500+5;struct node&#123; int value; struct node *next;&#125;; struct list&#123; int count; node *first;&#125;;struct Graph&#123; struct list arr[MAXSIZE];&#125;;void topsort(struct Graph *&amp;G,int N)&#123; priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; qu; for(int i=1;i&lt;=N;i++) if(G-&gt;arr[i].count==0) qu.push(i); int num=1; while(!qu.empty())&#123; int x=qu.top(); qu.pop(); if(num!=N)&#123; cout&lt;&lt;x&lt;&lt;&apos; &apos;; num++; &#125; else cout&lt;&lt;x&lt;&lt;endl; struct node *p; p=G-&gt;arr[x].first; while(p!=NULL)&#123; G-&gt;arr[p-&gt;value].count--; if(G-&gt;arr[p-&gt;value].count==0) qu.push(p-&gt;value); p=p-&gt;next; &#125; &#125;&#125;int main()&#123; int N,M; while(cin&gt;&gt;N&gt;&gt;M)&#123; struct Graph *G=(struct Graph *)malloc(sizeof(struct Graph)); for(int i=1;i&lt;=N;i++)&#123; G-&gt;arr[i].first=NULL; G-&gt;arr[i].count=0; &#125; for(int i=0;i&lt;M;i++)&#123; int a,b; cin&gt;&gt;a&gt;&gt;b; struct node *p=(struct node *)malloc(sizeof(struct node)); p-&gt;value=b; p-&gt;next=G-&gt;arr[a].first; G-&gt;arr[a].first=p; G-&gt;arr[b].count++; &#125; topsort(G,N); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[火车调度（栈）]]></title>
    <url>%2F2019%2F09%2F12%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E7%81%AB%E8%BD%A6%E8%B0%83%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[一、题目描述 火车调度传送门 Description 有一条东西方向的铁路穿过小城A，小城A有一个火车调度站，示意图如下：现在有N列火车自东向西依次开过来了，按照到达的先后次序编号为0号到N-1号。 根据调度局的要求，小城A的调度站要改变这些列车驶离A城的顺序。 为了达到这一目的， 调度站在任意时刻可以执行以下三种操作之一：1、如果调度站还有剩余空间，则可以令下一列开来的火车进入调度站；2、如果调度站内有列车，则可以令调度站最前方的火车离开调度站并驶离A城；3、可以命令下一列开来的火车不经过调度站而直接驶离A城。不过小城A的调度站实在太小了，只能容纳M列火车，请帮忙确认调度站能否完成任务。 例子如果有4列火车开来，调度站可以容纳2列火车，调度局要求火车按照2、1、3、0的顺序驶离A城，则此任务可满足，一种可能的方案如下：Step 1：火车0进入调度站；Step 2：火车1进入调度站；Step 3：火车2不经过调度站驶离A城；Step 4：火车1从调度站驶离A城；Step 5：火车3不经过调度站驶离A城；当然，你只需要回答是否可行，不需要列出一种可行方案。 Input Format 第一行是一个正整数T，表示本测试数据有多少个独立的测试点。（ T≤300 ）之后有T个独立的测试点，每个测试点占两行。 第一行有两个数字N和M，分别表示开来的火车数量，以及调度站最多可容纳的火车数量，两个数字之间用一个空格隔开。 第二行有N个整数，他们都在0到N−1之间，且不重复，用空格隔开，表示火车驶离A城的次序。N是正整数，且N≤1000；M是非负整数，且M≤1000。 M可能为0（这也许说明调度站的工作人员罢工了，或者正在这个考场考试）。 Output Format 输出共T行，每行对应一个测试点。如果能够调度，则回答YES，否则回答NO。 输出请注意大小写，每行行末直接回车，不要有其他字符。 Sample Input1234524 22 1 3 05 22 4 3 1 0 Sample Output12YESNO 二、题解一步步模拟即可，例子说的很明白。现在假如从山那边开来0，1，2，3······M-1，M列火车。从出站次序数组零号元素开始模拟，如果当前数组元素恰好等于开来的火车序号，说明此时火车可直接开过去，否则将开来的火车送入调度站。如果调度站满了，但开来的火车还不等于当前数组元素，就无解了，输出NO。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt; #define MAXSIZE 1000+100struct Stack&#123; int num[MAXSIZE]; int top; &#125;;int main()&#123; int Case; scanf(&quot;%d&quot;,&amp;Case); while(Case--)&#123; int N,M; int val[MAXSIZE]; scanf(&quot;%d%d&quot;,&amp;N,&amp;M); for(int i=0;i&lt;N;i++) scanf(&quot;%d&quot;,&amp;val[i]); struct Stack stack; stack.top=-1; int number=0; int flag=1; for(int i=0;i&lt;N;)&#123; if(val[i]==number)&#123; i++; number++; continue; &#125; if(val[i]==stack.num[stack.top])&#123; i++; stack.top--; continue; &#125; if(val[i]!=number)&#123; stack.top++; stack.num[stack.top]=number; number++; &#125; if(stack.top==M)&#123; flag=0; break; &#125; &#125; if(flag==1) printf(&quot;YES\n&quot;); else printf(&quot;NO\n&quot;); &#125; return 0;&#125; 继续补题…]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《数据结构 李春葆版》课后练习题二（线性表）]]></title>
    <url>%2F2019%2F09%2F12%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0%E9%A2%98%E4%BA%8C%E7%BA%BF%E6%80%A7%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[数据结构课程，做作业，打代码。头昏脑涨时写写这些题目，算是把学过的再重新温习一遍？再复习一遍？不过再写这些题目的时候还真有些地方有点感悟，做OJ上得题，通常会有时间限制，代码不够优化题目测试数据又庞大无比就必定超时。而这些题目呢？一直说要优化，却没有配套的数据来检测，写出来谁知道是不是够优化了。况且题目又只要写函数，这样一来，写的函数不放在完整的程序里跑一遍谁知道是不会出现编译错误（doge~）。好了，就这样吧，就当放松下得得得啊。题目就不抄了，太过练习打码熟练度的题目也不写了。 一、练习题二第六题原地算法了解一下123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;#include&lt;cstdlib&gt;using namespace std;#define MAXSIZE 1000struct List&#123; int data[MAXSIZE]; int length;&#125;;void fun6(struct List *&amp;L,int x,int y);int main()&#123; struct List *L; L=(struct List *)malloc(sizeof(struct List)); for(int i=0;i&lt;9;i++) cin&gt;&gt;L-&gt;data[i]; L-&gt;length=10; fun6(L,4,8); for(int i=0;i&lt;L-&gt;length;i++) cout&lt;&lt;L-&gt;data[i]&lt;&lt;&apos; &apos;; return 0;&#125;/*第六题*/void fun6(struct List *&amp;L,int x,int y)&#123; int j=0; for(int i=0;i&lt;L-&gt;length;i++)&#123; if(L-&gt;data[i]&lt;x||L-&gt;data[i]&gt;y)&#123; L-&gt;data[j]=L-&gt;data[i]; j++; &#125; &#125; L-&gt;length=j-1;&#125;/*测试数据*//*1、1 2 4 6 7 8 9 5 4 1 2 92、2 3 2 4 6 2 7 1 5 2 3 2 2 1*/ 第七题123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;#include&lt;cstdlib&gt;using namespace std;#define MAXSIZE 1000struct List&#123; int data[MAXSIZE]; int length;&#125;;void fun7(struct List *&amp;L,int x);int main()&#123; struct List *L; L=(struct List *)malloc(sizeof(struct List)); for(int i=0;i&lt;9;i++) cin&gt;&gt;L-&gt;data[i]; L-&gt;length=9; fun7(L,4); for(int i=0;i&lt;L-&gt;length;i++) cout&lt;&lt;L-&gt;data[i]&lt;&lt;&apos; &apos;; return 0;&#125;void fun7(struct List *&amp;L,int x)&#123; int i=0; for(i=0;i&lt;L-&gt;length;i++) if(x&lt;L-&gt;data[i]) break; for(int j=L-&gt;length-1;j&gt;=i;j--) L-&gt;data[j+1]=L-&gt;data[j]; L-&gt;data[i]=x; L-&gt;length++;&#125; /*测试数据*//*1、1 2 3 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10*/ 第八题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;#include&lt;cstdlib&gt;using namespace std;#define MAXSIZE 1000#define true1 L-&gt;data[j]&gt;0&amp;&amp;L-&gt;data[i]&lt;0 #define true2 L-&gt;data[j]&lt;0&amp;&amp;L-&gt;data[i]&gt;0struct List&#123; int data[MAXSIZE]; int length;&#125;;void fun8(struct List *&amp;L);void swap(int &amp;a,int &amp;b);int main()&#123; struct List *L; L=(struct List *)malloc(sizeof(struct List)); for(int i=0;i&lt;9;i++) cin&gt;&gt;L-&gt;data[i]; L-&gt;length=9; fun8(L); for(int i=0;i&lt;L-&gt;length;i++) cout&lt;&lt;L-&gt;data[i]&lt;&lt;&apos; &apos;; return 0;&#125;void fun8(struct List *&amp;L)&#123; int j=0; for(int i=1;i&lt;L-&gt;length;i++)&#123; if(true1)&#123; swap(L-&gt;data[j],L-&gt;data[i]); j++; &#125; if(true2) j++; &#125;&#125; void swap(int &amp;a,int &amp;b)&#123; int temp=a; a=b; b=temp;&#125;/*测试数据*/ /*1、-1 2 -2 3 -4 5 -6 7 -8 -1 -2 -4 -6 -8 5 3 7 22、1 -2 -3 1 -1 2 3 -2 -7 -2 -3 -1 -2 -7 2 3 1 1*/ 第十题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;#include&lt;cstdlib&gt;using namespace std;struct List&#123; int num; struct List *next,*pre;&#125;;void creat(struct List *&amp;L);void fun10(struct List *&amp;L);int main()&#123; struct List *L,*p,*p1; L=(struct List *)malloc(sizeof(struct List)); creat(L); fun10(L); p=L-&gt;next; while(p!=NULL)&#123; cout&lt;&lt;p-&gt;num&lt;&lt;&apos; &apos;; p1=p; //p1为验证双链表专用指针 p=p-&gt;next; &#125; /*验证双链表*/ cout&lt;&lt;endl&lt;&lt;&quot;验证双链表&quot;&lt;&lt;endl; while(p1!=L)&#123; cout&lt;&lt;p1-&gt;num&lt;&lt;&apos; &apos;; p1=p1-&gt;pre; &#125; return 0;&#125;void fun10(struct List *&amp;L)&#123; struct List *p1,*p2,*p3; p1=L; for(int i=0;i&lt;2;i++)&#123; p2=p1; p1=p1-&gt;next; &#125; p3=p1-&gt;next; p1-&gt;next=p3-&gt;next; p3-&gt;next=p1; p2-&gt;next=p3; p3-&gt;pre=p2; p1-&gt;next-&gt;pre=p1; p1-&gt;pre=p3; &#125;void creat(struct List *&amp;L)&#123; struct List *p1,*p2; p2=L; for(int i=0;i&lt;5;i++)&#123; p1=(struct List *)malloc(sizeof(struct List)); scanf(&quot;%d&quot;,&amp;p1-&gt;num); p2-&gt;next=p1; p1-&gt;pre=p2; p2=p1; &#125; p2-&gt;next=NULL;&#125;/*测试数据 选择第二个数与第三个数交换*//*1、1 2 3 4 5 1 3 2 4 52、3 4 5 6 3 3 5 4 6 3 */ 第十一题快慢指针了解下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;bits/stdc++.h&gt; #include&lt;cstdlib&gt;using namespace std;#define ture truestruct List&#123; int num; struct List *next;&#125;;void creat(struct List *&amp;L);bool sertchone(struct List *&amp;L,int x);bool sertchtwo(struct List *&amp;L,int x);bool sertchthree(struct List *&amp;L,int x);int main()&#123; struct List *L; L=(struct List *)malloc(sizeof(struct List)); creat(L); bool result1=sertchone(L,2); if(result1) cout&lt;&lt;&quot;true&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;false&quot;&lt;&lt;endl; bool result2=sertchtwo(L,2); if(result2) cout&lt;&lt;&quot;true&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;false&quot;&lt;&lt;endl; bool result3=sertchthree(L,2); if(result3) cout&lt;&lt;&quot;true&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;false&quot;&lt;&lt;endl; return 0;&#125;void creat(struct List *&amp;L)&#123; struct List *p1,*p2; p2=L; for(int i=0;i&lt;5;i++)&#123; p1=(struct List *)malloc(sizeof(struct List)); //scanf(&quot;%d&quot;,&amp;p1-&gt;num); cin&gt;&gt;p1-&gt;num; p2-&gt;next=p1; p2=p1; &#125; p2-&gt;next=NULL;&#125;bool sertchone(struct List *&amp;L,int x)//无序查找，遍历链表，时间复杂度为O(n) &#123; struct List *p=L; while(p!=NULL)&#123; if(p-&gt;num==x) return true; p=p-&gt;next; &#125; return false; &#125;bool sertchtwo(struct List *&amp;L,int x)//递增有序 ,快指针，时间复杂度为O(n/2); &#123; struct List *p1,*p2; p1=p2=L; while(p2-&gt;next-&gt;next!=NULL)&#123; if(p2-&gt;next-&gt;next-&gt;num&lt;=x)&#123; p2=p2-&gt;next-&gt;next; &#125; else&#123; p2=p2-&gt;next; &#125; if(p2-&gt;num==x) return true; &#125; return false; &#125;bool sertchthree(struct List *&amp;L,int x)//递减有序 快指针，时间复杂度为O(n/2); &#123; struct List *p1,*p2; p1=p2=L; while(p2-&gt;next-&gt;next!=NULL)&#123; if(p2-&gt;next-&gt;next-&gt;num&gt;=x)&#123; p2=p2-&gt;next-&gt;next; &#125; else&#123; p2=p2-&gt;next; &#125; if(p2-&gt;num==x) return true; &#125; return false;&#125; 第十二题链表逆转，比较有趣12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;#include&lt;cstdlib&gt;using namespace std;struct List&#123; int num; struct List *next;&#125;;void creat(struct List *&amp;L);void reverse(struct List *&amp;L); int main()&#123; struct List *L,*p; L=(struct List *)malloc(sizeof(struct List)); creat(L); reverse(L); p=L; while(p!=NULL)&#123; cout&lt;&lt;p-&gt;num&lt;&lt;&apos; &apos;; p=p-&gt;next; &#125; return 0;&#125;void creat(struct List *&amp;L)&#123; struct List *p1,*p2; p2=L; for(int i=0;i&lt;5;i++)&#123; p1=(struct List *)malloc(sizeof(struct List)); cin&gt;&gt;p1-&gt;num; if(i==0) L=p2=p1; else p2-&gt;next=p1; p2=p1; &#125; p2-&gt;next=NULL;&#125;void reverse(struct List *&amp;L)&#123; struct List *head,*p1,*p2; p1=p2=L; while(p1-&gt;next!=NULL) p1=p1-&gt;next; head=L; while(head!=p1)&#123; head=head-&gt;next; p2-&gt;next=p1-&gt;next; p1-&gt;next=p2; p2=head; &#125; L=head;&#125;/*测试数据*//*1、1 2 3 4 5 5 4 3 2 1*/ 第十三题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;#include&lt;cstdlib&gt;using namespace std;struct List&#123; int num; struct List *next;&#125;;void creat(struct List *&amp;L);int seartch(struct List *&amp;L);int main()&#123; struct List *L; L=(struct List *)malloc(sizeof(struct List)); creat(L); int result=seartch(L); cout&lt;&lt;result&lt;&lt;endl; return 0;&#125;void creat(struct List *&amp;L)&#123; struct List *p1,*p2; p2=L; for(int i=0;i&lt;7;i++)&#123; p1=(struct List *)malloc(sizeof(struct List)); cin&gt;&gt;p1-&gt;num; p2-&gt;next=p1; p2=p1; &#125; p2-&gt;next=NULL;&#125;int seartch(struct List *&amp;L)//利用快指针，时间复杂度降低&#123; struct List *p; p=L-&gt;next; int length=0; while(p!=NULL)&#123; length++; p=p-&gt;next; &#125; int count=1; p=L-&gt;next; int len; if(length%2==0) len=length/2; else len=length/2+1; while(count&lt;len)&#123; if(len-count&gt;=2)&#123; p=p-&gt;next-&gt;next; count+=2; &#125; else&#123; p=p-&gt;next; count++; &#125; &#125; return p-&gt;num;&#125;/*测试数据*//*1、1 2 3 4 5 6 7 8 42、1 2 3 4 5 6 7 4 */ 第十四题喵。题目看错了。下面代码错的。更新：遇到目前max时，在此值前面插入结点，同时用一个指针记下这个结点前面的位置，若在后面遍历过程中遇到比max还大，将前面插入的结点删去，同时插入结点记下位置。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;#include&lt;cstdlib&gt;#define MAXSIZE 100using namespace std;struct List&#123; int num; struct List *next;&#125;;void creat(struct List *&amp;L);void insert(struct List *&amp;L,int x); int main()&#123; struct List *L,*p; L=(struct List *)malloc(sizeof(struct List)); creat(L); insert(L,3); p=L-&gt;next; while(p!=NULL)&#123; cout&lt;&lt;p-&gt;num&lt;&lt;&apos; &apos;; p=p-&gt;next; &#125; return 0;&#125;void creat(struct List *&amp;L)&#123; struct List *p1,*p2; p2=L; for(int i=0;i&lt;7;i++)&#123; p1=(struct List *)malloc(sizeof(struct List)); cin&gt;&gt;p1-&gt;num; p2-&gt;next=p1; p2=p1; &#125; p2-&gt;next=NULL;&#125;void insert(struct List *&amp;L,int x)&#123; struct List *p1=L-&gt;next,*p2; int max=p1-&gt;num; while(p1!=NULL)&#123; if(max&lt;=p1-&gt;num)&#123; max=p1-&gt;num; &#125; p1=p1-&gt;next; &#125; p1=L; int flag=1; while(p1-&gt;next!=NULL)&#123; if(max==p1-&gt;next-&gt;num)&#123; p2=(struct List *)malloc(sizeof(struct List)); p2-&gt;num=x; p2-&gt;next=p1-&gt;next; p1-&gt;next=p2; flag=0; &#125; if(flag==1) p1=p1-&gt;next; else&#123; p1=p1-&gt;next-&gt;next; flag=1; &#125; &#125;&#125;/*测试数据*//*1、1 4 2 4 4 1 4 1 3 4 2 3 4 3 4 1 3 42、6 6 1 3 6 3 6 3 6 3 6 1 3 3 6 3 3 6 */ 第十五题空间复杂度满足了，但时间耗费好多，感觉这程序写的好蠢&lt;/\=/>12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;#include&lt;cstdio&gt;using namespace std;struct List&#123; int data; struct List *next;&#125;;void creat(struct List *&amp;L);void print(struct List *&amp;L);int main()&#123; struct List *L; L=(struct List *)malloc(sizeof(struct List)); creat(L); print(L); return 0;&#125; void creat(struct List *&amp;L)&#123; struct List *p1,*p2; p2=L; for(int i=0;i&lt;5;i++)&#123; p1=(struct List *)malloc(sizeof(struct List)); cin&gt;&gt;p1-&gt;data; p2-&gt;next=p1; p2=p1; &#125; p2-&gt;next=NULL;&#125;void print(struct List *&amp;L)&#123; struct List *p1,*p2; p1=L-&gt;next; while(L-&gt;next!=NULL)&#123; int max=p1-&gt;data; p2=L; while(p1-&gt;next!=NULL)&#123; if(max&lt;p1-&gt;next-&gt;data)&#123; p2=p1; max=p1-&gt;next-&gt;data; &#125; p1=p1-&gt;next; &#125; cout&lt;&lt;p2-&gt;next-&gt;data&lt;&lt;&apos; &apos;; p1=p2-&gt;next; p2-&gt;next=p1-&gt;next; free(p1); p1=L-&gt;next; &#125;&#125;/*测试数据*//*1、2 3 5 2 4 5 4 3 2 22、3 7 2 9 3 9 7 3 3 2 */ 第十七题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;#include&lt;cstdlib&gt;using namespace std;struct List&#123; int data; struct List *next;&#125;;struct List *creat();void unionList(struct List *&amp;ha,struct List *&amp;hb,struct List *&amp;hc);int main()&#123; struct List *ha,*hb,*hc,*p; ha=hb=hc=(struct List *)malloc(sizeof(struct List)); ha=creat(); hb=creat(); unionList(ha,hb,hc); p=hc-&gt;next; while(p!=hc)&#123; cout&lt;&lt;p-&gt;data&lt;&lt;&apos; &apos;; p=p-&gt;next; &#125; return 0;&#125;struct List *creat()&#123; struct List *p1,*p2,*L; L=(struct List *)malloc(sizeof(struct List)); p2=L; for(int i=0;i&lt;5;i++)&#123; p1=(struct List *)malloc(sizeof(struct List)); cin&gt;&gt;p1-&gt;data; p2-&gt;next=p1; p2=p1; &#125; p2-&gt;next=L; return L;&#125;void unionList(struct List *&amp;ha,struct List *&amp;hb,struct List *&amp;hc)&#123; struct List *p1,*p2; p1=hb-&gt;next; p2=ha-&gt;next; while(p1-&gt;next!=hb)&#123; p1=p1-&gt;next; &#125; while(p2-&gt;next!=ha)&#123; p2=p2-&gt;next; &#125; hc-&gt;next=ha-&gt;next; p2-&gt;next=hc; p2-&gt;next=hb-&gt;next; p1-&gt;next=hc;&#125;/*测试数据*//*1、1 2 3 4 5 2 3 4 5 6 1 2 3 4 5 2 3 4 5 6*/ 二、综合性实验实验题10单链表存储一元多项式，并实现两个多项式的相加运算123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include &lt;iostream&gt;#include&lt;malloc.h&gt;#define N 5using namespace std;struct List&#123; int x; //系数 int y; //指数 struct List *next; &#125;;struct List *creat(struct List *list)&#123; struct List *p1, *p2, *temp, *pre; p1 = pre = list; int flag = 1; for (int i = 0; i &lt; N; i++) &#123; temp = list-&gt;next; pre = list; p2 = (struct List *)malloc(sizeof(struct List)); cin &gt;&gt; p2-&gt;x &gt;&gt; p2-&gt;y; //使得多项式按照 指数大小 呈升序排列 if (flag == 1) &#123; p1-&gt;next = p2; p1 = p2; p1-&gt;next = NULL; &#125; else &#123; while (temp-&gt;next!= NULL &amp;&amp; temp-&gt;y &lt; p2-&gt;y) &#123; //p1 = temp; pre = temp; temp = temp-&gt;next; &#125; if (temp-&gt;y &lt; p2-&gt;y) &#123; p2-&gt;next = temp-&gt;next; temp-&gt;next = p2; &#125; else &#123; //p2-&gt;next = list-&gt;next; //list-&gt;next = p2; p2-&gt;next = temp; pre-&gt;next = p2; pre = pre-&gt;next; &#125; &#125; flag++; &#125; return list;&#125;struct List *AddPolynomial(struct List *list1, struct List *list2)&#123; //将相加后的结果保留在list1中 struct List *p1, *p2, *temp1, *temp2; p1 = list1-&gt;next; p2 = list2-&gt;next; //temp1,temp2用来指向p1,p2的前驱，便于操作 temp1 = list1; temp2 = list2; while (p1 != NULL &amp;&amp; p2 != NULL) &#123; if (p1-&gt;y == p2-&gt;y) &#123; p1-&gt;x += p2-&gt;x; if (p1-&gt;x != 0) &#123; temp1 = p1; temp2 = p2; p1 = p1-&gt;next; p2 = p2-&gt;next; &#125; else &#123; //若相加后p1的系数为0，则跳过p1并释放其内存 temp1-&gt;next = p1-&gt;next; free(p1); temp2 = p2; p1 = temp1-&gt;next; p2 = p2-&gt;next; &#125; &#125; else if (p1-&gt;y &lt; p2-&gt;y) &#123; //只需p1后移 temp1 = p1; p1 = p1-&gt;next; &#125; else if (p1-&gt;y &gt; p2-&gt;y) &#123; temp2-&gt;next = p2-&gt;next; //将p2插入temp1和p1中 p2-&gt;next = p1; temp1-&gt;next = p2; //p2指向下一个值，p1不变 p2 = temp2-&gt;next; &#125; &#125; return list1;&#125;void FreeNode(struct List *list)&#123; struct List *p1, *p2; p1 = p2 = list; while (p1-&gt;next != NULL) &#123; p2 = p1; p1 = p1-&gt;next; free(p2); &#125; free(p1);&#125;int main()&#123; struct List *list1, *list2; list1 = (struct List *)malloc(sizeof(struct List)); list2 = (struct List *)malloc(sizeof(struct List)); cout &lt;&lt; &quot;list1:&quot; &lt;&lt; endl; list1 = creat(list1); cout &lt;&lt; &quot;list2:&quot; &lt;&lt; endl; list2 = creat(list2); //验证输入是否按照指数升序排列 cout &lt;&lt; endl; struct List *p1 = list1-&gt;next; while (p1 != NULL) &#123; cout &lt;&lt; p1-&gt;x &lt;&lt; &apos; &apos; &lt;&lt; p1-&gt;y &lt;&lt; endl; p1 = p1-&gt;next; &#125; cout &lt;&lt; endl; p1 = list2-&gt;next; while (p1 != NULL) &#123; cout &lt;&lt; p1-&gt;x &lt;&lt; &apos; &apos; &lt;&lt; p1-&gt;y &lt;&lt; endl; p1 = p1-&gt;next; &#125; list1 = AddPolynomial(list1, list2); cout &lt;&lt; endl &lt;&lt; endl &lt;&lt; endl; //输出验证结果 p1=list1-&gt;next; while (p1 != NULL) &#123; cout &lt;&lt; p1-&gt;x &lt;&lt; &apos; &apos; &lt;&lt; p1-&gt;y &lt;&lt; endl; p1 = p1-&gt;next; &#125; //释放内存 FreeNode(list1); FreeNode(list2); return 0;&#125; 测试数据12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758其中x代表系数，y代表指数数据组1：list1：x y2 31 23 14 65 5list2：x y2 14 65 46 33 5相加： x y5 11 28 35 48 58 6数据组2：list1：x y3 15 36 23 9-1 4list2：x y1 44 32 71 56 2相加： x y3 112 29 32 73 9数据组3：list1：x y-1 14 3-4 92 05 2list2：x y1 1-4 32 22 95 5相加： x y2 07 25 5-2 9 实验题12本题用链表求大数加法，简单用链表模拟下加法运算。只写了具体求结果的代码，求中间位的就不写了。数据保证为正整数，小数负数这代码求不了，而我等有时间再改吧。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;using namespace std;#define MAXSIZE 100000+1000struct List&#123; int data; struct List *next;&#125;;struct List *rever(char ch[]);void add(struct List *&amp;L1,struct List *&amp;L2);int main()&#123; char str1[MAXSIZE],str2[MAXSIZE]; while(cin&gt;&gt;str1&gt;&gt;str2)&#123;//多组样列输入 struct List *L1,*L2; L1=L2=(struct List *)malloc(sizeof(struct List)); L1=rever(str1); L2=rever(str2); add(L1,L2); &#125; return 0;&#125;struct List *rever(char ch[])//将字符数组存入链表中 &#123; struct List *L,*p1,*p2; L=(struct List *)malloc(sizeof(struct List)); p2=L; for(int i=strlen(ch)-1;i&gt;=0;i--)&#123; p1=(struct List *)malloc(sizeof(struct List)); p1-&gt;data=ch[i]-48; p2-&gt;next=p1; p2=p1; &#125; p2-&gt;next=NULL; return L;&#125;void add(struct List *&amp;L1,struct List *&amp;L2)&#123; int num[MAXSIZE+10]; int i=0,t=0; struct List *p1=L1-&gt;next,*p2=L2-&gt;next; while(p1!=NULL||p2!=NULL)&#123; if(p1!=NULL&amp;&amp;p2!=NULL)&#123; num[i++]=(p1-&gt;data+p2-&gt;data+t)%10; t=(p1-&gt;data+p2-&gt;data+t)/10; p1=p1-&gt;next; p2=p2-&gt;next; &#125; if(p1!=NULL&amp;&amp;p2==NULL)&#123; num[i++]=(p1-&gt;data+t)%10; t=(p1-&gt;data+t)/10; p1=p1-&gt;next; &#125; if(p1==NULL&amp;&amp;p2!=NULL)&#123; num[i++]=(p2-&gt;data+t)%10; t=(p2-&gt;data+t)/10; p2=p2-&gt;next; &#125; &#125; if(t!=0) num[i++]=t; for(int j=i-1;j&gt;=0;j--) cout&lt;&lt;num[j]; cout&lt;&lt;endl;&#125; /*测试数据*//*1、112233445566778899 998877665544332211 11111111111111111102、1314 4131 5445 */ 待续…]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《数据结构 李春葆版》课后练习题三（栈与队列）]]></title>
    <url>%2F2019%2F09%2F12%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0%E9%A2%98%E4%B8%89%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[开始做的话，是在灌水吧。栈与队列，刚开始接触这部分知识感觉不是很上手，然而又有什么关系呢？东西就在那里，你学与不学又能怎么样呢？如果总是逃避的难题，碰到真正地难题你还会有信心去面对吗？况且这不能算是难题。明天很美好，前提是你有能力获得美好。然而又有什么好玩的呢？一天又一天的过去，真正做了什么呢？学了什么呢？不清楚自己在做什么，时间并不会等人。做自己想做的，学自己想学的，不要把别人要求你的当成包袱。 一、练习题三第十题括号匹配12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;using namespace std;#define MAXSIZE 1000+10struct Stack&#123; char num[MAXSIZE]; int top;&#125;; int main()&#123; char str[MAXSIZE]; cin&gt;&gt;str; struct Stack stack; stack.top=-1; for(int i=0;i&lt;strlen(str);i++)&#123; if(str[i]==&apos;(&apos;||str[i]==&apos;[&apos;||str[i]==&apos;&#123;&apos;)&#123; stack.top++; stack.num[stack.top]=str[i]; &#125; if(str[i]==&apos;)&apos;) if(stack.num[stack.top]==&apos;(&apos;) stack.top--; else break; if(str[i]==&apos;]&apos;) if(stack.num[stack.top]==&apos;[&apos;) stack.top--; else break; if(str[i]==&apos;&#125;&apos;) if(stack.num[stack.top]==&apos;&#123;&apos;) stack.top--; else break; &#125; if(stack.top==-1&amp;&amp;i&gt;=strlen(str)) cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; return 0;&#125; /*测试数据*//*1、][ No2、[][][]()&#123;&#125;&#123; No3、][][ No4、()[[(&#123;&#125;)]] Yes*/ 第十一题每天要喝八杯水，orz1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &quot;pch.h&quot;#include &lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;string&gt;#include&lt;malloc.h&gt;#define MAXSIZE 10using namespace std;struct Queue&#123; char ch[MAXSIZE]; int rear; int front;&#125;;int main()&#123; char str; struct Queue *queue; queue = (struct Queue *)malloc(sizeof(struct Queue)); queue-&gt;front = queue-&gt;rear = 0; while (1) &#123; cin &gt;&gt; str; if (str&lt;&apos;0&apos; || (str &gt; &apos;9&apos;&amp;&amp;str &lt; &apos;a&apos;) || str&gt;&apos;z&apos;) break; if (str &gt;= &apos;0&apos;&amp;&amp;str &lt;= &apos;9&apos;&amp;&amp;((queue-&gt;rear + 1) % MAXSIZE != queue-&gt;front)) &#123; queue-&gt;rear = (queue-&gt;rear + 1) % MAXSIZE; queue-&gt;ch[queue-&gt;rear] = str; &#125; if (str &gt;= &apos;a&apos;&amp;&amp;str &lt;= &apos;z&apos; &amp;&amp; (queue-&gt;front != queue-&gt;rear)) &#123; queue-&gt;front = (queue-&gt;front + 1) % MAXSIZE; &#125; &#125; while (queue-&gt;front != queue-&gt;rear) &#123; queue-&gt;front = (queue-&gt;front + 1) % MAXSIZE; cout &lt;&lt; queue-&gt;ch[queue-&gt;front] &lt;&lt; &apos; &apos;; &#125; free(queue); return 0;&#125;/*测试数据*//*1、123asw1sw123. 123*/ 第十二题将一个环形队列（容量为n,元素下标从0到n-1）的元素倒置思路：利用栈先进后出的特点，先把队列中的元素全部存到栈中，然后把栈中的元素转移到队列中，over。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;string&gt;#include&lt;malloc.h&gt;#define MAXSIZE 10using namespace std;struct Queue&#123; char ch[MAXSIZE]; int rear; int front;&#125;;struct Stack&#123; char data[MAXSIZE]; int top;&#125;;void Queue1();int main()&#123; char str[MAXSIZE]; cin &gt;&gt; str; struct Queue *queue; struct Stack *stack; queue = (struct Queue *)malloc(sizeof(struct Queue)); queue-&gt;front = queue-&gt;rear = 0; stack = (struct Stack *)malloc(sizeof(struct Stack)); stack-&gt;top = -1; for (int i = 0; i &lt; strlen(str); i++)&#123; queue-&gt;rear = (queue-&gt;rear + 1) % MAXSIZE; queue-&gt;ch[queue-&gt;rear] = str[i]; &#125; while (queue-&gt;front != queue-&gt;rear) &#123; queue-&gt;front = (queue-&gt;front + 1) % MAXSIZE; stack-&gt;top++; stack-&gt;data[stack-&gt;top] = queue-&gt;ch[queue-&gt;front]; &#125; queue-&gt;front = queue-&gt;rear = 0; while (stack-&gt;top != -1) &#123; queue-&gt;rear = (queue-&gt;rear + 1) % MAXSIZE; queue-&gt;ch[queue-&gt;rear] = stack-&gt;data[stack-&gt;top]; stack-&gt;top--; &#125; while (queue-&gt;front != queue-&gt;rear) &#123; queue-&gt;front = (queue-&gt;front + 1) % MAXSIZE; cout &lt;&lt; queue-&gt;ch[queue-&gt;front] &lt;&lt; &apos; &apos;; &#125; return 0;&#125;/*测试数据*//*abcdeff e d c b a*/ 待续……]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NYOJ305另类表达式求值（栈）]]></title>
    <url>%2F2019%2F09%2F12%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E5%8F%A6%E7%B1%BB%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一、题目描述表达式求值时间限制：3000 ms | 内存限制：65535 KB难度：3描述 Dr.Kong设计的机器人卡多掌握了加减法运算以后，最近又学会了一些简单的函数求值，比如，它知道函数min(20,23)的值是20 ，add(10,98) 的值是108等等。经过训练，Dr.Kong设计的机器人卡多甚至会计算一种嵌套的更复杂的表达式。假设表达式可以简单定义为: 一个正的十进制数 x 是一个表达式。 如果 x 和 y 是 表达式，则 函数min(x,y )也是表达式,其值为x,y 中的最小数。 如果 x 和 y 是 表达式，则 函数max(x,y )也是表达式,其值为x,y 中的最大数。 如果 x 和 y 是 表达式，则 函数add(x,y )也是表达式,其值为x,y 之和。例如， 表达式 max(add(1,2),7) 的值为 7。请你编写程序，对于给定的一组表达式，帮助 Dr.Kong 算出正确答案，以便校对卡多计算的正误。 输入 第一行： N 表示要计算的表达式个数 （1≤ N ≤ 10）接下来有N行， 每行是一个字符串，表示待求值的表达式（表达式中不会有多余的空格，每行不超过300个字符，表达式中出现的十进制数都不超过1000。） 输出 输出有N行，每一行对应一个表达式的值。 样例输入123add(1,2) max(1,999) add(min(1,1000),add(100,99)) 样例输出1233999200 二、题解本题是栈应用的类型。首先定义两个栈，一个用来存放运算符（记为栈1），一个用来存放待计算的数据（记为栈2）。从字符串首开始遍历直到尾部，若发现add串（在这里我们只需要识别字符a和字符d），则表示需要求和，将其存入栈1中。若发现min串、max串继续存放。若遍历到的是数字，则存入栈2，需要注意的是，由于输入的是字符串，在识别数据就要小心了。比如识别 47，首先识别到4，这时候可以发现后面还跟着7，4是十位上的数，7是各位上的数，如果在识别是不能处理，那么4就会被单独当成一个数存入栈2中，7也如此。具体看代码。举例add(min(1,1000),add(100,99))1、字符串遍历，到add处，将其进栈1，用“加”代替，那么这时候栈1：加-&gt;null;2、遍历到min，将其精栈1，用“小”代替，栈1：加-&gt;小-&gt;null；3、遍历到1，通过处理将得到的数字进栈2，栈2：1-&gt;null;4、遍历到1000串，处理得到1000进栈2，栈2：1-&gt;1000-&gt;null;5、遍历到），说明此时需要计算数据了，查看栈1栈首的元素，发现此时为小，表明前面两个数据需要比较大小求得较小的数据，拿栈2中栈首元素与次首元素比较，就是1和1000比较得到1，栈2退栈一位，此时栈2：1-&gt;null；将比较得到的数据赋给栈首元素，那么栈2：1-&gt;null；处理完栈2，发现刚才栈1中的栈首得到了应用，将其退栈一位，栈1：加-&gt;null；6、遍历到add处，用“加”代替，进栈，栈1：加-&gt;加-&gt;null;7、接着遍历100，99，分别将他们进栈2，此时栈2：1-&gt;100-&gt;99-&gt;null；8、遍历到），计算数据，栈1中栈首元素为加，则栈2中100和99相加的199，退栈，赋值。栈2：1-&gt;199-&gt;null。栈1退栈一位；9、遍历到），计算数据，栈1中栈首元素为加，则栈2中1和199相加的199，退栈，赋值。栈2：200-&gt;null。栈1退栈一位；10、200为表达式值。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#define MAXSIZE 300+10struct Stack1&#123; int flag[MAXSIZE]; int top;&#125;;struct Stack2&#123; int number[MAXSIZE]; int top;&#125;;double calculate(char str[]);int main()&#123; int Case; scanf(&quot;%d&quot;,&amp;Case); while(Case--)&#123; char str[MAXSIZE]; scanf(&quot;%s&quot;,str); double ans=calculate(str); printf(&quot;%.0lf\n&quot;,ans); &#125; return 0;&#125;double calculate(char str[])&#123; struct Stack1 stack1; //字符栈 struct Stack2 stack2; //数字栈 stack1.top=stack2.top=-1; int value=0; for(int i=0;i&lt;strlen(str);i++)&#123; if(str[i]==&apos;a&apos;&amp;&amp;str[i-1]!=&apos;m&apos;)&#123;//避免与求最大值的max区分开 value=0; stack1.top++; stack1.flag[stack1.top]=1; &#125; if(str[i]==&apos;m&apos;)&#123; value=0; stack1.top++; if(str[i+1]==&apos;i&apos;) stack1.flag[stack1.top]=2;//判断求最小值 else if(str[i+2]==&apos;x&apos;) stack1.flag[stack1.top]=3;//判断求最大值 &#125; if(str[i]==&apos;,&apos;) value=0; if(str[i]&gt;=&apos;0&apos;&amp;&amp;str[i]&lt;=&apos;9&apos;)&#123; if(str[i-1]&gt;=&apos;0&apos;&amp;&amp;str[i]&lt;=&apos;9&apos;)&#123; value=value*10+str[i]-48; &#125; else&#123; value=str[i]-48;//字符转数字 &#125; if(str[i+1]&lt;&apos;0&apos;||str[i+1]&gt;&apos;9&apos;)&#123; stack2.top++; stack2.number[stack2.top]=value; &#125; &#125; int temp=0; if(str[i]==&apos;)&apos;)&#123; value=0; switch(stack1.flag[stack1.top])&#123; case 1: temp=stack2.number[stack2.top]+stack2.number[stack2.top-1]; stack2.top--; stack2.number[stack2.top]=temp; break; case 2: if(stack2.number[stack2.top]&gt;=stack2.number[stack2.top-1]) stack2.top--; else&#123; temp=stack2.number[stack2.top]; stack2.top--; stack2.number[stack2.top]=temp; &#125; break; case 3: if(stack2.number[stack2.top]&lt;=stack2.number[stack2.top-1]) stack2.top--; else&#123; temp=stack2.number[stack2.top]; stack2.top--; stack2.number[stack2.top]=temp; &#125; &#125; stack1.top--; &#125; &#125; return double(stack2.number[stack2.top]); &#125; 继续补题ing…]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[判断连通图]]></title>
    <url>%2F2019%2F09%2F12%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E5%88%A4%E6%96%AD%E8%BF%9E%E9%80%9A%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[判断无向图是否连通 题目描述3967: 连通图时间限制: 1 Sec 内存限制: 32 MB提交: 4 解决: 4题目描述给定一个无向图和其中的所有边，判断这个图是否所有顶点都是连通的。 输入每组数据的第一行是两个整数 n 和 m（0&lt;=n&lt;=1000）。n 表示图的顶点数目，m 表示图中边的数目。如果 n 为 0 表示输入结束。随后有 m 行数据，每行有两个值 x 和 y（0&lt;x, y &lt;=n），表示顶点 x 和 y 相连，顶点的编号从 1 开始计算。输入不保证这些边是否重复。 输出对于每组输入数据，如果所有顶点都是连通的，输出”YES”，否则输出”NO”。 样例输入12345678910111213141516174 34 31 21 35 73 52 31 33 22 53 44 17 36 23 15 60 0 样例输出123YESYESNO 前几天写图遍历时，一直是按照书上先把矩阵转化为邻接表再遍历，这次终于换了一种方式。矩阵转邻接表：12345678910111213void MatToList(Graph *&amp;G, int n) &#123; Anode *p; for (int i = 1; i &lt;= n; i++) &#123; for (int j = n; j &gt;=1; j--) &#123; if (edge[i][j] == 1) &#123; p = new Anode; p-&gt;value = j; p-&gt;next = G-&gt;adjlist[i].firstarc; G-&gt;adjlist[i].firstarc = p; &#125; &#125; &#125;&#125; 想明白邻接表后直接对表头赋值如下1234567891011121314151617void input(Graph *&amp;G, int m) &#123; while (m--) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; Anode *p = new Anode; Anode *q = new Anode; p-&gt;value = b; q-&gt;value = a; p-&gt;next = G-&gt;adjlist[a].firstarc; G-&gt;adjlist[a].firstarc = p; q-&gt;next = G-&gt;adjlist[b].firstarc; G-&gt;adjlist[b].firstarc = q; &#125;&#125; AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;iostream&gt;using namespace std;const int MAXSIZE = 1000;int visited[MAXSIZE] = &#123; 0 &#125;;int edge[MAXSIZE][MAXSIZE] = &#123; 0 &#125;;class Anode &#123;public: int value; Anode *next;&#125;;class Adjlist &#123;public: Anode *firstarc;&#125;;class Graph &#123;public: Adjlist adjlist[MAXSIZE];&#125;;void initGraph(Graph *&amp;G, int n) &#123; G = new Graph; for (int i = 1; i &lt;= n; i++) G-&gt;adjlist[i].firstarc = NULL; //表头指针指向NULL&#125;void input(Graph *&amp;G, int m) &#123; while (m--) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; Anode *p = new Anode; Anode *q = new Anode; p-&gt;value = b; q-&gt;value = a; //头插法建表 p-&gt;next = G-&gt;adjlist[a].firstarc; G-&gt;adjlist[a].firstarc = p; q-&gt;next = G-&gt;adjlist[b].firstarc; G-&gt;adjlist[b].firstarc = q; &#125;&#125;void DFS(Graph *&amp;G, int count) &#123; Anode *p; visited[count] = 1; p = G-&gt;adjlist[count].firstarc; while (p != NULL) &#123; if (visited[p-&gt;value] == 0) DFS(G, p-&gt;value); //递归深搜 p = p-&gt;next; &#125;&#125;bool isConnectedGraph(Graph *&amp;G, int n) &#123; DFS(G, 1); for (int i = 1; i &lt;= n; i++) if (visited[i] != 1) //只要有一个节点未被访问就返回 return false; return true;&#125;int main()&#123; int n, m; while (cin &gt;&gt; n &gt;&gt; m) &#123; for (int i = 1; i &lt;= MAXSIZE; i++) &#123; visited[i] = 0 ; for (int j = 1; j &lt;= MAXSIZE; j++) edge[i][j] = 0; &#125; if (n == 0 &amp;&amp; m == 0) break; Graph *G; initGraph(G, n);//对图初始化 input(G,m); if (isConnectedGraph(G, n)) cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>图遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的创建及其遍历]]></title>
    <url>%2F2019%2F09%2F12%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%9B%E5%BB%BA%E5%8F%8A%E5%85%B6%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[二叉树是一种非常重要的数据结构，许多其他的数据结构都是基于二叉树发展推演过来的。用递归定义树的结构非常简洁，同样，递归遍历也非常简洁。在学习过程中，我发现递归算法往往只是一个简单的语句，虽然简洁的语句实现了功能，但在算法具体过程方面没有很好的阐述，我也很纠结为什么可以这么用，一次次调式试图弄明白内在机理，总是达不到预期效果，所以我转而写非递归的算法以此希望能够理解树的节点的构造、遍历。在这里，我写下这些天学习二叉树的历程。 一、树的创建利用递归创建二叉树。123456789101112131415struct Btree *inputTree()//创建二叉树 &#123; int number; struct Btree *tree; scanf(&quot;%d&quot;,&amp;number); if(number==0)&#123; //当输入0时，表示左孩子或右孩子为空 tree=NULL; &#125;else&#123; tree=(struct Btree *)malloc(LEN); tree-&gt;data=number; tree-&gt;lchild=inputTree(); //递归左孩子 tree-&gt;rchild=inputTree(); //递归右孩子 &#125; return tree;&#125; 二、三种遍历递归实现1、先序遍历递归算法规则：先根节点，再左子树，后右子树，简记NLR。具体，可将整棵树分为左子树和右子树，然后再将左子树分为次左子树、次右子树123456789void preTraversal(struct Btree *tree)&#123; if(tree!=NULL)&#123; printf(&quot;%d &quot;,tree-&gt;data); //打印根节点 preTraversal(tree-&gt;lchild); //遍历左孩子树 preTraversal(tree-&gt;rchild); //遍历右孩子树 &#125; return;&#125; 2、中序遍历递归算法规则：先左子树，再根节点，后右子树，简记LNR。具体同先序。123456789void inTraversal(struct Btree *tree)&#123; if(tree!=NULL)&#123; preTraversal(tree-&gt;lchild); //遍历左孩子树 printf(&quot;%d&quot;,tree-&gt;data); //打印根节点 preTraversal(tree-&gt;rchild); //遍历右孩子树 &#125; return;&#125; 3、后序遍历递归算法规则：先左子树，再右子树，后根节点，简记LRN。具体同先序。12345678void postTraversal(struct Btree *tree)&#123; if(tree!=NULL)&#123; postTraversal(tree-&gt;lchild); //遍历左孩子树 postTraversal(tree-&gt;rchild); //遍历右孩子树 printf(&quot;%d &quot;,tree-&gt;data); //打印根节点 &#125;&#125; 三、三种遍历非递归实现1、先序遍历非递归算法算法主要步骤：1、当树不为空时，将根节点压入栈中；2、当栈不为空时，说明需要此时访问当前节点，退栈访问；3、查看该节点的右孩子(这里先查看右孩子是因为这是先序遍历，先遍历根节点其次左孩子最后右孩子，这里用到栈也是因为栈的特点，先进后出，后进先出)，若右孩子存在，则压入栈中；4、查看该节点的左孩子，同3；5、若栈不为空，转2，循环。12345678910111213141516171819202122232425void preTraversal(struct Btree *tree)&#123; struct Btree *stack[MAXSIZE]; struct Btree *temp; int top=-1; if(tree!=NULL)&#123; top++; stack[top]=tree; //将根节点进栈 while(top!=-1)&#123; temp=stack[top]; top--; printf(&quot;%d &quot;,temp-&gt;data); if(temp-&gt;rchild!=NULL)&#123; //右孩子不为空，进栈 top++; stack[top]=temp-&gt;rchild; &#125; if(temp-&gt;lchild!=NULL)&#123; //左孩子不为空，进栈 top++; stack[top]=temp-&gt;lchild; &#125; &#125; &#125; printf(&quot;\n&quot;); return;&#125; 2、中序遍历非递归算法算法主要步骤：1、首先查看根节点，若根节点不为空，将其进栈；2、查看根节点的左孩子，若左孩子存在，将其进栈，继续访问以左孩子为根节点的次树；3、 若次树无左孩子，访问当前次树的根节点，然后查看该根节点的右孩子；4、循环。12345678910111213141516171819202122void inTraversal(struct Btree *tree)&#123; struct Btree *stack[MAXSIZE],*temp; int top=-1; if(tree!=NULL)&#123; temp=tree; while(top&gt;-1||temp!=NULL)&#123; if(temp!=NULL)&#123; top++; stack[top]=temp; temp=temp-&gt;lchild; &#125;else&#123; //此时说明当前次树已无左孩子，则访问该节点 temp=stack[top]; top--; printf(&quot;%d &quot;,temp-&gt;data); temp=temp-&gt;rchild; //查看该节点的右孩子 &#125; &#125; &#125; printf(&quot;\n&quot;); return; &#125; 3、后序遍历非递归算法算法主要步骤：1、首先将根节点进栈，若栈不为空，循环；2、查看栈顶元素，若其有左孩子或右孩子并且左右孩子没有被访问，将其左孩子或右孩子入栈，否则，访问该节点；3、 在2步骤中，若访问完一节点，则用pre指针记录下来 。1234567891011121314151617181920212223242526void postTraversal(struct Btree *tree)&#123; struct Btree *stack[MAXSIZE],*temp,*pre=NULL; int top=-1; top++; stack[top]=tree; while(top!=-1)&#123; temp=stack[top]; if((temp-&gt;lchild==NULL&amp;&amp;temp-&gt;rchild==NULL)||\ (pre!=NULL&amp;&amp;(temp-&gt;lchild==pre||temp-&gt;rchild==pre)))&#123; printf(&quot;%d &quot;,temp-&gt;data);//到此表明该节点无左右孩子 top--; //或者有左右孩子但已被访问输出，访问该节点 pre=temp; //pre指针用来记录上一访问过的节点 &#125;else&#123; if(temp-&gt;rchild!=NULL)&#123; //若右孩子存在，将其入栈 top++; stack[top]=temp-&gt;rchild; &#125; if(temp-&gt;lchild!=NULL)&#123; //若左孩子存在，将其入栈 top++; stack[top]=temp-&gt;lchild; &#125; &#125; &#125; printf(&quot;\n&quot;); &#125; 四、源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define LEN sizeof(struct Btree)#define MAXSIZE 1000+10struct Btree&#123; int data; struct Btree *lchild,*rchild;&#125;;void preTraversal(struct Btree *tree);void inTraversal(struct Btree *tree);void postTraversal(struct Btree *tree);struct Btree *inputTree();int main()&#123; struct Btree *tree; tree=inputTree(); printf(&quot;先序遍历:\n&quot;); preTraversal(tree); printf(&quot;中序遍历:\n&quot;); inTraversal(tree); printf(&quot;后序遍历:\n&quot;); postTraversal(tree); return 0;&#125;struct Btree *inputTree()//创建二叉树 &#123; int number; struct Btree *tree; scanf(&quot;%d&quot;,&amp;number); if(number==0)&#123; //当输入0时，表示左孩子或右孩子 为空 tree=NULL; &#125;else&#123; tree=(struct Btree *)malloc(LEN); tree-&gt;data=number; tree-&gt;lchild=inputTree(); //递归左孩子 tree-&gt;rchild=inputTree(); //递归右孩子 &#125; return tree;&#125;void preTraversal(struct Btree *tree)//先序递归&#123; if(tree!=NULL)&#123; printf(&quot;%d &quot;,tree-&gt;data); //打印根节点 preTraversal(tree-&gt;lchild); //遍历左孩子树 preTraversal(tree-&gt;rchild); //遍历右孩子树 &#125; return;&#125;void preTraversal(struct Btree *tree)//先序非递归&#123; struct Btree *stack[MAXSIZE]; struct Btree *temp; int top=-1; if(tree!=NULL)&#123; top++; stack[top]=tree; //将根节点进栈 while(top!=-1)&#123; temp=stack[top]; top--; printf(&quot;%d &quot;,temp-&gt;data); if(temp-&gt;rchild!=NULL)&#123; //右孩子不为空，进栈 top++; stack[top]=temp-&gt;rchild; &#125; if(temp-&gt;lchild!=NULL)&#123; //左孩子不为空，进栈 top++; stack[top]=temp-&gt;lchild; &#125; &#125; &#125; printf(&quot;\n&quot;); return; &#125;void inTraversal(struct Btree *tree)//中序递归&#123; if(tree!=NULL)&#123; preTraversal(tree-&gt;lchild); //遍历左孩子树 printf(&quot;%d&quot;,tree-&gt;data); //打印根节点 preTraversal(tree-&gt;rchild); //遍历右孩子树 &#125; return;&#125;void inTraversal(struct Btree *tree)//中序非递归&#123; struct Btree *stack[MAXSIZE],*temp; int top=-1; if(tree!=NULL)&#123; temp=tree; while(top&gt;-1||temp!=NULL)&#123; if(temp!=NULL)&#123; top++; stack[top]=temp; temp=temp-&gt;lchild; &#125;else&#123; //此时说明当前次树已无左孩子，则访问该节点 temp=stack[top]; top--; printf(&quot;%d &quot;,temp-&gt;data); temp=temp-&gt;rchild; //查看该节点的右孩子 &#125; &#125; &#125; printf(&quot;\n&quot;); return; &#125; void postTraversal(struct Btree *tree)//后序递归&#123; if(tree!=NULL)&#123; postTraversal(tree-&gt;lchild); //遍历左孩子树 postTraversal(tree-&gt;rchild); //遍历右孩子树 printf(&quot;%d &quot;,tree-&gt;data); //打印根节点 &#125; return;&#125;void postTraversal(struct Btree *tree)&#123; struct Btree *stack[MAXSIZE],*temp,*pre=NULL; int top=-1; top++; stack[top]=tree; while(top!=-1)&#123; temp=stack[top]; if((temp-&gt;lchild==NULL&amp;&amp;temp-&gt;rchild==NULL)||\ (pre!=NULL&amp;&amp;(temp-&gt;lchild==pre||temp-&gt;rchild==pre)))&#123; printf(&quot;%d &quot;,temp-&gt;data);//到此表明该节点无左右孩子 top--; //或者有左右孩子但已被访问输出，访问该节点 pre=temp;//pre指针用来记录上一访问过的节点 &#125;else&#123; if(temp-&gt;rchild!=NULL)&#123;//若右孩子存在，将其入栈 top++; stack[top]=temp-&gt;rchild; &#125; if(temp-&gt;lchild!=NULL)&#123;//若左孩子存在，将其入栈 top++; stack[top]=temp-&gt;lchild; &#125; &#125; &#125; printf(&quot;\n&quot;); return;&#125; 五、后记在用递归遍历二叉树时，总想搞明白递归遍历的过程是怎么样的，但每次都以头昏脑涨结尾。说实话，递归说它难，也就那样，说它简单，但……总之，用递归求解时，不要深究细节，逻辑对，递归一定对。最后若有什么想法，欢迎在评论区留言。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NYOJ465中缀式变后缀式（套题）]]></title>
    <url>%2F2019%2F09%2F12%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E4%B8%AD%E7%BC%80%E5%BC%8F%E5%8F%98%E5%90%8E%E7%BC%80%E5%BC%8F2%2F</url>
    <content type="text"><![CDATA[一、题目描述中缀式变后缀式时间限制：1000 ms | 内存限制：65535 KB难度：3描述 人们的日常习惯是把算术表达式写成中缀式，但对于机器来说更“习惯于”后缀式，关于算术表达式的中缀式和后缀式的论述一般的数据结构书都有相关内容可供参看，这里不再赘述，现在你的任务是将中缀式变为后缀式。输入第一行输入一个整数n，共有n组测试数据（n&lt;10)。每组测试数据只有一行，是一个长度不超过1000的字符串，表示这个运算式的中缀式，每个运算式都是以“=”结束。这个表达式里只包含+-*/与小括号这几种符号。其中小括号可以嵌套使用。数据保证输入的操作数中不会出现负数。数据保证除数不会为0 输出 每组都输出该组中缀式相应的后缀式，要求相邻的操作数操作符用空格隔开。样例输入12321.000+2/4=((1+2)*5+1)/4= 样例输出121.000 2 4 / + =1 2 + 5 * 1 + 4 / = 二、题解模拟过程点这123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;stdio.h&gt;#include&lt;string.h&gt; #define MAXSIZE 3000struct Stack&#123; char character[MAXSIZE]; int top; int flag[MAXSIZE];&#125;;int main()&#123; int Case; scanf(&quot;%d&quot;,&amp;Case); while(Case--) &#123; char str[MAXSIZE]; char ch[MAXSIZE]; struct Stack stack; int count=0; stack.top=-1; scanf(&quot;%s&quot;,str); for(int i=0;i&lt;strlen(str)-1;i++)&#123; if((str[i]&gt;=&apos;0&apos;&amp;&amp;str[i]&lt;=&apos;9&apos;)||str[i]==&apos;.&apos;)&#123; if((str[i+1]&gt;=&apos;0&apos;&amp;&amp;str[i+1]&lt;=&apos;9&apos;)||str[i+1]==&apos;.&apos;) ch[count++]=str[i]; else&#123; ch[count++]=str[i]; ch[count++]=&apos; &apos;; &#125; &#125; else &#123; switch(str[i])&#123; case &apos;-&apos;: case &apos;+&apos;: if(stack.top==-1)&#123; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=1; &#125; else&#123; if(stack.flag[stack.top]!=3)&#123; if(stack.flag[stack.top]==2)&#123; ch[count++]=stack.character[stack.top]; ch[count++]=&apos; &apos;; stack.top--; &#125; if(stack.flag[stack.top]==1)&#123; ch[count++]=stack.character[stack.top]; ch[count++]=&apos; &apos;; stack.top--; &#125; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=1; &#125; else&#123; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=1; &#125; &#125; break; case &apos;*&apos;: case &apos;/&apos;: if(stack.top==-1)&#123; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=2; &#125; else&#123; if(stack.flag[stack.top]==1||stack.flag[stack.top]==3)&#123; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=2; &#125; else&#123; ch[count++]=stack.character[stack.top]; ch[count++]=&apos; &apos;; stack.top--; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=2; &#125; &#125; break; case &apos;(&apos;: stack.top++; stack.character[stack.top]=&apos;(&apos;; stack.flag[stack.top]=3; break; case &apos;)&apos;: while(stack.character[stack.top]!=&apos;(&apos;)&#123; ch[count++]=stack.character[stack.top]; ch[count++]=&apos; &apos;; stack.top--; &#125; stack.top--; break; &#125; &#125; &#125; while(stack.top!=-1)&#123; ch[count++]=stack.character[stack.top]; ch[count++]=&apos; &apos;; stack.top--; &#125; ch[count++]=&apos;=&apos;; ch[count]=&apos;\0&apos;; printf(&quot;%s\n&quot;,ch); &#125; return 0; &#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NYOJ257中缀式变后缀式]]></title>
    <url>%2F2019%2F09%2F12%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E4%B8%AD%E7%BC%80%E5%BC%8F%E5%8F%98%E5%90%8E%E7%BC%80%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、题目描述郁闷的C小加（一）时间限制：1000 ms | 内存限制：65535 KB难度：3描述 我们熟悉的表达式如a+b、a+b(c+d)等都属于中缀表达式。中缀表达式就是（对于双目运算符来说）操作符在两个操作数中间：num1 operand num2。同理，后缀表达式就是操作符在两个操作数之后：num1 num2 operand。ACM队的“C小加”正在郁闷怎样把一个中缀表达式转换为后缀表达式，现在请你设计一个程序，帮助C小加把中缀表达式转换成后缀表达式。为简化问题，操作数均为个位数，操作符只有+-/ 和小括号。输入第一行输入T，表示有T组测试数据（T&lt;10）。每组测试数据只有一行，是一个长度不超过1000的字符串，表示这个表达式。这个表达式里只包含+-*/与小括号这几种符号。其中小括号可以嵌套使用。数据保证输入的操作数中不会出现负数。并且输入数据不会出现不匹配现象。 输出 每组输出都单独成行，输出转换的后缀表达式。 样例输入12321+2(1+2)*3+4*5 样例输出1212+12+3*45*+ 二、题解本题可以用栈来解决。设置运算符的优先级，本题中令+、-的优先级为1，*、/的优先级为2，(的优先级为3。遍历字符串，若发现运算符，将其优先级与栈首元素优先级比较，（如果栈为空直接进栈），若大于则该运算符进栈，若小于且栈首不为’(‘将栈首元素出栈然后将其进栈，若栈首为’(‘，无论何运算符，进栈。若遍历到’)’，则将栈中元素出栈直到栈首为’(‘，最后把’(‘出栈。遍历完字符串，若栈不为空，将栈中元素全部出栈。代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;stdio.h&gt;#include&lt;string.h&gt; #define MAXSIZE 3000struct Stack&#123; char character[MAXSIZE]; int top; int flag[MAXSIZE];//优先级&#125;;int main()&#123; int Case; scanf(&quot;%d&quot;,&amp;Case); while(Case--) &#123; char str[MAXSIZE]; char ch[MAXSIZE]; struct Stack stack; int count=0; stack.top=-1; scanf(&quot;%s&quot;,str); for(int i=0;i&lt;strlen(str);i++)&#123; if(str[i]&gt;=&apos;0&apos;&amp;&amp;str[i]&lt;=&apos;9&apos;) ch[count++]=str[i]; else &#123; switch(str[i])&#123; case &apos;-&apos;: case &apos;+&apos;: if(stack.top==-1)&#123; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=1; &#125; else&#123; if(stack.flag[stack.top]!=3)&#123; if(stack.flag[stack.top]==2)&#123; ch[count++]=stack.character[stack.top]; stack.top--; &#125; if(stack.flag[stack.top]==1)&#123; ch[count++]=stack.character[stack.top]; stack.top--; &#125; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=1; &#125; else&#123; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=1; &#125; &#125; break; case &apos;*&apos;: case &apos;/&apos;: if(stack.top==-1)&#123; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=2; &#125; else&#123; if(stack.flag[stack.top]==1||stack.flag[stack.top]==3)&#123; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=2; &#125; else&#123; ch[count++]=stack.character[stack.top]; stack.top--; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=2; &#125; &#125; break; case &apos;(&apos;: stack.top++; stack.character[stack.top]=&apos;(&apos;; stack.flag[stack.top]=3; break; case &apos;)&apos;: while(stack.character[stack.top]!=&apos;(&apos;)&#123; ch[count++]=stack.character[stack.top]; stack.top--; &#125; stack.top--; break; &#125; &#125; &#125; while(stack.top!=-1)&#123; ch[count++]=stack.character[stack.top]; stack.top--; &#125; ch[count]=&apos;\0&apos;; printf(&quot;%s\n&quot;,ch); &#125; return 0; &#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[皇后问题]]></title>
    <url>%2F2019%2F09%2F12%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2FN%E7%9A%87%E5%90%8E%2F</url>
    <content type="text"><![CDATA[皇后问题最重要的就是递归回溯思维。从第一行第一列开始逐级往下放皇后，若可以放置，则放置下一行的皇后，否则就退回到上一皇后的位置。 一、数组加回溯弄清楚了回溯怎么回事，就可以进行第二步了。如何判断在该位置可以放置皇后呢？举个例子来说，在图中，小圆圈代表在当前位置试探性放置，由于皇后是一行一行地放置，也就是说只需要判断位于它上方的位置，而与它位置想冲突的，就是左上角右上角和正上方了。定义一个二维数组eq[10][10]，如果在当前位置(i,j)放置了皇后,就让eq[i][j]=1; 2、代码说明以八皇后为例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#define SIZE 8using namespace std;int ep[SIZE][SIZE]=&#123;0&#125;;int num=0;void judge(int x);bool check(int x,int y);void print();int main()&#123; judge(0); return 0;&#125;void judge(int x)&#123; int j; for(j=0;j&lt;SIZE;j++)&#123; ep[x][j]=1;//先在该位置放置皇后 if(check(x,j)==true)&#123; /*若这个位置可以放置，则判断整个棋盘是否全部放完*/ if(x==SIZE-1) print(); else /*若这个位置可以放置，则这一行的皇后放置完成，转而判断下一行的皇后放置*/ judge(x+1); &#125; /*若这个位置不可以放置，就把该位置的状态恢复，转而判断这一行的下一个位置*/ ep[x][j]=0; &#125;&#125;bool check(int x,int y)&#123; /*判断正上方是否有皇后*/ for(int i=0;i&lt;x;i++) if(ep[i][y]==1) return false; /*判断左上方是否有皇后*/ int i=x-1; int j=y-1; while(i&gt;=0&amp;&amp;j&gt;=0)&#123; if(ep[i][j]==1)//若有，则不可放置，返回假 return false; i--; j--; &#125; /*判断当前位置右上角是否有皇后*/ i=x-1; j=y+1; while(i&gt;=0&amp;&amp;j&lt;SIZE)&#123; if(ep[i][j]==1)//若有皇后，说明这个位置不可以放置 return false; i--; j++; &#125; return true;&#125;void print()&#123; num++; cout&lt;&lt;&quot;No. &quot;&lt;&lt;num&lt;&lt;endl; for(int i=0;i&lt;SIZE;i++)&#123; for(int j=0;j&lt;SIZE;j++) cout&lt;&lt;ep[i][j]&lt;&lt;&apos; &apos;; cout&lt;&lt;endl; &#125; &#125; 二、栈加回溯说是栈，其实可以不用栈的结构，而是用栈存储数据的思想。用栈数组来存储数据，非常方便递归回溯。定义stack[10]，top=-1；用top来存当前位置的行坐标，用stack[top]来存当前位置的列坐标。再次用到这个图，那么当前位置可表示为(2,2)，用栈存储就是stack[2]=2；判断它正上方是否有皇后，那就只需要看整个栈里面是否有与这个位置的列坐标相等的数了，需要做的就是遍历整个栈；代码表示为： 123for(int i=0;i&lt;top;i++)&#123; if(stack1[i]==stack1[top]) return false; 再来看右上角和左上角由于它们是斜对角关系，可知这些位置中，每两个在同一斜线的行坐标之差必定等于列坐标的差比如(x1,y1),(x2,y2)，这两个点在同一斜线，必定fabs(x2-x1)==fabs(y2-y1)；代码表示：123for(int i=0;i&lt;top;i++)&#123; if((top-i)==fabs(stack1[top]-stack1[i])) return false; 2、代码说明以八皇后为例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;#include&lt;cmath&gt;#define SIZE 8using namespace std;int stack1[SIZE];int top=-1;int num=0;void judge(int x);bool check(int stack1[]);void print(int stack1[]);int main()&#123; judge(0); return 0; &#125;void judge(int x)&#123; for(int j=0;j&lt;SIZE;j++)&#123; top++; /*top代表行坐标，stack1[top]代表列坐标*/ stack1[top]=j; if(check(stack1)==true)&#123; if(top==SIZE-1) print(stack1); else /*递归判断下一行的皇后位置*/ judge(x+1); &#125; top--;//不能放置皇后就退栈 &#125;&#125;bool check(int stack1[])&#123; for(int i=0;i&lt;top;i++)&#123; /*判断该位置正上方是否放置了皇后*/ /*判断右上方和左上方是否放置皇后*/ if((top-i)==fabs(stack1[top]-stack1[i])||stack1[i]==stack1[top]) return false; &#125; return true;&#125;void print(int stack1[])&#123; num++; cout&lt;&lt;num&lt;&lt;endl; for(int i=0;i&lt;SIZE;i++)&#123; for(int j=0;j&lt;SIZE;j++) if(stack1[i]==j) cout&lt;&lt;&apos;1&apos;&lt;&lt;&apos; &apos;; else cout&lt;&lt;&apos;0&apos;&lt;&lt;&apos; &apos;; cout&lt;&lt;endl; &#125;&#125; 三、例题1、N皇后问题传送门描述 在N*N的方格棋盘放置了N个皇后，使得它们不相互攻击（即任意2个皇后不允许处在同一排，同一列，也不允许处在与棋盘边框成45角的斜线上。你的任务是，对于给定的N，求出有多少种合法的放置方法。 Input 共有若干行，每行一个正整数N≤10，表示棋盘和皇后的数量；如果N=0，表示结束。 Output 共有若干行，每行一个正整数，表示对应输入行的皇后的不同放置数量。 Sample Input12341850 Sample Output12319210 2、题解代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;#include&lt;cmath&gt;#define MAXSIZE 11using namespace std;int stack1[MAXSIZE];int top=-1;int num=0;void judge(int row,int N);bool check(int stack1[]);int main()&#123; int N; int val[11]; for(int i=1;i&lt;=10;i++)&#123; judge(0,i); val[i]=num; num=0; top=-1; &#125; while(cin&gt;&gt;N)&#123; if(N==0) break; cout&lt;&lt;val[N]&lt;&lt;endl; &#125; return 0; &#125;void judge(int row,int N)&#123; for(int j=0;j&lt;N;j++)&#123; top++; stack1[top]=j; if(check(stack1)==true)&#123; if(top==N-1) num++; else judge(row+1,N); &#125; top--; &#125;&#125;bool check(int stack1[])&#123; for(int i=0;i&lt;top;i++) if(((top-i)==fabs(stack1[top]-stack1[i]))||(stack1[i]==stack1[top])) return false; return true;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NYOJ63 小猴子下落（二叉树）]]></title>
    <url>%2F2019%2F09%2F12%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2FNYOJ63%E5%B0%8F%E7%8C%B4%E5%AD%90%E4%B8%8B%E8%90%BD%2F</url>
    <content type="text"><![CDATA[一、题目描述小猴子下落时间限制：3000 ms | 内存限制：65535 KB难度：3描述 有一颗二叉树，最大深度为D,且所有叶子的深度都相同。所有结点从左到右从上到下的编号为1,2,3，·····，2的D次方减1。在结点1处放一个小猴子，它会往下跑。每个内结点上都有一个开关，初始全部关闭，当每次有小猴子跑到一个开关上时，它的状态都会改变，当到达一个内结点时，如果开关关闭，小猴子往左走，否则往右走，直到走到叶子结点。一些小猴子从结点1处开始往下跑，最后一个小猴儿会跑到哪里呢？输入输入二叉树叶子的深度D,和小猴子数目I，假设I不超过整棵树的叶子个数，D&lt;=20.最终以 0 0 结尾 输出 输出第I个小猴子所在的叶子编号。 样例输入1234 23 40 0 样例输出12127 来源[张洁烽]原创上传者张洁烽 二、题解思路如下 1、首先可以明确当节点值为0时，往左走，然后节点值变为1，反之往右走，节点值变为0；2、定义一个大数组用来存放节点状态值，将数组看成满二叉树存储值的状态；3、左节点的序号为上一节点的2倍，右节点的序号为上一节点的2倍加1。 123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;memory.h&gt;#define MAXSIZE 40000+10int flag[MAXSIZE]=&#123;0&#125;; int main()&#123; int N,M; while(scanf(&quot;%d%d&quot;,&amp;N,&amp;M)!=EOF)&#123; memset(flag,0,MAXSIZE); if(N==0&amp;&amp;M==0) break; int temp=1; for(int i=1;i&lt;=M;i++)&#123; int depth=1; temp=1; while(depth&lt;N)&#123; if(flag[temp]==0)&#123; flag[temp]=1; temp=temp*2; &#125;else&#123; flag[temp]=0; temp=temp*2+1; &#125; depth++; &#125; &#125; printf(&quot;%d\n&quot;,temp); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jungle Roads HDU - 1301]]></title>
    <url>%2F2019%2F09%2F12%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2FJungle%20Roads%20HDU%20-%201301%2F</url>
    <content type="text"><![CDATA[题目The Head Elder of the tropical island of Lagrishan has a problem. A burst of foreign aid money was spent on extra roads between villages some years ago. But the jungle overtakes roads relentlessly, so the large road network is too expensive to maintain. The Council of Elders must choose to stop maintaining some roads. The map above on the left shows all the roads in use now and the cost in aacms per month to maintain them. Of course there needs to be some way to get between all the villages on maintained roads, even if the route is not as short as before. The Chief Elder would like to tell the Council of Elders what would be the smallest amount they could spend in aacms per month to maintain roads that would connect all the villages. The villages are labeled A through I in the maps above. The map on the right shows the roads that could be maintained most cheaply, for 216 aacms per month. Your task is to write a program that will solve such problems.The input consists of one to 100 data sets, followed by a final line containing only 0. Each data set starts with a line containing only a number n, which is the number of villages, 1 &lt; n &lt; 27, and the villages are labeled with the first n letters of the alphabet, capitalized. Each data set is completed with n-1 lines that start with village labels in alphabetical order. There is no line for the last village. Each line for a village starts with the village label followed by a number, k, of roads from this village to villages with labels later in the alphabet. If k is greater than 0, the line continues with data for each of the k roads. The data for each road is the village label for the other end of the road followed by the monthly maintenance cost in aacms for the road. Maintenance costs will be positive integers less than 100. All data fields in the row are separated by single blanks. The road network will always allow travel between all the villages. The network will never have more than 75 roads. No village will have more than 15 roads going to other villages (before or after in the alphabet). In the sample input below, the first data set goes with the map above. The output is one integer per line for each data set: the minimum cost in aacms per month to maintain a road system that connect all the villages. Caution: A brute force solution that examines every possible set of roads will not finish within the one minute time limit.Input123456789101112139A 2 B 12 I 25B 3 C 10 H 40 I 8C 2 D 18 G 55D 1 E 44E 2 F 60 G 38F 0G 1 H 35H 1 I 353A 2 B 10 C 40B 1 C 200 Output1221630 思路求最小生成树的模板题。利用kruskal算法来求解，首先将各节点的关系表示出来，对路径权值排序。当判断两节点是否可以相连（不会出现回路的情况）时，可以用并查集来判断。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=1000;const string str=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;int n;struct node&#123; int x,y,cost;&#125;;struct node arr[MAXN];int parent[MAXN];int judge(char ch)&#123; for(int i=0;i&lt;26;i++) if(ch==str[i]) return i+1;&#125;bool cmp(node a,node b)&#123;return a.cost&lt;b.cost;&#125;int find(int x)&#123; int r=x; while(r!=parent[r])r=parent[r]; int i=x,j; while(i!=r)&#123; //路径压缩 j=parent[i]; parent[i]=r; i=j; &#125; return r;&#125;int main()&#123; while(cin&gt;&gt;n&amp;&amp;n!=0)&#123; int k=0; for(int i=1;i&lt;n;i++)&#123; string s1; cin&gt;&gt;s1; int start=judge(s1[0]); int a; cin&gt;&gt;a; while(a--)&#123; string st; int cost; cin&gt;&gt;st&gt;&gt;cost; arr[k].x=start;arr[k].y=judge(st[0]);arr[k++].cost=cost; &#125; &#125; for(int i=1;i&lt;=n;i++)parent[i]=i; sort(arr,arr+k,cmp); int ans=0; for(int i=0;i&lt;k;i++)&#123; int x=find(arr[i].x); int y=find(arr[i].y); if(x!=y)&#123; ans+=arr[i].cost; parent[x]=y; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>最小生成树-kruskal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逆元(个人加深理解)]]></title>
    <url>%2F2019%2F09%2F12%2F%E6%95%B0%E5%AD%A6%2F%E9%80%86%E5%85%83%2F</url>
    <content type="text"><![CDATA[定义首先需要明确的是，在数论中不应该提及到除法运算，因为数论数研究整数的数学分支。 那么，要求解a/b%p怎么办？（a，b，p都是较大的数，longlong范围内）。直接求？会有精度损失！ 这时候就要借助到逆元这个工具了。 设c是b的逆元，根据定义，b*c≡1 （mod p）。a/b%p=a/b*1%p=a/b*b*c%p=a*c%p 如何求逆元费马小定理设模系p是一个质数。由费马小定理：ap-1≡1%p，其中p-1就是比p小与p互质的数的数量。a*aT≡1%p那么ap-1%p=a*aT%paT=ap-2%p 暂时只写这一种，未完待续……]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>逆元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客练习赛48-小w的a=b问题]]></title>
    <url>%2F2019%2F09%2F12%2F%E6%95%B0%E5%AD%A6%2F%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B48-C%2F</url>
    <content type="text"><![CDATA[题目https://ac.nowcoder.com/acm/contest/923/C 思路分析发糖的情况： 第一个人发糖，从位置pos开始向右每个人发一个糖，可以知道左右位置发糖数量是独立的，也就是说跟前面一个发多少个糖是没有关系的。那么每次前后发糖数量的递推公式为d[i-1]=d[i]。 第二个人发糖，从位置pos开始向右发糖，遇到的第一个人发一个糖遇到的第二个人发两个糖……以此类推，遇到的第K个人发K个糖。假如在pos位置一共发了三次糖，那么d[i-1]=d1+d2+d3，d[i]=(d1+1)+(d2+2)+(d3+3)，可推导得d[i-1]=d[i]+3，推广到在pos位置发了n次糖，则d[i-1]+n=d[i]。 第三个人发糖，从位置pos开始向右发糖，遇到的第一个人发一个，第二个发2$^2$，第三个发3$^2$个，第K个人发第K$^2$个糖。假如在pos位置一共发了三次糖，那么d[i-1]=d1$^2$+d2$^2$+d3$^2$，d[i]=(d1+1)$^2$+(d2+1)$^2$+(d3+1)$^2$，推导得d[i-1]+2(d1+d2+d2)+3=d[i],推广到发n次糖，那么d[i-1]+2(d1+d2+d2)+n=d[i]。还有一个问题，通过前后发糖得位置，可以知道(d1$^2$+d2$^2$+d3$^2$)的数量，但是却无法得知(d1+d2+d3)的值，实际上从前面发d1、d2、d3次糖可以知道，(d1+d2+d3)就是在当前位置发糖的次数，用一个数组sum表示就是sum[i]=sum[i-1]+n。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN=1e5+100;const ll MOD=1e9+7;ll d1[MAXN];ll d2[MAXN];ll d3[MAXN];ll sum[MAXN];ll cnt[4][MAXN];int main()&#123; //freopen("in.txt","r",stdin); ll T; scanf("%d",&amp;T); while(T--) &#123; memset(d1,0,sizeof(d1)); memset(d2,0,sizeof(d2)); memset(d3,0,sizeof(d3)); memset(sum,0,sizeof(sum)); memset(cnt,0,sizeof(cnt)); ll n,m; scanf("%lld%lld",&amp;n,&amp;m); while(m--) &#123; ll type,pos; scanf("%lld%lld",&amp;type,&amp;pos); if(type==1) d1[pos]++; else if(type==2) cnt[2][pos]++; else &#123; cnt[3][pos]++; &#125; &#125; for(ll i=1;i&lt;=n;i++) cnt[2][i]=(cnt[2][i]+cnt[2][i-1])%MOD; for(ll i=1;i&lt;=n;i++) cnt[3][i]=(cnt[3][i]+cnt[3][i-1])%MOD; for(ll i=1;i&lt;=n;i++) sum[i]=(sum[i-1]+cnt[3][i])%MOD; for(ll i=1;i&lt;=n;i++) d1[i]=(d1[i]+d1[i-1])%MOD; for(ll i=1;i&lt;=n;i++) d2[i]=(d2[i-1]+cnt[2][i])%MOD; for(ll i=1;i&lt;=n;i++) d3[i]=(d3[i-1]+2*sum[i-1]+cnt[3][i])%MOD; for(ll i=1;i&lt;=n;i++) printf("%lld ",(d1[i]+d2[i]+d3[i])%MOD); printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客练习赛48-小w的a=b问题]]></title>
    <url>%2F2019%2F09%2F12%2F%E6%95%B0%E5%AD%A6%2F%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B48-B%2F</url>
    <content type="text"><![CDATA[题目https://ac.nowcoder.com/acm/contest/923/B 思路说实话，感觉还是做题做得少了，刚开始看到这个题时，脑子里想的全是暴力模拟，想着如何把阶乘转化为另外可以解决的形式。 先前的想法：假如现在有两个数组，一个数组中的元素对另一个数组中的数求相差，如，a[1]=4，b[1]=2，那么a数组比b数组多一个4和一个3，计算数组间的相差，那么可以得到另外两个数组记录了不同的元素，这样就把阶乘转化为了连乘，最后将分别将两个数组的元素乘起来，再比较。但实际上，在计算相差时，可能得到的数据量特别的大。 官方题解：先预处理每一个数的阶乘在不同模系下的结果求出来，保证结果不超longlong。那么对两个数组的元素，就已经求出了阶乘结果，就下来就只需要求连乘，同样，对连乘的结果在与对阶乘取模的相同模下取模，比较两个数组的答案是否相同即可。 但这样并不严谨，因为不管你取的模系有多大（longlong范围内），总会有两个不相同的数对两个不同的数取模后的结果相同。在牛客的讨论群里问过出题人，得到的解答是能取到的这两个数的概率太低了。orz。 所以，老老实实用质因数分解吧。 这道题学到了，在所求结果可能超longlong的情况下，要借助取模公式化简结果，不同一昧的死暴力模拟。 代码对不同模系取模代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll MAXN=1e5+10;const ll MOD[]=&#123;1000000000+7,1000000+7,100000000+7,20000000+7,10000000+7&#125;;ll arr[MAXN];ll brr[MAXN];ll pre[MAXN][5];int main()&#123; //cout&lt;&lt;MOD[4]&lt;&lt;endl; for(ll i=0;i&lt;5;i++) &#123; pre[0][i]=1; for(ll j=1;j&lt;=MAXN;j++) pre[j][i]=pre[j-1][i]*j%MOD[i]; &#125; int T; scanf("%d",&amp;T); while(T--) &#123; ll n,m; scanf("%lld%lld",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;arr[i]); for(int i=1;i&lt;=m;i++) scanf("%lld",&amp;brr[i]); bool flag=false; for(ll i=0;i&lt;5;i++) &#123; ll tmpa=1; for(ll j=1;j&lt;=n;j++) tmpa=pre[arr[j]][i]*tmpa%MOD[i]; ll tmpb=1; for(ll j=1;j&lt;=m;j++) tmpb=pre[brr[j]][i]*tmpb%MOD[i]; if(tmpa!=tmpb) &#123; flag=true; break; &#125; &#125; if(flag) printf("unequal\n"); else printf("equal\n"); &#125; return 0;&#125; 质因数分解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=1e5+100;int prime[MAXN]=&#123;0&#125;;int primes[MAXN];int arr[MAXN];int brr[MAXN];int cnt[2][MAXN];int pt;int number[2][MAXN];void judgePrime()&#123; for(int i=2;i&lt;=MAXN;i++) &#123; if(!prime[i]) primes[pt++]=i; for(int j=0;j&lt;pt&amp;&amp;(i*primes[j])&lt;=MAXN;j++) &#123; prime[i*primes[j]]=1; if(!(i%primes[j])) break; &#125; &#125;&#125;void divi(int op,int x,int time)&#123; int tmpx=x; for(int j=0;primes[j]*primes[j]&lt;=tmpx;j++) &#123; int cnta=0; if(x%primes[j]==0) &#123; while(x&gt;1&amp;&amp;x%primes[j]==0) &#123; cnta++; x/=primes[j]; cnt[op][primes[j]]+=time; &#125; &#125; &#125; if(x&gt;1) cnt[op][x]+=time;&#125;int main()&#123; freopen("in.txt","r",stdin); pt=0; judgePrime(); int T; scanf("%d",&amp;T); while(T--) &#123; int n,m; scanf("%d%d",&amp;n,&amp;m); for(int i=max(m,n);i&gt;=0;i--) &#123; cnt[0][i]=cnt[1][i]=0; number[0][i]=number[1][i]=0; &#125; int maxa=0,maxb=0; for(int i=1;i&lt;=n;i++) &#123; int a; scanf("%d",&amp;a); number[0][a]++; maxa=max(maxa,a); &#125; for(int i=1;i&lt;=m;i++) &#123; int a; scanf("%d",&amp;a); number[1][a]++; maxb=max(maxb,a); &#125; int maxaa=max(maxa,maxb); for(int i=maxaa;i&gt;=1;i--) &#123; number[0][i-1]+=number[0][i]; number[1][i-1]+=number[1][i]; &#125; for(int i=2;i&lt;=maxaa;i++) &#123; if(number[0][i]&gt;=1) &#123; divi(0,i,number[0][i]); &#125; if(number[1][i]&gt;=1) &#123; divi(1,i,number[1][i]); &#125; &#125; bool flag=true; for(int i=0;i&lt;pt;i++) &#123; if(cnt[0][primes[i]]!=cnt[1][primes[i]]) &#123; flag=false;// cout&lt;&lt;primes[i]&lt;&lt;endl;// cout&lt;&lt;cnt[0][primes[i]]&lt;&lt;' '&lt;&lt;cnt[1][primes[i]]&lt;&lt;endl; break; &#125; &#125; if(flag) printf("equal\n"); else printf("unequal\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[快速幂(个人加深理解)]]></title>
    <url>%2F2019%2F09%2F12%2F%E6%95%B0%E5%AD%A6%2F%E5%BF%AB%E9%80%9F%E5%B9%82%2F</url>
    <content type="text"><![CDATA[12345678910111213typedef long long ll;const int mod=100000007;ll fast_pow(ll a,ll b) &#123; ll ans=1; a%=mod; while(b) &#123; if(b&amp;1) ans=ans%mod*a%mod%mod; a=a%mod*a%mod%mod; b&gt;&gt;=1; &#125; return ans%mod;&#125; 理解：对于一个十进制数都可以化成二进制，即1010==10102，1010也可以写成这样23+21。那么现在要求计算1010%mod，就可以转化为10(23+21)%mod，观察到在10的二进制数表示上当某位为1时，才与ans相乘，其余只是不断地由21累乘到22再到24，而不用一个个去计算22\2了。]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vasya and Triangle CodeForces - 1058D (几何推导)]]></title>
    <url>%2F2019%2F09%2F12%2F%E6%95%B0%E5%AD%A6%2FVasya%20and%20Triangle%20CodeForces%20-%201058D%20%EF%BC%88%E5%87%A0%E4%BD%95%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目https://cn.vjudge.net/problem/CodeForces-1058D Vasya has got three integers n, m and k. He’d like to find three integer points (x1,y1), (x2,y2), (x3,y3), such that 0≤x1,x2,x3≤n, 0≤y1,y2,y3≤m and the area of the triangle formed by these points is equal to nmk. Help Vasya! Find such points (if it’s possible). If there are multiple solutions, print any of them. InputThe single line contains three integers n, m, k (1≤n,m≤109, 2≤k≤109). OutputIf there are no such points, print “NO”. Otherwise print “YES” in the first line. The next three lines should contain integers xi,yi — coordinates of the points, one point per line. If there are multiple solutions, print any of them. You can print each letter in any case (upper or lower). ExamplesInput14 3 3 Output1234YES1 02 34 1 Input14 4 7 Output1NO NoteIn the first example area of the triangle should be equal to nmk=4. The triangle mentioned in the output is pictured below: In the second example there is no triangle with area nm/k=16/7. 思路首先需要证明的是，①三个整数点构成的面积一定是整数。 而需要证明①，需要明确一点，在以(0,0),(x,0),(0,y)三个顶点可以组成任意整数面积，如果以(0,0),(1,0),(0,y)，这样y取任意值，当然可以组成任意整数面积。 那么以(0,0)为顶点的面积为S=x*y/2。 要使得组成面积等于n*m/k，那么即是判断x*y==n*m*2/k，x*y为整数，即等式右边n*m*2要整除k，不能为无法满足。 接下来问题就转化为分解n*m*2/k为两个整数一个x&lt;=n、一个y&lt;=m。 首先如果k为偶数，那么直接除2先降一倍。接着求gcd(n,k)或gcd(m,k)，约分即可。如果为奇数，那么求p=gcd(2n,k)，如果2\n无法整除k，那么2*n一定要除一个数，使得x&lt;=n，可以看出要满足题目条件的化，一定存在gcd(2*m,k)&gt;=2，接下来就是约分的事了。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ll;ll gcd(ll a,ll b)&#123; return b==0?a:gcd(b,a%b);&#125;int main()&#123; ll n,m,k; scanf("%lld%lld%lld",&amp;n,&amp;m,&amp;k); if(n*m*2%k!=0) &#123; puts("NO"); return 0; &#125; else &#123; puts("YES"); puts("0 0"); if(k%2==0) &#123; k/=2; ll p=gcd(n,k); ll x=n/p;k/=p; ll y=m/k; printf("%lld 0\n",x); printf("0 %lld\n",y); return 0; &#125; ll p=gcd(2*n,k); if(p==1) &#123; p=gcd(2*m,k);// cout&lt;&lt;p&lt;&lt;endl; ll y=2*m/p; k/=p; ll x=n/k; printf("%lld 0\n",x); printf("0 %lld\n",y); return 0; &#125; ll x=2*n/p;k/=p; ll y=m/k; printf("%lld 0\n",x); printf("0 %lld\n",y); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The World is a Theatre CodeForces - 131C (组合数)]]></title>
    <url>%2F2019%2F09%2F12%2F%E6%95%B0%E5%AD%A6%2FThe%20World%20is%20a%20Theatre%20CodeForces%20-%20131C%20(%E7%BB%84%E5%90%88%E6%95%B0)%2F</url>
    <content type="text"><![CDATA[题目https://cn.vjudge.net/problem/CodeForces-131C There are n boys and m girls attending a theatre club. To set a play “The Big Bang Theory”, they need to choose a group containing exactly t actors containing no less than 4 boys and no less than one girl. How many ways are there to choose a group? Of course, the variants that only differ in the composition of the troupe are considered different. Perform all calculations in the 64-bit type: long long for С/С++, int64 for Delphi and long for Java. InputThe only line of the input data contains three integers n, m, t (4 ≤ n ≤ 30, 1 ≤ m ≤ 30, 5 ≤ t ≤ n + m). OutputFind the required number of ways. Please do not use the %lld specificator to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specificator. ExamplesInput15 2 5 Output110 Input14 3 5 Output13 思路这道题学到了组合数打表。 p[i][j]表示在i个中选j个有多少种选法，借助杨辉三角推法，得到p[i][j]=p[i-1][j-1]+p[i-1][j]l。 1234567const int MAXN=1000;dp[0][0]=1;for(int i=1;i&lt;MAXN;i++) &#123; dp[i][0]=1; for(int j=1;j&lt;=i;j++) dp[i][j]=dp[i-1][j]+dp[i-1][j-1];&#125; 那么对于这道题，就不断地枚举i（i&gt;=4）个男生k-i（k-i&gt;=1）个女生的组合方法就可以了。 代码1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ll;const int MAXN=400;ll dp[MAXN][MAXN];int main()&#123; dp[0][0]=1; for(int i=1;i&lt;MAXN;i++) &#123; dp[i][0]=1; for(int j=1;j&lt;=i;j++) dp[i][j]=dp[i-1][j]+dp[i-1][j-1]; &#125; ll n,m,k; scanf("%lld%lld%lld",&amp;n,&amp;m,&amp;k); ll ans=0; for(int i=4;i&lt;=k-1;i++) ans+=dp[n][i]*dp[m][k-i]; printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>组合数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Submarine in the Rybinsk Sea (hard edition) CodeForces - 1195D2 (算贡献)]]></title>
    <url>%2F2019%2F09%2F12%2F%E6%95%B0%E5%AD%A6%2FSubmarine%20in%20the%20Rybinsk%20Sea%20(hard%20edition)%20CodeForces%20-%201195D2%20(%E7%AE%97%E8%B4%A1%E7%8C%AE)%2F</url>
    <content type="text"><![CDATA[题目https://cn.vjudge.net/problem/CodeForces-1195D2 This problem differs from the previous one only in the absence of the constraint on the equal length of all numbers a1,a2,…,an. A team of SIS students is going to make a trip on a submarine. Their target is an ancient treasure in a sunken ship lying on the bottom of the Great Rybinsk sea. Unfortunately, the students don’t know the coordinates of the ship, so they asked Meshanya (who is a hereditary mage) to help them. He agreed to help them, but only if they solve his problem. Let’s denote a function that alternates digits of two numbers f(a1a2…ap−1ap,b1b2…bq−1bq), where a1…ap and b1…bq are digits of two integers written in the decimal notation without leading zeros. In other words, the function f(x,y) alternately shuffles the digits of the numbers x and y by writing them from the lowest digits to the older ones, starting with the number y. The result of the function is also built from right to left (that is, from the lower digits to the older ones). If the digits of one of the arguments have ended, then the remaining digits of the other argument are written out. Familiarize with examples and formal definitions of the function below. For example:f(1111,2222)=12121212f(7777,888)=7787878f(33,44444)=4443434f(555,6)=5556f(111,2222)=2121212Formally, if p≥q then f(a1…ap,b1…bq)=a1a2…ap−q+1b1ap−q+2b2…ap−1bq−1apbq;if p&lt;q then f(a1…ap,b1…bq)=b1b2…bq−pa1bq−p+1a2…ap−1bq−1apbq.Mishanya gives you an array consisting of n integers ai, your task is to help students to calculate ∑ni=1∑nj=1f(ai,aj) modulo 998244353. InputThe first line of the input contains a single integer n (1≤n≤100000) — the number of elements in the array. The second line of the input contains n integers a1,a2,…,an (1≤ai≤109) — the elements of the array. OutputPrint the answer modulo 998244353. ExamplesInput12312 3 45 Output112330 Input122123 456 Output11115598 思路这题其实跟那个简单版本的比较，变化的是每个数的位数不在一样。 其实解法是一样的，只是每个数遇到的数的位数变化，这样一来，上篇说的计算两种状态就要增加到计算十种状态，因为每个数都有可能遇到不同的位数的数，接着把每种状态对应的那些位数的个数统计出来，算到答案里面。这也就是算贡献了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ll;const int MAXN=1e5+10;const ll MOD=998244353;ll arr[MAXN];ll n;ll brr[MAXN][10][3];ll len[MAXN],pre[10];void debug()&#123; for(int i=1;i&lt;=9;i++) &#123; cout&lt;&lt;brr[1][i][1]&lt;&lt;endl; &#125;&#125;void cal1(ll x,ll index)&#123; ll j=100,t=1000; ll tmp1=x*10; brr[index][1][1]=tmp1; for(ll i=2;i&lt;=10;i++) &#123; tmp1=tmp1/j*t+tmp1%j; brr[index][i][1]=tmp1; j*=100; t*=100; &#125;// debug();&#125;void cal2(ll x,ll index)&#123; ll j=10,t=100; ll tmp1=x; for(ll i=1;i&lt;=10;i++) &#123; tmp1=tmp1/j*t+tmp1%j; brr[index][i][2]=tmp1; j*=100; t*=100; &#125;// debug();&#125;ll length(ll x)&#123; ll t=0; while(x) t++,x/=10;// cout&lt;&lt;t&lt;&lt;endl; return t;&#125;int main()&#123; scanf("%lld",&amp;n); for(ll i=1;i&lt;=n;i++) &#123; scanf("%lld",&amp;arr[i]); cal1(arr[i],i); cal2(arr[i],i); len[i]=length(arr[i]); pre[len[i]]++; &#125; ll ans=0; for(ll i=1;i&lt;=n;i++) &#123; for(ll j=1;j&lt;=10;j++) &#123; ans=(ans+(brr[i][j][1]%MOD)*(pre[j]%MOD)%MOD)%MOD; ans=(ans+brr[i][j][2]%MOD*pre[j]%MOD)%MOD; &#125; &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Submarine in the Rybinsk Sea (easy edition) CodeForces - 1195D1 (算贡献)]]></title>
    <url>%2F2019%2F09%2F12%2F%E6%95%B0%E5%AD%A6%2FSubmarine%20in%20the%20Rybinsk%20Sea%20(easy%20edition)%20CodeForces%20-%201195D1%20(%E7%AE%97%E8%B4%A1%E7%8C%AE)%2F</url>
    <content type="text"><![CDATA[题目https://cn.vjudge.net/problem/CodeForces-1195D1 This problem differs from the next one only in the presence of the constraint on the equal length of all numbers a1,a2,…,an. Actually, this problem is a subtask of the problem D2 from the same contest and the solution of D2 solves this subtask too. A team of SIS students is going to make a trip on a submarine. Their target is an ancient treasure in a sunken ship lying on the bottom of the Great Rybinsk sea. Unfortunately, the students don’t know the coordinates of the ship, so they asked Meshanya (who is a hereditary mage) to help them. He agreed to help them, but only if they solve his problem. Let’s denote a function that alternates digits of two numbers f(a1a2…ap−1ap,b1b2…bq−1bq), where a1…ap and b1…bq are digits of two integers written in the decimal notation without leading zeros. In other words, the function f(x,y) alternately shuffles the digits of the numbers x and y by writing them from the lowest digits to the older ones, starting with the number y. The result of the function is also built from right to left (that is, from the lower digits to the older ones). If the digits of one of the arguments have ended, then the remaining digits of the other argument are written out. Familiarize with examples and formal definitions of the function below. For example:f(1111,2222)=12121212f(7777,888)=7787878f(33,44444)=4443434f(555,6)=5556f(111,2222)=2121212Formally, if p≥q then f(a1…ap,b1…bq)=a1a2…ap−q+1b1ap−q+2b2…ap−1bq−1apbq;if p&lt;q then f(a1…ap,b1…bq)=b1b2…bq−pa1bq−p+1a2…ap−1bq−1apbq.Mishanya gives you an array consisting of n integers ai. All numbers in this array are of equal length (that is, they consist of the same number of digits). Your task is to help students to calculate ∑ni=1∑nj=1f(ai,aj) modulo 998244353. InputThe first line of the input contains a single integer n (1≤n≤100000) — the number of elements in the array. The second line of the input contains n integers a1,a2,…,an (1≤ai≤109) — the elements of the array. All numbers a1,a2,…,an are of equal length (that is, they consist of the same number of digits). OutputPrint the answer modulo 998244353. Examples Input12312 33 45 Output126730 Input122123 456 Output11115598 Input1211 Output111 Input1251000000000 1000000000 1000000000 1000000000 1000000000 Output1265359409 思路碰到这种题目怎么老是往暴力模拟的方向去想呢？暴力模拟肯定不行啊！ 这是简单版本的。可以知道给出每个数的位数都是相同的，那么按照题意给定的组合方法就是这些数中任意两个数每位数交替组合成一个新数，把这些新数全部加起来mod一个数得到答案。 而按照题意给定的组成新数的规则，我们可以大概模拟这样的情形。 当一个数（记为a，那么位数为a1a2a3……an）遇到另一个数(记为b，位数为b1b2b3……bn)时，那么数a就会变成为a10a20a30……an0，其中0的位置依次被数b的每位数插入。 而如果数a被其他的数遇到呢？就会变成这样。0a10a20a30……an，0的位置也是依次被别的数插入。 如此一来，对于每个数，都有两种状态，即上面说的两种，遇到其他数和被其他的数遇到。 而对于每个数的每种状态，都需要和数组中每个数去组合成新数，也就是每个数的每个状态都有被使用n次，这些都要被加到结果里面，这就是算答案贡献了。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ll;const int MAXN=1e5+10;const ll MOD=998244353;ll arr[MAXN];ll a[MAXN],b[MAXN];int n;ll len=0;void length(ll x) &#123; while(x) x/=10,len++;&#125;ll f1(ll x) &#123; ll j=10; ll ans=0; for(ll i=1;i&lt;=len;i++) &#123; ans=ans+x%10*j; j*=100; x/=10; &#125; return ans;&#125;ll f2(ll x) &#123; ll j=1; ll ans=0; for(ll i=1;i&lt;=len;i++) &#123; ans=ans+x%10*j; j*=100; x/=10; &#125; return ans;&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;arr[i]); length(arr[1]); ll ans=0; for(int i=1;i&lt;=n;i++) &#123; a[i]=f1(arr[i])%MOD; b[i]=f2(arr[i])%MOD; ans=(ans+n*a[i]%MOD)%MOD; ans=(ans+n*b[i]%MOD)%MOD; &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gcd(个人加深理解)]]></title>
    <url>%2F2019%2F09%2F12%2F%E6%95%B0%E5%AD%A6%2Fgcd%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[12345int gcd(int a,int b)&#123; return b==0?a:gcd(b,a%b);&#125;最大公约数val=gcd(a,b);最小公倍数val=a/gcd(a,b)*b;//防止a*b溢出 证明：a和b的最大公约数与b和a%b的最大公约数相同。设a和b的公约数为d，那么 a=nd ① b=md ②(n,m为自然数) 记a%b=r，可得a=bp+r ③将①、②代入③中，化简得(n-mp)d=r ④，d是r得约数，由②可知，d也是b得约数，所以d是b和r的公约数，即d是b和a%b的公约数，联立①②，d是a和b的公约数。 同理设d$’$是b和a%b的公约数，可求得d$’$也是a和b的公约数。 结论：a和b与b和a%b的公约数相同，那么它们的最大公约数也相同。]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>gcd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Traffic HDU - 6573]]></title>
    <url>%2F2019%2F09%2F12%2F%E6%8A%80%E5%B7%A7%E9%A2%98%2FTraffic%20HDU%20-%206573%20%2F</url>
    <content type="text"><![CDATA[题目https://cn.vjudge.net/problem/HDU-6573 Avin is observing the cars at a crossroads. He finds that there are n cars running in the east-west direction with the i-th car passing the intersection at time ai . There are another m cars running in the north-south direction with the i-th car passing the intersection at time bi . If two cars passing the intersections at the same time, a traffic crash occurs. In order to achieve world peace and harmony, all the cars running in the north-south direction wait the same amount of integral time so that no two cars bump. You are asked the minimum waiting time. Input The first line contains two integers n and m (1 ≤ n, m ≤ 1, 000). The second line contains n distinct integers ai (1 ≤ ai ≤ 1, 000). The third line contains m distinct integers bi (1 ≤ bi ≤ 1, 000). Output Print a non-negative integer denoting the minimum waiting time.Sample Input1234561 1111 221 3 Sample Output1210 思路刚开始做，确实是没理解题意。实际上题目要求的是，南北方向行驶的车整体停下来的时间，求这个最小值。 原先的做法：如果当前东西向的车与南北向的车在同一时间走，那么南北向车（记为a）就应该停下来，也就是停下来的时间加1，然后继续比较后面的车。实际上如果南北向后面的车（记为b）又与东西向的车通过时间相同，又要停下来，这时候b停下来2分钟，a只听了1分钟。这是不对的。南北向每辆车停的时间都要相同。 正确做法：从0开始枚举南北向停车时间，那么当南北向的（通过时间+停止时间）也就是真正的停车时间都与东西向的通过时间不同，这就是最小停止时间。 代码12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=1e4+10;int arr[MAXN],brr[MAXN];bool ta[MAXN],tb[MAXN];int main()&#123; int n,m; while(scanf("%d%d",&amp;n,&amp;m)!=EOF) &#123; memset(ta,false,sizeof(ta)); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;arr[i]),ta[arr[i]]=true; for(int i=1;i&lt;=m;i++) scanf("%d",&amp;brr[i]); int ans=0; while(true) &#123; memset(tb,false,sizeof(tb)); for(int i=1;i&lt;=m;i++) tb[brr[i]+ans]=true; int cnt=0; for(int i=1;i&lt;=2000;i++) if(ta[i]||tb[i]) cnt++; if(cnt==n+m) break; ans++; &#125; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>思维题</category>
      </categories>
      <tags>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rumor CodeForces - 893C]]></title>
    <url>%2F2019%2F09%2F12%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%2FRumor%20CodeForces%20-%20893C%2F</url>
    <content type="text"><![CDATA[题目Vova promised himself that he would never play computer games… But recently Firestorm — a well-known game developing company — published their newest game, World of Farcraft, and it became really popular. Of course, Vova started playing it. Now he tries to solve a quest. The task is to come to a settlement named Overcity and spread a rumor in it. Vova knows that there are n characters in Overcity. Some characters are friends to each other, and they share information they got. Also Vova knows that he can bribe each character so he or she starts spreading the rumor; i-th character wants ci gold in exchange for spreading the rumor. When a character hears the rumor, he tells it to all his friends, and they start spreading the rumor to their friends (for free), and so on.The quest is finished when all n characters know the rumor. What is the minimum amount of gold Vova needs to spend in order to finish the quest? Take a look at the notes if you think you haven’t understood the problem completely. InputThe first line contains two integer numbers n and m (1 ≤ n ≤ 105, 0 ≤ m ≤ 105) — the number of characters in Overcity and the number of pairs of friends. The second line contains n integer numbers ci (0 ≤ ci ≤ 109) — the amount of gold i-th character asks to start spreading the rumor. Then m lines follow, each containing a pair of numbers (xi, yi) which represent that characters xi and yi are friends (1 ≤ xi, yi ≤ n, xi ≠ yi). It is guaranteed that each pair is listed at most once. OutputPrint one number — the minimum amount of gold Vova has to spend in order to finish the quest. ExamplesInput12345 22 5 3 4 81 44 5 Output110 Input1210 01 2 3 4 5 6 7 8 9 10 Output155 Input123456710 51 6 2 7 3 8 4 9 5 101 23 45 67 89 10 Output115 NoteIn the first example the best decision is to bribe the first character (he will spread the rumor to fourth character, and the fourth one will spread it to fifth). Also Vova has to bribe the second and the third characters, so they know the rumor. In the second example Vova has to bribe everyone. In the third example the optimal decision is to bribe the first, the third, the fifth, the seventh and the ninth characters. 思路用并查集的思想把朋友关系合并在一起。在查找父节点的时候，把所有子节点的值赋0，合并的时候注意判断两者的父节点是否相同，若相同则会造成重复计算从而出错，在这个地方WA了n次，qwq。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int MAXN=10e5+5;int n,m;long long arr[MAXN];int parent[MAXN];int find(int x)&#123; int r=x; while(r!=parent[r])&#123; arr[r]=0; r=parent[r]; &#125; int i=x,j; while(i!=r)&#123; j=parent[i]; arr[i]=0; parent[i]=r; i=j; &#125; return r;&#125;void join(int x,int y)&#123; x=find(x); y=find(y); if(x!=y) //千万要注意 if(arr[x]&lt;=arr[y])&#123; parent[y]=x; arr[y]=0; &#125;else&#123; parent[x]=y; arr[x]=0; &#125;&#125;int main()&#123; while(cin&gt;&gt;n&gt;&gt;m)&#123; for(int i=1;i&lt;=n;i++)&#123; parent[i]=i; arr[i]=0; cin&gt;&gt;arr[i]; &#125; for(int i=1;i&lt;=m;i++)&#123; int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); join(a,b); &#125; long long ans=0; for(int i=1;i&lt;=n;i++) if(parent[i]==i) ans+=arr[i]; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj-2524-Ubiquitous Religions]]></title>
    <url>%2F2019%2F09%2F12%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%2Fpoj2524%2F</url>
    <content type="text"><![CDATA[描述Ubiquitous ReligionsTime Limit: 5000MS Memory Limit: 65536KTotal Submissions: 41487 Accepted: 19782Description There are so many different religions in the world today that it is difficult to keep track of them all. You are interested in finding out how many different religions students in your university believe in. You know that there are n students in your university (0 &lt; n &lt;= 50000). It is infeasible for you to ask every student their religious beliefs. Furthermore, many students are not comfortable expressing their beliefs. One way to avoid these problems is to ask m (0 &lt;= m &lt;= n(n-1)/2) pairs of students and ask them whether they believe in the same religion (e.g. they may know if they both attend the same church). From this data, you may not know what each person believes in, but you can get an idea of the upper bound of how many different religions can be possibly represented on campus. You may assume that each student subscribes to at most one religion.Input The input consists of a number of cases. Each case starts with a line specifying the integers n and m. The next m lines each consists of two integers i and j, specifying that students i and j believe in the same religion. The students are numbered 1 to n. The end of input is specified by a line in which n = m = 0.Output For each test case, print on a single line the case number (starting with 1) followed by the maximum number of different religions that the students in the university believe in.Sample Input1234567891011121314151610 91 21 31 41 51 61 71 81 91 1010 42 34 54 85 80 0 Sample Output12Case 1: 1Case 2: 7 Hint Huge input, scanf is recommended.Source Alberta Collegiate Programming Contest 2003.10.18 题解用并查集把所有人的关系求出来。对总人数遍历，若某人处于一个集合的受位置（根节点），说明有一个集合，将集合加起来。 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;using namespace std;const int MAXSIZE=50000+10;int parent[MAXSIZE];void create(int people)&#123; for(int i=1;i&lt;=people;i++) parent[i]=i;&#125;int findParent(int x)&#123; while(x!=parent[x]) x=parent[x]; return x;&#125;void unit(int x,int y)&#123; x=findParent(x); y=findParent(y); parent[x]=y; &#125; int main()&#123; int people,Case; int Count=1; while(cin&gt;&gt;people&gt;&gt;Case)&#123; if(people==0&amp;&amp;Case==0) break; create(people); while(Case--)&#123; int a,b; cin&gt;&gt;a&gt;&gt;b; unit(a,b); &#125; int ans=0; for(int i=1;i&lt;=people;i++)&#123; if(i==parent[i]) ans++; &#125; cout&lt;&lt;&quot;Case &quot;&lt;&lt;Count++&lt;&lt;&quot;: &quot;&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj-1611-The Suspects]]></title>
    <url>%2F2019%2F09%2F12%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%2Fpoj1611%2F</url>
    <content type="text"><![CDATA[描述The SuspectsTime Limit: 1000MS Memory Limit: 20000KTotal Submissions: 51831 Accepted: 24779Description Severe acute respiratory syndrome (SARS), an atypical pneumonia of unknown aetiology, was recognized as a global threat in mid-March 2003. To minimize transmission to others, the best strategy is to separate the suspects from others.In the Not-Spreading-Your-Sickness University (NSYSU), there are many student groups. Students in the same group intercommunicate with each other frequently, and a student may join several groups. To prevent the possible transmissions of SARS, the NSYSU collects the member lists of all student groups, and makes the following rule in their standard operation procedure (SOP).Once a member in a group is a suspect, all members in the group are suspects.However, they find that it is not easy to identify all the suspects when a student is recognized as a suspect. Your job is to write a program which finds all the suspects.Input The input file contains several cases. Each test case begins with two integers n and m in a line, where n is the number of students, and m is the number of groups. You may assume that 0 &lt; n &lt;= 30000 and 0 &lt;= m &lt;= 500. Every student is numbered by a unique integer between 0 and n−1, and initially student 0 is recognized as a suspect in all the cases. This line is followed by m member lists of the groups, one line per group. Each line begins with an integer k by itself representing the number of members in the group. Following the number of members, there are k integers representing the students in this group. All the integers in a line are separated by at least one space.A case with n = 0 and m = 0 indicates the end of the input, and need not be processed.Output For each case, output the number of suspects in one line.Sample Input12345678910100 42 1 25 10 13 11 12 142 0 12 99 2200 21 55 1 2 3 4 51 00 0 Sample Output123411 Source Asia Kaohsiung 2003 题解将0所在的集合的所有元素全部加起来即可。判断0与其他元素再同一个集合，仅需判断两元素根节点是否相同。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;iostream&gt;using namespace std;class Tree&#123; public: int data; int parent; int rank;&#125;;const int MAXSIZE=30000+5;Tree tree[MAXSIZE];void createTree(int people)&#123; for(int i=0;i&lt;people;i++)&#123; tree[i].data=i; tree[i].parent=i; tree[i].rank=0; &#125;&#125;int findParent(Tree tree[],int x)&#123; if(x!=tree[x].parent) findParent(tree,tree[x].parent); else return x;&#125;void unit(Tree tree[],int x,int y)&#123; x=findParent(tree,x); y=findParent(tree,y); if(tree[x].rank&gt;tree[y].rank)&#123; tree[y].parent=x; &#125; else&#123; tree[x].parent=y; if(tree[x].rank==tree[y].rank) tree[y].rank++; &#125; &#125;int main()&#123; int people,group; while(cin&gt;&gt;people&gt;&gt;group)&#123; if(people==0&amp;&amp;group==0) break; createTree(people); while(group--)&#123; int total; int num[MAXSIZE]; cin&gt;&gt;total; int a,b; cin&gt;&gt;a; for(int i=1;i&lt;total;i++)&#123; cin&gt;&gt;b; unit(tree,a,b); &#125; &#125; int result=1; int value=findParent(tree,0); //查找0元素的根节点 for(int i=1;i&lt;people;i++) if(value==findParent(tree,i)) result++; cout&lt;&lt;result&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HihoCoder-1066-无间道之并查集]]></title>
    <url>%2F2019%2F09%2F12%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%2Fhihocode-1066-%E6%97%A0%E9%97%B4%E9%81%93%E4%B9%8B%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[描述描述这天天气晴朗、阳光明媚、鸟语花香，空气中弥漫着春天的气息……额，说远了，总之，小Hi和小Ho决定趁着这朗朗春光出去玩。 但是刚刚离开居住的宾馆不久，抄近道不小心走入了一条偏僻小道的小Hi和小Ho就发现自己的前方走来了几个彪形大汉，定睛一看还都是地地道道的黑人兄弟！小Hi和小Ho这下就慌了神，捡肥皂事小，这一身百把来斤别一不小心葬身他乡可就没处说去了。 就在两人正举足无措之时，为首的黑叔叔从怀里掏出了一件东西——两张花花绿绿的纸，分别递给了小Hi和小Ho。小Hi和小Ho接过来，只见上面写道（译为中文）：“本地最大的帮派——青龙帮，诚邀您的加入！”下面还详细的列出了加入青龙帮的种种好处。 于是两人略感心安，在同黑叔叔们交谈一番之后，已是均感相见恨晚。同时，在小Hi和小Ho表示自己不日便将回国之后，黑叔叔们也没有再提加入帮派之事，但是那为首的黑叔叔思索一会，开口道（译为中文）：“我现在有一个难题，思索了很久也没法子解决，既然你们俩都是高材生，不如来帮我看看。” 小Hi和小Ho点了点头表示没问题，于是黑叔叔继续说道：“这个问题是这样的，我们帮派最近混进了许多警察的卧底，但是在我们的调查过程中只能够知道诸如‘某人和另一个人是同阵营的’这样的信息，虽然没有办法知道他们具体是哪个阵营的，但是这样的信息也是很重要的，因为我们经常会想要知道某两个人究竟是不是同一阵营的。” 小Hi和小Ho赞同的点了点头，毕竟无间道也都是他们看过的。 黑叔叔接着说道：“于是现在问题就来了，我希望你们能写出这样一个程序，我会有两种操作，一种是告诉它哪两个人是同一阵营的，而另一种是询问某两个人是不是同一阵营的……既然你们就要回国了，不如现在就去我们帮派的总部写好这个程序再走把。” 为了生命安全与……小Hi和小Ho都不得不解决这个问题！那么他们究竟从何下手呢？ 提示：说起来其实就是不断的合并集合嘛~×Close提示：说起来其实就是不断的合并集合嘛~到了青龙帮的总部，望着桌上的电脑，小Ho陷入了沉思，良久，抬起头向小Hi道：“小Hi，你看我这样做可以么，一开始我将每个人视作一个仅由他们自己组成的集合，每次遇见op=0的操作，实际上就是合并这两个人所在的两个集合，而每次遇见op=1的操作，实际上就是询问这两个人是否在同一个集合中。” “你说的很有道理。”小Hi点头道：“但是集合并不是计算机中直接就存在的一个基础类型，你准备用什么样的方式去实现这个集合呢？” “用Set……”小Ho道。 小Hi脸色一黑，道：“能不能有点追求啦，Set那底层实现都是红黑树什么的，你依靠别人的设计虽说没什么问题，但是为了知识水平的提高，自己学习一下还是很有必要的嘛！” “但是……这么短的时间里，你让我学红黑树，我也一时半会学不会吧。”小Ho表示为难。 “没让你用红黑树，我今天就教你一个非常简单的维护集合的方法——并查集。”小Hi道：“这个方法非常简单，就是在每个集合里选出一个代表元素，并且令这个集合里面的每一个元素都指向这个代表元素。像你之前所说‘一开始我将每个人视作一个仅由他们自己组成的集合’，也就是对于每一个人Name_i，都令represent[Name_i]=Name_i。” “那合并怎么办呢？”小Ho问道。 “合并的话首先你要看这两个人A和B所在的集合是不是同一个集合，也就是represent[A]和represent[B]是否相同，如果相同自然无需合并，否则就要把这两个集合合并是吧？” “你这话不等于没说么……”小Ho表示抗议。 小Hi无视了这抗议继续说道：“如果我令A’=represent[A],B’=represent[B]，那么我令represent[A’]=B’是否就在某种意义上将这两个集合合并了？” 小Ho道：“你这个……只改变了A所在集合中一个元素A’的represent值，但是这个集合中其他元素的represent值都没有发生改变啊？” 小Hi挥了挥手道：“别着急，你看，所有原来A所在集合中的元素都指向A’，而A’指向了B’，那么也就是A所在集合里的所有元素如果顺着这条链一直找寻下去，最终找到的那个就一定是它所在集合的代表元素？” “没错……” “所以我们就可以将寻找代表元素，也就是求解represent值这个过程做成一个迭代的过程，比如求解X所在集合的represent值，我先令X’=represent[X]，如果X’=X的话，那么就能说明X所在集合的代表元素就是X本身，否则就令X’’=represent[X’]，如果X’’=X’的话那么就能说明X所在集合的代表元素就是X’……一直持续这样的操作就能够找到最终的集合代表元素了。”小Hi说着说着在纸上写了几行代码递了过来：“就像这样。” 小Ho仔细想了想，继续问道：“但是如果每次合并都是将一条链接到另外一个点上，这样的操作会不会特别的没有效率，接近O(N^2)了？” “是会有这个问题，但是你很容易就注意到——合并这个操作是不可逆的，也就是说如果我求解出了X所在集合的代表元素是X_r的话，那么我就可以直接令represent[X]=X_r，这样就可以避免在下一次询问X所在集合的代表元素的时候再进行一次这样的计算了。”言罢，小Hi将之前写下的代码稍作修改，又递了过来。 “原来是这样，那么我的合并操作实际上就是令represent[find_represent(A)]=find_represent(B)，而询问操作就是判断find_represent(A)和find_represent(B)是否想通了？”小Ho道。 “没错呢！所以赶紧开始写把！，呆久了我可不知道会发生什么呢！” 输入每个测试点（输入文件）有且仅有一组测试数据。 每组测试数据的第1行为一个整数N，表示黑叔叔总共进行的操作次数。 每组测试数据的第2~N+1行，每行分别描述黑叔叔的一次操作，其中第i+1行为一个整数op_i和两个由大小写字母组成的字符串Name1_i, Name2_i，其中op_i只可能为0或1，当op_i=0时，表示黑叔叔判定Name1_i和Name2_i是同一阵营的，当op_i=1时，表示黑叔叔希望知道Name1_i和Name2_i是否为同一阵营的。 对于100%的数据，满足N&lt;=10^5, 且数据中所有涉及的人物中不存在两个名字相同的人（即姓名唯一的确定了一个人），对于所有的i，满足Name1_i和Name2_i是不同的两个人。 输出对于每组测试数据，对于黑叔叔每次op_i=1的操作，输出一行，表示查询的结果：如果根据已知信息（即这次操作之前的所有op_i=0的操作），可以判定询问中的两个人是同一阵营的，则输出yes，否则输出no。 Sample Input1234567891011100 Steven David0 Lcch Dzx1 Lcch Dzx1 David Dzx0 Lcch David0 Frank Dzx1 Steven Dzx1 Frank David0 Steven Dzx0 Dzx Frank Sample Output1234yesnoyesyes 题解这道题学到了map的用法，好开心。把每一个人名在map中比较下，找到下标位置，然后直接套用并查集。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;cstdlib&gt;using namespace std;const int MAXSIZE=500000+10;map&lt;string,int&gt;mp;int k=0;int parent[MAXSIZE];int toParse(string str)&#123; if(mp.count(str)) return mp[str]; else&#123; mp[str]=k++; return mp[str]; &#125;&#125;void create()&#123; for(int i=0;i&lt;MAXSIZE;i++) parent[i]=i;&#125;int find(int x)&#123; while(x!=parent[x]) //找根节点 x=parent[x]; return x;&#125;void unit(int x,int y)&#123; x=find(x); y=find(y); if(x!=y) //直接合并集合 parent[x]=y;&#125;int main()&#123; int total; cin&gt;&gt;total; create(); k=0; while(total--)&#123; int flag; string str1,str2; cin&gt;&gt;flag&gt;&gt;str1&gt;&gt;str2; if(mp.count(str1)==0) mp[str1]=k++; if(mp.count(str2)==0) mp[str2]=k++; if(flag==1) if(find(mp[str1])==find(mp[str2])) cout&lt;&lt;&quot;yes&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;no&quot;&lt;&lt;endl; else unit(mp[str1],mp[str2]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ordered Binary String HihoCoder - 1326 (前缀和)]]></title>
    <url>%2F2019%2F09%2F12%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%2FOrdered%20Binary%20String%20HihoCoder%20-%201326%20%EF%BC%88%E5%89%8D%E7%BC%80%E5%92%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目https://cn.vjudge.net/problem/HihoCoder-1326 Given a binary string S, you can change one digit (from 0 to 1 or from 1 to 0) at a time. So what is the minimum number of changes needed to change S into an ordered binary string (every 0 is before the 1s) ? InputThe first line contains an integer T, the number of the test cases. (1 ≤ T ≤ 10) Then follows T lines. Each line contains a binary string S. (1 ≤ |S| ≤ 1000) OutputFor each test case output the answer. Sample Input 12343000111010001100000 Sample Output 123011 思路这道题没有写出来真是太不应该了，深刻反省自己。本来在比赛中已经想出来了正确的解法，写出毒来了，这是一个很严重的问题！！！有思路，但是写代码还是磕磕绊绊，这就要好好花时间练一下那些基础题和大模拟题了。 将连续的0和1的个数求出来，会得到01相间的包含它们个数的数组，假如字符串为0000111000101，那么得到p[]={4,3,3,1,1,1}。 对于这样的一个p数组，假如字符串第一位为’0’的话，那么就可以直接跳到p的第二位，也就是说，对于后面存的值，是101010……或1010101……（区别在于最后一位数，但实际上好像也并没有关系）形式存的连续个数，接着看。 经过上面判’0’的的操作，可以知道i目前处于p数组的第几位。拿第i位和第i+1位存的元素比较，这里可以知道，第i位代表的一定是1，存的是1的连续的个数，第i+1位代表的是0，存的是0的连续的个数。 如果第i位的值小于第i+1位的值，也就是说前i+1段，1的个数小于0的个数，按照题目要求，0在1前面并且要步数最少，这样就可以把1转化为0，这样，贡献为p[i]。如果第i位的值大于第i+1位的值，这时不能简单粗暴的把0转化为1，因为后面0的个数有可能比1的个数多，把这两者的状态值存下来，依此比较后面的p[i+2]和p[i+3]等的值了。直到最后全部比较完，即是答案。 其实这个题，我还有一个困惑的地方，题目说0一定要在1前面，我在想是不是字符串中一定要包含0呢？比赛中在想这个问题，导致一直思考解决这一情况的方法，导致代码写出毒了，说到底还是基础不扎实。 毒代码附上，警醒自己。123456789101112for(;i&lt;cnt-1;) &#123; if((dp[i]+tmpx)&lt;=(dp[i+1]+tmpy)) &#123; ans+=dp[i]; //这里的ans应该是加dp[i]+tmpx，出毒 tmpx=tmpy=0; i+=2; &#125; else &#123; tmpx+=dp[i]; tmpy+=dp[i+1]; i+=2; &#125;&#125; 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=1e5+10;char str[MAXN];int dp[MAXN];int cnt;void debug()&#123; for(int i=0;i&lt;cnt;i++) cout&lt;&lt;dp[i]&lt;&lt;' ';&#125;int main()&#123; int t; scanf("%d",&amp;t); while(t--) &#123; scanf("%s",str); int len=strlen(str); int p=1; cnt=0; for(int i=0;i&lt;len-1;i++) if(str[i]==str[i+1]) p++; else dp[cnt++]=p,p=1; dp[cnt++]=p;// debug(); int tmp0=0,tmp1=0; int i=0; if(str[0]=='0') i++; int ans=0; for(;i&lt;cnt-1;i+=2) &#123; tmp1+=dp[i]; tmp0+=dp[i+1]; if(tmp1&lt;=tmp0) &#123; ans+=tmp1; tmp0=tmp1=0; &#125; &#125; ans+=min(tmp0,tmp1); printf("%d\n",ans); &#125; return 0;&#125;/*123001100011111110011*/]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Camp Schedule CodeForces - 1138D(KMP)]]></title>
    <url>%2F2019%2F09%2F12%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%2FCamp%20Schedule%20CodeForces%20-%201138D%20%EF%BC%88KMP%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目https://cn.vjudge.net/problem/CodeForces-1138D The new camp by widely-known over the country Spring Programming Camp is going to start soon. Hence, all the team of friendly curators and teachers started composing the camp’s schedule. After some continuous discussion, they came up with a schedule s, which can be represented as a binary string, in which the i-th symbol is ‘1’ if students will write the contest in the i-th day and ‘0’ if they will have a day off. At the last moment Gleb said that the camp will be the most productive if it runs with the schedule t (which can be described in the same format as schedule s). Since the number of days in the current may be different from number of days in schedule t, Gleb required that the camp’s schedule must be altered so that the number of occurrences of t in it as a substring is maximum possible. At the same time, the number of contest days and days off shouldn’t change, only their order may change. Could you rearrange the schedule in the best possible way? InputThe first line contains string s (1⩽|s|⩽500000), denoting the current project of the camp’s schedule. The second line contains string t (1⩽|t|⩽500000), denoting the optimal schedule according to Gleb. Strings s and t contain characters ‘0’ and ‘1’ only. OutputIn the only line print the schedule having the largest number of substrings equal to t. Printed schedule should consist of characters ‘0’ and ‘1’ only and the number of zeros should be equal to the number of zeros in s and the number of ones should be equal to the number of ones in s. In case there multiple optimal schedules, print any of them. ExamplesInput12101101110 Output1110110 Input1210010110100011 Output101100011 Input121011100 Output101 NoteIn the first example there are two occurrences, one starting from first position and one starting from fourth position. In the second example there is only one occurrence, which starts from third position. Note, that the answer is not unique. For example, if we move the first day (which is a day off) to the last position, the number of occurrences of t wouldn’t change. In the third example it’s impossible to make even a single occurrence. 思路题目意思：有一个模式串s，有一个目标串t，问让s串任意组合能构成包含t串最多的字符串是什么。 那么只需要求出目标串t的前缀和后缀最长相同的串的长度即可，以这个长度为跳板，当组成一个t串后可以立即这个t串的后缀为下个t串的前缀。求最长相同串的长度用KMP求Next数组即可。 其实这个题在比赛中应该是要写出来的，写不出的原因就是当时脑袋感觉已经要爆炸了，代码写出来已经看不得了，不知道写的是个什么东西，就是一堆杂乱无章的字母组合在一起，不能叫代码了。 深刻反思自己，为什么老是在这种需要清晰头脑思考细节的时候，不能控制自己的思维任其乱飞，把代码写的一团糟。以后写题目一定要在脑子里全部想清楚该怎么解决再动手，切忌思维一片混沌就开始写出的不知道是个什么东西。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=1e6+10;char str1[MAXN],str2[MAXN];int Next[MAXN];void getNext()&#123; Next[0]=-1; int i=0,j=-1; while(str2[i]!='\0') &#123; if(j==-1||str2[i]==str2[j]) &#123; i++; j++; Next[i]=j; &#125; else j=Next[j]; &#125;&#125;int main()&#123; scanf("%s%s",str1,str2); int len1=strlen(str1); int len2=strlen(str2); getNext();// for(int i=0;i&lt;=len2;i++)// cout&lt;&lt;Next[i]&lt;&lt;' '; int cnt0=0,cnt1=0; for(int i=0;i&lt;len1;i++) if(str1[i]=='0') cnt0++; else cnt1++; for(int i=0;;i++) &#123; if(i==len2) i=Next[len2]; if(str2[i]=='0') if(cnt0) printf("0"),cnt0--; else break; if(str2[i]=='1') if(cnt1) printf("1"),cnt1--; else break; &#125; while(cnt0) printf("0"),cnt0--; while(cnt1) printf("1"),cnt1--; return 0;&#125;]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串-KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[银联极客第二场-码队GO（dp）]]></title>
    <url>%2F2019%2F09%2F12%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F%E9%93%B6%E8%81%94%E6%9E%81%E5%AE%A22-%E7%A0%81%E9%98%9FGO%2F</url>
    <content type="text"><![CDATA[题目码队最近开发了一款基于虚拟现实的「码队GO」寻宝手游，他打算在银联唐镇园区里测试这个游戏。这个游戏规定，必须选择一个正方形的空旷区域来寻宝。但银联唐镇园区里有很多地方都会有各种各样的障碍物，码队想要请你帮忙，帮他找到一个最佳的游戏测试区域。 问题可以看成一个n×m 的方格，共有 n 行 m 列，每个小方格由 和 . 表示。（ 代表是障碍物， . 代表是空地）。你需要在这片区域上选择一个面积最大的正方形，且保证这个正方形内是没有障碍物的。 请你帮助码队找到这个最佳的正方形区域。 输入格式 有多组数据。 第一行输入一个整数，表示有 T 组数据（ 1≤T≤20 ）。 对于每一组测试数据：第一行输入两个整数 n,m，以空格分隔，表示方格为 n 行，m 列（1≤n,m≤300 ）。 接下来输入 nn 行 mm 列方格，字符与字符之间无空格（字符仅可能为 * 或 .）。 输出格式对于每一组测试数据，输出一行。 每行只包含一个整数，表示这个面积最大的正方形的面积。 输出时每行末尾的多余空格，不影响答案正确性 样例输入11234513 3***.***.. 样例输出111 样例输入21234513 5.*............. 样例输出219 思路给定一个矩阵，问最大的只包含.的正方形的面积是多少。可以知道，如果拿一个点当成正方形的右下角的顶点的话，该点能否构成正方形，由它左边、上边和左上方有多少.决定，而由正方形的性质可知，取三者最小值，就是该点能够构成的正方形的最大边长。转移方程为dp[i][j]=min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1])+1; 代码1234567891011121314151617181920212223242526272829303132333435363738#pragma GCC optimize(2)#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=305;int n,m;char str[MAXN][MAXN];int ans=0;int dp[MAXN][MAXN];void init() &#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%s",str[i]+1);&#125;void solve()&#123; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=m;j++) &#123; if(str[i][j]=='.') dp[i][j]=min(dp[i-1][j-1],min(dp[i-1][j],dp[i][j-1]))+1; ans=max(ans,dp[i][j]); &#125; &#125;&#125;int main()&#123; int T; scanf("%d",&amp;T); while(T--) &#123; ans=0; memset(dp,0,sizeof(dp)); init(); solve(); printf("%d\n",ans*ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[超级楼梯 HDU - 2041 （简单dp）]]></title>
    <url>%2F2019%2F09%2F12%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F%E8%B6%85%E7%BA%A7%E6%A5%BC%E6%A2%AF%20HDU%20-%202041%20%EF%BC%88%E7%AE%80%E5%8D%95dp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目有一楼梯共M级，刚开始时你在第一级，若每次只能跨上一级或二级，要走上第M级，共有多少种走法？Input输入数据首先包含一个整数N，表示测试实例的个数，然后是N行数据，每行包含一个整数M（1&lt;=M&lt;=40）,表示楼梯的级数。Output对于每个测试实例，请输出不同走法的数量Sample Input123223 Sample Output1212 思路对于第n（n&gt;3）级阶梯，可由n-2级阶梯走2步或者由n-1级阶梯走1步到达，可得状态转移方程dp[n]=dp[n-1]+dp[n-2] 代码1234567891011121314151617#include&lt;iostream&gt;using namespace std;int main()&#123; int N; int dp[41]; dp[2]=1; dp[3]=2; for(int i=4;i&lt;=40;i++) dp[i]=dp[i-1]+dp[i-2]; cin&gt;&gt;N; while(N--)&#123; int a; cin&gt;&gt;a; cout&lt;&lt;dp[a]&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最长上升子序列 CSU - 1047]]></title>
    <url>%2F2019%2F09%2F12%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%20CSU%20-%201047%20%2F</url>
    <content type="text"><![CDATA[题目名词解释： 一串数字比如1、5、3、6、9、8、10，它的子序列是从左到右不连续的若干个数，比如1、5、6，3、9、8、10都是它的子序列。 最长上升子序列即从左到右严格增长的最长的一个子序列，1、5、6、9、10就是这个序列的一个最长上升子序列。 给出若干序列，求出每个序列的最长上升子序列长度。Input 多组数据，每组第一行正整数n，1 &lt;= n &lt;= 1000，第二行n个空格隔开的不大于1,000,000的正整数。 Output 每组数据输出一行，最长上升子序列的长度。 Sample Input1271 5 3 6 9 8 10 Sample Output15 思路若一个序列为a[n]，记录当前元素的最长上升序列的长度为dp[n]。每个元素要满足1# 代码 #include #includeusing namespace std;const int MAXSIZE=1000+5;int getMax(int dp[],int arr[],int x){ int max=0; for(int i=0;i&lt;x;i++) //求0-x间的最大dp if(arr[i]&lt;arr[x]){ if(dp[i]&gt;max) max=dp[i]; } return max;}int main(){ int dp[MAXSIZE]; int arr[MAXSIZE]; int n; while(cin&gt;&gt;n){ for(int i=0;i&lt;n;i++){ scanf(“%d”,&amp;arr[i]); dp[i]=1; } for(int i=1;i&lt;n;i++) dp[i]+=getMax(dp,arr,i); int ans=0; for(int i=0;i&lt;n;i++) if(ans&lt;dp[i]) ans=dp[i]; cout&lt;&lt;ans&lt;&lt;endl; } return 0;}`]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数塔 HDU - 2084]]></title>
    <url>%2F2019%2F09%2F12%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F%E6%95%B0%E5%A1%94%20HDU%20-%202084%20%2F</url>
    <content type="text"><![CDATA[题目在讲述DP算法的时候，一个经典的例子就是数塔问题，它是这样描述的： 有如下所示的数塔，要求从顶层走到底层，若每一步只能走到相邻的结点，则经过的结点的数字之和最大是多少？ 已经告诉你了，这是个DP的题目，你能AC吗?Input输入数据首先包括一个整数C,表示测试实例的个数，每个测试实例的第一行是一个整数N(1 &lt;= N &lt;= 100)，表示数塔的高度，接下来用N行数字表示数塔，其中第i行有个i个整数，且所有的整数均在区间[0,99]内。Output对于每个测试实例，输出可能得到的最大和，每个实例的输出占一行。Sample Input12345671573 88 1 0 2 7 4 44 5 2 6 5 Sample Output130 思路对每一个节点，受它肩上的两个节点值的影响。即1dp[i][j]+=dp[i-1][j-1] 或1dp[i][j]+=dp[i-1][j] 要求最大的节点路径，只需要加上两个节点值取大的那个即可。最后比较最底层的路径值。 代码12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;using namespace std;const int MAXSIZE=100+5;int dp[MAXSIZE][MAXSIZE];int main()&#123; int Case; cin&gt;&gt;Case; while(Case--)&#123; int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=i;j++) cin&gt;&gt;dp[i][j]; dp[2][1]+=dp[1][1]; dp[2][2]+=dp[1][1]; for(int i=3;i&lt;=n;i++)&#123; dp[i][1]+=dp[i-1][1]; dp[i][i]+=dp[i-1][i-1]; &#125; for(int i=3;i&lt;=n;i++)&#123; for(int j=2;j&lt;i;j++)&#123; int temp=dp[i][j]+dp[i-1][j-1]; if(temp&gt;=(dp[i][j]+dp[i-1][j])) dp[i][j]=temp; else dp[i][j]+=dp[i-1][j]; &#125; &#125; int ans=0; for(int i=1;i&lt;=n;i++) if(dp[n][i]&gt;ans) ans=dp[n][i]; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[投掷硬币 HihoCoder - 1506 (简单概率dp)]]></title>
    <url>%2F2019%2F09%2F12%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F%E6%8A%95%E6%8E%B7%E7%A1%AC%E5%B8%81%20HihoCoder%20-%201506%20(%E6%A6%82%E7%8E%87dp)%2F</url>
    <content type="text"><![CDATA[题目https://cn.vjudge.net/problem/HihoCoder-1506 小Hi有一枚神奇的硬币。已知第i次投掷这枚硬币时，正面向上的概率是Pi。 现在小Hi想知道如果总共投掷N次，其中恰好M次正面向上的概率是多少。 Input第一行包含两个整数N和M。 第二行包含N个实数P1, P2, … PN。 对于30%的数据，1 &lt;= N &lt;= 20 对于100%的数据，1 &lt;= N &lt;= 1000, 0 &lt;= M &lt;= N, 0 &lt;= Pi &lt;= 1 Output输出一行一个实数表示恰好M次正面向上的概率。注意行末需要包含一个换行符’\n’。 输出与标准答案误差在0.001以内都被视为正确。 Sample Input122 10.5 0.5 Sample Output10.500000 思路概率dp入门。定义dp[i][j]为抛i枚硬币有j枚正面朝上。那么如果这次抛的正面朝上，就变成了抛i-1枚硬币有j-1枚硬币正面朝上，即dp[i-1][j-1]*p[i]；如果这次没有抛中，就变成抛i-1枚硬币有j枚正面朝上，即dp[i-1][j]*(1-p[i])。即dp[i][j]+=dp[i-1][j-1]*p[i]+dp[i-1][j]*(1-p[i])。 代码123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=1e3+10;double dp[MAXN][MAXN];int n,m;double p[MAXN];int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%lf",&amp;p[i]); memset(dp,0,sizeof(dp)); dp[1][0]=(1-p[1]); dp[1][1]=p[1]; for(int i=1;i&lt;=n;i++) dp[i][0]+=dp[i-1][0]*(1-p[i]); for(int i=2;i&lt;=n;i++) &#123; for(int j=1;j&lt;=i;j++) dp[i][j]+=dp[i-1][j-1]*p[i]+dp[i-1][j]*(1-p[i]); &#125; printf("%.5f\n",dp[n][m]); return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>概率dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一只小蜜蜂... HDU - 2044 (简单dp)]]></title>
    <url>%2F2019%2F09%2F12%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F%E4%B8%80%E5%8F%AA%E5%B0%8F%E8%9C%9C%E8%9C%82...%20HDU%20-%202044%20(%E7%AE%80%E5%8D%95dp)%2F</url>
    <content type="text"><![CDATA[题目有一只经过训练的蜜蜂只能爬向右侧相邻的蜂房，不能反向爬行。请编程计算蜜蜂从蜂房a爬到蜂房b的可能路线数。其中，蜂房的结构如下所示。 Input输入数据的第一行是一个整数N,表示测试实例的个数，然后是N 行数据，每行包含两个整数a和b(0&lt;a&lt;b&lt;50)。Output对于每个测试实例，请输出蜜蜂从蜂房a爬到蜂房b的可能路线数，每个实例的输出占一行。Sample Input12321 23 6 Sample Output1213 思路由蜂房的结构可以看到，蜂房1可以直接到达蜂房3，蜂房2也可以直接达到蜂房3，那么到达蜂房3的路线为蜂房1的路线加蜂房2的路线，递推公式12此题注意数值范围，（long long int ）。# 代码 #includeusing namespace std;int main(){ int n; long long int dp[550]; dp[1]=1; dp[2]=1; cin&gt;&gt;n; while(n–){ int a,b; cin&gt;&gt;a&gt;&gt;b; dp[a]=1; dp[a+1]=1; for(int i=a+2;i&lt;=b;i++) dp[i]=dp[i-1]+dp[i-2]; cout&lt;&lt;dp[b]&lt;&lt;endl; } return 0;}`]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Max Sum HDU - 1003]]></title>
    <url>%2F2019%2F09%2F12%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2FMax%20Sum%20HDU%20-%201003%20%2F</url>
    <content type="text"><![CDATA[题目Given a sequence a[1],a[2],a[3]……a[n], your job is to calculate the max sum of a sub-sequence. For example, given (6,-1,5,4,-7), the max sum in this sequence is 6 + (-1) + 5 + 4 = 14.InputThe first line of the input contains an integer T(1&lt;=T&lt;=20) which means the number of test cases. Then T lines follow, each line starts with a number N(1&lt;=N&lt;=100000), then N integers followed(all the integers are between -1000 and 1000).OutputFor each test case, you should output two lines. The first line is “Case #:”, # means the number of the test case. The second line contains three integers, the Max Sum in the sequence, the start position of the sub-sequence, the end position of the sub-sequence. If there are more than one result, output the first one. Output a blank line between two cases.Sample Input12325 6 -1 5 4 -77 0 6 -1 1 -6 7 -5 Sample Output12345Case 1:14 1 4Case 2:7 1 6 思路dp[i]=max{dp[i-1]+arr[i],arr[i]},0&lt;=i&lt;n 代码1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int MAXSIZE=100000+5;int arr[MAXSIZE]; int main()&#123; int T; cin&gt;&gt;T; int t=1; while(T--)&#123; int N; cin&gt;&gt;N; for(int i=1;i&lt;=N;i++) scanf("%d",&amp;arr[i]); int besti=1,bestj=1,tempi=1; int ans=arr[1],sum=arr[1]; for(int i=2;i&lt;=N;i++)&#123; if(sum&lt;0) &#123; sum=0; tempi=i; &#125; sum+=arr[i]; if(ans&lt;sum)&#123;ans=sum;besti=tempi;bestj=i;&#125; &#125; // printf("Case ");// cout&lt;&lt;t++&lt;&lt;":"&lt;&lt;endl&lt;&lt;ans&lt;&lt;" "&lt;&lt;besti&lt;&lt;" "&lt;&lt;bestj&lt;&lt;" "&lt;&lt;endl; printf("Case %d:\n%d %d %d\n",t++,ans,besti,bestj); if(T) printf("\n");// if(T)cout&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Longest Ordered Subsequence POJ - 2533]]></title>
    <url>%2F2019%2F09%2F12%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2FLongest%20Ordered%20Subsequence%20POJ%20-%202533%2F</url>
    <content type="text"><![CDATA[题目A numeric sequence of ai is ordered if a1 &lt; a2 &lt; … &lt; aN. Let the subsequence of the given numeric sequence ( a1, a2, …, aN) be any sequence ( ai1, ai2, …, aiK), where 1 &lt;= i1 &lt; i2 &lt; … &lt; iK &lt;= N. For example, sequence (1, 7, 3, 5, 9, 4, 8) has ordered subsequences, e. g., (1, 7), (3, 4, 8) and many others. All longest ordered subsequences are of length 4, e. g., (1, 3, 5, 8).Your program, when given the numeric sequence, must find the length of its longest ordered subsequence.InputThe first line of input file contains the length of sequence N. The second line contains the elements of sequence - N integers in the range from 0 to 10000 each, separated by spaces. 1 &lt;= N &lt;= 1000OutputOutput file must contain a single integer - the length of the longest ordered subsequence of the given sequence.Sample Input1271 7 3 5 9 4 8 Sample Output14 思路dp[i]=max(dp[j]){0&lt;=j&lt;i} 代码1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;using namespace std;const int MAXSIZE=1005;int dp[MAXSIZE];int arr[MAXSIZE];int find(int x)&#123; int max=0,j=0; for(int i=0;i&lt;x;i++) if(max&lt;dp[i]&amp;&amp;arr[x]&gt;arr[i])&#123; max=dp[i]; j=i; &#125; return max;&#125; int main()&#123; int N; cin&gt;&gt;N; for(int i=0;i&lt;N;i++)&#123; cin&gt;&gt;arr[i]; dp[i]=1; &#125; for(int i=1;i&lt;N;i++) dp[i]+=find(i); int ans=0; for(int i=0;i&lt;N;i++) if(ans&lt;dp[i]) ans=dp[i]; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Common Subsequence POJ - 1458]]></title>
    <url>%2F2019%2F09%2F12%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2FCommon%20Subsequence%20POJ%20-%201458%2F</url>
    <content type="text"><![CDATA[题目A subsequence of a given sequence is the given sequence with some elements (possible none) left out. Given a sequence X = &lt; x1, x2, …, xm &gt; another sequence Z = &lt; z1, z2, …, zk &gt; is a subsequence of X if there exists a strictly increasing sequence &lt; i1, i2, …, ik &gt; of indices of X such that for all j = 1,2,…,k, x ij = zj. For example, Z = &lt; a, b, f, c &gt; is a subsequence of X = &lt; a, b, c, f, b, c &gt; with index sequence &lt; 1, 2, 4, 6 &gt;. Given two sequences X and Y the problem is to find the length of the maximum-length common subsequence of X and Y.InputThe program input is from the std input. Each data set in the input contains two strings representing the given sequences. The sequences are separated by any number of white spaces. The input data are correct.OutputFor each set of data the program prints on the standard output the length of the maximum-length common subsequence from the beginning of a separate line.Sample Input123abcfbc abfcabprogramming contest abcd mnp Sample Output123420 思路dp简单应用题。 dp[i][j]=0，{i=0或者j=0} dp[i-1][j-1]+1，{str1[i]==str2[j]，x&gt;0&amp;&amp;y&gt;0} max{dp[i-1][j],dp[i][j-1]}，{str1[i]!=str2[j]，x&gt;0&amp;&amp;y&gt;0} 代码123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;cstring&gt;using namespace std;const int MAXSIZE=1000;int dp[MAXSIZE][MAXSIZE];int main()&#123; string str1=&quot;&quot;,str2=&quot;&quot;; while(cin&gt;&gt;str1&gt;&gt;str2)&#123; memset(dp,0,sizeof(dp)); int len1=str1.length(); int len2=str2.length(); for(int i=0;i&lt;len1;i++) dp[i][0]=0; for(int i=0;i&lt;len2;i++) dp[0][i]=0; for(int i=1;i&lt;=len1;i++) for(int j=1;j&lt;=len2;j++)&#123; if(str1[i-1]==str2[j-1]) dp[i][j]=dp[i-1][j-1]+1; else dp[i][j]=max(dp[i-1][j],dp[i][j-1]); &#125; cout&lt;&lt;dp[len1][len2]&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>简单题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Basketball Exercise CodeForces - 1195C (线性dp)]]></title>
    <url>%2F2019%2F09%2F12%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2FBasketball%20Exercise%20CodeForces%20-%201195C%20(%E7%BA%BF%E6%80%A7dp)%2F</url>
    <content type="text"><![CDATA[题目https://cn.vjudge.net/problem/CodeForces-1195C Finally, a basketball court has been opened in SIS, so Demid has decided to hold a basketball exercise session. 2⋅n students have come to Demid’s exercise session, and he lined up them into two rows of the same size (there are exactly n people in each row). Students are numbered from 1 to n in each row in order from left to right. Now Demid wants to choose a team to play basketball. He will choose players from left to right, and the index of each chosen player (excluding the first one taken) will be strictly greater than the index of the previously chosen player. To avoid giving preference to one of the rows, Demid chooses students in such a way that no consecutive chosen students belong to the same row. The first student can be chosen among all 2n students (there are no additional constraints), and a team can consist of any number of students. Demid thinks, that in order to compose a perfect team, he should choose students in such a way, that the total height of all chosen students is maximum possible. Help Demid to find the maximum possible total height of players in a team he can choose. InputThe first line of the input contains a single integer n (1≤n≤105) — the number of students in each row. The second line of the input contains n integers h1,1,h1,2,…,h1,n (1≤h1,i≤109), where h1,i is the height of the i-th student in the first row. The third line of the input contains n integers h2,1,h2,2,…,h2,n (1≤h2,i≤109), where h2,i is the height of the i-th student in the second row. OutputPrint a single integer — the maximum possible total height of players in a team Demid can choose. ExamplesInput12359 3 5 7 35 8 1 4 5 Output129 Input12331 2 910 1 1 Output119 Input123174 Output17 思路考虑某个元素取还是不取应该由5个元素决定，假设这个元素是xi，那么与它同在一行决定它的元素就是xi-3和xi-2,与它不在一行决定它的元素就是yi-3、yi-2和yi-1。dp[i][j]表示在第i行第j个元素能取到的最大元素。状态转移为:12dp[2][i]=max(max(dp[1][i-3]+brr[i-2]+arr[i-1],dp[2][i-3]+max(arr[i-2],arr[i-1])),max(dp[2][i-2]+arr[i-1],dp[1][i-2]))+brr[i];dp[1][i]=max(max(dp[2][i-3]+arr[i-2]+brr[i-1],dp[1][i-3]+max(brr[i-1],brr[i-2])),max(dp[1][i-2]+brr[i-1],dp[2][i-2]))+arr[i]; 代码123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN=1e5+100;ll dp[3][MAXN];ll arr[MAXN],brr[MAXN];int n;int main()&#123; scanf("%d",&amp;n); for(int i=3;i&lt;=n+2;i++) scanf("%lld",&amp;arr[i]); for(int i=3;i&lt;=n+2;i++) scanf("%lld",&amp;brr[i]); memset(dp,0,sizeof(dp)); for(int i=3;i&lt;=n+2;i++) &#123; dp[2][i]=max(max(dp[1][i-3]+brr[i-2]+arr[i-1],dp[2][i-3]+max(arr[i-2],arr[i-1])),max(dp[2][i-2]+arr[i-1],dp[1][i-2]))+brr[i]; dp[1][i]=max(max(dp[2][i-3]+arr[i-2]+brr[i-1],dp[1][i-3]+max(brr[i-1],brr[i-2])),max(dp[1][i-2]+brr[i-1],dp[2][i-2]))+arr[i]; &#125; printf("%lld\n",max(dp[1][n+2],dp[2][n+2])); return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>线性dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSU-2324-Do You Like XOR?]]></title>
    <url>%2F2019%2F09%2F12%2F%E4%BD%8D%E8%BF%90%E7%AE%97%2FCSU-2324-Do%20You%20Like%20XOR%2F</url>
    <content type="text"><![CDATA[题目http://acm.csu.edu.cn:20080/csuoj/problemset/problem?pid=2324Do you like XOR? Whatever your answer is, Backlight like XOR very much. Thus, he uses a XOR problem as an encryption algorithm, and apply it to his personal computer. The algorithm is as follow:1.choose 3 integers a,b,c and a,b (1 &lt;= a &lt; b&lt;= 10^18),c (1 &lt;= c &lt;= 10^18) .2.calculate password forpi = i ⊕ i ⊕ i⋯i(a total of c times) password=⊕[a,b] (p[i]) here, ⊕ means XOR(exclusive OR). One day, Backlight forget his password. But he remember the 3 integers he use to encrypt. Given the 3 integers, could you help him to calculate out his password? InputInput contains multiple test cases. Each test case consists of a pair of integers a, b and c , separated by a space, one pair of integers per line. OutputFor each test case, print a single integer on its own line denoting the password. Sample Input121 2 36 66 666 Sample Output1230 Hint1⊕1⊕1=1,2⊕2⊕2=2,1⊕2=3 思路首先知道，偶数个相同的数异或最后等于0，奇数个相同的数异或最后结果等于该数本身。所以容易得到：当c等于偶数时，最终的结果为0。那么当c为奇数的情况呢？来看这里，偶数的二进制表示最后一个都为0，当这个偶数加1后，最后一位就变成了1，可推得偶数与与它加1得到得奇数异或结果等于1。该情况就转化为区间[a,b]内有多少个偶奇对了。 代码12345678910111213141516171819202122232425262728293031323334353637/*http://acm.csu.edu.cn:20080/csuoj/problemset/problem?pid=2324*/#include&lt;bits/stdc++.h&gt;using namespace std;unsigned long long a,b,c;int main() &#123; while(cin&gt;&gt;a&gt;&gt;b&gt;&gt;c) &#123; if(c%2==0) cout&lt;&lt;0&lt;&lt;endl; else &#123; unsigned long long d=0; unsigned long long tmpa=0,tmpb=0; if(a%2==1) &#123; tmpa=a; a++; &#125; if(b%2==0) &#123; tmpb=b; b--; &#125; unsigned long long cnt=(b-a+1)/2; if(cnt%2==0) d=0; else d=1; cout&lt;&lt;(tmpa^tmpb^d)&lt;&lt;endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>位运算</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组划分游戏 HihoCoder - 1948 (二分答案)]]></title>
    <url>%2F2019%2F09%2F12%2F%E4%BA%8C%E5%88%86%2F%E6%95%B0%E7%BB%84%E5%88%92%E5%88%86%E6%B8%B8%E6%88%8F%20HihoCoder%20-%201948%20%EF%BC%88%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目https://cn.vjudge.net/problem/HihoCoder-1948 小Hi在玩一个有关数组划分的游戏。给定一个整数K和一个长度为N的数组A=[A1, A2, … AN]，小Hi需要将它划分为K个连续子数组，并对每个子数组求和。 不妨设这K个子数组的和依次是S1, S2, … SK，则小Hi的得分是其中的最小值即min(S1, S2, … SK)。 例如对于A=[1, 2, 3, 4]和K=2，小Hi可以划分成[1, 2]和[3, 4]，这样得分是3；也可以划分成[1, 2, 3]和[4]，这样得分是4。 对于给定的K和数组A，你能帮助小Hi算出他最多能得多少分吗？ Input第一行包含两个整数N和K。 第二行包含N个整数A1, A2, … AN。 对于60%的数据，1 &lt;= N &lt;= 1000 对于100%的数据，1 &lt;= K &lt;= N &lt;= 100000 1 &lt;= Ai &lt;= 1000000 Output 一个整数代表答案 Sample Input124 21 2 3 4 Sample Output14 思路通过这个题总算明白了二分答案是怎么一回事了。 二分答案，即假设已经知道了答案，拿这个已知的答案去验证题目要求是否满足。二分答案就是在答案的可能选择的区间内，二分地枚举每一个答案是否满足题目要求，将最优性问题（难以解决）转化为可行性问题。 而这个题目，就是枚举每个可能地得分数，然后看按照这个得分数，数组能否被划分为指定的段数，如果能，这即是答案，如果不能，接着二分枚举。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN=1e5+10;ll arr[MAXN];ll n,m;ll Min=0x3f3f3f3f,Sum=0;ll check(ll x)&#123; ll ans=0,tmp=0; for(int i=1;i&lt;=n;i++) &#123; tmp+=arr[i]; if(tmp&gt;=x) ans++,tmp=0; &#125; return ans;&#125;int main()&#123;// cout&lt;&lt;(1&lt;&lt;30)&lt;&lt;endl&lt;&lt;(0x3f3f3f3f)&lt;&lt;endl; scanf("%lld%lld",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) &#123; scanf("%lld",&amp;arr[i]); Min=min(Min,arr[i]); Sum+=arr[i]; &#125; ll l=Min,r=2*Sum; while(l&lt;=r) &#123; if(l+1==r) break; ll mid=(l+r)/2; ll q=check(mid); if(q&lt;m) r=mid; else l=mid; &#125; printf("%lld\n",l); return 0;&#125;/*3 21 2 3*/]]></content>
      <categories>
        <category>二分-三分-分治</category>
      </categories>
      <tags>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown一些常用语法]]></title>
    <url>%2F2019%2F09%2F12%2F%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%8A%80%E5%B7%A7%2Fmarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[上标、下标12&lt;sup&gt;上标&lt;/sup&gt;&lt;sub&gt;下标&lt;/sub&gt;]]></content>
      <tags>
        <tag>小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo小配置]]></title>
    <url>%2F2019%2F09%2F12%2F%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%8A%80%E5%B7%A7%2Fhexo%E5%B0%8F%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[一、hexo部署本地图片把图片在hexo/blog/public/css/images目录下，其中(hexo/blog)是你博客所在文件夹。使用/css/images/at.png的方式进行链接。 二、在首页只显示摘要信息12345这里写文章的简介&lt;!-- more --&gt;这里写文章的正文 三、在首页显示图片123456---title: hexo小配置categories: hexotags: 小技巧photo: https://hexo.io/logo.svg //写上这一行，注意“photo:”有一个空格，“photo: ”后面就写上图片的地址--- 四、新建“about”页面1、在git Bash命令行界面输入1hexo new page &quot;about&quot; 2、在主题配置文件中将menu中about的注释去掉文件路径：themes/hiero/config（hiero是你主题的名称123456menu: Home: / Archives: /archives Categories: /categories Tags: /tags About: /about 上面代码为已经去掉注释后的这里就可以拓展一下，比如分类、标签页面等等。分类：123456---title: categoriesdate: 2018-09-09 23:48:07layout: &quot;categories&quot;--- 标签：12345---title: tagsdate: 2018-09-09 23:47:25layout: &quot;tags&quot;--- 未完待续……]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客小白月赛15-H-数据结构题(upper_bound/lower_bound)]]></title>
    <url>%2F2019%2F09%2F12%2FSTL%2F%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B15-H%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目链接：https://ac.nowcoder.com/acm/contest/917/H来源：牛客网 思路题目要求在给定区间内x出现的次数，如果单纯的对于每一次询问都从头到尾遍历区间，结果肯定会超时。可以看到给出x的数据范围是小于100000，不妨这样想，对每个1-100000的数字，用一个容器把它出现的下标位置存起来，这样，对于每次询问x，只需要到存x的下标的容器里去找就可以了。 对上面提到的容器可以用vector存位置下标，因为出现的顺序肯定是从小到大的，存到vector中的顺序也是排好序的，那么只需要查找区间就可以了。 说一下upper_bound和lower_bound,第一次用。12lower_bound(begin,end,x);upper_bound(begin,end,x); 其中，lower_bound是在有序数组中查找第一个大于或等于x的地址，将其减去begin就得到在数组中的位置，不存在就返回end；upper_bound则是查找第一个大于x的地址，同理得到数组中的位置，不存在返回end。 这个题还有一个要注意的地方就是r可能会小于l。 代码123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=1e5+10;const int MOD=20180623;int n,m;vector&lt;int&gt; vt[MAXN];int main() &#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) &#123; int a; scanf("%d",&amp;a); vt[a].push_back(i); &#125; while(m--) &#123; int l,r,l1,r1,x; scanf("%d%d%d%d%d",&amp;l,&amp;r,&amp;l1,&amp;r1,&amp;x); if(l&gt;r) swap(l,r); if(l1&gt;r1) swap(l1,r1); int q=(upper_bound(vt[x].begin(),vt[x].end(),r)-lower_bound(vt[x].begin(),vt[x].end(),l))%MOD; int p=(upper_bound(vt[x].begin(),vt[x].end(),r1)-lower_bound(vt[x].begin(),vt[x].end(),l1))%MOD; printf("%d\n%d\n%d\n",q%MOD,p%MOD,(q*p)%MOD); &#125; return 0;&#125;]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈队列容器用法整理]]></title>
    <url>%2F2019%2F09%2F12%2FSTL%2F%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[记下学习STL的经历。STL很强大。变量减少了，代码也更清晰明了。但有个困惑的地方，我个人使用队列写题的时候，会采用一种取巧的方法，就是随机访问队列中的元素（大概会被老师打死qwq）如下1for(int i=queue-&gt;front;i&lt;=queue-&gt;rear;i++) 但在STL里没有？是不鼓励我们这么做吧，囧rz。 stack容器stack的模板包含在#include&lt;stack&gt;内 定义：123stack&lt;int&gt; s;stack&lt;double&gt; s;stack&lt;char&gt; s; 基本用法：12345入栈：s.push(x);出栈：s.pop(); 出栈只是删除栈顶元素并不返回该元素判断栈空：s.empty();若为空返回ture访问栈顶：s.top();访问栈的元素个数：s.size(); 应用实列–括号匹配1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;string&gt;using namespace std;int main()&#123; int Case; cin &gt;&gt; Case; while (Case--) &#123; string str; stack&lt;char&gt; s; cin &gt;&gt; str; string::iterator it; for (it = str.begin(); it != str.end(); it++) &#123; if (*it == &apos;[&apos; || *it == &apos;&#123;&apos; || *it == &apos;(&apos;) &#123; s.push(*it); &#125; if (*it == &apos;]&apos;) if (s.empty()||s.top() != &apos;[&apos;) break; else s.pop(); if (*it == &apos;)&apos;) if (s.empty() || s.top() != &apos;(&apos;) break; else s.pop(); if (*it == &apos;&#125;&apos;) if (s.empty() || s.top() != &apos;&#123;&apos;) break; else s.pop(); &#125; if (!s.empty() || it &lt; str.end()) cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; &#125; return 0;&#125; 队列queue包含在#include&lt;queue&gt;中 定义123queue&lt;int&gt; q;queue&lt;double&gt; q;queue&lt;char&gt; q; 基本用法123456入队：queue.push(x);出队：queue.pop(); 出队只是删除队首元素并不返回该元素判断队空：queue.empty();访问队首元素：queue.front();访问队尾元素：queue.back();访问队列中元素个数：queue.size(); 应用实例–队列元素倒置1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;string&gt;#include&lt;malloc.h&gt;#define MAXSIZE 10using namespace std;int main()&#123; char str[MAXSIZE]; cin &gt;&gt; str; stack&lt;char&gt; stack; queue&lt;char&gt; queue; for (int i = 0; i &lt; strlen(str); i++)&#123; queue.push(str[i]); &#125; cout &lt;&lt;&quot;the queue&apos;s size is &quot;&lt;&lt; queue.size() &lt;&lt; endl; while (!queue.empty()) &#123; stack.push(queue.front()); queue.pop(); &#125; while (!stack.empty()) &#123; queue.push(stack.top()); stack.pop(); &#125; while (!queue.empty()) &#123; char x = queue.front(); cout &lt;&lt; x &lt;&lt; &apos; &apos;; queue.pop(); &#125; return 0;&#125; 时间过的好快啊。]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新建 Microsoft Office Word 文档]]></title>
    <url>%2F2019%2F09%2F12%2FSTL%2F%E6%96%B0%E5%BB%BAms%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[描述链接：https://ac.nowcoder.com/acm/contest/190/I来源：牛客网 CSL正在学习《计算机办公自动化》文件的建立与删除。 CSL发现，当他新建一个word文档时，会得到一个名为”新建 Microsoft Office Word 文档.doc”的文件，再新建一个，则名为”新建 Microsoft Office Word 文档(2).doc”，再新建，便是”新建 Microsoft Office Word 文档(3).doc”。不断新建，编号不断递增。倘若他已经新建了三个文档，然后删除了”新建 Microsoft Office Word 文档(2).doc”，再新建一个就又会得到一个”新建 Microsoft Office Word 文档(2).doc”。严格来说，Windows在每次新建文档时，都会选取一个与已有文件编号不重复的最小正整数作为新文档的编号。 现在，请你编程模拟以上过程，支持以下两种操作： New：新建一个word文档，反馈新建的文档的编号； Delete id：删除一个编号为id的word文档，反馈删除是否成功。 初始时一个文件都没有，”新建 Microsoft Office Word 文档.doc”的编号算作1。输入描述:第一行一个正整数n表示操作次数，接下来n行，每行表示一个操作。若该行为”New”，则表示新建，为:Delete id”则表示要删除编号为id的文档，其中id为一个正整数。操作按输入顺序依次进行。操作次数不超过100000，删除编号的数值不超过100000。输出描述:对于输入的每一个操作，输出其反馈结果。对于新建操作，输出新建的文档的编号；对于删除操作，反馈删除是否成功：如果删除的文件存在，则删除成功，输出”Successful”，否则输出”Failed”。示例1输入1234567891011121312NewNewNewDelete 2NewDelete 4Delete 3Delete 1NewNewNewDelete 4 输出123456789101112123Successful2FailedSuccessfulSuccessful134Successful 题解学到set，好开心。用set&lt;int&gt;来维护可以创建的队列，然后模拟。 代码1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;const int MAXSIZE=100000+5;int main()&#123; int Case; cin&gt;&gt;Case; set&lt;int&gt; st; set&lt;int&gt;::iterator it; for(int i=1;i&lt;=MAXSIZE;i++) st.insert(i); while(Case--)&#123; string str; cin&gt;&gt;str; if(str==&quot;New&quot;)&#123; it=st.begin(); cout&lt;&lt;*it&lt;&lt;endl; st.erase(it); &#125; else&#123; int a; cin&gt;&gt;a; if(!st.count(a))&#123; cout&lt;&lt;&quot;Successful&quot;&lt;&lt;endl; st.insert(a); &#125; else cout&lt;&lt;&quot;Failed&quot;&lt;&lt;endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>简单题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[排名 HDU - 1236]]></title>
    <url>%2F2019%2F09%2F12%2FSTL%2F%E6%8E%92%E5%90%8D%20HDU%20-%201236%2F</url>
    <content type="text"><![CDATA[题目今天的上机考试虽然有实时的Ranklist，但上面的排名只是根据完成的题数排序，没有考虑每题的分值，所以并不是最后的排名。给定录取分数线，请你写程序找出最后通过分数线的考生，并将他们的成绩按降序打印。Input测试输入包含若干场考试的信息。每场考试信息的第1行给出考生人数N ( 0 &lt; N &lt; 1000 )、考题数M ( 0 &lt; M &lt; = 10 )、分数线（正整数）G；第2行排序给出第1题至第M题的正整数分值；以下N行，每行给出一名考生的准考证号（长度不超过20的字符串）、该生解决的题目总数m、以及这m道题的题号 （题目号由1到M）。当读入的考生人数为0时，输入结束，该场考试不予处理。Output对每场考试，首先在第1行输出不低于分数线的考生人数n，随后n行按分数从高到低输出上线考生的考号与分数，其间用1空格分隔。若有多名考生分数相同，则按他们考号的升序输出。Sample Input12345678910111213144 5 2510 10 12 13 15CS004 3 5 1 3CS003 5 2 4 1 3 5CS002 2 1 2CS001 3 2 3 51 2 4010 30CS001 1 22 3 2010 10 10CS000000000000000001 0CS000000000000000002 2 1 20 Sample Output123456789101112133CS003 60CS001 37CS004 3701CS000000000000000002 20``` HintHuge input, scanf is recommended.# 思路sort函数的应用。# 代码 #include #include #includeusing namespace std;struct List{ string str; int score;};bool cmp(struct List a,struct List b){ if(a.score==b.score) return a.str&lt;b.str; return a.score&gt;b.score;}int main(){ int people,size,maxScore; while(scanf(“%d”,&amp;people)&amp;&amp;people!=0){ scanf(“%d%d”,&amp;size,&amp;maxScore); int perScore[11]; for(int i=1;i&lt;=size;i++) scanf(“%d”,&amp;perScore[i]); struct List stu[1000+5]; int count=0; for(int i=0;i&lt;people;i++){ stu[i].score=0; cin&gt;&gt;stu[i].str; int a; scanf(“%d”,&amp;a); while(a–){ int b; scanf(“%d”,&amp;b); stu[i].score+=perScore[b]; } if(stu[i].score&gt;=maxScore) count++; } sort(stu,stu+people,cmp); cout&lt;&lt;count&lt;&lt;endl; for(int i=0;i&lt;people;i++) if(stu[i].score&gt;=maxScore) cout&lt;&lt;stu[i].str&lt;&lt;’ ‘&lt;&lt;stu[i].score&lt;&lt;endl; } return 0;}`]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>水题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单词数 HDU - 2072]]></title>
    <url>%2F2019%2F09%2F12%2FSTL%2F%E5%8D%95%E8%AF%8D%E6%95%B0%20HDU%20-%202072%2F</url>
    <content type="text"><![CDATA[题目lily的好朋友xiaoou333最近很空，他想了一件没有什么意义的事情，就是统计一篇文章里不同单词的总数。下面你的任务是帮助xiaoou333解决这个问题。Input有多组数据，每组一行，每组就是一篇小文章。每篇小文章都是由小写字母和空格组成，没有标点符号，遇到#时表示输入结束。Output每组只输出一个整数，其单独成行，该整数代表一篇文章里不同单词的总数。Sample Input12you are my friend# Sample Output14 思路练习map？ 代码1234567891011121314151617181920212223#include&lt;iostream&gt;#include&lt;map&gt;using namespace std;int main()&#123; map&lt;string,int&gt; mp; string str; int k=0; while(getline(cin,str)&amp;&amp;str!=&quot;#&quot;)&#123; string t=&quot;&quot;; k=0; mp.clear(); for(int i=0;i&lt;int(str.size());i++)&#123; t=&quot;&quot;; while(str[i]&lt;=&apos;z&apos;&amp;&amp;str[i]&gt;=&apos;a&apos;) t+=str[i++]; if(t!=&quot;&quot;) mp[t]=k++; &#125; cout&lt;&lt;mp.size()&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[产生冠军 HDU - 2094]]></title>
    <url>%2F2019%2F09%2F12%2FSTL%2F%E4%BA%A7%E7%94%9F%E5%86%A0%E5%86%9B%20HDU%20-%202094%2F</url>
    <content type="text"><![CDATA[题目有一群人，打乒乓球比赛，两两捉对撕杀，每两个人之间最多打一场比赛。球赛的规则如下：如果A打败了B，B又打败了C，而A与C之间没有进行过比赛，那么就认定，A一定能打败C。如果A打败了B，B又打败了C，而且，C又打败了A，那么A、B、C三者都不可能成为冠军。根据这个规则，无需循环较量，或许就能确定冠军。你的任务就是面对一群比赛选手，在经过了若干场撕杀之后，确定是否已经实际上产生了冠军。Input输入含有一些选手群，每群选手都以一个整数n(n&lt;1000)开头，后跟n对选手的比赛结果，比赛结果以一对选手名字（中间隔一空格）表示，前者战胜后者。如果n为0，则表示输入结束。Output对于每个选手群，若你判断出产生了冠军，则在一行中输出“Yes”，否则在一行中输出“No”。Sample Input12345678910113Alice BobSmith JohnAlice Smith5a cc dd eb ea d0 Sample Output12YesNo 思路用map容器给每个人编号，如果谁输了，就标记下，最后统计未被标记的人数即可。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;string&gt; #include&lt;algorithm&gt;using namespace std;const int MAXSIZE=1000+5;int countNum=0;int flag[MAXSIZE]=&#123;0&#125;;map&lt;string,int&gt;mp;void arr(string str[],int &amp;x,int &amp;y)&#123; if(mp.count(str[0])) x=mp[str[0]]; else&#123; mp[str[0]]=countNum++; x=mp[str[0]]; &#125; if(mp.count(str[1])) y=mp[str[1]]; else&#123; mp[str[1]]=countNum++; y=mp[str[1]]; &#125; &#125;int main()&#123; int N; while(cin&gt;&gt;N)&#123; if(N==0) break; for(int i=0;i&lt;countNum;i++) flag[i]=0; mp.clear(); countNum=0; for(int i=0;i&lt;N;i++)&#123; string str[2]; cin&gt;&gt;str[0]&gt;&gt;str[1]; int x,y; arr(str,x,y); flag[y]=1; &#125; int ans=0; for(int i=0;i&lt;countNum;i++) if(flag[i]==0) ans++; if(ans==1) cout&lt;&lt;&quot;Yes&quot;; else cout&lt;&lt;&quot;No&quot;; cout&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STL常用技巧]]></title>
    <url>%2F2019%2F09%2F12%2FSTL%2FSTL%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[总结一下近些时间写题用到的stl容器骚操作写法。 STL容器 queue12345678910#include&lt;queue&gt;struct node&#123; int x; int y; int dis; node(int x,int y,int dis):x(x),y(y),dis(dis)&#123;&#125;&#125;;queue&lt;node&gt; qu;qu.push(x);qu.pop(); priority_queue定义方法优先队列比较算子定义方法，tql。1234567#include&lt;queue&gt;struct node&#123; int x,y,dep; node(int x,int y,int dep):x(x),y(y),dep(dep)&#123;&#125; bool operator &lt; (const node &amp;a) const &#123;return dep&gt;a.dep;&#125;&#125;;priority_queue&lt;node&gt; qu; 各类操作12345qu.size();//返回qu里元素个数qu.empty();//返回qu是否为空，空则返回1，否则返回0qu.push(k);//在qu的末尾插入kqu.pop();//删掉qu的第一个元素qu.top();//返回qu的第一个元素 mapvalue值为queue容器12345678910111213141516#include&lt;map&gt;#include&lt;queue&gt;map&lt;int,queue &gt; mp;int a;for(int i=1;i&lt;=n;i++)&#123; scanf(“%d”,&amp;a); mp[a].push(i);&#125;for(int i=0;i&lt;m;i++)&#123; scanf(“%d”,&amp;a); if(mp[a].size()==0) cout&lt;&lt;”-1”; else&#123; cout&lt;&lt;mp[a].front(); mp[a].pop();&#125; Map的按Key排序123456789#include&lt;map&gt;struct cmp&#123; bool operator()(string s1,string s2)&#123; return s1.length()&gt;s1.length(); &#125;&#125;;map&lt;string,int,cmp&gt; mp;//#include &lt;functional&gt;//map&lt;string,int,greater&lt;string&gt; &gt;mp; vectorvector数组表示邻接表。12#include&lt;vector&gt;vector&lt;int &gt; edge[MAXSIZE]; algorithmsort函数123#include&lt;algorithm&gt;bool cmp(int a,int b)&#123;return a&gt;b;&#125;sort(arr,arr+n,cmp); STL-lower_bound-upper_bound简介lower_bound和upper_bound是STL中实现二分查找的函数。 用法12lower_bound(begin,end,x);upper_bound(begin,end,x); 其中，lower_bound是在有序数组中查找第一个大于或等于x的地址，将其减去begin就得到在数组中的位置，不存在就返回end；upper_bound则是查找第一个大于x的地址，同理得到数组中的位置，不存在返回end。 代码123456789101112#include&lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int arr[]=&#123;0,1,2,4,6,8,9,10,23,45&#125;; cout&lt;&lt;lower_bound(arr,arr+10,5)-arr&lt;&lt;' '&lt;&lt;arr[lower_bound(arr,arr+10,5)-arr]&lt;&lt;endl; cout&lt;&lt;upper_bound(arr,arr+10,6)-arr&lt;&lt;' '&lt;&lt;arr[upper_bound(arr,arr+10,6)-arr]&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>STL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Gunner II HDU - 5233]]></title>
    <url>%2F2019%2F09%2F12%2FSTL%2FGunner%20II%20HDU%20-%205233%20%2F</url>
    <content type="text"><![CDATA[题目Long long ago, there was a gunner whose name is Jack. He likes to go hunting very much. One day he go to the grove. There are n birds and n trees. The i-th bird stands on the top of the i-th tree. The trees stand in straight line from left to the right. Every tree has its height. Jack stands on the left side of the left most tree. When Jack shots a bullet in height H to the right, the nearest bird which stands in the tree with height H will falls.Jack will shot many times, he wants to know which bird will fall during each shot.InputThere are multiple test cases (about 5), every case gives n, m in the first line, n indicates there are n trees and n birds, m means Jack will shot m times.In the second line, there are n numbers h[1],h[2],h[3],…,h[n] which describes the height of the trees.In the third line, there are m numbers q[1],q[2],q[3],…,q[m] which describes the height of the Jack’s shots.Please process to the end of file.“Technical Specification”All input items are integers.1&lt;=n,m&lt;=100000(10^5)1&lt;=h[i],q[i]&lt;=1000000000(10^9)OutputFor each q[i], output an integer in a single line indicates the id of bird Jack shots down. If Jack can’t shot any bird, just output -1. The id starts from 1.Sample Input1235 51 2 3 4 11 3 1 4 2 Sample Output1234567891013542``` # 思路定义map容器时，元素类型设置为queue队列。学到了学到了，tql。# 代码 #include #include #include #includeusing namespace std;int main(){ int n,m; while(cin&gt;&gt;n&gt;&gt;m){ map&lt;int,queue &gt; mp; int a; for(int i=1;i&lt;=n;i++){ scanf(“%d”,&amp;a); mp[a].push(i); } for(int i=0;i&lt;m;i++){ scanf(“%d”,&amp;a); if(mp[a].size()==0) cout&lt;&lt;”-1”; else{ cout&lt;&lt;mp[a].front(); mp[a].pop(); } cout&lt;&lt;endl; } } return 0;}`]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSU-2331-向右看（优先队列）]]></title>
    <url>%2F2019%2F09%2F12%2FSTL%2FCSU-2331-%E5%90%91%E5%8F%B3%E7%9C%8B%EF%BC%88%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目http://acm.csu.edu.cn:20080/csuoj/problemset/problem?pid=2331大一新生（又）开始军训了。现在教官让一行萌新向右看齐。 每位萌新看齐的对象是在他右边、比他高（不能同样高）且离他最近的人。 请问每个人分别向谁看齐了？Input单组数据。 第一行是一个整数n，表示人数。 下面一行是n个整数a1, a2, …, an，表示从左至右萌新的身高。 数据范围：1 ≤ n ≤ 105，1 ≤ ai ≤ 109。 Output输出n行整数，第i行表示第i个人看齐的对象编号。如果他没有向任何人看齐，则输出0。 Sample Input1283 5 1 2 5 7 8 6 Sample Output1234567826456700 思路从右到左遍历，用一个优先队列来维护最高身高的萌新。每次遍历到萌新时，就查询该萌新到最高身高的萌新区间内比他高的就可以了。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/*http://acm.csu.edu.cn:20080/csuoj/user/userinfo?user_id=1489438788*/#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=1e5+10;struct node&#123; int value; int index; node(int value,int index):value(value),index(index)&#123;&#125; bool operator &lt; (const node &amp;a) const &#123;return value&lt;a.value;&#125;&#125;;int n;int arr[MAXN];int brr[MAXN];priority_queue&lt;node&gt; qu;int main() &#123; int cnt=0; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;arr[i]); brr[cnt++]=0; qu.push(node(arr[n],n)); for(int i=n-1;i&gt;=1;i--) &#123; node t=qu.top(); int j; for(j=i+1;j&lt;=t.index;j++) &#123; if(arr[j]&gt;arr[i]) &#123; brr[cnt++]=j; break; &#125; &#125; if(j&gt;t.index) brr[cnt++]=0; qu.push(node(arr[i],i)); &#125; for(int i=cnt-1;i&gt;=0;i--) printf("%d\n",brr[i]); return 0;&#125;]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu14.04文件操作]]></title>
    <url>%2F2019%2F09%2F12%2FLinux%2Fubuntu14.04%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[使用xshell连接云服务器一些文件操作 安装rzsz1apt-get install lrzsz rzsz说明：sz命令 发送文件到本地： #sz filenamerz命令 将本地上传文件到服务器 #rz执行该命令后，在弹出框中选择要上传的文件即可 新建文件夹1mkdir filename 重命名文件1mv filename1 filename2 这也是移动某文件到另一文件目录下的操作]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>基本操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu14.04mysql常用命令]]></title>
    <url>%2F2019%2F09%2F12%2FLinux%2Fmysql%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[记录折腾阿里云服务器的求知经历 状态启动1sudo service mysql start 重启1sudo service mysql restart 关闭1sudo service mysql stop 使用创建数据库1mysql&gt; create database 数据库名称; 删除数据库（慎用）1mysql&gt; drop database 数据库名称; 查看数据库1mysql&gt; show databases; 对某数据库加入元素或者删除元素1mysql&gt; use 数据库名称; 数据表创建数据表1mysql&gt; create table 数据表名称 (字段参数); 如1mysql&gt; create table youtable (x int ,y int , z int); 删除数据表1mysql&gt; drop table 数据表名称; 查看某一数据库中有多少表1mysql&gt; show tables; 查看表中的字段1mysql&gt; select * from 数据表;]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu14.04mysql卸载与重装]]></title>
    <url>%2F2019%2F09%2F12%2FLinux%2FMySQL%E5%8D%B8%E8%BD%BD%E9%87%8D%E8%A3%85%2F</url>
    <content type="text"><![CDATA[搭环境的遇到的问题，记录下来 安装MySQL1sudo apt-get install mysql-server mysql-client 卸载查看MySQL版本1mysql -V 选择MySQL的版本然后卸载1sudo apt-get autoremove --purge mysql-server-5.5 以下依次进行1sudo apt-get remove mysql-server 1sudo apt-get autoremove mysql-server 1sudo apt-get remove mysql-common 清理残留数据1dpkg -l |grep ^rc|awk &apos;&#123;print $2&#125;&apos; |sudo xargs dpkg -P 参考博文：Ubuntu彻底卸载MySQL、Apache2和Php的方法教程]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hustoj的一些操作]]></title>
    <url>%2F2019%2F09%2F12%2FLinux%2Fhustoj%E7%BB%B4%E6%8A%A4%2F</url>
    <content type="text"><![CDATA[从10月5号开始OJ的导入数据，然，未知的总是让人恐惧。陆陆续续搞了多少天？网站挂了，数据库删了，一切重新来一遍吧。想到什么说什么啊！永远告诉自己啊！不要瞎操作啊！教训啊！你知道我这些天怎么过的啊！心里郁闷啊！明明是一样的操作啊！明明一样的环境啊！为什么得到不同的结果啊！ navicat连接数据库要想navicat能够连接到数据库，需要满足两个条件1、数据库用户有足够的权限访问数据库里说有的数据2、开放3306端口 创建数据库用户并分配权限登录数据库12root@Ubuntu:~# mysql -u root -pEnter password: 按提示输入密码注意：在数据库下所有命令都要以 ；结尾。 查看数据库用户名1select host,user,password from mysql.user; 一般来说输入上面命令会出现如下123456789101112mysql&gt; select Host,user,password from mysql.user;+-----------+------------------+-------------------------------------------+| Host | user | password |+-----------+------------------+-------------------------------------------+| localhost | root | password| ubuntu | root | password| 127.0.0.1 | root | password| ::1 | root | password| localhost | debian-sys-maint | password| % | passwords | password+-----------+------------------+-------------------------------------------+6 rows in set (0.00 sec) 其中Host栏目下的%代表该用户拥有所有的权限，如果没有该用户，就需要创建。 创建用户1234mysql&gt; create user youname identified by &apos;youname&apos;;Query OK, 0 rows affected (0.00 sec)mysql&gt; 其中第一个youname是你创建的这个数据库用户名的名称，第二个youname就是密码了。 授权1234mysql&gt; grant all privileges on *.* to &apos;youname&apos;@&apos;%&apos;identified by &apos;youname&apos; with grant option; Query OK, 0 rows affected (0.00 sec)mysql&gt; 操作完成后刷新mysql用户权限相关表1234mysql&gt; flush privileges ;Query OK, 0 rows affected (0.00 sec)mysql&gt; 查看端口开放1netstat -an | grep 3306 出现如下表示端口开放,12root@Ubuntu:~# netstat -an | grep 3306tcp 0 0 0.0.0.0:3306 0.0.0.0:* LISTEN 若是1127.0.0.1:3306 表示3306端口被本机IP绑定，外机无法访问，所以需要将其开放。 打开my.cnf配置文件1root@Ubuntu:~# vim /etc/mysql/my.cnf 找到 bind-address =127.0.0.1，将其注释掉或者改为bind-address = 0.0.0.01234567## Instead of skip-networking the default is now to listen only on# localhost which is more compatible and is not less secure.bind-address = 127.0.0.1## * Fine Tuning# 如此navicat就可以连接上数据库了。 OJ重要的配置文件1234/home/judge/etc/judge.conf/home/judge/src/web/include/db_info.inc.php/etc/php5/fpm/php.ini 或 /etc/php7.0/fpm/php.ini/etc/nginx/sites-enabled/default 开启考试模式因为学校作业练习的需要，在考试时需要改成比赛模式，以防止使用原来提交过的代码。修改db_info.inc.php文件1root@Ubuntu:~# vim /home/judge/src/web/include/db_info.inc.php 如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;?php @session_start(); ini_set(&quot;display_errors&quot;,&quot;Off&quot;); //set this to &quot;On&quot; for debugging ,especially when no reason blank shows up. ini_set(&quot;session.cookie_httponly&quot;, 1); header(&apos;X-Frame-Options:SAMEORIGIN&apos;);//for people using hustoj out of China , be careful of the last two line of this file !// connect db static $DB_HOST=&quot;localhost&quot;;static $DB_NAME=&quot;jol&quot;;static $DB_USER=&quot;root&quot;;static $DB_PASS=&quot;root&quot;;//上面四行中如果没有问题就不要动，都是默认好的。可能数据库账户密码不是root，这点并不影响。//16.04安装可能数据库账户密码为空，如果为空，账户填写为 root 密码填写 自己设置的。//如果需要改写的话一定要用vim或者vi打开static $OJ_NAME=&quot;HUSTOJ&quot;;static $OJ_HOME=&quot;./&quot;;static $OJ_ADMIN=&quot;root@localhost&quot;;static $OJ_DATA=&quot;/home/judge/data&quot;;static $OJ_BBS=&quot;discuss3&quot;;//&quot;bbs&quot; for phpBB3 bridge or &quot;discuss&quot; for mini-forumstatic $OJ_ONLINE=false;static $OJ_LANG=&quot;en&quot;;static $OJ_SIM=false; static $OJ_DICT=false;static $OJ_LANGMASK=0; //1mC 2mCPP 4mPascal 8mJava 16mRuby 32mBash 1008 for security reason to mask all other languagestatic $OJ_EDITE_AREA=true;//true: syntax highlighting is activestatic $OJ_ACE_EDITOR=true;static $OJ_AUTO_SHARE=false;//true: One can view all AC submit if he/she has ACed it onece.static $OJ_CSS=&quot;white.css&quot;;static $OJ_SAE=false; //using sina application enginestatic $OJ_VCODE=false;static $OJ_APPENDCODE=false;static $OJ_CE_PENALTY=false;static $OJ_PRINTER=false;static $OJ_MAIL=false;static $OJ_MEMCACHE=false;static $OJ_MEMSERVER=&quot;127.0.0.1&quot;;static $OJ_MEMPORT=11211;static $OJ_REDIS=false;static $OJ_REDISSERVER=&quot;127.0.0.1&quot;;static $OJ_REDISPORT=6379;static $OJ_REDISQNAME=&quot;hustoj&quot;;static $SAE_STORAGE_ROOT=&quot;http://hustoj-web.stor.sinaapp.com/&quot;;static $OJ_TEMPLATE=&quot;bs3&quot;; //使用的默认模板if(isset($_GET[&apos;tp&apos;])) $OJ_TEMPLATE=$_GET[&apos;tp&apos;];static $OJ_LOGIN_MOD=&quot;hustoj&quot;;static $OJ_REGISTER=true; //允许注册新用户static $OJ_REG_NEED_CONFIRM=false; //新注册用户需要审核static $OJ_NEED_LOGIN=false; //需要登录才能访问static $OJ_RANK_LOCK_PERCENT=0; //比赛封榜时间比例static $OJ_SHOW_DIFF=false; //是否显示WA的对比说明static $OJ_TEST_RUN=false; //提交界面是否允许测试运行static $OJ_BLOCKLY=false; //是否启用Blockly界面static $OJ_ENCODE_SUBMIT=false; //是否启用base64编码提交的功能，用来回避WAF防火墙误拦截。//static $OJ_EXAM_CONTEST_ID=1000; // 启用考试状态，填写考试比赛ID//static $OJ_ON_SITE_CONTEST_ID=1000; //启用现场赛状态，填写现场赛比赛IDstatic $OJ_OPENID_PWD = &apos;8a367fe87b1e406ea8e94d7d508dcf01&apos;;/* weibo config here */static $OJ_WEIBO_AUTH=false;static $OJ_WEIBO_AKEY=&apos;1124518951&apos;;static $OJ_WEIBO_ASEC=&apos;df709a1253ef8878548920718085e84b&apos;;static $OJ_WEIBO_CBURL=&apos;http://192.168.0.108/JudgeOnline/login_weibo.php&apos;;/* renren config here */static $OJ_RR_AUTH=false;static $OJ_RR_AKEY=&apos;d066ad780742404d85d0955ac05654df&apos;;static $OJ_RR_ASEC=&apos;c4d2988cf5c149fabf8098f32f9b49ed&apos;;static $OJ_RR_CBURL=&apos;http://192.168.0.108/JudgeOnline/login_renren.php&apos;;/* qq config here */static $OJ_QQ_AUTH=false;static $OJ_QQ_AKEY=&apos;1124518951&apos;;static $OJ_QQ_ASEC=&apos;df709a1253ef8878548920718085e84b&apos;;static $OJ_QQ_CBURL=&apos;192.168.0.108&apos;;//if(date(&apos;H&apos;)&lt;5||date(&apos;H&apos;)&gt;21||isset($_GET[&apos;dark&apos;])) $OJ_CSS=&quot;dark.css&quot;;if( isset($_SERVER[&apos;HTTP_ACCEPT_LANGUAGE&apos;]) &amp;&amp; strstr($_SERVER[&apos;HTTP_ACCEPT_LANGUAGE&apos;],&quot;zh-CN&quot;)) &#123; $OJ_LANG=&quot;cn&quot;;&#125;if (isset($_SESSION[$OJ_NAME.&apos;_&apos;.&apos;OJ_LANG&apos;])) $OJ_LANG=$_SESSION[$OJ_NAME.&apos;_&apos;.&apos;OJ_LANG&apos;];require_once(dirname(__FILE__).&quot;/pdo.php&quot;); // use db //pdo_query(&quot;set names utf8&quot;); if(isset($OJ_CSRF)&amp;&amp;$OJ_CSRF&amp;&amp;$OJ_TEMPLATE==&quot;bs3&quot;&amp;&amp;basename($_SERVER[&apos;PHP_SELF&apos;])!=&quot;problem_judge&quot;) require_once(&apos;csrf_check.php&apos;); //sychronize php and mysql server with timezone settings, dafault setting for China //if you are not from China, comment out these two lines or modify them. //date_default_timezone_set(&quot;PRC&quot;); //pdo_query(&quot;SET time_zone =&apos;+8:00&apos;&quot;);?&gt; 找到并取消注释就可以了12//static $OJ_EXAM_CONTEST_ID=1000; // 启用考试状态，填写考试比赛ID//static $OJ_ON_SITE_CONTEST_ID=1000; //启用现场赛状态，填写现场赛比赛ID OJ判题语言，找到并修改1static $OJ_LANGMASK=0; //1mC 2mCPP 4mPascal 8mJava 16mRuby 32mBash 1008 for security reason to mask all other language 在源码中的位置1root@Ubuntu:~# vim /home/judge/src/core/judge_client/judge_client.cc 大约在130行，这个文件有2000+行代码qwq123456#ifdef _mysql_hMYSQL *conn;#endifstatic char lang_ext[18][8] = &#123; &quot;c&quot;, &quot;cc&quot;, &quot;pas&quot;, &quot;java&quot;, &quot;rb&quot;, &quot;sh&quot;, &quot;py&quot;, &quot;php&quot;, &quot;pl&quot;, &quot;cs&quot;, &quot;m&quot;, &quot;bas&quot;, &quot;scm&quot;,&quot;c&quot;,&quot;cc&quot;,&quot;lua&quot;,&quot;js&quot;,&quot;go&quot; &#125;; 按照上文$OJ_LANGMASK=0代表所有的语言都可以提交，可知0决定何种语言可以使用。先说明0代表启用，1代表禁用。比如想要c和c++可以使用，那么二进制编码就是001111111111111111，转换成十进制就是‭65535‬，让 OJ_LANGMASK=65535就可以了。 转移数据库关于把原来服务器上的OJ上的数据全部转移到另一台服务器上的具体命令。首先在新服务器上装上hustoj。两个重要的数据：jol数据库 学生做题记录，ac代码/home/judge/data 题目的测试数据 转移jol在原来服务器上12mysqldump -u root -p密码 数据库名 &gt; 数据库文件路径如：mysqldump -u root -ppassword jol &gt; /home/jol.sql //在home文件下的data.sql文件 下载到本地：sz 命令是从linux下载文件到本地1sz /home/jol.sql 在后一台服务器上把本地的文件上传到该服务器上进入相应的文件路径，然后输入rz选择你本地（假如是window）1rz 登录数据库1mysql - u root -p 选择转入的数据库1use jol; 然后把jol.sql传入database中，注意/home/jol.sql是你从本地上传到服务器上的文件路径1source /home/jol.sql; 转移/home/judge/data原服务器上打包data(不压缩)1tar -cvf /home/judge/data.tar data 下载到本地1sz /home/judge/data.tar 后一台服务器上将data.tar上传到/home/judge1rz 在路径/home/judge下解包1tar -xvf data.tar 可以了。维护工作尚在进行，祝自己好运吧，qwq。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>OJ运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[划水日常]]></title>
    <url>%2F2019%2F09%2F12%2F%E5%88%92%E6%B0%B4%E6%97%A5%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[记录学习训练中的日常，时刻提醒自己哪些事情不能做。 时间 a题数量 算法学习 杂 心情 2019.4.22 1 字符串 总结上周末比赛题目 (。・∀・)ノ 2019.4.23 1 双端队列解BFS 湘大谢神来讲座 qwq 2019.4.24 1 马拉车算法求回文字符串 如此巧妙的算法，神往 (￣y▽￣)╭ Ohohoho….. 2019.4.25 3 双端队列解BFS/DFS随机解 果不其然，cf又掉分了 ┗( T﹏T )┛ 2019.4.26 3 温习KMP算法 打了一把div3，果不其然，又掉分了 qwq 2019.4.27 3 字符串（kuangbin专题KMP，Manacher） 还是要继续啊 qwq 2019.4.28 3 周日集训 签了三个水题，手速还是太慢了。看来要刻意练一下敲代码的速度了 qwq 2019.4.29 5 补题加div2 div2掉1分。对于那个本应该在赛场上写出来的却没有写出来赛后一眼就看出来的规律题，我这方面的训练还是不太够啊。 qwq 2019.4.30 3 补题 把以前没写出来的题目都看了一遍，发现有的题是真的水，当初怎么这么菜啊。另外，发下一个问题，对于double类型，用printf输出时一定要用%f，而不是%lf，%lf好像是long double的输出？ qwq 补题加div2 div2掉1分。对于那个本应该在赛场上写出来的却没有写出来赛后一眼就看出来的规律题，我这方面的训练还是不太够啊。 qwq 2019.4.30 3 补题 把以前没写出来的题目都看了一遍，发现有的题是真的水，当初怎么这么菜啊。另外，发下一个问题，对于double类型，用printf输出时一定要用%f，而不是%lf，%lf好像是long double的输出？ qwq 2019.5.1 2 日常划水 日常划水 qwq 2019.5.2 3 位运算技巧 “中途夭折，轻易放弃，多次失败，多次重头再来” qwq 2019.5.3 4 字符串 KMP中的Next数组怎么这么强？ qwq 停止划水，专心训练。]]></content>
  </entry>
</search>
