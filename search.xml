<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[产生冠军 HDU - 2094]]></title>
    <url>%2F2019%2F02%2F01%2FSTL%2F%E4%BA%A7%E7%94%9F%E5%86%A0%E5%86%9B%20HDU%20-%202094%2F</url>
    <content type="text"><![CDATA[题目有一群人，打乒乓球比赛，两两捉对撕杀，每两个人之间最多打一场比赛。球赛的规则如下：如果A打败了B，B又打败了C，而A与C之间没有进行过比赛，那么就认定，A一定能打败C。如果A打败了B，B又打败了C，而且，C又打败了A，那么A、B、C三者都不可能成为冠军。根据这个规则，无需循环较量，或许就能确定冠军。你的任务就是面对一群比赛选手，在经过了若干场撕杀之后，确定是否已经实际上产生了冠军。Input输入含有一些选手群，每群选手都以一个整数n(n&lt;1000)开头，后跟n对选手的比赛结果，比赛结果以一对选手名字（中间隔一空格）表示，前者战胜后者。如果n为0，则表示输入结束。Output对于每个选手群，若你判断出产生了冠军，则在一行中输出“Yes”，否则在一行中输出“No”。Sample Input12345678910113Alice BobSmith JohnAlice Smith5a cc dd eb ea d0 Sample Output12YesNo 题解用map容器给每个人编号，如果谁输了，就标记下，最后统计未被标记的人数即可。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;string&gt; #include&lt;algorithm&gt;using namespace std;const int MAXSIZE=1000+5;int countNum=0;int flag[MAXSIZE]=&#123;0&#125;;map&lt;string,int&gt;mp;void arr(string str[],int &amp;x,int &amp;y)&#123; if(mp.count(str[0])) x=mp[str[0]]; else&#123; mp[str[0]]=countNum++; x=mp[str[0]]; &#125; if(mp.count(str[1])) y=mp[str[1]]; else&#123; mp[str[1]]=countNum++; y=mp[str[1]]; &#125; &#125;int main()&#123; int N; while(cin&gt;&gt;N)&#123; if(N==0) break; for(int i=0;i&lt;countNum;i++) flag[i]=0; mp.clear(); countNum=0; for(int i=0;i&lt;N;i++)&#123; string str[2]; cin&gt;&gt;str[0]&gt;&gt;str[1]; int x,y; arr(str,x,y); flag[y]=1; &#125; int ans=0; for(int i=0;i&lt;countNum;i++) if(flag[i]==0) ans++; if(ans==1) cout&lt;&lt;"Yes"; else cout&lt;&lt;"No"; cout&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最少拦截系统 HDU - 1257]]></title>
    <url>%2F2019%2F01%2F31%2F%E8%B4%AA%E5%BF%83%2F%E6%9C%80%E5%B0%91%E6%8B%A6%E6%88%AA%E7%B3%BB%E7%BB%9F%20HDU%20-%201257%20%2F</url>
    <content type="text"><![CDATA[题目某国为了防御敌国的导弹袭击,发展出一种导弹拦截系统.但是这种导弹拦截系统有一个缺陷:虽然它的第一发炮弹能够到达任意的高度,但是以后每一发炮弹都不能超过前一发的高度.某天,雷达捕捉到敌国的导弹来袭.由于该系统还在试用阶段,所以只有一套系统,因此有可能不能拦截所有的导弹.怎么办呢?多搞几套系统呗!你说说倒蛮容易,成本呢?成本是个大问题啊.所以俺就到这里来求救了,请帮助计算一下最少需要多少套拦截系统.Input输入若干组数据.每组数据包括:导弹总个数(正整数),导弹依此飞来的高度(雷达给出的高度数据是不大于30000的正整数,用空格分隔)Output对应每组数据输出拦截所有导弹最少要配备多少套这种导弹拦截系统.Sample Input18 389 207 155 300 299 170 158 65 Sample Output12 题解导弹是依次飞来的并且每一发都不能超过前一发的高度，可知当后一个导弹的高度高于前一个时，就需要一个新的拦截系统。如果仅仅是这么想，就会被坑了。因为之前的拦截系统的最后一发炮弹的高度可能比新的拦截系统的高度要高。比如这组数据 389 207 155 300 299 170 158 65 100，不想清楚后一种可能那么就需要三套，实际上两套就行了。 代码123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int MAXSIZE=50000;int main()&#123; int n; while(cin&gt;&gt;n)&#123; int sum=0; int arr[MAXSIZE]; for(int i=0;i&lt;n;i++) cin&gt;&gt;arr[i]; int check=1; for(int i=0;i&lt;n;)&#123; if(check==i) break; check=i; int first=arr[i]; int flag=1; for(int j=i+1;j&lt;n;j++)&#123; if(first&gt;arr[j]&amp;&amp;arr[j]!=0)&#123; first=arr[j]; arr[j]=0; &#125; if(flag==1&amp;&amp;first&lt;arr[j])&#123; flag=0; i=j; &#125; &#125; &#125; for(int i=0;i&lt;n;i++) if(arr[i]!=0) sum++; cout&lt;&lt;sum&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>贪心算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Saving HDU HDU - 2111]]></title>
    <url>%2F2019%2F01%2F31%2F%E8%B4%AA%E5%BF%83%2FSaving%20HDU%20HDU%20-%202111%20%2F</url>
    <content type="text"><![CDATA[题目话说上回讲到海东集团面临内外交困，公司的元老也只剩下XHD夫妇二人了。显然，作为多年拼搏的商人，XHD不会坐以待毙的。 一天，当他正在苦思冥想解困良策的时候，突然想到了自己的传家宝，那是公司成立的时候，父亲作为贺礼送来的一个锦囊，徐父当时交代，不到万不得已的时候，不要打开它。“现在不正是最需要的时候吗？”，一边想，XHD一边找到了这个精心保管的锦囊，打开一看，里面只有一句话“杭城北麓千人洞有宝”。 二话不说，XHD拿起一个大口袋就出发了，这个千人洞他是知道的，小的时候，爸爸曾经带他来过这个隐蔽的路口，并告诉他，这是千人洞。他现在才明白爸爸当初这句话的含义。 尽管有点印象，XHD还是花了很大的精力才找到这个异常隐蔽的洞口，走进一看，几乎惊呆了，真的是眼花缭乱！不过尽管宝贝的种类不少，但是每种宝贝的量并不多，当然，每种宝贝单位体积的价格也不一样，为了挽救HDU，现在请你帮忙尽快计算出来XHD最多能带回多少价值的宝贝？（假设宝贝可以分割，分割后的价值和对应的体积成正比）Input输入包含多个测试实例，每个实例的第一行是两个整数v和n(v,n&lt;100)，分别表示口袋的容量和宝贝的种类，接着的n行每行包含2个整数pi和mi(0&lt;pi,mi&lt;10)，分别表示某种宝贝的单价和对应的体积，v为0的时候结束输入。Output对于每个测试实例，请输出XHD最多能取回多少价值的宝贝，每个实例的输出占一行。Sample Input12342 23 12 30 Sample Output15 经过锦囊相助，HDU会脱离危机吗？欲知后事如何，且听下回分解—— 题解对宝贝的价值从高到底排序，再贪心 代码12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int MAXSIZE=500+5;struct Node&#123; int pi; int mi;&#125;;bool cmp(struct Node a,struct Node b)&#123; return a.pi&gt;b.pi;&#125;int main()&#123; int v,n; while(cin&gt;&gt;v)&#123; if(v==0) break; cin&gt;&gt;n; struct Node arr[MAXSIZE]; for(int i=0;i&lt;n;i++) cin&gt;&gt;arr[i].pi&gt;&gt;arr[i].mi; sort(arr,arr+n,cmp); int sum=0; int allVal=0; int i=0; for(i=0;i&lt;n&amp;&amp;((sum+arr[i].mi)&lt;=v);i++)&#123; sum+=arr[i].mi; allVal+=arr[i].pi*arr[i].mi; //if(i&gt;=n) break; &#125; if(i&lt;n) allVal+=(v-sum)*arr[i].pi; cout&lt;&lt;allVal&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>贪心算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[老人是真饿了 HDU - 2187]]></title>
    <url>%2F2019%2F01%2F31%2F%E8%B4%AA%E5%BF%83%2F%E8%80%81%E4%BA%BA%E6%98%AF%E7%9C%9F%E9%A5%BF%E4%BA%86%20HDU%20-%202187%20%2F</url>
    <content type="text"><![CDATA[题目时间：2008年5月16日（震后第4天）地点：汶川县牛脑寨人物：羌族老奶奶 【转载整理】牛脑寨是一个全村600多人的羌族寨子，震后几天，这里依然能常常听到隆隆的声音，那是对面山上石头不断滑落的声音。在完成整个突击队的抢修移动基站的任务后，我提着相机开始记录这里的受创情况。突然，我的视线里出现一个羌族老人，这让我无比的震惊，要知道，那是一个极陡的坡，这个佝偻着腰的老人是怎么艰难地爬上来的？她上来做什么？ 老人背后是极陡的坡，她只有一只眼睛有依稀的视力，望着满地废墟，她徘徊了很久。家在哪里，她极力地用很低的视力找寻着。她曾经的家就在旁边，但是满目废墟已经让老人看不出来。她举目远眺，期望那里能看到家的一点点痕迹。原来家就在旁边，左手抓住一个房橼，努力让自己站住，地震过去三天了，她第一次回到曾经的家。 一个倒塌的柜子，里面装着一丝希望，老人很吃力地搬动掩盖在柜子上的薪柴。老人找到一把木匠用的刨子，老泪纵横，或许有哪个逝去的亲人是木匠。睹物思人，逝者已矣。 继续找，一把散碎的挂面出现在我的眼前。她颤颤巍巍地捞起铺满灰尘的挂面，再次流出了眼泪……看着她仔细地把挂面放进胸前的围腰里，我顿然感觉到，这是老人在得到外援之前赖以生存的口粮了，如果不是交通中断，外部救援进不来，老人家又何必拖着80多岁的躯体，强忍失去亲人的痛苦，重新回到这夺取她亲人生命的废墟，寻找这点点挂面？老人是真饿了…… 老人佝偻着腰，低声喃喃地念着那两句话“你们走了，我可怎么活”，拿着那对我们身处城市的人们微不足道的挂面，远去了…… PS: 拍完这组照片后我才知道，5月14号军用运输飞机第一次给汶川空投救援物资就掉在牛脑寨，受灾的村民们没有占为己有，而是汗流浃背地走了两个小时背到山下的县城交给政府。 对于幸存的灾民来说，最急待解决的显然是温饱问题，救灾部队一边在组织人员全力打通交通，一边在组织采购粮食。现在假设下拨了一定数量的救灾经费要去市场采购大米（散装）。如果市场有m种大米，各种大米的单价和重量已知，请问，为了满足更多灾民的需求，最多能采购多少重量的大米呢？Input输入数据首先包含一个正整数C，表示有C组测试用例，每组测试用例的第一行是两个整数n和m（0&lt;n&lt;=1000,0&lt;m&lt;=1000）,分别表示经费的金额和大米的种类，然后是m行数据，每行包含2个整数p和h(1&lt;=p&lt;=25,1&lt;=h&lt;=100)，分别表示单价和对应大米的重量。Output对于每组测试数据，请输出能够购买大米的最多重量（你可以假设经费买不光所有的大米）。每个实例的输出占一行，保留2位小数。Sample Input123417 23 34 4 Sample Output12.33 题解对大米的价格从低到高排序，再贪心过一遍 代码1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;algorithm&gt; using namespace std;const int MAXSIZE=1000+5;struct Node&#123; int p; int h;&#125;;bool cmp(struct Node a,struct Node b)&#123; return a.p&lt;b.p;&#125;int main()&#123; int Case; cin&gt;&gt;Case; while(Case--)&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; struct Node arr[MAXSIZE]; for(int i=0;i&lt;m;i++) cin&gt;&gt;arr[i].p&gt;&gt;arr[i].h; sort(arr,arr+m,cmp); int i=0; int sum=0; double allVal=0; int S=0; for(i=0;i&lt;m&amp;&amp;((sum+arr[i].p*arr[i].h)&lt;=n);i++)&#123; sum+=arr[i].p*arr[i].h; S+=arr[i].h; &#125; if(i&lt;m) allVal=(n-sum)/arr[i].p+(n-sum)%arr[i].p*1.0/arr[i].p; printf("%.2lf\n",allVal+S); &#125; return 0;&#125;]]></content>
      <categories>
        <category>贪心算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bookshelf]]></title>
    <url>%2F2019%2F01%2F30%2F%E8%B4%AA%E5%BF%83%2Fbookshelf%2F</url>
    <content type="text"><![CDATA[题目Farmer John recently bought a bookshelf for cow library, but the shelf is getting filled up quite quickly, and now the only available space is at the top. Each of the N cows (1 &lt;= N &lt;= 20,000) has some height of H_i (1 &lt;= H_i &lt;= 10,000) and a total height summed across all N cows of S. The bookshelf has a height of B (1 &lt;= B &lt;= S &lt; 2,000,000,007). To reach the top of the bookshelf taller than the tallest cow, one or more of the cows can stand on top of each other in a stack, so that their total height is the sum of each of their individual heights. This total height must be no less than the height of the bookshelf. Since more cows than necessary in the stack can be dangerous, your job is to find the set of cows that produces a stack of the smallest number of cows possible such that the stack can reach the bookshelf.Input Line 1: Two space-separated integers: N and B Lines 2..N+1: Line i+1 contains a single integer: H_iOutput Line 1: A single integer representing the size of the smallest set of cows that can reach the bookshelf.Sample Input12345676 4061811131911 Sample Output13 Hint1234567INPUT DETAILS: Six cows; bookshelf height 40. Cow heights fall in the range 6..19. OUTPUT DETAILS: One way to reach 40 with 3 cows is 18+11+13; many others exist 题解不断贪最大高度直到高于height即可。 代码1234567891011121314151617181920212223#include&lt;iostream&gt;#include&lt;algorithm&gt;const int MAXSIZE=20000+5;using namespace std;bool cmp(int a,int b)&#123;return a&gt;b;&#125;int main()&#123; int N,height; while(cin&gt;&gt;N&gt;&gt;height)&#123; int arr[MAXSIZE]; for(int i=0;i&lt;N;i++) cin&gt;&gt;arr[i]; sort(arr,arr+N,cmp); int sum=0; int i=0; for(i=0;i&lt;N;i++)&#123; sum+=arr[i]; if(sum&gt;=height) break; &#125; cout&lt;&lt;i&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>贪心算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[金银岛]]></title>
    <url>%2F2019%2F01%2F30%2F%E8%B4%AA%E5%BF%83%2F%E9%87%91%E9%93%B6%E5%B2%9B%2F</url>
    <content type="text"><![CDATA[题目某天KID利用飞行器飞到了一个金银岛上，上面有许多珍贵的金属，KID虽然更喜欢各种宝石的艺术品，可是也不拒绝这样珍贵的金属。但是他只带着一个口袋，口袋至多只能装重量为w的物品。岛上金属有s个种类, 每种金属重量不同，分别为n 1, n 2, … , n s，同时每个种类的金属总的价值也不同，分别为v 1,v 2, …, v s。KID想一次带走价值尽可能多的金属，问他最多能带走价值多少的金属。注意到金属是可以被任意分割的，并且金属的价值和其重量成正比。Input第1行是测试数据的组数k，后面跟着k组输入。 每组测试数据占3行，第1行是一个正整数w (1 &lt;= w &lt;= 10000)，表示口袋承重上限。第2行是一个正整数s (1 &lt;= s &lt;=100)，表示金属种类。第3行有2s个正整数，分别为n 1, v 1, n 2, v 2, … , n s, v s分别为第一种，第二种，…，第s种金属的总重量和总价值(1 &lt;= n i &lt;= 10000, 1 &lt;= v i &lt;= 10000)。Outputk行，每行输出对应一个输入。输出应精确到小数点后2位。Sample Input1234567250410 100 50 30 7 34 87 1001000051 43 43 323 35 45 43 54 87 43 Sample Output12171.93508.00 题解该题跟圣诞老人题类似传送，单位重量内价值越高优先选择。 代码12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;algorithm&gt;const int MAXSIZE=10000+5;using namespace std;struct Node&#123; int weight; int value; double single;&#125;;bool cmp(struct Node a,struct Node b)&#123;return a.single&gt;b.single;&#125;int main()&#123; int Case; cin&gt;&gt;Case; while(Case--)&#123; int w; cin&gt;&gt;w; int s; cin&gt;&gt;s; struct Node arr[MAXSIZE]; for(int i=0;i&lt;s;i++)&#123; cin&gt;&gt;arr[i].weight&gt;&gt;arr[i].value; arr[i].single=arr[i].value*1.0/arr[i].weight; &#125; sort(arr,arr+s,cmp); int sum=0; int i=0; double allVal=0; for(i=0;i&lt;s&amp;&amp;(sum+arr[i].weight)&lt;=w;i++)&#123; sum+=arr[i].weight; allVal+=arr[i].value; &#125; if(i&lt;s) allVal=allVal+(w-sum)*arr[i].single; printf("%.2lf\n",allVal); &#125; return 0;&#125;]]></content>
      <categories>
        <category>贪心算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[圣诞老人的礼物-Santa Clau’s Gifts]]></title>
    <url>%2F2019%2F01%2F30%2F%E8%B4%AA%E5%BF%83%2F%E5%9C%A3%E8%AF%9E%E8%80%81%E4%BA%BA%E7%9A%84%E7%A4%BC%E7%89%A9-Santa%20Clau%E2%80%99s%20Gifts%20%2F</url>
    <content type="text"><![CDATA[题目圣诞节来临了，在城市A中圣诞老人准备分发糖果，现在有多箱不同的糖果，每箱糖果有自己的价值和重量，每箱糖果都可以拆分成任意散装组合带走。圣诞老人的驯鹿最多只能承受一定重量的糖果，请问圣诞老人最多能带走多大价值的糖果。Input第一行由两个部分组成，分别为糖果箱数正整数n(1 &lt;= n &lt;= 100)，驯鹿能承受的最大重量正整数w（0 &lt; w &lt; 10000），两个数用空格隔开。其余n行每行对应一箱糖果，由两部分组成，分别为一箱糖果的价值正整数v和重量正整数w，中间用空格隔开。Output输出圣诞老人能带走的糖果的最大总价值，保留1位小数。输出为一行，以换行符结束。Sample Input123454 15100 4412 8266 7591 2 Sample Output11193.0 题解由一箱糖果的总价值和它的总重量可以算出每一份重量所对应的价值，记为份重量=总价值/总重量。要尽可能地带走价值大的糖果，那么在载重允许范围内，份重量对应的糖果价值越大带走的糖果价值就越高。对份重量从高到底排序，选择即可 代码1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;algorithm&gt;const int MAXSIZE=100+5;using namespace std;struct Santa&#123; int value; int weight; double single;&#125;;bool cmp(struct Santa a,struct Santa b)&#123;return a.single&gt;b.single;&#125;int main()&#123; struct Santa arr[MAXSIZE]; int n,w; while(cin&gt;&gt;n&gt;&gt;w)&#123; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;arr[i].value&gt;&gt;arr[i].weight; arr[i].single=(arr[i].value*1.0)/(arr[i].weight*1.0); &#125; sort(arr,arr+n,cmp); int sum=0; double allVal=0; int i=0; while((arr[i].weight+sum)&lt;=w)&#123; allVal=allVal+arr[i].value; sum+=arr[i].weight; i++; if(i&gt;=n) break; &#125; if(i&lt;n) allVal=allVal+arr[i].single*(w-sum); printf("%.1lf\n",allVal); &#125; return 0;&#125;//AC]]></content>
      <categories>
        <category>贪心算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小新整数]]></title>
    <url>%2F2019%2F01%2F30%2F%E7%AE%80%E5%8D%95%E6%A8%A1%E6%8B%9F%2F%E6%9C%80%E5%B0%8F%E6%96%B0%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目给定一个十进制正整数n(0 &lt; n &lt; 1000000000)，每个数位上数字均不为0。n的位数为m。现在从m位中删除k位(0&lt;k &lt; m)，求生成的新整数最小为多少？例如: n = 9128456, k = 2, 则生成的新整数最小为12456Input第一行t, 表示有t组数据；接下来t行，每一行表示一组测试数据，每组测试数据包含两个数字n, k。Outputt行，每行一个数字，表示从n中删除k位后得到的最小整数。Sample Input12329128456 21444 3 Sample Output12124561 题解前一位数与后一位数比较，若大于后一位就删掉它。 代码123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int main()&#123; int Case; cin&gt;&gt;Case; while(Case--)&#123; char str[20]; int k; cin&gt;&gt;str&gt;&gt;k; while(k--)&#123; for(int i=0;i&lt;strlen(str);i++)&#123; if(str[i]&gt;str[i+1])&#123; for(int j=i;j&lt;strlen(str);j++) str[j]=str[j+1]; break; &#125; &#125; &#125; cout&lt;&lt;str&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>简单模拟</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Not half of the heart]]></title>
    <url>%2F2018%2F12%2F09%2F%E9%9A%8F%E7%AC%94%E6%9D%82%E6%83%B3%2Fifeelsad%2F</url>
    <content type="text"><![CDATA[好像每到这个时期，都不知道干些什么 见到那些想要学的习东西，python/前端 都提不起兴趣。 已在这过了一年半了，好快，不久，又是考研了 送走一届又一届 当轮到我时 是否还记得入学时许下的承若。 想到了毕业 又担心自己一事无成 打开电脑，敲下一行行的代码不能使我心安。 外界的嘈杂 尚不及内心的一半 以后无穷无尽的压力 有过绝望。 以前的人们 在19岁时感受到过生活的压力吗 肯定是有的 那么当他们绝望时 是什么支撑着走下去。 熬夜到2点好像已经习惯了 以前可没这样 熬到这时候又做了些什么 没有答案 或许自己也不知道为什么又熬夜了，呵呵。 古来圣贤皆寂寞 唯有饮者留其名 我是谁 我以前干了些什么 我现在在干什么 我以后要干什么。 也曾看过你的微博 也曾删掉联系方式 也曾留恋虚无缥缈的念想 现在 想着 过去了 就不要想了。 莫问前路无知己 天下谁人不识君。 子在川上曰：逝者如斯夫，不舍昼夜 都说时间可以消磨过去的痕迹 可为什么痕迹越来越深了。 2019愿你走的每一步都是坚定而扎实的。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[nyoj-71-独木舟上的旅行（贪心入门]]></title>
    <url>%2F2018%2F12%2F02%2F%E8%B4%AA%E5%BF%83%2Fnyoj71%E7%8B%AC%E6%9C%A8%E8%88%9F%E4%B8%8A%E7%9A%84%E6%97%85%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[描述独木舟上的旅行时间限制：3000 ms | 内存限制：65535 KB难度：2描述进行一次独木舟的旅行活动，独木舟可以在港口租到，并且之间没有区别。一条独木舟最多只能乘坐两个人，且乘客的总重量不能超过独木舟的最大承载量。我们要尽量减少这次活动中的花销，所以要找出可以安置所有旅客的最少的独木舟条数。现在请写一个程序，读入独木舟的最大承载量、旅客数目和每位旅客的重量。根据给出的规则，计算要安置所有旅客必须的最少的独木舟条数，并输出结果。输入第一行输入s,表示测试数据的组数；每组数据的第一行包括两个整数w，n，80&lt;=w&lt;=200,1&lt;=n&lt;=300，w为一条独木舟的最大承载量,n为人数；接下来的一组数据为每个人的重量（不能大于船的承载量）；输出每组人数所需要的最少独木舟的条数。样例输入1234567385 65 84 85 80 84 8390 390 45 60100 550 50 90 40 60 样例输出123533 题解以最小的体重为基准，再从最大体重中往下找，满足承载重就说明两者可以搭乘同一船，否则就只有最小的那一个独自搭船。然后依次选择剩下的最小体重。说明：一条船只能坐两人。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;//--const int MAXSIZE=300+5;//--int main()&#123; int Case; cin&gt;&gt;Case; while(Case--)&#123; int weith,people; cin&gt;&gt;weith&gt;&gt;people; int a[MAXSIZE]; for(int i=0;i&lt;people;i++) cin&gt;&gt;a[i]; sort(a,a+people); int ans=0; for(int i=0;i&lt;people;i++)&#123; if(a[i]!=0)&#123; int value=weith-a[i]; for(int j=people-1;j&gt;i;j--)&#123; if(value&gt;=a[j]&amp;&amp;a[j]!=0)&#123; value=value-a[j]; a[j]=0; break; &#125; &#125; ans++; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; /*385 65 84 85 80 84 8390 390 45 60100 550 50 90 40 60*/]]></content>
      <categories>
        <category>贪心算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nyoj-13-会场安排问题（贪心入门]]></title>
    <url>%2F2018%2F12%2F01%2F%E8%B4%AA%E5%BF%83%2Fnyoj14%E4%BC%9A%E5%9C%BA%E5%AE%89%E6%8E%92%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[描述会场安排问题学校的小礼堂每天都会有许多活动，有时间这些活动的计划时间会发生冲突，需要选择出一些活动进行举办。小刘的工作就是安排学校小礼堂的活动，每个时间最多安排一个活动。现在小刘有一些活动计划的时间表，他想尽可能的安排更多的活动，请问他该如何安排。输入第一行是一个整型数m(m&lt;100)表示共有m组测试数据。每组测试数据的第一行是一个整数n(1&lt;n&lt;10000)表示该测试数据共有n个活动。随后的n行，每行有两个正整数Bi,Ei(0&lt;=Bi,Ei&lt;10000),分别表示第i个活动的起始与结束时间（Bi&lt;=Ei)输出对于每一组输入，输出最多能够安排的活动数量。每组的输出占一行样例输入12345678221 1010 1131 1010 1111 20 样例输出1212 提示注意：如果上一个活动在t时间结束，下一个活动最早应该在t+1时间开始 题解活动越早结束，剩余的时间就越多。那么每次找最早结束的活动，然后继续在剩下的活动中找最小的。当然这些满足一个条件，即如提示说明。 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;//--const int MAXSIZE=10000+5;class node&#123; public: int Bi; int Ei;&#125;;node a[MAXSIZE];//--bool cmp(node a,node b)&#123; return a.Ei&lt;b.Ei;&#125;int main()&#123; int Case; cin&gt;&gt;Case; while(Case--)&#123; int n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i].Bi&gt;&gt;a[i].Ei; sort(a,a+n,cmp); int ans=1; int t=0; for(int i=1;i&lt;n;i++)&#123; if(a[i].Bi&gt;a[t].Ei)&#123; ans++; t=i; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>贪心算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新建 Microsoft Office Word 文档]]></title>
    <url>%2F2018%2F11%2F30%2F%E7%AE%80%E5%8D%95%E9%A2%98%2F%E6%96%B0%E5%BB%BAms%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[描述链接：https://ac.nowcoder.com/acm/contest/190/I来源：牛客网 CSL正在学习《计算机办公自动化》文件的建立与删除。 CSL发现，当他新建一个word文档时，会得到一个名为”新建 Microsoft Office Word 文档.doc”的文件，再新建一个，则名为”新建 Microsoft Office Word 文档(2).doc”，再新建，便是”新建 Microsoft Office Word 文档(3).doc”。不断新建，编号不断递增。倘若他已经新建了三个文档，然后删除了”新建 Microsoft Office Word 文档(2).doc”，再新建一个就又会得到一个”新建 Microsoft Office Word 文档(2).doc”。严格来说，Windows在每次新建文档时，都会选取一个与已有文件编号不重复的最小正整数作为新文档的编号。 现在，请你编程模拟以上过程，支持以下两种操作： New：新建一个word文档，反馈新建的文档的编号； Delete id：删除一个编号为id的word文档，反馈删除是否成功。 初始时一个文件都没有，”新建 Microsoft Office Word 文档.doc”的编号算作1。输入描述:第一行一个正整数n表示操作次数，接下来n行，每行表示一个操作。若该行为”New”，则表示新建，为:Delete id”则表示要删除编号为id的文档，其中id为一个正整数。操作按输入顺序依次进行。操作次数不超过100000，删除编号的数值不超过100000。输出描述:对于输入的每一个操作，输出其反馈结果。对于新建操作，输出新建的文档的编号；对于删除操作，反馈删除是否成功：如果删除的文件存在，则删除成功，输出”Successful”，否则输出”Failed”。示例1输入1234567891011121312NewNewNewDelete 2NewDelete 4Delete 3Delete 1NewNewNewDelete 4 输出123456789101112123Successful2FailedSuccessfulSuccessful134Successful 题解学到set，好开心。用set&lt;int&gt;来维护可以创建的队列，然后模拟。 代码1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;const int MAXSIZE=100000+5;int main()&#123; int Case; cin&gt;&gt;Case; set&lt;int&gt; st; set&lt;int&gt;::iterator it; for(int i=1;i&lt;=MAXSIZE;i++) st.insert(i); while(Case--)&#123; string str; cin&gt;&gt;str; if(str=="New")&#123; it=st.begin(); cout&lt;&lt;*it&lt;&lt;endl; st.erase(it); &#125; else&#123; int a; cin&gt;&gt;a; if(!st.count(a))&#123; cout&lt;&lt;"Successful"&lt;&lt;endl; st.insert(a); &#125; else cout&lt;&lt;"Failed"&lt;&lt;endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>简单题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HihoCoder-1066-无间道之并查集]]></title>
    <url>%2F2018%2F11%2F29%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%2Fhihocode-1066-%E6%97%A0%E9%97%B4%E9%81%93%E4%B9%8B%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[描述描述这天天气晴朗、阳光明媚、鸟语花香，空气中弥漫着春天的气息……额，说远了，总之，小Hi和小Ho决定趁着这朗朗春光出去玩。 但是刚刚离开居住的宾馆不久，抄近道不小心走入了一条偏僻小道的小Hi和小Ho就发现自己的前方走来了几个彪形大汉，定睛一看还都是地地道道的黑人兄弟！小Hi和小Ho这下就慌了神，捡肥皂事小，这一身百把来斤别一不小心葬身他乡可就没处说去了。 就在两人正举足无措之时，为首的黑叔叔从怀里掏出了一件东西——两张花花绿绿的纸，分别递给了小Hi和小Ho。小Hi和小Ho接过来，只见上面写道（译为中文）：“本地最大的帮派——青龙帮，诚邀您的加入！”下面还详细的列出了加入青龙帮的种种好处。 于是两人略感心安，在同黑叔叔们交谈一番之后，已是均感相见恨晚。同时，在小Hi和小Ho表示自己不日便将回国之后，黑叔叔们也没有再提加入帮派之事，但是那为首的黑叔叔思索一会，开口道（译为中文）：“我现在有一个难题，思索了很久也没法子解决，既然你们俩都是高材生，不如来帮我看看。” 小Hi和小Ho点了点头表示没问题，于是黑叔叔继续说道：“这个问题是这样的，我们帮派最近混进了许多警察的卧底，但是在我们的调查过程中只能够知道诸如‘某人和另一个人是同阵营的’这样的信息，虽然没有办法知道他们具体是哪个阵营的，但是这样的信息也是很重要的，因为我们经常会想要知道某两个人究竟是不是同一阵营的。” 小Hi和小Ho赞同的点了点头，毕竟无间道也都是他们看过的。 黑叔叔接着说道：“于是现在问题就来了，我希望你们能写出这样一个程序，我会有两种操作，一种是告诉它哪两个人是同一阵营的，而另一种是询问某两个人是不是同一阵营的……既然你们就要回国了，不如现在就去我们帮派的总部写好这个程序再走把。” 为了生命安全与……小Hi和小Ho都不得不解决这个问题！那么他们究竟从何下手呢？ 提示：说起来其实就是不断的合并集合嘛~×Close提示：说起来其实就是不断的合并集合嘛~到了青龙帮的总部，望着桌上的电脑，小Ho陷入了沉思，良久，抬起头向小Hi道：“小Hi，你看我这样做可以么，一开始我将每个人视作一个仅由他们自己组成的集合，每次遇见op=0的操作，实际上就是合并这两个人所在的两个集合，而每次遇见op=1的操作，实际上就是询问这两个人是否在同一个集合中。” “你说的很有道理。”小Hi点头道：“但是集合并不是计算机中直接就存在的一个基础类型，你准备用什么样的方式去实现这个集合呢？” “用Set……”小Ho道。 小Hi脸色一黑，道：“能不能有点追求啦，Set那底层实现都是红黑树什么的，你依靠别人的设计虽说没什么问题，但是为了知识水平的提高，自己学习一下还是很有必要的嘛！” “但是……这么短的时间里，你让我学红黑树，我也一时半会学不会吧。”小Ho表示为难。 “没让你用红黑树，我今天就教你一个非常简单的维护集合的方法——并查集。”小Hi道：“这个方法非常简单，就是在每个集合里选出一个代表元素，并且令这个集合里面的每一个元素都指向这个代表元素。像你之前所说‘一开始我将每个人视作一个仅由他们自己组成的集合’，也就是对于每一个人Name_i，都令represent[Name_i]=Name_i。” “那合并怎么办呢？”小Ho问道。 “合并的话首先你要看这两个人A和B所在的集合是不是同一个集合，也就是represent[A]和represent[B]是否相同，如果相同自然无需合并，否则就要把这两个集合合并是吧？” “你这话不等于没说么……”小Ho表示抗议。 小Hi无视了这抗议继续说道：“如果我令A’=represent[A],B’=represent[B]，那么我令represent[A’]=B’是否就在某种意义上将这两个集合合并了？” 小Ho道：“你这个……只改变了A所在集合中一个元素A’的represent值，但是这个集合中其他元素的represent值都没有发生改变啊？” 小Hi挥了挥手道：“别着急，你看，所有原来A所在集合中的元素都指向A’，而A’指向了B’，那么也就是A所在集合里的所有元素如果顺着这条链一直找寻下去，最终找到的那个就一定是它所在集合的代表元素？” “没错……” “所以我们就可以将寻找代表元素，也就是求解represent值这个过程做成一个迭代的过程，比如求解X所在集合的represent值，我先令X’=represent[X]，如果X’=X的话，那么就能说明X所在集合的代表元素就是X本身，否则就令X’’=represent[X’]，如果X’’=X’的话那么就能说明X所在集合的代表元素就是X’……一直持续这样的操作就能够找到最终的集合代表元素了。”小Hi说着说着在纸上写了几行代码递了过来：“就像这样。” 小Ho仔细想了想，继续问道：“但是如果每次合并都是将一条链接到另外一个点上，这样的操作会不会特别的没有效率，接近O(N^2)了？” “是会有这个问题，但是你很容易就注意到——合并这个操作是不可逆的，也就是说如果我求解出了X所在集合的代表元素是X_r的话，那么我就可以直接令represent[X]=X_r，这样就可以避免在下一次询问X所在集合的代表元素的时候再进行一次这样的计算了。”言罢，小Hi将之前写下的代码稍作修改，又递了过来。 “原来是这样，那么我的合并操作实际上就是令represent[find_represent(A)]=find_represent(B)，而询问操作就是判断find_represent(A)和find_represent(B)是否想通了？”小Ho道。 “没错呢！所以赶紧开始写把！，呆久了我可不知道会发生什么呢！” 输入每个测试点（输入文件）有且仅有一组测试数据。 每组测试数据的第1行为一个整数N，表示黑叔叔总共进行的操作次数。 每组测试数据的第2~N+1行，每行分别描述黑叔叔的一次操作，其中第i+1行为一个整数op_i和两个由大小写字母组成的字符串Name1_i, Name2_i，其中op_i只可能为0或1，当op_i=0时，表示黑叔叔判定Name1_i和Name2_i是同一阵营的，当op_i=1时，表示黑叔叔希望知道Name1_i和Name2_i是否为同一阵营的。 对于100%的数据，满足N&lt;=10^5, 且数据中所有涉及的人物中不存在两个名字相同的人（即姓名唯一的确定了一个人），对于所有的i，满足Name1_i和Name2_i是不同的两个人。 输出对于每组测试数据，对于黑叔叔每次op_i=1的操作，输出一行，表示查询的结果：如果根据已知信息（即这次操作之前的所有op_i=0的操作），可以判定询问中的两个人是同一阵营的，则输出yes，否则输出no。 Sample Input1234567891011100 Steven David0 Lcch Dzx1 Lcch Dzx1 David Dzx0 Lcch David0 Frank Dzx1 Steven Dzx1 Frank David0 Steven Dzx0 Dzx Frank Sample Output1234yesnoyesyes 题解这道题学到了map的用法，好开心。把每一个人名在map中比较下，找到下标位置，然后直接套用并查集。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;cstdlib&gt;using namespace std;const int MAXSIZE=500000+10;map&lt;string,int&gt;mp;int k=0;int parent[MAXSIZE];int toParse(string str)&#123; if(mp.count(str)) return mp[str]; else&#123; mp[str]=k++; return mp[str]; &#125;&#125;void create()&#123; for(int i=0;i&lt;MAXSIZE;i++) parent[i]=i;&#125;int find(int x)&#123; while(x!=parent[x]) //找根节点 x=parent[x]; return x;&#125;void unit(int x,int y)&#123; x=find(x); y=find(y); if(x!=y) //直接合并集合 parent[x]=y;&#125;int main()&#123; int total; cin&gt;&gt;total; create(); k=0; while(total--)&#123; int flag; string str1,str2; cin&gt;&gt;flag&gt;&gt;str1&gt;&gt;str2; if(mp.count(str1)==0) mp[str1]=k++; if(mp.count(str2)==0) mp[str2]=k++; if(flag==1) if(find(mp[str1])==find(mp[str2])) cout&lt;&lt;"yes"&lt;&lt;endl; else cout&lt;&lt;"no"&lt;&lt;endl; else unit(mp[str1],mp[str2]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj-2524-Ubiquitous Religions]]></title>
    <url>%2F2018%2F11%2F29%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%2Fpoj2524%2F</url>
    <content type="text"><![CDATA[描述Ubiquitous ReligionsTime Limit: 5000MS Memory Limit: 65536KTotal Submissions: 41487 Accepted: 19782Description There are so many different religions in the world today that it is difficult to keep track of them all. You are interested in finding out how many different religions students in your university believe in. You know that there are n students in your university (0 &lt; n &lt;= 50000). It is infeasible for you to ask every student their religious beliefs. Furthermore, many students are not comfortable expressing their beliefs. One way to avoid these problems is to ask m (0 &lt;= m &lt;= n(n-1)/2) pairs of students and ask them whether they believe in the same religion (e.g. they may know if they both attend the same church). From this data, you may not know what each person believes in, but you can get an idea of the upper bound of how many different religions can be possibly represented on campus. You may assume that each student subscribes to at most one religion.Input The input consists of a number of cases. Each case starts with a line specifying the integers n and m. The next m lines each consists of two integers i and j, specifying that students i and j believe in the same religion. The students are numbered 1 to n. The end of input is specified by a line in which n = m = 0.Output For each test case, print on a single line the case number (starting with 1) followed by the maximum number of different religions that the students in the university believe in.Sample Input1234567891011121314151610 91 21 31 41 51 61 71 81 91 1010 42 34 54 85 80 0 Sample Output12Case 1: 1Case 2: 7 Hint Huge input, scanf is recommended.Source Alberta Collegiate Programming Contest 2003.10.18 题解用并查集把所有人的关系求出来。对总人数遍历，若某人处于一个集合的受位置（根节点），说明有一个集合，将集合加起来。 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;using namespace std;const int MAXSIZE=50000+10;int parent[MAXSIZE];void create(int people)&#123; for(int i=1;i&lt;=people;i++) parent[i]=i;&#125;int findParent(int x)&#123; while(x!=parent[x]) x=parent[x]; return x;&#125;void unit(int x,int y)&#123; x=findParent(x); y=findParent(y); parent[x]=y; &#125; int main()&#123; int people,Case; int Count=1; while(cin&gt;&gt;people&gt;&gt;Case)&#123; if(people==0&amp;&amp;Case==0) break; create(people); while(Case--)&#123; int a,b; cin&gt;&gt;a&gt;&gt;b; unit(a,b); &#125; int ans=0; for(int i=1;i&lt;=people;i++)&#123; if(i==parent[i]) ans++; &#125; cout&lt;&lt;"Case "&lt;&lt;Count++&lt;&lt;": "&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj-1611-The Suspects]]></title>
    <url>%2F2018%2F11%2F29%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%2Fpoj1611%2F</url>
    <content type="text"><![CDATA[描述The SuspectsTime Limit: 1000MS Memory Limit: 20000KTotal Submissions: 51831 Accepted: 24779Description Severe acute respiratory syndrome (SARS), an atypical pneumonia of unknown aetiology, was recognized as a global threat in mid-March 2003. To minimize transmission to others, the best strategy is to separate the suspects from others.In the Not-Spreading-Your-Sickness University (NSYSU), there are many student groups. Students in the same group intercommunicate with each other frequently, and a student may join several groups. To prevent the possible transmissions of SARS, the NSYSU collects the member lists of all student groups, and makes the following rule in their standard operation procedure (SOP).Once a member in a group is a suspect, all members in the group are suspects.However, they find that it is not easy to identify all the suspects when a student is recognized as a suspect. Your job is to write a program which finds all the suspects.Input The input file contains several cases. Each test case begins with two integers n and m in a line, where n is the number of students, and m is the number of groups. You may assume that 0 &lt; n &lt;= 30000 and 0 &lt;= m &lt;= 500. Every student is numbered by a unique integer between 0 and n−1, and initially student 0 is recognized as a suspect in all the cases. This line is followed by m member lists of the groups, one line per group. Each line begins with an integer k by itself representing the number of members in the group. Following the number of members, there are k integers representing the students in this group. All the integers in a line are separated by at least one space.A case with n = 0 and m = 0 indicates the end of the input, and need not be processed.Output For each case, output the number of suspects in one line.Sample Input12345678910100 42 1 25 10 13 11 12 142 0 12 99 2200 21 55 1 2 3 4 51 00 0 Sample Output123411 Source Asia Kaohsiung 2003 题解将0所在的集合的所有元素全部加起来即可。判断0与其他元素再同一个集合，仅需判断两元素根节点是否相同。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;iostream&gt;using namespace std;class Tree&#123; public: int data; int parent; int rank;&#125;;const int MAXSIZE=30000+5;Tree tree[MAXSIZE];void createTree(int people)&#123; for(int i=0;i&lt;people;i++)&#123; tree[i].data=i; tree[i].parent=i; tree[i].rank=0; &#125;&#125;int findParent(Tree tree[],int x)&#123; if(x!=tree[x].parent) findParent(tree,tree[x].parent); else return x;&#125;void unit(Tree tree[],int x,int y)&#123; x=findParent(tree,x); y=findParent(tree,y); if(tree[x].rank&gt;tree[y].rank)&#123; tree[y].parent=x; &#125; else&#123; tree[x].parent=y; if(tree[x].rank==tree[y].rank) tree[y].rank++; &#125; &#125;int main()&#123; int people,group; while(cin&gt;&gt;people&gt;&gt;group)&#123; if(people==0&amp;&amp;group==0) break; createTree(people); while(group--)&#123; int total; int num[MAXSIZE]; cin&gt;&gt;total; int a,b; cin&gt;&gt;a; for(int i=1;i&lt;total;i++)&#123; cin&gt;&gt;b; unit(tree,a,b); &#125; &#125; int result=1; int value=findParent(tree,0); //查找0元素的根节点 for(int i=1;i&lt;people;i++) if(value==findParent(tree,i)) result++; cout&lt;&lt;result&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu14.04mysql常用命令]]></title>
    <url>%2F2018%2F11%2F13%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2Fmysql%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[记录折腾阿里云服务器的求知经历 状态启动1sudo service mysql start 重启1sudo service mysql restart 关闭1sudo service mysql stop 使用创建数据库1mysql&gt; create database 数据库名称; 删除数据库（慎用）1mysql&gt; drop database 数据库名称; 查看数据库1mysql&gt; show databases; 对某数据库加入元素或者删除元素1mysql&gt; use 数据库名称; 数据表创建数据表1mysql&gt; create table 数据表名称 (字段参数); 如1mysql&gt; create table youtable (x int ,y int , z int); 删除数据表1mysql&gt; drop table 数据表名称; 查看某一数据库中有多少表1mysql&gt; show tables; 查看表中的字段1mysql&gt; select * from 数据表;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[判断连通图]]></title>
    <url>%2F2018%2F11%2F10%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E5%88%A4%E6%96%AD%E8%BF%9E%E9%80%9A%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[判断无向图是否连通 题目描述3967: 连通图时间限制: 1 Sec 内存限制: 32 MB提交: 4 解决: 4题目描述给定一个无向图和其中的所有边，判断这个图是否所有顶点都是连通的。 输入每组数据的第一行是两个整数 n 和 m（0&lt;=n&lt;=1000）。n 表示图的顶点数目，m 表示图中边的数目。如果 n 为 0 表示输入结束。随后有 m 行数据，每行有两个值 x 和 y（0&lt;x, y &lt;=n），表示顶点 x 和 y 相连，顶点的编号从 1 开始计算。输入不保证这些边是否重复。 输出对于每组输入数据，如果所有顶点都是连通的，输出”YES”，否则输出”NO”。 样例输入12345678910111213141516174 34 31 21 35 73 52 31 33 22 53 44 17 36 23 15 60 0 样例输出123YESYESNO 前几天写图遍历时，一直是按照书上先把矩阵转化为邻接表再遍历，这次终于换了一种方式。矩阵转邻接表：12345678910111213void MatToList(Graph *&amp;G, int n) &#123; Anode *p; for (int i = 1; i &lt;= n; i++) &#123; for (int j = n; j &gt;=1; j--) &#123; if (edge[i][j] == 1) &#123; p = new Anode; p-&gt;value = j; p-&gt;next = G-&gt;adjlist[i].firstarc; G-&gt;adjlist[i].firstarc = p; &#125; &#125; &#125;&#125; 想明白邻接表后直接对表头赋值如下1234567891011121314151617void input(Graph *&amp;G, int m) &#123; while (m--) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; Anode *p = new Anode; Anode *q = new Anode; p-&gt;value = b; q-&gt;value = a; p-&gt;next = G-&gt;adjlist[a].firstarc; G-&gt;adjlist[a].firstarc = p; q-&gt;next = G-&gt;adjlist[b].firstarc; G-&gt;adjlist[b].firstarc = q; &#125;&#125; AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;iostream&gt;using namespace std;const int MAXSIZE = 1000;int visited[MAXSIZE] = &#123; 0 &#125;;int edge[MAXSIZE][MAXSIZE] = &#123; 0 &#125;;class Anode &#123;public: int value; Anode *next;&#125;;class Adjlist &#123;public: Anode *firstarc;&#125;;class Graph &#123;public: Adjlist adjlist[MAXSIZE];&#125;;void initGraph(Graph *&amp;G, int n) &#123; G = new Graph; for (int i = 1; i &lt;= n; i++) G-&gt;adjlist[i].firstarc = NULL; //表头指针指向NULL&#125;void input(Graph *&amp;G, int m) &#123; while (m--) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; Anode *p = new Anode; Anode *q = new Anode; p-&gt;value = b; q-&gt;value = a; //头插法建表 p-&gt;next = G-&gt;adjlist[a].firstarc; G-&gt;adjlist[a].firstarc = p; q-&gt;next = G-&gt;adjlist[b].firstarc; G-&gt;adjlist[b].firstarc = q; &#125;&#125;void DFS(Graph *&amp;G, int count) &#123; Anode *p; visited[count] = 1; p = G-&gt;adjlist[count].firstarc; while (p != NULL) &#123; if (visited[p-&gt;value] == 0) DFS(G, p-&gt;value); //递归深搜 p = p-&gt;next; &#125;&#125;bool isConnectedGraph(Graph *&amp;G, int n) &#123; DFS(G, 1); for (int i = 1; i &lt;= n; i++) if (visited[i] != 1) //只要有一个节点未被访问就返回 return false; return true;&#125;int main()&#123; int n, m; while (cin &gt;&gt; n &gt;&gt; m) &#123; for (int i = 1; i &lt;= MAXSIZE; i++) &#123; visited[i] = 0 ; for (int j = 1; j &lt;= MAXSIZE; j++) edge[i][j] = 0; &#125; if (n == 0 &amp;&amp; m == 0) break; Graph *G; initGraph(G, n);//对图初始化 input(G,m); if (isConnectedGraph(G, n)) cout &lt;&lt; "YES" &lt;&lt; endl; else cout &lt;&lt; "NO" &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>图遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[银行排队]]></title>
    <url>%2F2018%2F11%2F10%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E9%93%B6%E8%A1%8C%E6%8E%92%E9%98%9F%2F</url>
    <content type="text"><![CDATA[数据结构，化腐朽为神奇的力量 问题描述3970: 银行排队时间限制: 1 Sec 内存限制: 32 MB提交: 5 解决: 5题目描述我们大多都有在银行排队的经历，唉，那坑爹的排队啊！现在就让我们来算算我们这些客户平均需要等多久吧。每天刚开始时银行会开m个窗口来为我们total个客户办理业务，当有客户需要办理业务时，先选择可以办理业务的窗口，如果有多个窗口可以办理业务就选择空闲时间最长的窗口，如果有多个窗口空闲的时间一样长，则选择序号小的窗口办理业务。假设我们每个人来到的时间和办理业务所需要的时间（为了简化问题，采用整数表示时间）都知道了。现在请你算算我们平均需要等待多久呢？ 输入有多组测试数据，每组数据开始有两个正整数m(&lt;20)和total(&lt;200)，后面有total对整数，对应客户先后到来的时间以及办理业务所需的时间。 输出平均等待的时间，保留两位小数。 样例输入1232 6 1 3 4 1 5 3 9 2 13 4 13 33 14 0 3 2 2 2 4 5 4 7 2 11 3 12 3 12 4 12 1 13 3 15 4 19 1 22 3 23 22 5 0 6 0 5 0 6 7 1 7 2 样例输出1230.000.291.20 题解利用数组来模拟队列，序号从小到大每一个数组元素表示一个窗口。首先分析一个人处理业务后的时间，假设只有一个窗口。来到的时间：x1；办理业务的时间为y1；那么这个窗口在x1+y1时间后才能被下一个人使用，即此人的离开时间 ；如果另一个人（来到时间x2，办理业务时间y2）在[x1,y1]时间段内到达，就意味着他必须等待的时间为y1-x2。 可分为两种情况：1、后者[x1,y1]的到达时间比前者[x2,y2]的离开时间晚。这个窗口的可使用时间为x1+y1；2、后者[x1,y1]来了，前者[x2,y2]还未离开。先记下这个窗口的编号，再遍历所有的窗口，若有窗口空闲，则取办理业务。否则，找到最早离开的人所在的窗口，计算等待时间，即为y1-x2。 代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt; const int MAXSIZE = 20; //定义10*10的矩阵大小using namespace std; double run(int m, int total) &#123; int countTime = 0; int a, b; int num[MAXSIZE] = &#123; 0 &#125;; while (total--) &#123; cin &gt;&gt; a &gt;&gt; b; int min = 0; int minTime = 1000; for (int i = 1; i &lt;= m; i++) &#123; if (a &gt;= num[i]) &#123; num[i] = a + b; min = 0; minTime = 1000; break; &#125; if (a &lt; num[i]&amp;&amp;minTime&gt;num[i]) &#123; min = i; minTime = num[i]; &#125; &#125; if (min != 0) &#123; countTime = countTime + num[min] - a; num[min] = num[min] + b; &#125; &#125; return countTime;&#125;int main()&#123; int m, total; while (cin &gt;&gt; m &gt;&gt; total) &#123; double countTime = run(m, total); printf("%.2lf\n", countTime/(1.0*total)); &#125; return 0;&#125; 关于 cout 浮点数输出头文件1#include&lt;iomanip&gt; 输出格式1cout&lt;&lt;setprecision(2)&lt;&lt;x&lt;&lt;endl;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>模拟队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu14.04mysql卸载与重装]]></title>
    <url>%2F2018%2F11%2F08%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2FMySQL%E5%8D%B8%E8%BD%BD%E9%87%8D%E8%A3%85%2F</url>
    <content type="text"><![CDATA[搭环境的遇到的问题，记录下来 安装MySQL1sudo apt-get install mysql-server mysql-client 卸载查看MySQL版本1mysql -V 选择MySQL的版本然后卸载1sudo apt-get autoremove --purge mysql-server-5.5 以下依次进行1sudo apt-get remove mysql-server 1sudo apt-get autoremove mysql-server 1sudo apt-get remove mysql-common 清理残留数据1dpkg -l |grep ^rc|awk '&#123;print $2&#125;' |sudo xargs dpkg -P 参考博文：Ubuntu彻底卸载MySQL、Apache2和Php的方法教程]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu14.04文件操作]]></title>
    <url>%2F2018%2F11%2F06%2FLinux%2Fubuntu14.04%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[使用xshell连接云服务器一些文件操作 安装rzsz1apt-get install lrzsz rzsz说明：sz命令 发送文件到本地： #sz filenamerz命令 将本地上传文件到服务器 #rz执行该命令后，在弹出框中选择要上传的文件即可 新建文件夹1mkdir filename 重命名文件1mv filename1 filename2 这也是移动某文件到另一文件目录下的操作]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>基本操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迷宫寻路可视化]]></title>
    <url>%2F2018%2F10%2F27%2F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%2F%E8%BF%B7%E5%AE%AB%E5%AF%BB%E8%B7%AF%E5%8F%AF%E8%A7%86%E5%8C%96%2F</url>
    <content type="text"><![CDATA[学了数据结构，一直想做个东西出来玩。八皇后？五子棋？贪吃蛇？推箱子？二叉树？来个我最熟悉的迷宫求解吧。函数说明：设置背景颜色：setbkcolor(RED);画线算法：line(x1,y1,x2,y2);画矩阵算法：rectangle(left,top,right,bottom);字体颜色：settextcolor(YELLOW);输出字符串：RECT r = { left,top,right,bottom}; drawtext(_T(“退出”), &amp;r, DT_CENTER | DT_VCENTER | DT_SINGLELINE);编译环境：Visual Studio 2017123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577#include &lt;iostream&gt;#include &lt;graphics.h&gt;#include&lt;malloc.h&gt;#include &lt;time.h&gt;#include &lt;conio.h&gt;//在控制台输入输出文件using namespace std;#define MAXSIZE 1000+10void MEUN2(struct Stack *&amp;stack, struct Queue *&amp;queue);void MEUN1(struct Stack *&amp;stack, struct Queue *&amp;queue);void init();void PrintLine();void FillColor();void QueueRoad(struct Queue *&amp;queue);void StackRoad(struct Stack *&amp;stack);//栈寻找迷宫路径struct Box&#123; int x; int y; int di;//方位值&#125;;struct Stack&#123; struct Box data[MAXSIZE]; int top;&#125;;//队列寻找迷宫路径struct Box1&#123; int x; int y; int pre;&#125;;struct Queue&#123; struct Box1 data[MAXSIZE]; int rear; int front;&#125;;int px1 = 0, px2 = 0, py1 = 0, py2 = 0;int flag1 = 0;//迷宫数组int mg[14][22] = &#123; 0 &#125;;//设置迷宫的边界void init() &#123; for (int i = 0; i &lt; 14; i++) for (int j = 0; j &lt; 22; j++) mg[i][j] = 0; for (int i = 0; i &lt; 14; i++) mg[i][21] = 1; for (int i = 0; i &lt; 14; i++) mg[i][0] = 1; for (int i = 0; i &lt; 22; i++) mg[13][i] = 1; for (int i = 0; i &lt; 22; i++) mg[0][i] = 1;&#125;//栈寻找路径bool StackFind(struct Stack *&amp;stack, int x1, int y1, int x2, int y2)&#123; int i = 0; int j = 0; struct Box box; //di的用来记录方位值，如果要退回的话，就不用再一次的重新来找一遍了 box.x = x1; box.y = y1; box.di = -1; stack-&gt;top++; stack-&gt;data[stack-&gt;top] = box; mg[x1][y1] = -1; //solidrectangle((box.y-1) * 50, (box.x-1) * 50, (box.y-1) * 50 + 50, (box.x-1) * 50 + 50); while (stack-&gt;top != -1) &#123; box = stack-&gt;data[stack-&gt;top]; int x = box.x; int y = box.y; int di = box.di; if (x == x2 &amp;&amp; y == y2) return true; else &#123; while (di &lt; 4) &#123; di++; switch (di) &#123; case 0: i = x - 1; j = y; break; case 1: i = x; j = y + 1; break; case 2: i = x + 1; j = y; break; case 3: i = x; j = y - 1; break; &#125; if (mg[i][j] == 0) break; &#125; if (di &lt; 4) &#123; stack-&gt;data[stack-&gt;top].di = di; box.x = i; box.y = j; box.di = -1; stack-&gt;top++; stack-&gt;data[stack-&gt;top] = box; mg[i][j] = -1; &#125; else &#123; stack-&gt;top--; mg[x][y] = 0; &#125; &#125; &#125; return false;&#125;//队列寻找路径bool QueueFind(struct Queue *&amp;queue, int x1, int y1, int x2, int y2)&#123; int i = 0; int j = 0; //pre的用来记录上一个可走方块在 struct Box1 box1; box1.x = x1; box1.y = y1; box1.pre = -1; queue-&gt;rear++; queue-&gt;data[queue-&gt;rear] = box1; mg[x1][y1] = -1; while (queue-&gt;rear != queue-&gt;front) &#123; queue-&gt;front++; box1 = queue-&gt;data[queue-&gt;front]; int x = box1.x; int y = box1.y; if (x == x2 &amp;&amp; y == y2) &#123; return true; &#125; else &#123; int di = -1; while (di &lt; 4) &#123; di++; switch (di) &#123; case 0: i = x - 1; j = y; break; case 1: i = x; j = y + 1; break; case 2: i = x + 1; j = y; break; case 3: i = x; j = y - 1; break; &#125; if (mg[i][j] == 0) &#123; box1.x = i; box1.y = j; box1.pre = queue-&gt;front; queue-&gt;rear++; queue-&gt;data[queue-&gt;rear] = box1; mg[i][j] = -1; &#125; &#125; &#125; &#125;&#125;//画迷宫图形void PrintLine()&#123; setbkcolor(WHITE); cleardevice(); //画迷宫图形 setlinecolor(BLACK); for (int i = 0; i &lt;= 1000; i += 50) line(i, 0, i, 1000); for (int i = 0; i &lt;= 600; i += 50) line(0, i, 1000, i);&#125;//填充颜色void FillColor()&#123; setfillcolor(RED); //填充颜色，以分别可走路径和不可走路径 int flag = 1; for (int i = 0; i &lt; 1000; i += 50) &#123; for (int j = 0; j &lt; 600; j += 50) &#123; //随机设置位置为不可走状态 flag = rand(); if (flag % 2 != 0 &amp;&amp; flag % 3 != 0) &#123; solidrectangle(i, j, i + 50, j + 50); mg[(j + 50) / 50][(i + 50) / 50] = 1; Sleep(10); &#125; &#125; &#125;&#125;void QueueRoad(struct Queue *&amp;queue)&#123; if (QueueFind(queue, px1, py1, px2, py2) == true) &#123; int root = queue-&gt;front; while (root != 0) &#123; int pre = queue-&gt;data[root].pre; queue-&gt;data[root].pre = -1; root = pre; &#125; struct Box1 box1; for (int i = 1; i &lt; queue-&gt;front; i++)&#123; if (queue-&gt;data[i].pre == -1) &#123; setfillcolor(GREEN); box1 = queue-&gt;data[i]; solidrectangle((box1.y - 1) * 50, (box1.x - 1) * 50, (box1.y - 1) * 50 + 50, (box1.x - 1) * 50 + 50); Sleep(1000); &#125; &#125; &#125;&#125;void StackRoad(struct Stack *&amp;stack)&#123; struct Box box; if (StackFind(stack, px1, py1, px2, py2) == true) &#123; for (int i = 1; i &lt; stack-&gt;top; i++) &#123; setfillcolor(GREEN); box = stack-&gt;data[i]; solidrectangle((box.y - 1) * 50, (box.x - 1) * 50, (box.y - 1) * 50 + 50, (box.x - 1) * 50 + 50); //暂停0.1s钟以便于观察路径过程 Sleep(1000); &#125; &#125;&#125;void MEUN1(struct Stack *&amp;stack,struct Queue *&amp;queue)&#123; initgraph(1300, 600); setbkmode(TRANSPARENT);//透明字体 HWND hwnd = GetHWnd();//获取当前窗口句柄 setbkcolor(RED); cleardevice(); setlinecolor(GREEN); settextcolor(GREEN);//字体颜色 LOGFONT f; gettextstyle(&amp;f); // 获取当前字体设置 f.lfHeight = 48; // 设置字体高度为 48 _tcscpy_s(f.lfFaceName, _T("微软雅黑")); // 设置字体为“黑体”(高版本 VC 推荐使用 _tcscpy_s 函数) //f.lfQuality = ANTIALIASED_QUALITY; // 设置输出效果为抗锯齿 settextstyle(&amp;f); // 设置字体样式 rectangle(550, 300, 750, 400); rectangle(550, 400, 750, 500); rectangle(550, 500, 750, 600); RECT r1 = &#123; 550, 300, 750, 400 &#125;; drawtext(_T("栈寻路"), &amp;r1, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r2 = &#123; 550, 400, 750, 500 &#125;; drawtext(_T("队列寻路"), &amp;r2, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r3 = &#123; 550,500,750,600 &#125;; drawtext(_T("退出"), &amp;r3, DT_CENTER | DT_VCENTER | DT_SINGLELINE); MOUSEMSG Mou; BeginBatchDraw(); bool flag = true; while (flag) &#123; Mou = GetMouseMsg(); switch (Mou.uMsg) &#123; case WM_MOUSEMOVE: EndBatchDraw(); if ((Mou.y &gt;= 300 &amp;&amp; Mou.y &lt;= 400) &amp;&amp; (Mou.x &lt;= 750 &amp;&amp; Mou.x &gt;= 550)) &#123; settextcolor(YELLOW); rectangle(550, 300, 750, 400); RECT r1 = &#123; 550, 300, 750, 400 &#125;; drawtext(_T("栈寻路"), &amp;r1, DT_CENTER | DT_VCENTER | DT_SINGLELINE); settextcolor(GREEN); rectangle(550, 400, 750, 500); RECT r2 = &#123; 550,400,750,500 &#125;; drawtext(_T("队列寻路"), &amp;r2, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r3 = &#123; 550, 750, 500, 600 &#125;; drawtext(_T("退出"), &amp;r3, DT_CENTER | DT_VCENTER | DT_SINGLELINE); &#125; else if (Mou.y &gt;= 400 &amp;&amp; Mou.y &lt;= 500 &amp;&amp; Mou.x &lt;= 750 &amp;&amp; Mou.x &gt;= 550) &#123; settextcolor(YELLOW); RECT r2 = &#123; 550,400,750,500 &#125;; drawtext(_T("队列寻路"), &amp;r2, DT_CENTER | DT_VCENTER | DT_SINGLELINE); settextcolor(GREEN); rectangle(550, 300, 750, 400); RECT r1 = &#123; 550, 300, 750, 400 &#125;; drawtext(_T("栈寻路"), &amp;r1, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r3 = &#123; 550, 750, 500, 600 &#125;; drawtext(_T("退出"), &amp;r3, DT_CENTER | DT_VCENTER | DT_SINGLELINE); &#125; else if (Mou.x &gt;= 550 &amp;&amp; Mou.x &lt;= 750 &amp;&amp; Mou.y &gt;= 500 &amp;&amp; Mou.y &lt;= 600) &#123; settextcolor(YELLOW); RECT r3 = &#123; 550, 500, 750, 600 &#125;; drawtext(_T("退出"), &amp;r3, DT_CENTER | DT_VCENTER | DT_SINGLELINE); settextcolor(GREEN); rectangle(550, 300, 750, 400); rectangle(550, 400, 750, 500); RECT r1 = &#123; 550, 300, 750, 400 &#125;; drawtext(_T("栈寻路"), &amp;r1, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r2 = &#123; 550, 400, 750, 500 &#125;; drawtext(_T("队列寻路"), &amp;r2, DT_CENTER | DT_VCENTER | DT_SINGLELINE); &#125; else &#123; settextcolor(GREEN); rectangle(550, 300, 750, 400); rectangle(550, 400, 750, 500); rectangle(550, 500, 750, 600); RECT r1 = &#123; 550, 300, 750, 400 &#125;; drawtext(_T("栈寻路"), &amp;r1, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r2 = &#123; 550, 400, 750, 500 &#125;; drawtext(_T("队列寻路"), &amp;r2, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r3 = &#123; 550,500,750,600 &#125;; drawtext(_T("退出"), &amp;r3, DT_CENTER | DT_VCENTER | DT_SINGLELINE); &#125; break; case WM_LBUTTONDOWN: EndBatchDraw(); if (Mou.x &gt;= 550 &amp;&amp; Mou.x &lt;= 750 &amp;&amp; Mou.y &lt;= 400 &amp;&amp; Mou.y &gt;= 300) &#123; flag1 = 1; closegraph(); MEUN2(stack,queue); &#125; else if (Mou.x &gt;= 550 &amp;&amp; Mou.x &lt;= 750 &amp;&amp; Mou.y &gt;= 400 &amp;&amp; Mou.y &lt;= 500)&#123; flag1 = 2; closegraph(); MEUN2(stack,queue); &#125; else if (Mou.x &gt;= 550 &amp;&amp; Mou.x &lt;= 750 &amp;&amp; Mou.y &gt;= 500 &amp;&amp; Mou.y &lt;= 600) &#123; closegraph(); flag = false; &#125; break; &#125; &#125;&#125;void MEUN2(struct Stack *&amp;stack, struct Queue *&amp;queue)&#123; initgraph(1300, 600); setbkcolor(WHITE); cleardevice(); PrintLine(); settextcolor(GREEN);//字体颜色 LOGFONT f; gettextstyle(&amp;f); // 获取当前字体设置 f.lfHeight = 48; // 设置字体高度为 48 _tcscpy_s(f.lfFaceName, _T("微软雅黑")); // 设置字体为“黑体”(高版本 VC 推荐使用 _tcscpy_s 函数) f.lfQuality = ANTIALIASED_QUALITY; // 设置输出效果为抗锯齿 settextstyle(&amp;f); // 设置字体样式 rectangle(1050, 100, 1250, 150);//设置起点 rectangle(1050, 150, 1250, 200);//设置终点 rectangle(1050, 200, 1250, 250);//随机障碍 rectangle(1050, 250, 1250, 300);//开始寻路 rectangle(1050, 300, 1250, 350);//退出迷宫 RECT r1 = &#123; 1050, 100, 1250, 150 &#125;; drawtext(_T("设置起点"), &amp;r1, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r2 = &#123; 1050, 150, 1250, 200 &#125;; drawtext(_T("设置终点"), &amp;r2, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r3 = &#123; 1050, 200, 1250, 250 &#125;; drawtext(_T("随机障碍"), &amp;r3, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r4 = &#123; 1050, 250, 1250, 300 &#125;; drawtext(_T("开始寻路"), &amp;r4, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r5 = &#123; 1050, 300, 1250, 350 &#125;; drawtext(_T("退出迷宫"), &amp;r5, DT_CENTER | DT_VCENTER | DT_SINGLELINE); MOUSEMSG Mou; while (true) &#123; Mou = GetMouseMsg(); BeginBatchDraw(); switch (Mou.uMsg) &#123; case WM_MOUSEMOVE: EndBatchDraw(); if ((Mou.x &gt;= 1050 &amp;&amp; Mou.x &lt;= 1250) &amp;&amp; (Mou.y &gt;= 100 &amp;&amp; Mou.y &lt;= 150)) &#123; settextcolor(YELLOW); rectangle(1050, 100, 1250, 150); RECT r1 = &#123; 1050, 100, 1250, 150 &#125;; drawtext(_T("设置起点"), &amp;r1, DT_CENTER | DT_VCENTER | DT_SINGLELINE); settextcolor(GREEN); rectangle(1050, 150, 1250, 200);//设置终点 rectangle(1050, 200, 1250, 250);//随机障碍 rectangle(1050, 250, 1250, 300);//开始寻路 rectangle(1050, 300, 1250, 350);//退出迷宫 RECT r2 = &#123; 1050, 150, 1250, 200 &#125;; drawtext(_T("设置终点"), &amp;r2, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r3 = &#123; 1050, 200, 1250, 250 &#125;; drawtext(_T("随机障碍"), &amp;r3, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r4 = &#123; 1050, 250, 1250, 300 &#125;; drawtext(_T("开始寻路"), &amp;r4, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r5 = &#123; 1050, 300, 1250, 350 &#125;; drawtext(_T("退出迷宫"), &amp;r5, DT_CENTER | DT_VCENTER | DT_SINGLELINE); &#125; else if (Mou.x &gt;= 1050 &amp;&amp; Mou.x &lt;= 1250 &amp;&amp; Mou.y &gt;= 150 &amp;&amp; Mou.y &lt;= 200) &#123; settextcolor(YELLOW); rectangle(1050, 150, 1250, 200); RECT r2 = &#123; 1050, 150, 1250, 200 &#125;; drawtext(_T("设置终点"), &amp;r2, DT_CENTER | DT_VCENTER | DT_SINGLELINE); settextcolor(GREEN); rectangle(1050, 100, 1250, 150);//设置起点 rectangle(1050, 200, 1250, 250);//随机障碍 rectangle(1050, 250, 1250, 300);//开始寻路 rectangle(1050, 300, 1250, 350);//退出迷宫 RECT r1 = &#123; 1050, 100, 1250, 150 &#125;; drawtext(_T("设置起点"), &amp;r1, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r3 = &#123; 1050, 200, 1250, 250 &#125;; drawtext(_T("随机障碍"), &amp;r3, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r4 = &#123; 1050, 250, 1250, 300 &#125;; drawtext(_T("开始寻路"), &amp;r4, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r5 = &#123; 1050, 300, 1250, 350 &#125;; drawtext(_T("退出迷宫"), &amp;r5, DT_CENTER | DT_VCENTER | DT_SINGLELINE); &#125; else if (Mou.x &gt;= 1050 &amp;&amp; Mou.x &lt;= 1250 &amp;&amp; Mou.y &gt;= 200 &amp;&amp; Mou.y &lt;= 250) &#123; stack-&gt;top = -1; queue-&gt;front = queue-&gt;rear = -1; settextcolor(YELLOW); rectangle(1050, 200, 1250, 250); RECT r3 = &#123; 1050, 200, 1250, 250 &#125;; drawtext(_T("随机障碍"), &amp;r3, DT_CENTER | DT_VCENTER | DT_SINGLELINE); settextcolor(GREEN); rectangle(1050, 100, 1250, 150);//设置起点 rectangle(1050, 150, 1250, 200);//设置终点 rectangle(1050, 250, 1250, 300);//开始寻路 rectangle(1050, 300, 1250, 350);//退出迷宫 RECT r1 = &#123; 1050, 100, 1250, 150 &#125;; drawtext(_T("设置起点"), &amp;r1, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r2 = &#123; 1050, 150, 1250, 200 &#125;; drawtext(_T("设置终点"), &amp;r2, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r4 = &#123; 1050, 250, 1250, 300 &#125;; drawtext(_T("开始寻路"), &amp;r4, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r5 = &#123; 1050, 300, 1250, 350 &#125;; drawtext(_T("退出迷宫"), &amp;r5, DT_CENTER | DT_VCENTER | DT_SINGLELINE); &#125; else if (Mou.x &gt;= 1050 &amp;&amp; Mou.x &lt;= 1250 &amp;&amp; Mou.y &lt;= 300 &amp;&amp; Mou.y &gt;= 250) &#123; settextcolor(YELLOW); rectangle(1050, 250, 1250, 300); RECT r4 = &#123; 1050, 250, 1250, 300 &#125;; drawtext(_T("开始寻路"), &amp;r4, DT_CENTER | DT_VCENTER | DT_SINGLELINE); settextcolor(GREEN); rectangle(1050, 100, 1250, 150);//设置起点 rectangle(1050, 150, 1250, 200);//设置终点 rectangle(1050, 200, 1250, 250);//随机障碍 rectangle(1050, 300, 1250, 350);//退出迷宫 RECT r1 = &#123; 1050, 100, 1250, 150 &#125;; drawtext(_T("设置起点"), &amp;r1, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r2 = &#123; 1050, 150, 1250, 200 &#125;; drawtext(_T("设置终点"), &amp;r2, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r3 = &#123; 1050, 200, 1250, 250 &#125;; drawtext(_T("随机障碍"), &amp;r3, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r5 = &#123; 1050, 300, 1250, 350 &#125;; drawtext(_T("退出迷宫"), &amp;r5, DT_CENTER | DT_VCENTER | DT_SINGLELINE); &#125; else if (Mou.x &gt;= 1050 &amp;&amp; Mou.x &lt;= 1250 &amp;&amp; Mou.y &gt;= 300 &amp;&amp; Mou.y &lt;= 350) &#123; settextcolor(YELLOW); rectangle(1050, 250, 1250, 300); RECT r5 = &#123; 1050, 300, 1250, 350 &#125;; drawtext(_T("退出迷宫"), &amp;r5, DT_CENTER | DT_VCENTER | DT_SINGLELINE); settextcolor(GREEN); rectangle(1050, 100, 1250, 150);//设置起点 rectangle(1050, 150, 1250, 200);//设置终点 rectangle(1050, 200, 1250, 250);//随机障碍 rectangle(1050, 250, 1250, 300);//开始寻路 RECT r1 = &#123; 1050, 100, 1250, 150 &#125;; drawtext(_T("设置起点"), &amp;r1, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r2 = &#123; 1050, 150, 1250, 200 &#125;; drawtext(_T("设置终点"), &amp;r2, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r3 = &#123; 1050, 200, 1250, 250 &#125;; drawtext(_T("随机障碍"), &amp;r3, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r4 = &#123; 1050, 250, 1250, 300 &#125;; drawtext(_T("开始寻路"), &amp;r4, DT_CENTER | DT_VCENTER | DT_SINGLELINE); &#125; else &#123; settextcolor(GREEN); rectangle(1050, 100, 1250, 150);//设置起点 rectangle(1050, 150, 1250, 200);//设置终点 rectangle(1050, 200, 1250, 250);//随机障碍 rectangle(1050, 250, 1250, 300);//开始寻路 rectangle(1050, 300, 1250, 350);//退出迷宫 RECT r1 = &#123; 1050, 100, 1250, 150 &#125;; drawtext(_T("设置起点"), &amp;r1, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r2 = &#123; 1050, 150, 1250, 200 &#125;; drawtext(_T("设置终点"), &amp;r2, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r3 = &#123; 1050, 200, 1250, 250 &#125;; drawtext(_T("随机障碍"), &amp;r3, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r4 = &#123; 1050, 250, 1250, 300 &#125;; drawtext(_T("开始寻路"), &amp;r4, DT_CENTER | DT_VCENTER | DT_SINGLELINE); RECT r5 = &#123; 1050, 300, 1250, 350 &#125;; drawtext(_T("退出迷宫"), &amp;r5, DT_CENTER | DT_VCENTER | DT_SINGLELINE); &#125; break; case WM_LBUTTONDOWN: EndBatchDraw(); if (Mou.x &gt;= 1050 &amp;&amp; Mou.x &lt;= 1250 &amp;&amp; Mou.y &gt;= 100 &amp;&amp; Mou.y &lt;= 150) &#123; bool flag = true; while (flag) &#123; //FlushMouseMsgBuffer(); Mou = GetMouseMsg(); BeginBatchDraw(); switch (Mou.uMsg) &#123; case WM_LBUTTONDOWN: EndBatchDraw(); py1 = Mou.x / 50; px1 = Mou.y / 50; if (mg[py1 + 1][px1 + 1] != 1) &#123; setfillcolor(BLUE); fillrectangle(Mou.x / 50 * 50, Mou.y / 50 * 50, Mou.x / 50 * 50 + 50, Mou.y / 50 * 50 + 50); flag = false; &#125; py1 += 1; px1 += 1; break; &#125; &#125; &#125; else if (Mou.x &gt;= 1050 &amp;&amp; Mou.x &lt;= 1250 &amp;&amp; Mou.y &gt;= 150 &amp;&amp; Mou.y &lt;= 200) &#123; bool flag = true; while (flag) &#123; //FlushMouseMsgBuffer(); Mou = GetMouseMsg(); BeginBatchDraw(); switch (Mou.uMsg) &#123; case WM_LBUTTONDOWN: EndBatchDraw(); py2 = Mou.x / 50; px2 = Mou.y / 50; if (mg[py2 + 1][px2 + 1] != 1) &#123; setfillcolor(YELLOW); fillrectangle(Mou.x / 50 * 50, Mou.y / 50 * 50, Mou.x / 50 * 50 + 50, Mou.y / 50 * 50 + 50); flag = false; &#125; py2 += 1; px2 += 1; break; &#125; &#125; &#125; else if (Mou.x &gt;= 1050 &amp;&amp; Mou.x &lt;= 1250 &amp;&amp; Mou.y &gt;= 200 &amp;&amp; Mou.y &lt;= 250) &#123; stack-&gt;top = -1; queue-&gt;front = queue-&gt;rear = -1; init(); cleardevice(); PrintLine(); FillColor(); &#125; else if (Mou.x &gt;= 1050 &amp;&amp; Mou.x &lt;= 1250 &amp;&amp; Mou.y &lt;= 300 &amp;&amp; Mou.y &gt;= 250) &#123; if (flag1 == 1) &#123; cout &lt;&lt; px1 &lt;&lt; ' ' &lt;&lt; py1 &lt;&lt; endl; cout &lt;&lt; px2 &lt;&lt; ' ' &lt;&lt; py2 &lt;&lt; endl; StackRoad(stack); &#125; else if (flag1 == 2) &#123; cout &lt;&lt; px1 &lt;&lt; ' ' &lt;&lt; py1 &lt;&lt; endl; cout &lt;&lt; px2 &lt;&lt; ' ' &lt;&lt; py2 &lt;&lt; endl; QueueRoad(queue); &#125; &#125; else if (Mou.x &gt;= 1050 &amp;&amp; Mou.x &lt;= 1250 &amp;&amp; Mou.y &gt;= 300 &amp;&amp; Mou.y &lt;= 350) &#123; closegraph(); stack-&gt;top = -1; queue-&gt;front = queue-&gt;rear = -1; flag1 = 0; init(); MEUN1(stack,queue); &#125; &#125; &#125;&#125;int main()&#123; //栈 struct Stack *stack; stack = (struct Stack *)malloc(sizeof(struct Stack)); stack-&gt;top = -1; //队列 struct Queue *queue; queue = (struct Queue *)malloc(sizeof(struct Queue)); queue-&gt;rear = queue-&gt;front = -1; //设置迷宫边界值 init(); //Sleep(1000); MEUN1(stack,queue); return 0;&#125; 编译完整版本：链接：https://pan.baidu.com/s/1RrWjaRj_w47mxJy3aWdBhw提取码：0dy0 下个目标：五子棋？]]></content>
      <categories>
        <category>课程设计</category>
      </categories>
      <tags>
        <tag>小玩具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈队列容器用法整理]]></title>
    <url>%2F2018%2F10%2F27%2FSTL%2F%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[记下学习STL的经历。STL很强大。变量减少了，代码也更清晰明了。但有个困惑的地方，我个人使用队列写题的时候，会采用一种取巧的方法，就是随机访问队列中的元素（大概会被老师打死qwq）如下1for(int i=queue-&gt;front;i&lt;=queue-&gt;rear;i++) 但在STL里没有？是不鼓励我们这么做吧，囧rz。 stack容器stack的模板包含在#include&lt;stack&gt;内 定义：123stack&lt;int&gt; s;stack&lt;double&gt; s;stack&lt;char&gt; s; 基本用法：12345入栈：s.push(x);出栈：s.pop(); 出栈只是删除栈顶元素并不返回该元素判断栈空：s.empty();若为空返回ture访问栈顶：s.top();访问栈的元素个数：s.size(); 应用实列–括号匹配1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;string&gt;using namespace std;int main()&#123; int Case; cin &gt;&gt; Case; while (Case--) &#123; string str; stack&lt;char&gt; s; cin &gt;&gt; str; string::iterator it; for (it = str.begin(); it != str.end(); it++) &#123; if (*it == '[' || *it == '&#123;' || *it == '(') &#123; s.push(*it); &#125; if (*it == ']') if (s.empty()||s.top() != '[') break; else s.pop(); if (*it == ')') if (s.empty() || s.top() != '(') break; else s.pop(); if (*it == '&#125;') if (s.empty() || s.top() != '&#123;') break; else s.pop(); &#125; if (!s.empty() || it &lt; str.end()) cout &lt;&lt; "No" &lt;&lt; endl; else cout &lt;&lt; "Yes" &lt;&lt; endl; &#125; return 0;&#125; 队列queue包含在#include&lt;queue&gt;中 定义123queue&lt;int&gt; q;queue&lt;double&gt; q;queue&lt;char&gt; q; 基本用法123456入队：queue.push(x);出队：queue.pop(); 出队只是删除队首元素并不返回该元素判断队空：queue.empty();访问队首元素：queue.front();访问队尾元素：queue.back();访问队列中元素个数：queue.size(); 应用实例–队列元素倒置1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;string&gt;#include&lt;malloc.h&gt;#define MAXSIZE 10using namespace std;int main()&#123; char str[MAXSIZE]; cin &gt;&gt; str; stack&lt;char&gt; stack; queue&lt;char&gt; queue; for (int i = 0; i &lt; strlen(str); i++)&#123; queue.push(str[i]); &#125; cout &lt;&lt;"the queue's size is "&lt;&lt; queue.size() &lt;&lt; endl; while (!queue.empty()) &#123; stack.push(queue.front()); queue.pop(); &#125; while (!stack.empty()) &#123; queue.push(stack.top()); stack.pop(); &#125; while (!queue.empty()) &#123; char x = queue.front(); cout &lt;&lt; x &lt;&lt; ' '; queue.pop(); &#125; return 0;&#125; 时间过的好快啊。]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hustoj的一些操作]]></title>
    <url>%2F2018%2F10%2F25%2FLinux%2Fhustoj%E7%BB%B4%E6%8A%A4%2F</url>
    <content type="text"><![CDATA[从10月5号开始OJ的导入数据，然，未知的总是让人恐惧。陆陆续续搞了多少天？网站挂了，数据库删了，一切重新来一遍吧。想到什么说什么啊！永远告诉自己啊！不要瞎操作啊！教训啊！你知道我这些天怎么过的啊！心里郁闷啊！明明是一样的操作啊！明明一样的环境啊！为什么得到不同的结果啊！ navicat连接数据库要想navicat能够连接到数据库，需要满足两个条件1、数据库用户有足够的权限访问数据库里说有的数据2、开放3306端口 创建数据库用户并分配权限登录数据库12root@Ubuntu:~# mysql -u root -pEnter password: 按提示输入密码注意：在数据库下所有命令都要以 ；结尾。 查看数据库用户名1select host,user,password from mysql.user; 一般来说输入上面命令会出现如下123456789101112mysql&gt; select Host,user,password from mysql.user;+-----------+------------------+-------------------------------------------+| Host | user | password |+-----------+------------------+-------------------------------------------+| localhost | root | password| ubuntu | root | password| 127.0.0.1 | root | password| ::1 | root | password| localhost | debian-sys-maint | password| % | passwords | password+-----------+------------------+-------------------------------------------+6 rows in set (0.00 sec) 其中Host栏目下的%代表该用户拥有所有的权限，如果没有该用户，就需要创建。 创建用户1234mysql&gt; create user youname identified by 'youname';Query OK, 0 rows affected (0.00 sec)mysql&gt; 其中第一个youname是你创建的这个数据库用户名的名称，第二个youname就是密码了。 授权1234mysql&gt; grant all privileges on *.* to 'youname'@'%'identified by 'youname' with grant option; Query OK, 0 rows affected (0.00 sec)mysql&gt; 操作完成后刷新mysql用户权限相关表1234mysql&gt; flush privileges ;Query OK, 0 rows affected (0.00 sec)mysql&gt; 查看端口开放1netstat -an | grep 3306 出现如下表示端口开放,12root@Ubuntu:~# netstat -an | grep 3306tcp 0 0 0.0.0.0:3306 0.0.0.0:* LISTEN 若是1127.0.0.1:3306 表示3306端口被本机IP绑定，外机无法访问，所以需要将其开放。 打开my.cnf配置文件1root@Ubuntu:~# vim /etc/mysql/my.cnf 找到 bind-address =127.0.0.1，将其注释掉或者改为bind-address = 0.0.0.01234567## Instead of skip-networking the default is now to listen only on# localhost which is more compatible and is not less secure.bind-address = 127.0.0.1## * Fine Tuning# 如此navicat就可以连接上数据库了。 OJ重要的配置文件1234/home/judge/etc/judge.conf/home/judge/src/web/include/db_info.inc.php/etc/php5/fpm/php.ini 或 /etc/php7.0/fpm/php.ini/etc/nginx/sites-enabled/default 开启考试模式因为学校作业练习的需要，在考试时需要改成比赛模式，以防止使用原来提交过的代码。修改db_info.inc.php文件1root@Ubuntu:~# vim /home/judge/src/web/include/db_info.inc.php 如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;?php @session_start(); ini_set("display_errors","Off"); //set this to "On" for debugging ,especially when no reason blank shows up. ini_set("session.cookie_httponly", 1); header('X-Frame-Options:SAMEORIGIN');//for people using hustoj out of China , be careful of the last two line of this file !// connect db static $DB_HOST="localhost";static $DB_NAME="jol";static $DB_USER="root";static $DB_PASS="root";//上面四行中如果没有问题就不要动，都是默认好的。可能数据库账户密码不是root，这点并不影响。//16.04安装可能数据库账户密码为空，如果为空，账户填写为 root 密码填写 自己设置的。//如果需要改写的话一定要用vim或者vi打开static $OJ_NAME="HUSTOJ";static $OJ_HOME="./";static $OJ_ADMIN="root@localhost";static $OJ_DATA="/home/judge/data";static $OJ_BBS="discuss3";//"bbs" for phpBB3 bridge or "discuss" for mini-forumstatic $OJ_ONLINE=false;static $OJ_LANG="en";static $OJ_SIM=false; static $OJ_DICT=false;static $OJ_LANGMASK=0; //1mC 2mCPP 4mPascal 8mJava 16mRuby 32mBash 1008 for security reason to mask all other languagestatic $OJ_EDITE_AREA=true;//true: syntax highlighting is activestatic $OJ_ACE_EDITOR=true;static $OJ_AUTO_SHARE=false;//true: One can view all AC submit if he/she has ACed it onece.static $OJ_CSS="white.css";static $OJ_SAE=false; //using sina application enginestatic $OJ_VCODE=false;static $OJ_APPENDCODE=false;static $OJ_CE_PENALTY=false;static $OJ_PRINTER=false;static $OJ_MAIL=false;static $OJ_MEMCACHE=false;static $OJ_MEMSERVER="127.0.0.1";static $OJ_MEMPORT=11211;static $OJ_REDIS=false;static $OJ_REDISSERVER="127.0.0.1";static $OJ_REDISPORT=6379;static $OJ_REDISQNAME="hustoj";static $SAE_STORAGE_ROOT="http://hustoj-web.stor.sinaapp.com/";static $OJ_TEMPLATE="bs3"; //使用的默认模板if(isset($_GET['tp'])) $OJ_TEMPLATE=$_GET['tp'];static $OJ_LOGIN_MOD="hustoj";static $OJ_REGISTER=true; //允许注册新用户static $OJ_REG_NEED_CONFIRM=false; //新注册用户需要审核static $OJ_NEED_LOGIN=false; //需要登录才能访问static $OJ_RANK_LOCK_PERCENT=0; //比赛封榜时间比例static $OJ_SHOW_DIFF=false; //是否显示WA的对比说明static $OJ_TEST_RUN=false; //提交界面是否允许测试运行static $OJ_BLOCKLY=false; //是否启用Blockly界面static $OJ_ENCODE_SUBMIT=false; //是否启用base64编码提交的功能，用来回避WAF防火墙误拦截。//static $OJ_EXAM_CONTEST_ID=1000; // 启用考试状态，填写考试比赛ID//static $OJ_ON_SITE_CONTEST_ID=1000; //启用现场赛状态，填写现场赛比赛IDstatic $OJ_OPENID_PWD = '8a367fe87b1e406ea8e94d7d508dcf01';/* weibo config here */static $OJ_WEIBO_AUTH=false;static $OJ_WEIBO_AKEY='1124518951';static $OJ_WEIBO_ASEC='df709a1253ef8878548920718085e84b';static $OJ_WEIBO_CBURL='http://192.168.0.108/JudgeOnline/login_weibo.php';/* renren config here */static $OJ_RR_AUTH=false;static $OJ_RR_AKEY='d066ad780742404d85d0955ac05654df';static $OJ_RR_ASEC='c4d2988cf5c149fabf8098f32f9b49ed';static $OJ_RR_CBURL='http://192.168.0.108/JudgeOnline/login_renren.php';/* qq config here */static $OJ_QQ_AUTH=false;static $OJ_QQ_AKEY='1124518951';static $OJ_QQ_ASEC='df709a1253ef8878548920718085e84b';static $OJ_QQ_CBURL='192.168.0.108';//if(date('H')&lt;5||date('H')&gt;21||isset($_GET['dark'])) $OJ_CSS="dark.css";if( isset($_SERVER['HTTP_ACCEPT_LANGUAGE']) &amp;&amp; strstr($_SERVER['HTTP_ACCEPT_LANGUAGE'],"zh-CN")) &#123; $OJ_LANG="cn";&#125;if (isset($_SESSION[$OJ_NAME.'_'.'OJ_LANG'])) $OJ_LANG=$_SESSION[$OJ_NAME.'_'.'OJ_LANG'];require_once(dirname(__FILE__)."/pdo.php"); // use db //pdo_query("set names utf8"); if(isset($OJ_CSRF)&amp;&amp;$OJ_CSRF&amp;&amp;$OJ_TEMPLATE=="bs3"&amp;&amp;basename($_SERVER['PHP_SELF'])!="problem_judge") require_once('csrf_check.php'); //sychronize php and mysql server with timezone settings, dafault setting for China //if you are not from China, comment out these two lines or modify them. //date_default_timezone_set("PRC"); //pdo_query("SET time_zone ='+8:00'");?&gt; 找到并取消注释就可以了12//static $OJ_EXAM_CONTEST_ID=1000; // 启用考试状态，填写考试比赛ID//static $OJ_ON_SITE_CONTEST_ID=1000; //启用现场赛状态，填写现场赛比赛ID OJ判题语言，找到并修改1static $OJ_LANGMASK=0; //1mC 2mCPP 4mPascal 8mJava 16mRuby 32mBash 1008 for security reason to mask all other language 在源码中的位置1root@Ubuntu:~# vim /home/judge/src/core/judge_client/judge_client.cc 大约在130行，这个文件有2000+行代码qwq123456#ifdef _mysql_hMYSQL *conn;#endifstatic char lang_ext[18][8] = &#123; "c", "cc", "pas", "java", "rb", "sh", "py", "php", "pl", "cs", "m", "bas", "scm","c","cc","lua","js","go" &#125;; 按照上文$OJ_LANGMASK=0代表所有的语言都可以提交，可知0决定何种语言可以使用。先说明0代表启用，1代表禁用。比如想要c和c++可以使用，那么二进制编码就是001111111111111111，转换成十进制就是‭65535‬，让 OJ_LANGMASK=65535就可以了。 转移数据库关于把原来服务器上的OJ上的数据全部转移到另一台服务器上的具体命令。首先在新服务器上装上hustoj。两个重要的数据：jol数据库 学生做题记录，ac代码/home/judge/data 题目的测试数据 转移jol在原来服务器上12mysqldump -u root -p密码 数据库名 &gt; 数据库文件路径如：mysqldump -u root -ppassword jol &gt; /home/jol.sql //在home文件下的data.sql文件 下载到本地：sz 命令是从linux下载文件到本地1sz /home/jol.sql 在后一台服务器上把本地的文件上传到该服务器上进入相应的文件路径，然后输入rz选择你本地（假如是window）1rz 登录数据库1mysql - u root -p 选择转入的数据库1use jol; 然后把jol.sql传入database中，注意/home/jol.sql是你从本地上传到服务器上的文件路径1source /home/jol.sql; 转移/home/judge/data原服务器上打包data(不压缩)1tar -cvf /home/judge/data.tar data 下载到本地1sz /home/judge/data.tar 后一台服务器上将data.tar上传到/home/judge1rz 在路径/home/judge下解包1tar -xvf data.tar 可以了。维护工作尚在进行，祝自己好运吧，qwq。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>OJ运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对未来的一些规划]]></title>
    <url>%2F2018%2F10%2F24%2F%E9%9A%8F%E7%AC%94%E6%9D%82%E6%83%B3%2Fdowhatiwant%2F</url>
    <content type="text"><![CDATA[子在川上曰：逝者如斯夫，不舍昼夜。不知不觉中已经快要11月了，想起来电脑已经买来4个月了。也做过一些好玩的东西，但不知怎么地总是达不到心理的预期目标。明明好像一直呆在实验室，但为什么心里就是感觉不踏实呢？或许看到别人的状态，以为自己还是学到了东西，其实眼光一直局限在学校内，看不到外面的世界，井底之蛙罢了。YI到底还是做出了选择。心里肯定非常不甘的，但还有什么用呢？当初逃避的是你，能怨谁呢？只是在默默祝福。图形学是要学的。但怎么学呢？Csharp你花了多少时间？听说你又想搞前端了？蓝桥杯有能力拿奖吗？网络安全技能大赛又懂得多少？Linux+MySQL现在开始了吗？以前没有服务器，现在有个服务器了你又干了多少事？OJ你不能落下，这是你接的任务就必须完成！数据结构好久没做题了，准备什么时候开始？算法作为计算机专业的核心课程，懂了多少？六级考试只剩50多天了，做了几个题，背了几个单词，听力练过吗？现在就好好考虑吧？我真的担心你一事无成，白白浪费父母的血汉钱！ 主线：计算机图形学+CPP 副线：csharp 到leetcode上写题 熟练语法后开始跟项目 跟上副线：数据结构+算法 解决 蓝桥杯 前端+服务器 前端每天练习30分钟，不做完不睡觉 六级英语：听力 单词 阅读 其中听力单词最为重要 最后做：Linux+Mysql解决OJ linux看鸟哥的书 对于课间的时间就别刷知乎了，看前端也行Linux也可以。手机知乎就卸了吧]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算器2.0实现]]></title>
    <url>%2F2018%2F10%2F11%2Fcsharp%2F%E8%AE%A1%E7%AE%97%E5%99%A82.0%2F</url>
    <content type="text"><![CDATA[前文描述上次已经写过一个计算器1.0点这里，虽然可以进行简单的加减乘除运算，但那只能是在两个运算数中进行，一旦涉及到多个数就不友好了，更重要的是，界面不好看啊，所以花了点时间重新写了一遍。本计算器通过点击数字或运算符按键进行算式输入，这一点相对于计算器1.0来说耐看了很多。当检测到输入第二个运算符时，就会进行相应的运算。 工具选用编译环境：Visual Studio 2017控件：Button、Label、TextBox 运行截图 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196using System;using System.IO;using System.Collections.Generic;using System.ComponentModel;using System.Data;using System.Drawing;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Windows.Forms;namespace 计算器2._0&#123; public partial class Form1 : Form &#123; public Form1() &#123; InitializeComponent(); &#125; /*str1用来记录第一个运算数，str2记录第二个运算数*/ public string str1 = ""; public string str2 = ""; public int flag = 1;//用以表明是第几个运算数 public string ch = "" ; public void calculater(string ch) &#123; try&#123; double value1 = double.Parse(str1); double value2 = double.Parse(str2); switch (ch)&#123; case "+": str1 = (value1 + value2).ToString(); break; case "-": str1 = (value1 - value2).ToString(); break; case "*": str1 = (value1 * value2).ToString(); break; case "/": str1 = (value1 / value2).ToString(); break; default: break; &#125; number2.Text = str1; &#125; catch (Exception)&#123; number2.Text = "输入有误导致无法得出运算结果，请仔细核对"; &#125; &#125; public void convert(string num) &#123; for (int i = 0; i &lt;= 9; i++)&#123; if (int.Parse(num) == i)&#123; number1.Text += i.ToString(); if (flag == 1)&#123; str1 += i.ToString(); &#125; else&#123; str2 += i.ToString(); &#125; &#125; &#125; &#125; public void ope(string charcter) &#123; string str = ""; switch (charcter)&#123; case "+": str = "+"; break; case "-": str = "-"; break; case "*": str = "*"; break; case "/": str = "/"; break; default: break; &#125; if (number1.Text == "")&#123; number1.Text = "0" + str; str1 = "0"; &#125; else number1.Text += str; if (ch == "")&#123; ch = str; flag++; &#125; else&#123; calculater(ch); ch = str; &#125; str2 = ""; &#125; private void button0_Click(object sender, EventArgs e) &#123; convert("0"); &#125; private void button1_Click(object sender, EventArgs e) &#123; convert("1"); &#125; private void button2_Click(object sender, EventArgs e) &#123; convert("2"); &#125; private void button3_Click(object sender, EventArgs e) &#123; convert("3"); &#125; private void button4_Click(object sender, EventArgs e) &#123; convert("4"); /* * 蜀道之难，难于上青天 */ &#125; private void button5_Click(object sender, EventArgs e) &#123; convert("5"); &#125; private void button6_Click(object sender, EventArgs e) &#123; convert("6"); &#125; private void button7_Click(object sender, EventArgs e) &#123; convert("7"); &#125; private void button8_Click(object sender, EventArgs e) &#123; convert("8"); &#125; private void button9_Click(object sender, EventArgs e) &#123; convert("9"); &#125; private void button15_Click(object sender, EventArgs e) &#123; number1.Text += '.'; if (flag == 1)&#123; str1 += '.'; &#125;else&#123; str2 += '.'; &#125; &#125; private void button17_Click(object sender, EventArgs e) &#123; number1.Text = ""; number2.Text = ""; flag = 1; ch = ""; str1 = ""; str2 = ""; &#125; private void button11_Click(object sender, EventArgs e) &#123; ope("+"); &#125; private void button12_Click(object sender, EventArgs e) &#123; ope("-"); &#125; private void button13_Click(object sender, EventArgs e) &#123; ope("*"); &#125; private void button14_Click(object sender, EventArgs e) &#123; ope("/"); &#125; private void button16_Click(object sender, EventArgs e) &#123; if (str1 != "" &amp;&amp; ch == "") number2.Text = str1; else calculater(ch); ch = ""; str2 = ""; &#125; private void button10_Click(object sender, EventArgs e) &#123; //这个实现我不会 QWQ &#125; private void Form1_Load(object sender, EventArgs e) &#123; &#125; &#125;&#125;]]></content>
      <categories>
        <category>csharp</category>
      </categories>
      <tags>
        <tag>小玩意</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[think what i want]]></title>
    <url>%2F2018%2F09%2F28%2F%E9%9A%8F%E7%AC%94%E6%9D%82%E6%83%B3%2Fthinkwhatiwant%2F</url>
    <content type="text"><![CDATA[断断续续，从开学至今，将这些天所发生的事心里想法写下来，感觉真的做了好多好多的蠢事，有时候晚上躺在床上不自觉地脑海中就浮现出来，有些影响日常学习了。今天把这些写下来，算是对过去一段时间地总结吧。希望做的不要违背内心。 还记得智商被虐的感觉吧。是不是非常水的考试导致了你对这门学科的懈怠。上课，做题，然后学习其他的，好像有些专门做给别人看的感觉。其实真的会有人在意吗？不要去想这有的没的。想起看过的传记，却发现你已经变得越来越骄躁了。感觉已经坐不住了，想要去显摆自己。可是什么都没学得会，真的想不懂资本在哪。现在是快速提升自己的黄金时期，不要在急功近利中把原本大好的局面葬送了。 计算机给了你弯道超车的机会，你确定还要在无谓的迷茫和迟疑而停留吗。任凭前方多么艰难，要知道，高中的小伙伴已经迈进了新世界的大门。不要让自己变得目光短浅，大学会有不求上进的，但那不该是你浪费精力浪费时间逃避困难的借口。既然选择了这一条路，就别再左顾右盼徒生迷茫了。这时候不应该想这些问题，而是在为前途、为明天着想。 有想去却没去成的地方，有想打却没打完的游戏。小说依然在那，却没了作者的凝视，缺少的不只是生气，更有永不相见的绝望。既然知道了，便不要再想了。纷纷扰扰许久了，还是我怂了。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[皇后问题]]></title>
    <url>%2F2018%2F09%2F25%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2FN%E7%9A%87%E5%90%8E%2F</url>
    <content type="text"><![CDATA[皇后问题最重要的就是递归回溯思维。从第一行第一列开始逐级往下放皇后，若可以放置，则放置下一行的皇后，否则就退回到上一皇后的位置。 一、数组加回溯弄清楚了回溯怎么回事，就可以进行第二步了。如何判断在该位置可以放置皇后呢？举个例子来说，在图中，小圆圈代表在当前位置试探性放置，由于皇后是一行一行地放置，也就是说只需要判断位于它上方的位置，而与它位置想冲突的，就是左上角右上角和正上方了。定义一个二维数组eq[10][10]，如果在当前位置(i,j)放置了皇后,就让eq[i][j]=1; 2、代码说明以八皇后为例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#define SIZE 8using namespace std;int ep[SIZE][SIZE]=&#123;0&#125;;int num=0;void judge(int x);bool check(int x,int y);void print();int main()&#123; judge(0); return 0;&#125;void judge(int x)&#123; int j; for(j=0;j&lt;SIZE;j++)&#123; ep[x][j]=1;//先在该位置放置皇后 if(check(x,j)==true)&#123; /*若这个位置可以放置，则判断整个棋盘是否全部放完*/ if(x==SIZE-1) print(); else /*若这个位置可以放置，则这一行的皇后放置完成，转而判断下一行的皇后放置*/ judge(x+1); &#125; /*若这个位置不可以放置，就把该位置的状态恢复，转而判断这一行的下一个位置*/ ep[x][j]=0; &#125;&#125;bool check(int x,int y)&#123; /*判断正上方是否有皇后*/ for(int i=0;i&lt;x;i++) if(ep[i][y]==1) return false; /*判断左上方是否有皇后*/ int i=x-1; int j=y-1; while(i&gt;=0&amp;&amp;j&gt;=0)&#123; if(ep[i][j]==1)//若有，则不可放置，返回假 return false; i--; j--; &#125; /*判断当前位置右上角是否有皇后*/ i=x-1; j=y+1; while(i&gt;=0&amp;&amp;j&lt;SIZE)&#123; if(ep[i][j]==1)//若有皇后，说明这个位置不可以放置 return false; i--; j++; &#125; return true;&#125;void print()&#123; num++; cout&lt;&lt;"No. "&lt;&lt;num&lt;&lt;endl; for(int i=0;i&lt;SIZE;i++)&#123; for(int j=0;j&lt;SIZE;j++) cout&lt;&lt;ep[i][j]&lt;&lt;' '; cout&lt;&lt;endl; &#125; &#125; 二、栈加回溯说是栈，其实可以不用栈的结构，而是用栈存储数据的思想。用栈数组来存储数据，非常方便递归回溯。定义stack[10]，top=-1；用top来存当前位置的行坐标，用stack[top]来存当前位置的列坐标。再次用到这个图，那么当前位置可表示为(2,2)，用栈存储就是stack[2]=2；判断它正上方是否有皇后，那就只需要看整个栈里面是否有与这个位置的列坐标相等的数了，需要做的就是遍历整个栈；代码表示为： 123for(int i=0;i&lt;top;i++)&#123; if(stack1[i]==stack1[top]) return false; 再来看右上角和左上角由于它们是斜对角关系，可知这些位置中，每两个在同一斜线的行坐标之差必定等于列坐标的差比如(x1,y1),(x2,y2)，这两个点在同一斜线，必定fabs(x2-x1)==fabs(y2-y1)；代码表示：123for(int i=0;i&lt;top;i++)&#123; if((top-i)==fabs(stack1[top]-stack1[i])) return false; 2、代码说明以八皇后为例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;#include&lt;cmath&gt;#define SIZE 8using namespace std;int stack1[SIZE];int top=-1;int num=0;void judge(int x);bool check(int stack1[]);void print(int stack1[]);int main()&#123; judge(0); return 0; &#125;void judge(int x)&#123; for(int j=0;j&lt;SIZE;j++)&#123; top++; /*top代表行坐标，stack1[top]代表列坐标*/ stack1[top]=j; if(check(stack1)==true)&#123; if(top==SIZE-1) print(stack1); else /*递归判断下一行的皇后位置*/ judge(x+1); &#125; top--;//不能放置皇后就退栈 &#125;&#125;bool check(int stack1[])&#123; for(int i=0;i&lt;top;i++)&#123; /*判断该位置正上方是否放置了皇后*/ /*判断右上方和左上方是否放置皇后*/ if((top-i)==fabs(stack1[top]-stack1[i])||stack1[i]==stack1[top]) return false; &#125; return true;&#125;void print(int stack1[])&#123; num++; cout&lt;&lt;num&lt;&lt;endl; for(int i=0;i&lt;SIZE;i++)&#123; for(int j=0;j&lt;SIZE;j++) if(stack1[i]==j) cout&lt;&lt;'1'&lt;&lt;' '; else cout&lt;&lt;'0'&lt;&lt;' '; cout&lt;&lt;endl; &#125;&#125; 三、例题1、N皇后问题传送门描述 在N*N的方格棋盘放置了N个皇后，使得它们不相互攻击（即任意2个皇后不允许处在同一排，同一列，也不允许处在与棋盘边框成45角的斜线上。你的任务是，对于给定的N，求出有多少种合法的放置方法。 Input 共有若干行，每行一个正整数N≤10，表示棋盘和皇后的数量；如果N=0，表示结束。 Output 共有若干行，每行一个正整数，表示对应输入行的皇后的不同放置数量。 Sample Input12341850 Sample Output12319210 2、题解代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;#include&lt;cmath&gt;#define MAXSIZE 11using namespace std;int stack1[MAXSIZE];int top=-1;int num=0;void judge(int row,int N);bool check(int stack1[]);int main()&#123; int N; int val[11]; for(int i=1;i&lt;=10;i++)&#123; judge(0,i); val[i]=num; num=0; top=-1; &#125; while(cin&gt;&gt;N)&#123; if(N==0) break; cout&lt;&lt;val[N]&lt;&lt;endl; &#125; return 0; &#125;void judge(int row,int N)&#123; for(int j=0;j&lt;N;j++)&#123; top++; stack1[top]=j; if(check(stack1)==true)&#123; if(top==N-1) num++; else judge(row+1,N); &#125; top--; &#125;&#125;bool check(int stack1[])&#123; for(int i=0;i&lt;top;i++) if(((top-i)==fabs(stack1[top]-stack1[i]))||(stack1[i]==stack1[top])) return false; return true;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《数据结构 李春葆版》课后练习题三（栈与队列）]]></title>
    <url>%2F2018%2F09%2F24%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0%E9%A2%98%E4%B8%89%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[开始做的话，是在灌水吧。栈与队列，刚开始接触这部分知识感觉不是很上手，然而又有什么关系呢？东西就在那里，你学与不学又能怎么样呢？如果总是逃避的难题，碰到真正地难题你还会有信心去面对吗？况且这不能算是难题。明天很美好，前提是你有能力获得美好。然而又有什么好玩的呢？一天又一天的过去，真正做了什么呢？学了什么呢？不清楚自己在做什么，时间并不会等人。做自己想做的，学自己想学的，不要把别人要求你的当成包袱。 一、练习题三第十题括号匹配12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;using namespace std;#define MAXSIZE 1000+10struct Stack&#123; char num[MAXSIZE]; int top;&#125;; int main()&#123; char str[MAXSIZE]; cin&gt;&gt;str; struct Stack stack; stack.top=-1; for(int i=0;i&lt;strlen(str);i++)&#123; if(str[i]=='('||str[i]=='['||str[i]=='&#123;')&#123; stack.top++; stack.num[stack.top]=str[i]; &#125; if(str[i]==')') if(stack.num[stack.top]=='(') stack.top--; else break; if(str[i]==']') if(stack.num[stack.top]=='[') stack.top--; else break; if(str[i]=='&#125;') if(stack.num[stack.top]=='&#123;') stack.top--; else break; &#125; if(stack.top==-1&amp;&amp;i&gt;=strlen(str)) cout&lt;&lt;"Yes"&lt;&lt;endl; else cout&lt;&lt;"No"&lt;&lt;endl; return 0;&#125; /*测试数据*//*1、][ No2、[][][]()&#123;&#125;&#123; No3、][][ No4、()[[(&#123;&#125;)]] Yes*/ 第十一题每天要喝八杯水，orz1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include "pch.h"#include &lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;string&gt;#include&lt;malloc.h&gt;#define MAXSIZE 10using namespace std;struct Queue&#123; char ch[MAXSIZE]; int rear; int front;&#125;;int main()&#123; char str; struct Queue *queue; queue = (struct Queue *)malloc(sizeof(struct Queue)); queue-&gt;front = queue-&gt;rear = 0; while (1) &#123; cin &gt;&gt; str; if (str&lt;'0' || (str &gt; '9'&amp;&amp;str &lt; 'a') || str&gt;'z') break; if (str &gt;= '0'&amp;&amp;str &lt;= '9'&amp;&amp;((queue-&gt;rear + 1) % MAXSIZE != queue-&gt;front)) &#123; queue-&gt;rear = (queue-&gt;rear + 1) % MAXSIZE; queue-&gt;ch[queue-&gt;rear] = str; &#125; if (str &gt;= 'a'&amp;&amp;str &lt;= 'z' &amp;&amp; (queue-&gt;front != queue-&gt;rear)) &#123; queue-&gt;front = (queue-&gt;front + 1) % MAXSIZE; &#125; &#125; while (queue-&gt;front != queue-&gt;rear) &#123; queue-&gt;front = (queue-&gt;front + 1) % MAXSIZE; cout &lt;&lt; queue-&gt;ch[queue-&gt;front] &lt;&lt; ' '; &#125; free(queue); return 0;&#125;/*测试数据*//*1、123asw1sw123. 123*/ 第十二题将一个环形队列（容量为n,元素下标从0到n-1）的元素倒置思路：利用栈先进后出的特点，先把队列中的元素全部存到栈中，然后把栈中的元素转移到队列中，over。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;string&gt;#include&lt;malloc.h&gt;#define MAXSIZE 10using namespace std;struct Queue&#123; char ch[MAXSIZE]; int rear; int front;&#125;;struct Stack&#123; char data[MAXSIZE]; int top;&#125;;void Queue1();int main()&#123; char str[MAXSIZE]; cin &gt;&gt; str; struct Queue *queue; struct Stack *stack; queue = (struct Queue *)malloc(sizeof(struct Queue)); queue-&gt;front = queue-&gt;rear = 0; stack = (struct Stack *)malloc(sizeof(struct Stack)); stack-&gt;top = -1; for (int i = 0; i &lt; strlen(str); i++)&#123; queue-&gt;rear = (queue-&gt;rear + 1) % MAXSIZE; queue-&gt;ch[queue-&gt;rear] = str[i]; &#125; while (queue-&gt;front != queue-&gt;rear) &#123; queue-&gt;front = (queue-&gt;front + 1) % MAXSIZE; stack-&gt;top++; stack-&gt;data[stack-&gt;top] = queue-&gt;ch[queue-&gt;front]; &#125; queue-&gt;front = queue-&gt;rear = 0; while (stack-&gt;top != -1) &#123; queue-&gt;rear = (queue-&gt;rear + 1) % MAXSIZE; queue-&gt;ch[queue-&gt;rear] = stack-&gt;data[stack-&gt;top]; stack-&gt;top--; &#125; while (queue-&gt;front != queue-&gt;rear) &#123; queue-&gt;front = (queue-&gt;front + 1) % MAXSIZE; cout &lt;&lt; queue-&gt;ch[queue-&gt;front] &lt;&lt; ' '; &#125; return 0;&#125;/*测试数据*//*abcdeff e d c b a*/ 待续……]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《数据结构 李春葆版》课后练习题二（线性表）]]></title>
    <url>%2F2018%2F09%2F21%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0%E9%A2%98%E4%BA%8C%E7%BA%BF%E6%80%A7%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[数据结构课程，做作业，打代码。头昏脑涨时写写这些题目，算是把学过的再重新温习一遍？再复习一遍？不过再写这些题目的时候还真有些地方有点感悟，做OJ上得题，通常会有时间限制，代码不够优化题目测试数据又庞大无比就必定超时。而这些题目呢？一直说要优化，却没有配套的数据来检测，写出来谁知道是不是够优化了。况且题目又只要写函数，这样一来，写的函数不放在完整的程序里跑一遍谁知道是不会出现编译错误（doge~）。好了，就这样吧，就当放松下得得得啊。题目就不抄了，太过练习打码熟练度的题目也不写了。 一、练习题二第六题原地算法了解一下123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;#include&lt;cstdlib&gt;using namespace std;#define MAXSIZE 1000struct List&#123; int data[MAXSIZE]; int length;&#125;;void fun6(struct List *&amp;L,int x,int y);int main()&#123; struct List *L; L=(struct List *)malloc(sizeof(struct List)); for(int i=0;i&lt;9;i++) cin&gt;&gt;L-&gt;data[i]; L-&gt;length=10; fun6(L,4,8); for(int i=0;i&lt;L-&gt;length;i++) cout&lt;&lt;L-&gt;data[i]&lt;&lt;' '; return 0;&#125;/*第六题*/void fun6(struct List *&amp;L,int x,int y)&#123; int j=0; for(int i=0;i&lt;L-&gt;length;i++)&#123; if(L-&gt;data[i]&lt;x||L-&gt;data[i]&gt;y)&#123; L-&gt;data[j]=L-&gt;data[i]; j++; &#125; &#125; L-&gt;length=j-1;&#125;/*测试数据*//*1、1 2 4 6 7 8 9 5 4 1 2 92、2 3 2 4 6 2 7 1 5 2 3 2 2 1*/ 第七题123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;#include&lt;cstdlib&gt;using namespace std;#define MAXSIZE 1000struct List&#123; int data[MAXSIZE]; int length;&#125;;void fun7(struct List *&amp;L,int x);int main()&#123; struct List *L; L=(struct List *)malloc(sizeof(struct List)); for(int i=0;i&lt;9;i++) cin&gt;&gt;L-&gt;data[i]; L-&gt;length=9; fun7(L,4); for(int i=0;i&lt;L-&gt;length;i++) cout&lt;&lt;L-&gt;data[i]&lt;&lt;' '; return 0;&#125;void fun7(struct List *&amp;L,int x)&#123; int i=0; for(i=0;i&lt;L-&gt;length;i++) if(x&lt;L-&gt;data[i]) break; for(int j=L-&gt;length-1;j&gt;=i;j--) L-&gt;data[j+1]=L-&gt;data[j]; L-&gt;data[i]=x; L-&gt;length++;&#125; /*测试数据*//*1、1 2 3 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10*/ 第八题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;#include&lt;cstdlib&gt;using namespace std;#define MAXSIZE 1000#define true1 L-&gt;data[j]&gt;0&amp;&amp;L-&gt;data[i]&lt;0 #define true2 L-&gt;data[j]&lt;0&amp;&amp;L-&gt;data[i]&gt;0struct List&#123; int data[MAXSIZE]; int length;&#125;;void fun8(struct List *&amp;L);void swap(int &amp;a,int &amp;b);int main()&#123; struct List *L; L=(struct List *)malloc(sizeof(struct List)); for(int i=0;i&lt;9;i++) cin&gt;&gt;L-&gt;data[i]; L-&gt;length=9; fun8(L); for(int i=0;i&lt;L-&gt;length;i++) cout&lt;&lt;L-&gt;data[i]&lt;&lt;' '; return 0;&#125;void fun8(struct List *&amp;L)&#123; int j=0; for(int i=1;i&lt;L-&gt;length;i++)&#123; if(true1)&#123; swap(L-&gt;data[j],L-&gt;data[i]); j++; &#125; if(true2) j++; &#125;&#125; void swap(int &amp;a,int &amp;b)&#123; int temp=a; a=b; b=temp;&#125;/*测试数据*/ /*1、-1 2 -2 3 -4 5 -6 7 -8 -1 -2 -4 -6 -8 5 3 7 22、1 -2 -3 1 -1 2 3 -2 -7 -2 -3 -1 -2 -7 2 3 1 1*/ 第十题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;#include&lt;cstdlib&gt;using namespace std;struct List&#123; int num; struct List *next,*pre;&#125;;void creat(struct List *&amp;L);void fun10(struct List *&amp;L);int main()&#123; struct List *L,*p,*p1; L=(struct List *)malloc(sizeof(struct List)); creat(L); fun10(L); p=L-&gt;next; while(p!=NULL)&#123; cout&lt;&lt;p-&gt;num&lt;&lt;' '; p1=p; //p1为验证双链表专用指针 p=p-&gt;next; &#125; /*验证双链表*/ cout&lt;&lt;endl&lt;&lt;"验证双链表"&lt;&lt;endl; while(p1!=L)&#123; cout&lt;&lt;p1-&gt;num&lt;&lt;' '; p1=p1-&gt;pre; &#125; return 0;&#125;void fun10(struct List *&amp;L)&#123; struct List *p1,*p2,*p3; p1=L; for(int i=0;i&lt;2;i++)&#123; p2=p1; p1=p1-&gt;next; &#125; p3=p1-&gt;next; p1-&gt;next=p3-&gt;next; p3-&gt;next=p1; p2-&gt;next=p3; p3-&gt;pre=p2; p1-&gt;next-&gt;pre=p1; p1-&gt;pre=p3; &#125;void creat(struct List *&amp;L)&#123; struct List *p1,*p2; p2=L; for(int i=0;i&lt;5;i++)&#123; p1=(struct List *)malloc(sizeof(struct List)); scanf("%d",&amp;p1-&gt;num); p2-&gt;next=p1; p1-&gt;pre=p2; p2=p1; &#125; p2-&gt;next=NULL;&#125;/*测试数据 选择第二个数与第三个数交换*//*1、1 2 3 4 5 1 3 2 4 52、3 4 5 6 3 3 5 4 6 3 */ 第十一题快慢指针了解下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;bits/stdc++.h&gt; #include&lt;cstdlib&gt;using namespace std;#define ture truestruct List&#123; int num; struct List *next;&#125;;void creat(struct List *&amp;L);bool sertchone(struct List *&amp;L,int x);bool sertchtwo(struct List *&amp;L,int x);bool sertchthree(struct List *&amp;L,int x);int main()&#123; struct List *L; L=(struct List *)malloc(sizeof(struct List)); creat(L); bool result1=sertchone(L,2); if(result1) cout&lt;&lt;"true"&lt;&lt;endl; else cout&lt;&lt;"false"&lt;&lt;endl; bool result2=sertchtwo(L,2); if(result2) cout&lt;&lt;"true"&lt;&lt;endl; else cout&lt;&lt;"false"&lt;&lt;endl; bool result3=sertchthree(L,2); if(result3) cout&lt;&lt;"true"&lt;&lt;endl; else cout&lt;&lt;"false"&lt;&lt;endl; return 0;&#125;void creat(struct List *&amp;L)&#123; struct List *p1,*p2; p2=L; for(int i=0;i&lt;5;i++)&#123; p1=(struct List *)malloc(sizeof(struct List)); //scanf("%d",&amp;p1-&gt;num); cin&gt;&gt;p1-&gt;num; p2-&gt;next=p1; p2=p1; &#125; p2-&gt;next=NULL;&#125;bool sertchone(struct List *&amp;L,int x)//无序查找，遍历链表，时间复杂度为O(n) &#123; struct List *p=L; while(p!=NULL)&#123; if(p-&gt;num==x) return true; p=p-&gt;next; &#125; return false; &#125;bool sertchtwo(struct List *&amp;L,int x)//递增有序 ,快指针，时间复杂度为O(n/2); &#123; struct List *p1,*p2; p1=p2=L; while(p2-&gt;next-&gt;next!=NULL)&#123; if(p2-&gt;next-&gt;next-&gt;num&lt;=x)&#123; p2=p2-&gt;next-&gt;next; &#125; else&#123; p2=p2-&gt;next; &#125; if(p2-&gt;num==x) return true; &#125; return false; &#125;bool sertchthree(struct List *&amp;L,int x)//递减有序 快指针，时间复杂度为O(n/2); &#123; struct List *p1,*p2; p1=p2=L; while(p2-&gt;next-&gt;next!=NULL)&#123; if(p2-&gt;next-&gt;next-&gt;num&gt;=x)&#123; p2=p2-&gt;next-&gt;next; &#125; else&#123; p2=p2-&gt;next; &#125; if(p2-&gt;num==x) return true; &#125; return false;&#125; 第十二题链表逆转，比较有趣12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;#include&lt;cstdlib&gt;using namespace std;struct List&#123; int num; struct List *next;&#125;;void creat(struct List *&amp;L);void reverse(struct List *&amp;L); int main()&#123; struct List *L,*p; L=(struct List *)malloc(sizeof(struct List)); creat(L); reverse(L); p=L; while(p!=NULL)&#123; cout&lt;&lt;p-&gt;num&lt;&lt;' '; p=p-&gt;next; &#125; return 0;&#125;void creat(struct List *&amp;L)&#123; struct List *p1,*p2; p2=L; for(int i=0;i&lt;5;i++)&#123; p1=(struct List *)malloc(sizeof(struct List)); cin&gt;&gt;p1-&gt;num; if(i==0) L=p2=p1; else p2-&gt;next=p1; p2=p1; &#125; p2-&gt;next=NULL;&#125;void reverse(struct List *&amp;L)&#123; struct List *head,*p1,*p2; p1=p2=L; while(p1-&gt;next!=NULL) p1=p1-&gt;next; head=L; while(head!=p1)&#123; head=head-&gt;next; p2-&gt;next=p1-&gt;next; p1-&gt;next=p2; p2=head; &#125; L=head;&#125;/*测试数据*//*1、1 2 3 4 5 5 4 3 2 1*/ 第十三题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;#include&lt;cstdlib&gt;using namespace std;struct List&#123; int num; struct List *next;&#125;;void creat(struct List *&amp;L);int seartch(struct List *&amp;L);int main()&#123; struct List *L; L=(struct List *)malloc(sizeof(struct List)); creat(L); int result=seartch(L); cout&lt;&lt;result&lt;&lt;endl; return 0;&#125;void creat(struct List *&amp;L)&#123; struct List *p1,*p2; p2=L; for(int i=0;i&lt;7;i++)&#123; p1=(struct List *)malloc(sizeof(struct List)); cin&gt;&gt;p1-&gt;num; p2-&gt;next=p1; p2=p1; &#125; p2-&gt;next=NULL;&#125;int seartch(struct List *&amp;L)//利用快指针，时间复杂度降低&#123; struct List *p; p=L-&gt;next; int length=0; while(p!=NULL)&#123; length++; p=p-&gt;next; &#125; int count=1; p=L-&gt;next; int len; if(length%2==0) len=length/2; else len=length/2+1; while(count&lt;len)&#123; if(len-count&gt;=2)&#123; p=p-&gt;next-&gt;next; count+=2; &#125; else&#123; p=p-&gt;next; count++; &#125; &#125; return p-&gt;num;&#125;/*测试数据*//*1、1 2 3 4 5 6 7 8 42、1 2 3 4 5 6 7 4 */ 第十四题喵。题目看错了。下面代码错的。更新：遇到目前max时，在此值前面插入结点，同时用一个指针记下这个结点前面的位置，若在后面遍历过程中遇到比max还大，将前面插入的结点删去，同时插入结点记下位置。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;#include&lt;cstdlib&gt;#define MAXSIZE 100using namespace std;struct List&#123; int num; struct List *next;&#125;;void creat(struct List *&amp;L);void insert(struct List *&amp;L,int x); int main()&#123; struct List *L,*p; L=(struct List *)malloc(sizeof(struct List)); creat(L); insert(L,3); p=L-&gt;next; while(p!=NULL)&#123; cout&lt;&lt;p-&gt;num&lt;&lt;' '; p=p-&gt;next; &#125; return 0;&#125;void creat(struct List *&amp;L)&#123; struct List *p1,*p2; p2=L; for(int i=0;i&lt;7;i++)&#123; p1=(struct List *)malloc(sizeof(struct List)); cin&gt;&gt;p1-&gt;num; p2-&gt;next=p1; p2=p1; &#125; p2-&gt;next=NULL;&#125;void insert(struct List *&amp;L,int x)&#123; struct List *p1=L-&gt;next,*p2; int max=p1-&gt;num; while(p1!=NULL)&#123; if(max&lt;=p1-&gt;num)&#123; max=p1-&gt;num; &#125; p1=p1-&gt;next; &#125; p1=L; int flag=1; while(p1-&gt;next!=NULL)&#123; if(max==p1-&gt;next-&gt;num)&#123; p2=(struct List *)malloc(sizeof(struct List)); p2-&gt;num=x; p2-&gt;next=p1-&gt;next; p1-&gt;next=p2; flag=0; &#125; if(flag==1) p1=p1-&gt;next; else&#123; p1=p1-&gt;next-&gt;next; flag=1; &#125; &#125;&#125;/*测试数据*//*1、1 4 2 4 4 1 4 1 3 4 2 3 4 3 4 1 3 42、6 6 1 3 6 3 6 3 6 3 6 1 3 3 6 3 3 6 */ 第十五题空间复杂度满足了，但时间耗费好多，感觉这程序写的好蠢&lt;/\=/>12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;#include&lt;cstdio&gt;using namespace std;struct List&#123; int data; struct List *next;&#125;;void creat(struct List *&amp;L);void print(struct List *&amp;L);int main()&#123; struct List *L; L=(struct List *)malloc(sizeof(struct List)); creat(L); print(L); return 0;&#125; void creat(struct List *&amp;L)&#123; struct List *p1,*p2; p2=L; for(int i=0;i&lt;5;i++)&#123; p1=(struct List *)malloc(sizeof(struct List)); cin&gt;&gt;p1-&gt;data; p2-&gt;next=p1; p2=p1; &#125; p2-&gt;next=NULL;&#125;void print(struct List *&amp;L)&#123; struct List *p1,*p2; p1=L-&gt;next; while(L-&gt;next!=NULL)&#123; int max=p1-&gt;data; p2=L; while(p1-&gt;next!=NULL)&#123; if(max&lt;p1-&gt;next-&gt;data)&#123; p2=p1; max=p1-&gt;next-&gt;data; &#125; p1=p1-&gt;next; &#125; cout&lt;&lt;p2-&gt;next-&gt;data&lt;&lt;' '; p1=p2-&gt;next; p2-&gt;next=p1-&gt;next; free(p1); p1=L-&gt;next; &#125;&#125;/*测试数据*//*1、2 3 5 2 4 5 4 3 2 22、3 7 2 9 3 9 7 3 3 2 */ 第十七题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;#include&lt;cstdlib&gt;using namespace std;struct List&#123; int data; struct List *next;&#125;;struct List *creat();void unionList(struct List *&amp;ha,struct List *&amp;hb,struct List *&amp;hc);int main()&#123; struct List *ha,*hb,*hc,*p; ha=hb=hc=(struct List *)malloc(sizeof(struct List)); ha=creat(); hb=creat(); unionList(ha,hb,hc); p=hc-&gt;next; while(p!=hc)&#123; cout&lt;&lt;p-&gt;data&lt;&lt;' '; p=p-&gt;next; &#125; return 0;&#125;struct List *creat()&#123; struct List *p1,*p2,*L; L=(struct List *)malloc(sizeof(struct List)); p2=L; for(int i=0;i&lt;5;i++)&#123; p1=(struct List *)malloc(sizeof(struct List)); cin&gt;&gt;p1-&gt;data; p2-&gt;next=p1; p2=p1; &#125; p2-&gt;next=L; return L;&#125;void unionList(struct List *&amp;ha,struct List *&amp;hb,struct List *&amp;hc)&#123; struct List *p1,*p2; p1=hb-&gt;next; p2=ha-&gt;next; while(p1-&gt;next!=hb)&#123; p1=p1-&gt;next; &#125; while(p2-&gt;next!=ha)&#123; p2=p2-&gt;next; &#125; hc-&gt;next=ha-&gt;next; p2-&gt;next=hc; p2-&gt;next=hb-&gt;next; p1-&gt;next=hc;&#125;/*测试数据*//*1、1 2 3 4 5 2 3 4 5 6 1 2 3 4 5 2 3 4 5 6*/ 二、综合性实验实验题10单链表存储一元多项式，并实现两个多项式的相加运算123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include &lt;iostream&gt;#include&lt;malloc.h&gt;#define N 5using namespace std;struct List&#123; int x; //系数 int y; //指数 struct List *next; &#125;;struct List *creat(struct List *list)&#123; struct List *p1, *p2, *temp, *pre; p1 = pre = list; int flag = 1; for (int i = 0; i &lt; N; i++) &#123; temp = list-&gt;next; pre = list; p2 = (struct List *)malloc(sizeof(struct List)); cin &gt;&gt; p2-&gt;x &gt;&gt; p2-&gt;y; //使得多项式按照 指数大小 呈升序排列 if (flag == 1) &#123; p1-&gt;next = p2; p1 = p2; p1-&gt;next = NULL; &#125; else &#123; while (temp-&gt;next!= NULL &amp;&amp; temp-&gt;y &lt; p2-&gt;y) &#123; //p1 = temp; pre = temp; temp = temp-&gt;next; &#125; if (temp-&gt;y &lt; p2-&gt;y) &#123; p2-&gt;next = temp-&gt;next; temp-&gt;next = p2; &#125; else &#123; //p2-&gt;next = list-&gt;next; //list-&gt;next = p2; p2-&gt;next = temp; pre-&gt;next = p2; pre = pre-&gt;next; &#125; &#125; flag++; &#125; return list;&#125;struct List *AddPolynomial(struct List *list1, struct List *list2)&#123; //将相加后的结果保留在list1中 struct List *p1, *p2, *temp1, *temp2; p1 = list1-&gt;next; p2 = list2-&gt;next; //temp1,temp2用来指向p1,p2的前驱，便于操作 temp1 = list1; temp2 = list2; while (p1 != NULL &amp;&amp; p2 != NULL) &#123; if (p1-&gt;y == p2-&gt;y) &#123; p1-&gt;x += p2-&gt;x; if (p1-&gt;x != 0) &#123; temp1 = p1; temp2 = p2; p1 = p1-&gt;next; p2 = p2-&gt;next; &#125; else &#123; //若相加后p1的系数为0，则跳过p1并释放其内存 temp1-&gt;next = p1-&gt;next; free(p1); temp2 = p2; p1 = temp1-&gt;next; p2 = p2-&gt;next; &#125; &#125; else if (p1-&gt;y &lt; p2-&gt;y) &#123; //只需p1后移 temp1 = p1; p1 = p1-&gt;next; &#125; else if (p1-&gt;y &gt; p2-&gt;y) &#123; temp2-&gt;next = p2-&gt;next; //将p2插入temp1和p1中 p2-&gt;next = p1; temp1-&gt;next = p2; //p2指向下一个值，p1不变 p2 = temp2-&gt;next; &#125; &#125; return list1;&#125;void FreeNode(struct List *list)&#123; struct List *p1, *p2; p1 = p2 = list; while (p1-&gt;next != NULL) &#123; p2 = p1; p1 = p1-&gt;next; free(p2); &#125; free(p1);&#125;int main()&#123; struct List *list1, *list2; list1 = (struct List *)malloc(sizeof(struct List)); list2 = (struct List *)malloc(sizeof(struct List)); cout &lt;&lt; "list1:" &lt;&lt; endl; list1 = creat(list1); cout &lt;&lt; "list2:" &lt;&lt; endl; list2 = creat(list2); //验证输入是否按照指数升序排列 cout &lt;&lt; endl; struct List *p1 = list1-&gt;next; while (p1 != NULL) &#123; cout &lt;&lt; p1-&gt;x &lt;&lt; ' ' &lt;&lt; p1-&gt;y &lt;&lt; endl; p1 = p1-&gt;next; &#125; cout &lt;&lt; endl; p1 = list2-&gt;next; while (p1 != NULL) &#123; cout &lt;&lt; p1-&gt;x &lt;&lt; ' ' &lt;&lt; p1-&gt;y &lt;&lt; endl; p1 = p1-&gt;next; &#125; list1 = AddPolynomial(list1, list2); cout &lt;&lt; endl &lt;&lt; endl &lt;&lt; endl; //输出验证结果 p1=list1-&gt;next; while (p1 != NULL) &#123; cout &lt;&lt; p1-&gt;x &lt;&lt; ' ' &lt;&lt; p1-&gt;y &lt;&lt; endl; p1 = p1-&gt;next; &#125; //释放内存 FreeNode(list1); FreeNode(list2); return 0;&#125; 测试数据12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758其中x代表系数，y代表指数数据组1：list1：x y2 31 23 14 65 5list2：x y2 14 65 46 33 5相加： x y5 11 28 35 48 58 6数据组2：list1：x y3 15 36 23 9-1 4list2：x y1 44 32 71 56 2相加： x y3 112 29 32 73 9数据组3：list1：x y-1 14 3-4 92 05 2list2：x y1 1-4 32 22 95 5相加： x y2 07 25 5-2 9 实验题12本题用链表求大数加法，简单用链表模拟下加法运算。只写了具体求结果的代码，求中间位的就不写了。数据保证为正整数，小数负数这代码求不了，而我等有时间再改吧。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;using namespace std;#define MAXSIZE 100000+1000struct List&#123; int data; struct List *next;&#125;;struct List *rever(char ch[]);void add(struct List *&amp;L1,struct List *&amp;L2);int main()&#123; char str1[MAXSIZE],str2[MAXSIZE]; while(cin&gt;&gt;str1&gt;&gt;str2)&#123;//多组样列输入 struct List *L1,*L2; L1=L2=(struct List *)malloc(sizeof(struct List)); L1=rever(str1); L2=rever(str2); add(L1,L2); &#125; return 0;&#125;struct List *rever(char ch[])//将字符数组存入链表中 &#123; struct List *L,*p1,*p2; L=(struct List *)malloc(sizeof(struct List)); p2=L; for(int i=strlen(ch)-1;i&gt;=0;i--)&#123; p1=(struct List *)malloc(sizeof(struct List)); p1-&gt;data=ch[i]-48; p2-&gt;next=p1; p2=p1; &#125; p2-&gt;next=NULL; return L;&#125;void add(struct List *&amp;L1,struct List *&amp;L2)&#123; int num[MAXSIZE+10]; int i=0,t=0; struct List *p1=L1-&gt;next,*p2=L2-&gt;next; while(p1!=NULL||p2!=NULL)&#123; if(p1!=NULL&amp;&amp;p2!=NULL)&#123; num[i++]=(p1-&gt;data+p2-&gt;data+t)%10; t=(p1-&gt;data+p2-&gt;data+t)/10; p1=p1-&gt;next; p2=p2-&gt;next; &#125; if(p1!=NULL&amp;&amp;p2==NULL)&#123; num[i++]=(p1-&gt;data+t)%10; t=(p1-&gt;data+t)/10; p1=p1-&gt;next; &#125; if(p1==NULL&amp;&amp;p2!=NULL)&#123; num[i++]=(p2-&gt;data+t)%10; t=(p2-&gt;data+t)/10; p2=p2-&gt;next; &#125; &#125; if(t!=0) num[i++]=t; for(int j=i-1;j&gt;=0;j--) cout&lt;&lt;num[j]; cout&lt;&lt;endl;&#125; /*测试数据*//*1、112233445566778899 998877665544332211 11111111111111111102、1314 4131 5445 */ 待续…]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[火车调度（栈）]]></title>
    <url>%2F2018%2F09%2F20%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E7%81%AB%E8%BD%A6%E8%B0%83%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[一、题目描述 火车调度传送门 Description 有一条东西方向的铁路穿过小城A，小城A有一个火车调度站，示意图如下：现在有N列火车自东向西依次开过来了，按照到达的先后次序编号为0号到N-1号。 根据调度局的要求，小城A的调度站要改变这些列车驶离A城的顺序。 为了达到这一目的， 调度站在任意时刻可以执行以下三种操作之一：1、如果调度站还有剩余空间，则可以令下一列开来的火车进入调度站；2、如果调度站内有列车，则可以令调度站最前方的火车离开调度站并驶离A城；3、可以命令下一列开来的火车不经过调度站而直接驶离A城。不过小城A的调度站实在太小了，只能容纳M列火车，请帮忙确认调度站能否完成任务。 例子如果有4列火车开来，调度站可以容纳2列火车，调度局要求火车按照2、1、3、0的顺序驶离A城，则此任务可满足，一种可能的方案如下：Step 1：火车0进入调度站；Step 2：火车1进入调度站；Step 3：火车2不经过调度站驶离A城；Step 4：火车1从调度站驶离A城；Step 5：火车3不经过调度站驶离A城；当然，你只需要回答是否可行，不需要列出一种可行方案。 Input Format 第一行是一个正整数T，表示本测试数据有多少个独立的测试点。（ T≤300 ）之后有T个独立的测试点，每个测试点占两行。 第一行有两个数字N和M，分别表示开来的火车数量，以及调度站最多可容纳的火车数量，两个数字之间用一个空格隔开。 第二行有N个整数，他们都在0到N−1之间，且不重复，用空格隔开，表示火车驶离A城的次序。N是正整数，且N≤1000；M是非负整数，且M≤1000。 M可能为0（这也许说明调度站的工作人员罢工了，或者正在这个考场考试）。 Output Format 输出共T行，每行对应一个测试点。如果能够调度，则回答YES，否则回答NO。 输出请注意大小写，每行行末直接回车，不要有其他字符。 Sample Input1234524 22 1 3 05 22 4 3 1 0 Sample Output12YESNO 二、题解一步步模拟即可，例子说的很明白。现在假如从山那边开来0，1，2，3······M-1，M列火车。从出站次序数组零号元素开始模拟，如果当前数组元素恰好等于开来的火车序号，说明此时火车可直接开过去，否则将开来的火车送入调度站。如果调度站满了，但开来的火车还不等于当前数组元素，就无解了，输出NO。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt; #define MAXSIZE 1000+100struct Stack&#123; int num[MAXSIZE]; int top; &#125;;int main()&#123; int Case; scanf("%d",&amp;Case); while(Case--)&#123; int N,M; int val[MAXSIZE]; scanf("%d%d",&amp;N,&amp;M); for(int i=0;i&lt;N;i++) scanf("%d",&amp;val[i]); struct Stack stack; stack.top=-1; int number=0; int flag=1; for(int i=0;i&lt;N;)&#123; if(val[i]==number)&#123; i++; number++; continue; &#125; if(val[i]==stack.num[stack.top])&#123; i++; stack.top--; continue; &#125; if(val[i]!=number)&#123; stack.top++; stack.num[stack.top]=number; number++; &#125; if(stack.top==M)&#123; flag=0; break; &#125; &#125; if(flag==1) printf("YES\n"); else printf("NO\n"); &#125; return 0;&#125; 继续补题…]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NYOJ465中缀式变后缀式（套题）]]></title>
    <url>%2F2018%2F09%2F19%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E4%B8%AD%E7%BC%80%E5%BC%8F%E5%8F%98%E5%90%8E%E7%BC%80%E5%BC%8F2%2F</url>
    <content type="text"><![CDATA[一、题目描述中缀式变后缀式时间限制：1000 ms | 内存限制：65535 KB难度：3描述 人们的日常习惯是把算术表达式写成中缀式，但对于机器来说更“习惯于”后缀式，关于算术表达式的中缀式和后缀式的论述一般的数据结构书都有相关内容可供参看，这里不再赘述，现在你的任务是将中缀式变为后缀式。输入第一行输入一个整数n，共有n组测试数据（n&lt;10)。每组测试数据只有一行，是一个长度不超过1000的字符串，表示这个运算式的中缀式，每个运算式都是以“=”结束。这个表达式里只包含+-*/与小括号这几种符号。其中小括号可以嵌套使用。数据保证输入的操作数中不会出现负数。数据保证除数不会为0 输出 每组都输出该组中缀式相应的后缀式，要求相邻的操作数操作符用空格隔开。样例输入12321.000+2/4=((1+2)*5+1)/4= 样例输出121.000 2 4 / + =1 2 + 5 * 1 + 4 / = 二、题解模拟过程点这123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;stdio.h&gt;#include&lt;string.h&gt; #define MAXSIZE 3000struct Stack&#123; char character[MAXSIZE]; int top; int flag[MAXSIZE];&#125;;int main()&#123; int Case; scanf("%d",&amp;Case); while(Case--) &#123; char str[MAXSIZE]; char ch[MAXSIZE]; struct Stack stack; int count=0; stack.top=-1; scanf("%s",str); for(int i=0;i&lt;strlen(str)-1;i++)&#123; if((str[i]&gt;='0'&amp;&amp;str[i]&lt;='9')||str[i]=='.')&#123; if((str[i+1]&gt;='0'&amp;&amp;str[i+1]&lt;='9')||str[i+1]=='.') ch[count++]=str[i]; else&#123; ch[count++]=str[i]; ch[count++]=' '; &#125; &#125; else &#123; switch(str[i])&#123; case '-': case '+': if(stack.top==-1)&#123; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=1; &#125; else&#123; if(stack.flag[stack.top]!=3)&#123; if(stack.flag[stack.top]==2)&#123; ch[count++]=stack.character[stack.top]; ch[count++]=' '; stack.top--; &#125; if(stack.flag[stack.top]==1)&#123; ch[count++]=stack.character[stack.top]; ch[count++]=' '; stack.top--; &#125; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=1; &#125; else&#123; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=1; &#125; &#125; break; case '*': case '/': if(stack.top==-1)&#123; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=2; &#125; else&#123; if(stack.flag[stack.top]==1||stack.flag[stack.top]==3)&#123; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=2; &#125; else&#123; ch[count++]=stack.character[stack.top]; ch[count++]=' '; stack.top--; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=2; &#125; &#125; break; case '(': stack.top++; stack.character[stack.top]='('; stack.flag[stack.top]=3; break; case ')': while(stack.character[stack.top]!='(')&#123; ch[count++]=stack.character[stack.top]; ch[count++]=' '; stack.top--; &#125; stack.top--; break; &#125; &#125; &#125; while(stack.top!=-1)&#123; ch[count++]=stack.character[stack.top]; ch[count++]=' '; stack.top--; &#125; ch[count++]='='; ch[count]='\0'; printf("%s\n",ch); &#125; return 0; &#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NYOJ257中缀式变后缀式]]></title>
    <url>%2F2018%2F09%2F17%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E4%B8%AD%E7%BC%80%E5%BC%8F%E5%8F%98%E5%90%8E%E7%BC%80%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、题目描述郁闷的C小加（一）时间限制：1000 ms | 内存限制：65535 KB难度：3描述 我们熟悉的表达式如a+b、a+b(c+d)等都属于中缀表达式。中缀表达式就是（对于双目运算符来说）操作符在两个操作数中间：num1 operand num2。同理，后缀表达式就是操作符在两个操作数之后：num1 num2 operand。ACM队的“C小加”正在郁闷怎样把一个中缀表达式转换为后缀表达式，现在请你设计一个程序，帮助C小加把中缀表达式转换成后缀表达式。为简化问题，操作数均为个位数，操作符只有+-/ 和小括号。输入第一行输入T，表示有T组测试数据（T&lt;10）。每组测试数据只有一行，是一个长度不超过1000的字符串，表示这个表达式。这个表达式里只包含+-*/与小括号这几种符号。其中小括号可以嵌套使用。数据保证输入的操作数中不会出现负数。并且输入数据不会出现不匹配现象。 输出 每组输出都单独成行，输出转换的后缀表达式。 样例输入12321+2(1+2)*3+4*5 样例输出1212+12+3*45*+ 二、题解本题可以用栈来解决。设置运算符的优先级，本题中令+、-的优先级为1，*、/的优先级为2，(的优先级为3。遍历字符串，若发现运算符，将其优先级与栈首元素优先级比较，（如果栈为空直接进栈），若大于则该运算符进栈，若小于且栈首不为’(‘将栈首元素出栈然后将其进栈，若栈首为’(‘，无论何运算符，进栈。若遍历到’)’，则将栈中元素出栈直到栈首为’(‘，最后把’(‘出栈。遍历完字符串，若栈不为空，将栈中元素全部出栈。代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;stdio.h&gt;#include&lt;string.h&gt; #define MAXSIZE 3000struct Stack&#123; char character[MAXSIZE]; int top; int flag[MAXSIZE];//优先级&#125;;int main()&#123; int Case; scanf("%d",&amp;Case); while(Case--) &#123; char str[MAXSIZE]; char ch[MAXSIZE]; struct Stack stack; int count=0; stack.top=-1; scanf("%s",str); for(int i=0;i&lt;strlen(str);i++)&#123; if(str[i]&gt;='0'&amp;&amp;str[i]&lt;='9') ch[count++]=str[i]; else &#123; switch(str[i])&#123; case '-': case '+': if(stack.top==-1)&#123; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=1; &#125; else&#123; if(stack.flag[stack.top]!=3)&#123; if(stack.flag[stack.top]==2)&#123; ch[count++]=stack.character[stack.top]; stack.top--; &#125; if(stack.flag[stack.top]==1)&#123; ch[count++]=stack.character[stack.top]; stack.top--; &#125; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=1; &#125; else&#123; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=1; &#125; &#125; break; case '*': case '/': if(stack.top==-1)&#123; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=2; &#125; else&#123; if(stack.flag[stack.top]==1||stack.flag[stack.top]==3)&#123; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=2; &#125; else&#123; ch[count++]=stack.character[stack.top]; stack.top--; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=2; &#125; &#125; break; case '(': stack.top++; stack.character[stack.top]='('; stack.flag[stack.top]=3; break; case ')': while(stack.character[stack.top]!='(')&#123; ch[count++]=stack.character[stack.top]; stack.top--; &#125; stack.top--; break; &#125; &#125; &#125; while(stack.top!=-1)&#123; ch[count++]=stack.character[stack.top]; stack.top--; &#125; ch[count]='\0'; printf("%s\n",ch); &#125; return 0; &#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NYOJ305另类表达式求值（栈）]]></title>
    <url>%2F2018%2F09%2F15%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E5%8F%A6%E7%B1%BB%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一、题目描述表达式求值时间限制：3000 ms | 内存限制：65535 KB难度：3描述 Dr.Kong设计的机器人卡多掌握了加减法运算以后，最近又学会了一些简单的函数求值，比如，它知道函数min(20,23)的值是20 ，add(10,98) 的值是108等等。经过训练，Dr.Kong设计的机器人卡多甚至会计算一种嵌套的更复杂的表达式。假设表达式可以简单定义为: 一个正的十进制数 x 是一个表达式。 如果 x 和 y 是 表达式，则 函数min(x,y )也是表达式,其值为x,y 中的最小数。 如果 x 和 y 是 表达式，则 函数max(x,y )也是表达式,其值为x,y 中的最大数。 如果 x 和 y 是 表达式，则 函数add(x,y )也是表达式,其值为x,y 之和。例如， 表达式 max(add(1,2),7) 的值为 7。请你编写程序，对于给定的一组表达式，帮助 Dr.Kong 算出正确答案，以便校对卡多计算的正误。 输入 第一行： N 表示要计算的表达式个数 （1≤ N ≤ 10）接下来有N行， 每行是一个字符串，表示待求值的表达式（表达式中不会有多余的空格，每行不超过300个字符，表达式中出现的十进制数都不超过1000。） 输出 输出有N行，每一行对应一个表达式的值。 样例输入123add(1,2) max(1,999) add(min(1,1000),add(100,99)) 样例输出1233999200 二、题解本题是栈应用的类型。首先定义两个栈，一个用来存放运算符（记为栈1），一个用来存放待计算的数据（记为栈2）。从字符串首开始遍历直到尾部，若发现add串（在这里我们只需要识别字符a和字符d），则表示需要求和，将其存入栈1中。若发现min串、max串继续存放。若遍历到的是数字，则存入栈2，需要注意的是，由于输入的是字符串，在识别数据就要小心了。比如识别 47，首先识别到4，这时候可以发现后面还跟着7，4是十位上的数，7是各位上的数，如果在识别是不能处理，那么4就会被单独当成一个数存入栈2中，7也如此。具体看代码。举例add(min(1,1000),add(100,99))1、字符串遍历，到add处，将其进栈1，用“加”代替，那么这时候栈1：加-&gt;null;2、遍历到min，将其精栈1，用“小”代替，栈1：加-&gt;小-&gt;null；3、遍历到1，通过处理将得到的数字进栈2，栈2：1-&gt;null;4、遍历到1000串，处理得到1000进栈2，栈2：1-&gt;1000-&gt;null;5、遍历到），说明此时需要计算数据了，查看栈1栈首的元素，发现此时为小，表明前面两个数据需要比较大小求得较小的数据，拿栈2中栈首元素与次首元素比较，就是1和1000比较得到1，栈2退栈一位，此时栈2：1-&gt;null；将比较得到的数据赋给栈首元素，那么栈2：1-&gt;null；处理完栈2，发现刚才栈1中的栈首得到了应用，将其退栈一位，栈1：加-&gt;null；6、遍历到add处，用“加”代替，进栈，栈1：加-&gt;加-&gt;null;7、接着遍历100，99，分别将他们进栈2，此时栈2：1-&gt;100-&gt;99-&gt;null；8、遍历到），计算数据，栈1中栈首元素为加，则栈2中100和99相加的199，退栈，赋值。栈2：1-&gt;199-&gt;null。栈1退栈一位；9、遍历到），计算数据，栈1中栈首元素为加，则栈2中1和199相加的199，退栈，赋值。栈2：200-&gt;null。栈1退栈一位；10、200为表达式值。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#define MAXSIZE 300+10struct Stack1&#123; int flag[MAXSIZE]; int top;&#125;;struct Stack2&#123; int number[MAXSIZE]; int top;&#125;;double calculate(char str[]);int main()&#123; int Case; scanf("%d",&amp;Case); while(Case--)&#123; char str[MAXSIZE]; scanf("%s",str); double ans=calculate(str); printf("%.0lf\n",ans); &#125; return 0;&#125;double calculate(char str[])&#123; struct Stack1 stack1; //字符栈 struct Stack2 stack2; //数字栈 stack1.top=stack2.top=-1; int value=0; for(int i=0;i&lt;strlen(str);i++)&#123; if(str[i]=='a'&amp;&amp;str[i-1]!='m')&#123;//避免与求最大值的max区分开 value=0; stack1.top++; stack1.flag[stack1.top]=1; &#125; if(str[i]=='m')&#123; value=0; stack1.top++; if(str[i+1]=='i') stack1.flag[stack1.top]=2;//判断求最小值 else if(str[i+2]=='x') stack1.flag[stack1.top]=3;//判断求最大值 &#125; if(str[i]==',') value=0; if(str[i]&gt;='0'&amp;&amp;str[i]&lt;='9')&#123; if(str[i-1]&gt;='0'&amp;&amp;str[i]&lt;='9')&#123; value=value*10+str[i]-48; &#125; else&#123; value=str[i]-48;//字符转数字 &#125; if(str[i+1]&lt;'0'||str[i+1]&gt;'9')&#123; stack2.top++; stack2.number[stack2.top]=value; &#125; &#125; int temp=0; if(str[i]==')')&#123; value=0; switch(stack1.flag[stack1.top])&#123; case 1: temp=stack2.number[stack2.top]+stack2.number[stack2.top-1]; stack2.top--; stack2.number[stack2.top]=temp; break; case 2: if(stack2.number[stack2.top]&gt;=stack2.number[stack2.top-1]) stack2.top--; else&#123; temp=stack2.number[stack2.top]; stack2.top--; stack2.number[stack2.top]=temp; &#125; break; case 3: if(stack2.number[stack2.top]&lt;=stack2.number[stack2.top-1]) stack2.top--; else&#123; temp=stack2.number[stack2.top]; stack2.top--; stack2.number[stack2.top]=temp; &#125; &#125; stack1.top--; &#125; &#125; return double(stack2.number[stack2.top]); &#125; 继续补题ing…]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[走迷宫（迷宫问题补题）]]></title>
    <url>%2F2018%2F09%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E8%B5%B0%E8%BF%B7%E5%AE%AB%2F</url>
    <content type="text"><![CDATA[一、题目描述 一个迷宫由R行C列格子组成，有的格子里有障碍物，不能走；有的格子是空地，可以走。给定一个迷宫，求从左上角走到右下角最少需要走多少步(数据保证一定能走到)。只能在水平方向或垂直方向走，不能斜着走。Input第一行是两个整数，Ｒ和Ｃ，代表迷宫的长和宽。（ 1&lt;= R，C &lt;= 40)接下来是Ｒ行，每行Ｃ个字符，代表整个迷宫。 空地格子用’.’表示，有障碍物的格子用’#’表示。迷宫左上角和右下角都是’.’。Output输出从左上角走到右下角至少要经过多少步（即至少要经过多少个空地格子）。计算步数要包括起点和终点。 样列输入1234565 5..####....#.#.##.#.##.#.. 样列输出19 二、题解本题方法跟前一篇写的《迷宫求解》队列实现方法一致，传送门需要注意的是二维字符数组的输入问题，可以单个字符的输入，但这就要考虑回车键对数组的影响；而采用字符串形式输入则不会有这个问题，具体见代码。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt;const int MAXSIZE=10000+10;struct Box&#123; int i; int j; int pre;&#125;;struct Type&#123; struct Box data[MAXSIZE]; int front,rear;&#125;;const int LEN=sizeof(struct Type);int findRoad(int a,int b,int c,int d,char mg[42][42]);int main()&#123; char mg[42][42],mgtemp[42][42]; int N,M; scanf("%d%d",&amp;N,&amp;M); for(int i=1;i&lt;=N;i++)&#123; scanf("%s",mgtemp[i]); //采用临时数组，注意列行从0开始而不是需要的从1开始 &#125; for(int i=1;i&lt;=N;i++)&#123; int t=1; for(int j=0;j&lt;M;j++) mg[i][t++]=mgtemp[i][j];//用此转换 &#125; int ans=findRoad(1,1,N,M,mg); printf("%d\n",ans); return 0; &#125; int findRoad(int a,int b,int c,int d,char mg[42][42])&#123; Box e; struct Type *queue; queue=(struct Type *)malloc(LEN); queue-&gt;front=queue-&gt;rear=-1; int i,j; e.i=a;e.j=b;e.pre=-1; mg[a][b]='/'; queue-&gt;rear++; queue-&gt;data[queue-&gt;rear]=e; while(queue-&gt;rear!=queue-&gt;front)&#123; queue-&gt;front++; e=queue-&gt;data[queue-&gt;front]; i=e.i;j=e.j; if(i==c&amp;&amp;j==d)&#123; int temp=queue-&gt;front; while(temp!=0)&#123; int num=queue-&gt;data[temp].pre; queue-&gt;data[temp].pre=-1; temp=num; &#125; temp=0; int count=0; while(temp&lt;=queue-&gt;front)&#123; if(queue-&gt;data[temp].pre==-1) count++; temp++; &#125; return count; &#125; int x,y; for(int k=0;k&lt;4;k++)&#123; switch(k)&#123; case 0: x=i-1;y=j;break; case 1: x=i;y=j+1;break; case 2: x=i+1;y=j;break; case 3: x=i;y=j-1;break; &#125; if(mg[x][y]=='.')&#123; e.i=x;e.j=y;e.pre=queue-&gt;front; queue-&gt;rear++; queue-&gt;data[queue-&gt;rear]=e; mg[x][y]='/'; &#125; &#125; &#125;&#125; 继续补题ing…]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迷宫求解]]></title>
    <url>%2F2018%2F09%2F13%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E8%BF%B7%E5%AE%AB%E6%B1%82%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[想不到迷宫求解还困惑我这么久久久？搞清楚了吧？做下笔记防止遗忘？去补点题？let’s go! 一、问题描述给定一个10*10的迷宫图，求一条从指定路口到指定出口的路径。在这里可以定义一个二维数组，用0来代表迷宫路径可走，用1代表路径不可走。迷宫问题可以用两种数据结构来解决（我暂时只会两种，囧rz），分别为栈、队列。栈只能简单地求出从指定路口到制定出口的路径，也就是说并不能考虑路径长短问题；而用队列来求解的话，可以求出一条最短路径。 二、栈实现1、解决方案说实话，不喜欢用栈来求解，耗时耗力还得不到最优解。就这样吧。从指定路口开始，将指定入口入栈。然后查找与栈头相邻且可走的路口。需要说明是首先要制定一个选择路口的方案，不然计算机怎么知道往哪走呢？我选择的是顺时针查看，即先查看上再右其次下最后左方。若找到，则将其入栈，在这里有一个非常关键的地方，就是需要记住处于栈头相对于前一个路口的方位值，所谓方位值，简单来讲，用0代表上，1代表右，2代表下，3代表左。接着再次查找相邻可走路口。为避免查找到的路口是已经走过的，在设计程序的时候，每一个路口入栈后，都将该路口的状态改变，比如，前面用0代表路径可走，那么可以设置入栈的入口状态值为-1，为区分起始条件不可走的状态值1。若没有找到，也就是说处于当前路口时，上下左右都不可走，不要怕，退一步。退一步就是退回到上一路口。那么整个栈中的元素就是从入口到出口的迷宫路径了。如此直到找到出口，若没有出口，就。。。 2、代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define MAXSIZE 10000int mg[10][10]=&#123; //迷宫数组 &#123;1,1,1,1,1,1,1,1,1,1&#125;, &#123;1,0,0,1,0,0,0,1,0,1&#125;, &#123;1,0,0,1,0,0,0,1,0,1&#125;, &#123;1,0,0,0,0,1,1,0,0,1&#125;, &#123;1,0,1,1,1,0,0,0,0,1&#125;, &#123;1,0,0,0,1,0,0,0,0,1&#125;, &#123;1,0,1,0,0,0,1,0,0,1&#125;, &#123;1,0,1,1,1,0,1,1,0,1&#125;, &#123;1,1,0,0,0,0,0,0,0,1&#125;, &#123;1,1,1,1,1,1,1,1,1,1&#125; &#125;;struct Box&#123; int i; int j; int di; //表示方位值&#125;;struct Type&#123; struct Box data[MAXSIZE]; int top;&#125;;bool findRode(int m,int n,int it,int yt);int main()&#123; if(findRode(1,1,8,8)==false) printf("failed\n"); return 0;&#125;bool findRode(int m,int n,int it,int yt)&#123; int i,j,di,k=0; Box e; struct Type *stack; stack=(struct Type *)malloc(sizeof(struct Type)); stack-&gt;top=-1; e.i=m;e.j=n;e.di=0; stack-&gt;top++; //将第一个路口入栈 stack-&gt;data[stack-&gt;top]=e; mg[e.i][e.j]=-1; while(stack-&gt;top!=-1)&#123; e=stack-&gt;data[stack-&gt;top]; i=e.i;j=e.j;k=e.di; if(i==it&amp;&amp;j==yt)&#123; while(stack-&gt;top!=-1)&#123; e=stack-&gt;data[stack-&gt;top]; printf("(%d,%d) ",e.i,e.j); mg[e.i][e.j]=0; stack-&gt;top--; &#125; free(stack); return true; &#125; bool find=false; while(k&lt;4&amp;&amp;find!=true)&#123; k++; switch(k)&#123; case 0: i=e.i-1;j=e.j;break; case 1: i=e.i;j=e.j+1;break; case 2: i=e.i+1;j=e.j;break; case 3: i=e.i;j=e.j-1;break; &#125; if(mg[i][j]==0) find=true; &#125; if(k&lt;4)&#123; stack-&gt;data[stack-&gt;top].di=k; e.i=i;e.j=j;e.di=-1; stack-&gt;top++; stack-&gt;data[stack-&gt;top]=e; mg[i][j]=-1; &#125;else&#123; //如果当前路口没有相邻可走且不是出口，则退栈回到上一路口 stack-&gt;top--; mg[e.i][e.j]=0; //将该路口状态值重置，表示可走 &#125; &#125; free(stack); return false;&#125; 三、队列实现1、解决方案为什么说用队列来解可以求得最短路径呢？与栈不同的是，队列在查看相邻可走路口时，是将全部相邻可走路口进队；首先将入口进队，队列中就记录下该路口的信息了。将队首元素出队，（注意此时队伍中还记录有路口的信息），以该路口为中心查看相邻路口，使全部相邻可走路口记下该路口在队列中的位置，然后将它们进队。比如起点为A，进队。此时队列为A-&gt;NULL；此时A在队列中的位置就是0（记0是开始），出队，B、C、D是A的相邻可走路口，则B、C、D的前导值就是0，通过查询前导值，就可以清楚地知道A的位置（说明下，第一个路口的前导值记为-1）。此时队列为a-&gt;B-&gt;C-&gt;D-&gt;NULL；（A已出队，但A的信息保留着，所以用a代替）注意队首为B（B在队列中的位置是1），然后将B出队，执行与出队A类似的步骤。直到找到出口。找到出口后，那么通过出口的前导值可以知道它前面的路口（记为M）在哪（将M在队列中的状态值记为-1，后面皆是如此），通过M的前导值又可以知道M前面的路口在哪，直到与入口联系起来。从队首信息开始扫描整个队列，若队列中的元素的状态值为-1，则将该元素记录的坐标输出。求解完成。 2、代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define MAXSIZE 10000#define LEN sizeof(struct Type )int mg[10][10]=&#123; &#123;1,1,1,1,1,1,1,1,1,1&#125;, &#123;1,0,0,1,0,0,0,1,0,1&#125;, &#123;1,0,0,1,0,0,0,1,0,1&#125;, &#123;1,0,0,0,0,1,1,0,0,1&#125;, &#123;1,0,1,1,1,0,0,0,0,1&#125;, &#123;1,0,0,0,1,0,0,0,0,1&#125;, &#123;1,0,1,0,0,0,1,0,0,1&#125;, &#123;1,0,1,1,1,0,1,1,0,1&#125;, &#123;1,1,0,0,0,0,0,0,0,1&#125;, &#123;1,1,1,1,1,1,1,1,1,1&#125; &#125;;struct Box&#123; int i; int j; int pre;//记录上一路口的前导值,所谓前导值，就是可走路口在队列中的位置&#125;;struct Type&#123; struct Box data[MAXSIZE]; int front,rear;&#125;;bool findRoad(int m,int n,int it,int yt);int main()&#123; if(findRoad(1,1,8,8)==false) printf("failed\n"); return 0;&#125;bool findRoad(int m,int n,int it,int yt)&#123; int i,j; Box e; struct Type *queue; queue=(struct Type *)malloc(LEN); e.i=m;e.j=n;e.pre=-1; queue-&gt;front=queue-&gt;rear=-1; queue-&gt;rear++; queue-&gt;data[queue-&gt;rear]=e; mg[e.i][e.j]=-1; while(queue-&gt;rear!=queue-&gt;front)&#123; queue-&gt;front++; e=queue-&gt;data[queue-&gt;front]; i=e.i;j=e.j; if(i==it&amp;&amp;j==yt)&#123; int temp=queue-&gt;front; int num=0; while(temp!=0)&#123; num=queue-&gt;data[temp].pre; queue-&gt;data[temp].pre=-1; temp=num; &#125; temp=0; int count=1; while(temp&lt;=queue-&gt;rear)&#123; if(queue-&gt;data[temp].pre==-1)&#123; printf("(%d,%d)",queue-&gt;data[temp].i,queue-&gt;data[temp].j); if(count%5==0) printf("\n"); count++; &#125; temp++; &#125; return true; &#125; int x,y; int k=0; while(k&lt;4)&#123; switch(k)&#123; case 0: x=i-1;y=j;break; case 1: x=i;y=j+1;break; case 2: x=i+1;y=j;break; case 3: x=i;y=j-1;break; &#125; k++; if(mg[x][y]==0)&#123; /*只要该路口可走，就将其进队 *并且记录上一路口的前导值 */ queue-&gt;rear++; e.i=x;e.j=y;e.pre=queue-&gt;front; queue-&gt;data[queue-&gt;rear]=e; mg[i][j]=-1; &#125; &#125; &#125; return false;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[统计磁盘文件数量（c#实现）]]></title>
    <url>%2F2018%2F09%2F11%2Fcsharp%2F%E7%BB%9F%E8%AE%A1%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6%E6%95%B0%2F</url>
    <content type="text"><![CDATA[一、想法想到能不能写一个小程序用来统计磁盘中有多少个文件呢？虽然系统可以统计出来，但如果自己也可以写出来会不会更舒服，而且这也可以作为c#实践的练手玩具啊啊啊啊？想到了就去做？让我造个轮子出来吧，orz。 二、原理编译环境：Visual Studio 2017页面控件： Button、Label、TextBox、ListBox应用项目：.NET Framework 解决方案：1、首先识别磁盘第一层（就是点开磁盘后所显示的）中有多少文件夹2、然后从上往下从第一个文件夹（记为文件夹A）开始识别，若文件夹A中还有若干个子文件夹，则又从第一个子文件夹开始识别3、接2，直到文件夹里没有其他子文件夹了，则开始统计文件的数量 4、接3，统计完当前文件夹里的文件后，返回上一层，也就是与当前文件夹处于同一层。这就是递归处理了，以前写过，递归算法不要深究，逻辑对递归一定对。注意事项：在用到GetDirectories方法时，要在命名空间添加1using System.IO; 使用截图: 三、实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657using System;using System.Collections.Generic;using System.ComponentModel;using System.Data;using System.Drawing;using System.Linq;using System.Text;using System.Threading.Tasks;using System.IO;using System.Windows.Forms;namespace 小轮子之统计文件数&#123; public partial class Form1 : Form &#123; public Form1() &#123; InitializeComponent(); &#125; private void PathName_TextChanged(object sender, EventArgs e) &#123; /*吃好睡好身体好*/ &#125; private void button1_Click(object sender, EventArgs e) &#123; MessageBox.Show("统计中，请耐心等待..."); string str = PathName.Text.ToString(); long count = GetFiles(str); MessageBox.Show(count.ToString(), "共有文件数"); &#125; static long GetFiles(string path) &#123; long count = 0L; try &#123; var files = Directory.GetFiles(path); count += files.Length; var dirs = Directory.GetDirectories(path); foreach (var dir in dirs) &#123; count += GetFiles(dir);//递归实现深度查找 &#125; &#125; catch (Exception e) &#123; /* 欲渡黄河冰塞川 * 将登太行雪满山 * 闲来垂钓碧溪上 * 忽复乘舟梦日边 */ &#125; return count; &#125; &#125;&#125;]]></content>
      <categories>
        <category>csharp</category>
      </categories>
      <tags>
        <tag>小玩具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c#中try catch finally用法]]></title>
    <url>%2F2018%2F09%2F09%2Fcsharp%2FC%23%E4%B8%ADtry%20catch%20finally%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一、处理机制1、基本语法123456789101112try&#123; //语句&#125;catch&#123; //语句&#125;finally&#123; //语句&#125; try：将可能产生异常的代码块放到try中，这一语句在整个异常处理中不可缺少catch：如果try中的代码出现了异常，则在这一块中需给出异常处理程序，提示使用者出现了怎样的问题。这一语句与下面的finally语句两者必须有一个，可以都有，若两者都有，finally语句在最后。当然这一语句可以有多条，用以处理不同的代码异常。这里还要指出的是catch语句抓取异常分为三种形式。 1、catch{…..代码…..} 一般形式，这样的子句将抓取任何try中出现的异常2、catch(Exception){…..代码…..} 特定形式，这样的子句抓取try中与Exception匹配的异常3、catch(Exception e){…..代码…..} 带对象的特定形式，其中e为异常变量，在这里可以该异常变量并获得与其相关得信息 如123456catch (Exception e)&#123; Console.WriteLine("Message:&#123;0&#125;", e.Message); Console.WriteLine("Source:&#123;0&#125;", e.Source); Console.WriteLine("Stack:&#123;0&#125;", e.StackTrace);&#125; finally：这一语句如果出现，则不管try语句中是否出现异常，finally包涵的代码都要执行，在这里特别要说明得是即使try语块中有return语句，finally块中得语句也要先执行完然后才能执行return语句。如：123456789101112131415try&#123; var number = 5; if (number &lt;= 10) &#123; Console.WriteLine("天生我材必有用"); return; &#125; else Console.WriteLine("人生得意须尽欢");&#125;finally&#123; Console.WriteLine("千金散尽还复来");&#125; 2、异常代码示例我们都知道，被除数不能为0。那么要一个数除以0会发生什么情况呢？如没有异常处理机制，程序会直接中断，俗称的程序崩了或者说“闪退”？但如有，就不会发生这种情况了，程序会提示使用者哪里哪里出现了什么什么问题，提示之后程序继续运行。无处理机制：12345678910111213namespace 验证try_catch&#123; class Program &#123; static void Main(string[] args) &#123; var number1 = 10; var number2 = 0; number1 /= number2; //程序运行到这里会报错 Console.WriteLine(number1); &#125; &#125; &#125; 有处理机制：1234567891011121314151617181920namespace 验证try_catch&#123; class Program &#123; static void Main(string[] args) &#123; try &#123; var number1 = 10; var number2 = 0; number1 /= number2;//抛出异常 Console.WriteLine(number1); &#125; catch //抓住异常 &#123; Console.WriteLine("There has an error --Keep on running!"); &#125; &#125; &#125;&#125; 3、小结12345678910111213141516try&#123; //可能出现异常得代码放入其中&#125;catch&#123; //抓取异常并提示信息&#125;catch&#123; //可以有多个catch语块用来抓取不同得异常&#125;finally&#123; //只要有该语块则一定要执行且在&#125; 二、解读try catch程序123456789101112131415161718192021222324252627282930313233343536373839404142using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace 验证try_catch&#123; class Program &#123; private static void PrintString(string str) &#123; if (str == null) throw new ArgumentException();//抛出异常 &#125; static void Main(string[] args) &#123; string str = null; try &#123; PrintString(str); &#125; catch (ArgumentException e) &#123; /*抓住来自PrintString函数抛来的异常 e为异常变量，通过打印与之相关得信息我们可以知道程序出现了什么问题 */ Console.WriteLine("Message:&#123;0&#125;",e.Message); &#125; catch(Exception) &#123; Console.WriteLine("今朝有酒今朝醉"); &#125; finally &#123; Console.WriteLine("知我者谓我心忧，不知我者谓我何求"); &#125; Console.ReadLine(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>csharp</category>
      </categories>
      <tags>
        <tag>编程实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[语言熟练之计算器（c#实现）]]></title>
    <url>%2F2018%2F09%2F08%2Fcsharp%2F%E8%AF%AD%E8%A8%80%E7%86%9F%E7%BB%83%E4%B9%8B%E8%AE%A1%E7%AE%97%E5%99%A8%2F</url>
    <content type="text"><![CDATA[一、大致介绍本次的编程实验是为了更进一步熟练c#语言，现写下实验过程。 1、工具选用这个计算器可以解决int64位内的+、-、*、/运算。在设计实验时，选用的是.NET Framework，页面控件选择了 Button、Label、TextBox。编译环境：Visual Studio 2017 2、处理异常在测试数据的时候，我发现不输入数据直接点击运算符号时，会出现异常，所以在这里步，用到了try{}catch{}语句，也算是知道如何抓取异常。（之后会专门写下try{}catch{}的使用方法） 3、运行截图 二、代码训练123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100using System;using System.Collections.Generic;using System.ComponentModel;using System.Data;using System.Drawing;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Windows.Forms;namespace 计算器&#123; public partial class Form1 : Form &#123; public Form1() &#123; InitializeComponent(); &#125; private void label1_Click(object sender, EventArgs e) &#123; /* 人生得意须尽欢 */ &#125; /* 莫使金樽空对月 */ private void number1_TextChanged(object sender, EventArgs e) &#123; /* 天生我材必有用 千金散尽还复来 */ &#125; private void button1_Click(object sender, EventArgs e) //处理加法运算 &#123; try &#123; double value1 = double.Parse(number1.Text); double value2 = double.Parse(number2.Text); string result = (value1 + value2).ToString(); MessageBox.Show(result); &#125; catch &#123; MessageBox.Show("傻嗨，把两个数都输完(￣▽￣)"); &#125; &#125; private void button2_Click(object sender, EventArgs e)//处理减法运算 &#123; try &#123; double value1 = double.Parse(number1.Text); double value2 = double.Parse(number2.Text); string result = (value1 - value2).ToString(); MessageBox.Show(result); &#125; catch &#123; MessageBox.Show("傻嗨，把两个数都输完(￣▽￣)"); &#125; &#125; private void button3_Click(object sender, EventArgs e)//处理乘法运算 &#123; try &#123; double value1 = double.Parse(number1.Text); double value2 = double.Parse(number2.Text); string result = (value1 * value2).ToString(); MessageBox.Show(result); &#125; catch &#123; MessageBox.Show("傻嗨，把两个数都输完(￣▽￣)"); &#125; &#125; private void button4_Click(object sender, EventArgs e)//处理除法运算 &#123; try &#123; double value1 = double.Parse(number1.Text); double value2 = double.Parse(number2.Text); string result = (value1 / value2).ToString(); MessageBox.Show(result); &#125; catch &#123; MessageBox.Show("傻嗨，把两个数都输完(￣▽￣)"); &#125; &#125; &#125;&#125; 三、总结完成这个简单计算器后，我将其跟手机上的计算器做了对比。当然运算功能上没有可比性，只是在页面设计上，我觉得还有改进的地方。比如输入框输入的不是数字时抛出的异常却是把两个数字输完，这个bug我还没有改过来。其实我觉得在键入非数字的符号时，程序可以提示使用者键入了非数字。然涉及到知识盲区了，囧rz。如有更好的想法，欢迎在评论区留言，一起找bug，改bug。人生多少欢乐事，尽在debug中。]]></content>
      <categories>
        <category>csharp</category>
      </categories>
      <tags>
        <tag>小玩具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[验证回文字符串（c#实现）]]></title>
    <url>%2F2018%2F09%2F07%2Fcsharp%2F%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[最近在学习c#语言，为提高c#熟练度，特意到leetcode上写题，现写下代码 回文字符串概念：一个字符串从左往右数和从右往左数是一样的。 12345678910111213141516171819202122232425262728293031using System;namespace 验证回文字符串__leetcode&#123; class Program &#123; static void Main(string[] args) &#123; string s = "A man, a plan, a canal: Panama"; bool result = IsPalindrome(s); Console.WriteLine(result); Console.ReadLine(); &#125; public static bool IsPalindrome(string s) &#123; string s1 = ""; s = s.ToUpper(); for (int i = 0; i &lt; s.Length; i++) &#123; if ((s[i] &gt;= 'A' &amp;&amp; s[i] &lt;= 'Z') || (s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '9')) s1 += s[i]; &#125; Console.WriteLine(s1); char[] arr = s1.ToCharArray(); Array.Reverse(arr); string str = new string(arr); return str == s1; &#125; &#125;&#125;]]></content>
      <categories>
        <category>csharp</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NYOJ63 小猴子下落（二叉树）]]></title>
    <url>%2F2018%2F08%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2FNYOJ63%E5%B0%8F%E7%8C%B4%E5%AD%90%E4%B8%8B%E8%90%BD%2F</url>
    <content type="text"><![CDATA[一、题目描述小猴子下落时间限制：3000 ms | 内存限制：65535 KB难度：3描述 有一颗二叉树，最大深度为D,且所有叶子的深度都相同。所有结点从左到右从上到下的编号为1,2,3，·····，2的D次方减1。在结点1处放一个小猴子，它会往下跑。每个内结点上都有一个开关，初始全部关闭，当每次有小猴子跑到一个开关上时，它的状态都会改变，当到达一个内结点时，如果开关关闭，小猴子往左走，否则往右走，直到走到叶子结点。一些小猴子从结点1处开始往下跑，最后一个小猴儿会跑到哪里呢？输入输入二叉树叶子的深度D,和小猴子数目I，假设I不超过整棵树的叶子个数，D&lt;=20.最终以 0 0 结尾 输出 输出第I个小猴子所在的叶子编号。 样例输入1234 23 40 0 样例输出12127 来源[张洁烽]原创上传者张洁烽 二、题解思路如下 1、首先可以明确当节点值为0时，往左走，然后节点值变为1，反之往右走，节点值变为0；2、定义一个大数组用来存放节点状态值，将数组看成满二叉树存储值的状态；3、左节点的序号为上一节点的2倍，右节点的序号为上一节点的2倍加1。 123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;memory.h&gt;#define MAXSIZE 40000+10int flag[MAXSIZE]=&#123;0&#125;; int main()&#123; int N,M; while(scanf("%d%d",&amp;N,&amp;M)!=EOF)&#123; memset(flag,0,MAXSIZE); if(N==0&amp;&amp;M==0) break; int temp=1; for(int i=1;i&lt;=M;i++)&#123; int depth=1; temp=1; while(depth&lt;N)&#123; if(flag[temp]==0)&#123; flag[temp]=1; temp=temp*2; &#125;else&#123; flag[temp]=0; temp=temp*2+1; &#125; depth++; &#125; &#125; printf("%d\n",temp); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo小配置]]></title>
    <url>%2F2018%2F08%2F10%2F%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%8A%80%E5%B7%A7%2Fhexo%E5%B0%8F%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[一、hexo部署本地图片把图片在hexo/blog/public/css/images目录下，其中(hexo/blog)是你博客所在文件夹。使用/css/images/at.png的方式进行链接。 二、在首页只显示摘要信息12345这里写文章的简介&lt;!-- more --&gt;这里写文章的正文 三、在首页显示图片123456---title: hexo小配置categories: hexotags: 小技巧photo: https://hexo.io/logo.svg //写上这一行，注意“photo:”有一个空格，“photo: ”后面就写上图片的地址--- 四、新建“about”页面1、在git Bash命令行界面输入1hexo new page "about" 2、在主题配置文件中将menu中about的注释去掉文件路径：themes/hiero/config（hiero是你主题的名称123456menu: Home: / Archives: /archives Categories: /categories Tags: /tags About: /about 上面代码为已经去掉注释后的这里就可以拓展一下，比如分类、标签页面等等。分类：123456---title: categoriesdate: 2018-09-09 23:48:07layout: "categories"--- 标签：12345---title: tagsdate: 2018-09-09 23:47:25layout: "tags"--- 未完待续……]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的创建及其遍历]]></title>
    <url>%2F2018%2F08%2F09%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%9B%E5%BB%BA%E5%8F%8A%E5%85%B6%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[二叉树是一种非常重要的数据结构，许多其他的数据结构都是基于二叉树发展推演过来的。用递归定义树的结构非常简洁，同样，递归遍历也非常简洁。在学习过程中，我发现递归算法往往只是一个简单的语句，虽然简洁的语句实现了功能，但在算法具体过程方面没有很好的阐述，我也很纠结为什么可以这么用，一次次调式试图弄明白内在机理，总是达不到预期效果，所以我转而写非递归的算法以此希望能够理解树的节点的构造、遍历。在这里，我写下这些天学习二叉树的历程。 一、树的创建利用递归创建二叉树。123456789101112131415struct Btree *inputTree()//创建二叉树 &#123; int number; struct Btree *tree; scanf("%d",&amp;number); if(number==0)&#123; //当输入0时，表示左孩子或右孩子为空 tree=NULL; &#125;else&#123; tree=(struct Btree *)malloc(LEN); tree-&gt;data=number; tree-&gt;lchild=inputTree(); //递归左孩子 tree-&gt;rchild=inputTree(); //递归右孩子 &#125; return tree;&#125; 二、三种遍历递归实现1、先序遍历递归算法规则：先根节点，再左子树，后右子树，简记NLR。具体，可将整棵树分为左子树和右子树，然后再将左子树分为次左子树、次右子树123456789void preTraversal(struct Btree *tree)&#123; if(tree!=NULL)&#123; printf("%d ",tree-&gt;data); //打印根节点 preTraversal(tree-&gt;lchild); //遍历左孩子树 preTraversal(tree-&gt;rchild); //遍历右孩子树 &#125; return;&#125; 2、中序遍历递归算法规则：先左子树，再根节点，后右子树，简记LNR。具体同先序。123456789void inTraversal(struct Btree *tree)&#123; if(tree!=NULL)&#123; preTraversal(tree-&gt;lchild); //遍历左孩子树 printf("%d",tree-&gt;data); //打印根节点 preTraversal(tree-&gt;rchild); //遍历右孩子树 &#125; return;&#125; 3、后序遍历递归算法规则：先左子树，再右子树，后根节点，简记LRN。具体同先序。12345678void postTraversal(struct Btree *tree)&#123; if(tree!=NULL)&#123; postTraversal(tree-&gt;lchild); //遍历左孩子树 postTraversal(tree-&gt;rchild); //遍历右孩子树 printf("%d ",tree-&gt;data); //打印根节点 &#125;&#125; 三、三种遍历非递归实现1、先序遍历非递归算法算法主要步骤：1、当树不为空时，将根节点压入栈中；2、当栈不为空时，说明需要此时访问当前节点，退栈访问；3、查看该节点的右孩子(这里先查看右孩子是因为这是先序遍历，先遍历根节点其次左孩子最后右孩子，这里用到栈也是因为栈的特点，先进后出，后进先出)，若右孩子存在，则压入栈中；4、查看该节点的左孩子，同3；5、若栈不为空，转2，循环。12345678910111213141516171819202122232425void preTraversal(struct Btree *tree)&#123; struct Btree *stack[MAXSIZE]; struct Btree *temp; int top=-1; if(tree!=NULL)&#123; top++; stack[top]=tree; //将根节点进栈 while(top!=-1)&#123; temp=stack[top]; top--; printf("%d ",temp-&gt;data); if(temp-&gt;rchild!=NULL)&#123; //右孩子不为空，进栈 top++; stack[top]=temp-&gt;rchild; &#125; if(temp-&gt;lchild!=NULL)&#123; //左孩子不为空，进栈 top++; stack[top]=temp-&gt;lchild; &#125; &#125; &#125; printf("\n"); return;&#125; 2、中序遍历非递归算法算法主要步骤：1、首先查看根节点，若根节点不为空，将其进栈；2、查看根节点的左孩子，若左孩子存在，将其进栈，继续访问以左孩子为根节点的次树；3、 若次树无左孩子，访问当前次树的根节点，然后查看该根节点的右孩子；4、循环。12345678910111213141516171819202122void inTraversal(struct Btree *tree)&#123; struct Btree *stack[MAXSIZE],*temp; int top=-1; if(tree!=NULL)&#123; temp=tree; while(top&gt;-1||temp!=NULL)&#123; if(temp!=NULL)&#123; top++; stack[top]=temp; temp=temp-&gt;lchild; &#125;else&#123; //此时说明当前次树已无左孩子，则访问该节点 temp=stack[top]; top--; printf("%d ",temp-&gt;data); temp=temp-&gt;rchild; //查看该节点的右孩子 &#125; &#125; &#125; printf("\n"); return; &#125; 3、后序遍历非递归算法算法主要步骤：1、首先将根节点进栈，若栈不为空，循环；2、查看栈顶元素，若其有左孩子或右孩子并且左右孩子没有被访问，将其左孩子或右孩子入栈，否则，访问该节点；3、 在2步骤中，若访问完一节点，则用pre指针记录下来 。1234567891011121314151617181920212223242526void postTraversal(struct Btree *tree)&#123; struct Btree *stack[MAXSIZE],*temp,*pre=NULL; int top=-1; top++; stack[top]=tree; while(top!=-1)&#123; temp=stack[top]; if((temp-&gt;lchild==NULL&amp;&amp;temp-&gt;rchild==NULL)||\ (pre!=NULL&amp;&amp;(temp-&gt;lchild==pre||temp-&gt;rchild==pre)))&#123; printf("%d ",temp-&gt;data);//到此表明该节点无左右孩子 top--; //或者有左右孩子但已被访问输出，访问该节点 pre=temp; //pre指针用来记录上一访问过的节点 &#125;else&#123; if(temp-&gt;rchild!=NULL)&#123; //若右孩子存在，将其入栈 top++; stack[top]=temp-&gt;rchild; &#125; if(temp-&gt;lchild!=NULL)&#123; //若左孩子存在，将其入栈 top++; stack[top]=temp-&gt;lchild; &#125; &#125; &#125; printf("\n"); &#125; 四、源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define LEN sizeof(struct Btree)#define MAXSIZE 1000+10struct Btree&#123; int data; struct Btree *lchild,*rchild;&#125;;void preTraversal(struct Btree *tree);void inTraversal(struct Btree *tree);void postTraversal(struct Btree *tree);struct Btree *inputTree();int main()&#123; struct Btree *tree; tree=inputTree(); printf("先序遍历:\n"); preTraversal(tree); printf("中序遍历:\n"); inTraversal(tree); printf("后序遍历:\n"); postTraversal(tree); return 0;&#125;struct Btree *inputTree()//创建二叉树 &#123; int number; struct Btree *tree; scanf("%d",&amp;number); if(number==0)&#123; //当输入0时，表示左孩子或右孩子 为空 tree=NULL; &#125;else&#123; tree=(struct Btree *)malloc(LEN); tree-&gt;data=number; tree-&gt;lchild=inputTree(); //递归左孩子 tree-&gt;rchild=inputTree(); //递归右孩子 &#125; return tree;&#125;void preTraversal(struct Btree *tree)//先序递归&#123; if(tree!=NULL)&#123; printf("%d ",tree-&gt;data); //打印根节点 preTraversal(tree-&gt;lchild); //遍历左孩子树 preTraversal(tree-&gt;rchild); //遍历右孩子树 &#125; return;&#125;void preTraversal(struct Btree *tree)//先序非递归&#123; struct Btree *stack[MAXSIZE]; struct Btree *temp; int top=-1; if(tree!=NULL)&#123; top++; stack[top]=tree; //将根节点进栈 while(top!=-1)&#123; temp=stack[top]; top--; printf("%d ",temp-&gt;data); if(temp-&gt;rchild!=NULL)&#123; //右孩子不为空，进栈 top++; stack[top]=temp-&gt;rchild; &#125; if(temp-&gt;lchild!=NULL)&#123; //左孩子不为空，进栈 top++; stack[top]=temp-&gt;lchild; &#125; &#125; &#125; printf("\n"); return; &#125;void inTraversal(struct Btree *tree)//中序递归&#123; if(tree!=NULL)&#123; preTraversal(tree-&gt;lchild); //遍历左孩子树 printf("%d",tree-&gt;data); //打印根节点 preTraversal(tree-&gt;rchild); //遍历右孩子树 &#125; return;&#125;void inTraversal(struct Btree *tree)//中序非递归&#123; struct Btree *stack[MAXSIZE],*temp; int top=-1; if(tree!=NULL)&#123; temp=tree; while(top&gt;-1||temp!=NULL)&#123; if(temp!=NULL)&#123; top++; stack[top]=temp; temp=temp-&gt;lchild; &#125;else&#123; //此时说明当前次树已无左孩子，则访问该节点 temp=stack[top]; top--; printf("%d ",temp-&gt;data); temp=temp-&gt;rchild; //查看该节点的右孩子 &#125; &#125; &#125; printf("\n"); return; &#125; void postTraversal(struct Btree *tree)//后序递归&#123; if(tree!=NULL)&#123; postTraversal(tree-&gt;lchild); //遍历左孩子树 postTraversal(tree-&gt;rchild); //遍历右孩子树 printf("%d ",tree-&gt;data); //打印根节点 &#125; return;&#125;void postTraversal(struct Btree *tree)&#123; struct Btree *stack[MAXSIZE],*temp,*pre=NULL; int top=-1; top++; stack[top]=tree; while(top!=-1)&#123; temp=stack[top]; if((temp-&gt;lchild==NULL&amp;&amp;temp-&gt;rchild==NULL)||\ (pre!=NULL&amp;&amp;(temp-&gt;lchild==pre||temp-&gt;rchild==pre)))&#123; printf("%d ",temp-&gt;data);//到此表明该节点无左右孩子 top--; //或者有左右孩子但已被访问输出，访问该节点 pre=temp;//pre指针用来记录上一访问过的节点 &#125;else&#123; if(temp-&gt;rchild!=NULL)&#123;//若右孩子存在，将其入栈 top++; stack[top]=temp-&gt;rchild; &#125; if(temp-&gt;lchild!=NULL)&#123;//若左孩子存在，将其入栈 top++; stack[top]=temp-&gt;lchild; &#125; &#125; &#125; printf("\n"); return;&#125; 五、后记在用递归遍历二叉树时，总想搞明白递归遍历的过程是怎么样的，但每次都以头昏脑涨结尾。说实话，递归说它难，也就那样，说它简单，但……总之，用递归求解时，不要深究细节，逻辑对，递归一定对。最后若有什么想法，欢迎在评论区留言。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[I am coming]]></title>
    <url>%2F2018%2F08%2F02%2F%E9%9A%8F%E7%AC%94%E6%9D%82%E6%83%B3%2Fhello-world%2F</url>
    <content type="text"><![CDATA[ONE 将学习and工作中遇到的问题记录下来，小白成长为大佬，若干年后，相必值得回味。这是我的第一篇博客。想写博客，但会不会变成为了写博客而写博客呢，不知道。认真地想，以往遇到问题，求助知乎、csdn、博客园，大部分问题都能得到很好的解决，感慨众多大神and大佬的无私分享，遂生出想法，记录问题，待知识丰富后，再来看看这些，希望能够得到些许乐趣吧。 ——GageShan 于2018.08.02 夜]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
</search>
