<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Codeforces-516-Div.2 | GageShan</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="A    Make a triangle!题目Masha has three sticks of length a, b and c centimeters respectively. In one minute Masha can pick one arbitrary stick and increase its length by one centimeter. She is not allo">
<meta name="keywords" content="比赛">
<meta property="og:type" content="article">
<meta property="og:title" content="Codeforces-516-Div.2">
<meta property="og:url" content="https://shann.xyz/2019/09/21/比赛/Codeforces-516-Div. 2/index.html">
<meta property="og:site_name" content="GageShan">
<meta property="og:description" content="A    Make a triangle!题目Masha has three sticks of length a, b and c centimeters respectively. In one minute Masha can pick one arbitrary stick and increase its length by one centimeter. She is not allo">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-04-24T01:55:18.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Codeforces-516-Div.2">
<meta name="twitter:description" content="A    Make a triangle!题目Masha has three sticks of length a, b and c centimeters respectively. In one minute Masha can pick one arbitrary stick and increase its length by one centimeter. She is not allo">
  
    <link rel="alternate" href="/atom.xml" title="GageShan" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">GageShan</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://shann.xyz"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-比赛/Codeforces-516-Div. 2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/21/比赛/Codeforces-516-Div. 2/" class="article-date">
  <time datetime="2019-09-21T13:05:24.199Z" itemprop="datePublished">2019-09-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/比赛/">比赛</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Codeforces-516-Div.2
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="A-Make-a-triangle"><a href="#A-Make-a-triangle" class="headerlink" title="A    Make a triangle!"></a>A    Make a triangle!</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Masha has three sticks of length a, b and c centimeters respectively. In one minute Masha can pick one arbitrary stick and increase its length by one centimeter. She is not allowed to break sticks.</p>
<p>What is the minimum number of minutes she needs to spend increasing the stick’s length in order to be able to assemble a triangle of positive area. Sticks should be used as triangle’s sides (one stick for one side) and their endpoints should be located at triangle’s vertices.<br><a id="more"></a><br>Input<br>The only line contains tree integers a, b and c (1≤a,b,c≤100) — the lengths of sticks Masha possesses.</p>
<p>Output<br>Print a single integer — the minimum number of minutes that Masha needs to spend in order to be able to make the triangle of positive area from her sticks.</p>
<p>Examples<br>Input<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 4 5</span><br></pre></td></tr></table></figure></p>
<p>Output<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure></p>
<p>Input<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 5 3</span><br></pre></td></tr></table></figure></p>
<p>Output<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure></p>
<p>Input<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100 10 10</span><br></pre></td></tr></table></figure></p>
<p>Output<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">81</span><br></pre></td></tr></table></figure></p>
<p>Note<br>In the first example, Masha can make a triangle from the sticks without increasing the length of any of them.</p>
<p>In the second example, Masha can’t make a triangle of positive area from the sticks she has at the beginning, but she can spend one minute to increase the length 2 centimeter stick by one and after that form a triangle with sides 3, 3 and 5 centimeters.</p>
<p>In the third example, Masha can take 33 minutes to increase one of the 10 centimeters sticks by 33 centimeters, and after that take 48 minutes to increase another 10 centimeters stick by 48 centimeters. This way she can form a triangle with lengths 43, 58 and 100 centimeters in 81 minutes. One can show that it is impossible to get a valid triangle faster.</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意为求让两条小边最少增加多少才能够与第三条边构成三角形。<br>而三条边能够构成三角形的条件很简单，那么让最大的边加1减去两条小边长即可。当然，如果直接就满足构成三角形的条件直接输出0就行了。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int arr[3];</span><br><span class="line">	cin&gt;&gt;arr[0]&gt;&gt;arr[1]&gt;&gt;arr[2];</span><br><span class="line">	sort(arr,arr+3);</span><br><span class="line">	if((arr[0]+arr[1]&gt;arr[2])&amp;&amp;(arr[1]+arr[2]&gt;arr[0])&amp;&amp;(arr[0]+arr[2]&gt;arr[1]))&#123;</span><br><span class="line">		cout&lt;&lt;0&lt;&lt;endl;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	int ans=arr[2]+1-(arr[0]+arr[1]);</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="B-Equations-of-Mathematical-Magic"><a href="#B-Equations-of-Mathematical-Magic" class="headerlink" title="B Equations of Mathematical Magic"></a>B Equations of Mathematical Magic</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>Colossal! — exclaimed Hawk-nose. — A programmer! That’s exactly what we are looking for.<br>Arkadi and Boris Strugatsky. Monday starts on Saturday<br>Reading the book “Equations of Mathematical Magic” Roman Oira-Oira and Cristobal Junta found an interesting equation: <code>a−(a⊕x)−x=0</code> for some given a, where ⊕ stands for a bitwise exclusive or (XOR) of two integers (this operation is denoted as ^ or xor in many modern programming languages). Oira-Oira quickly found some x, which is the solution of the equation, but Cristobal Junta decided that Oira-Oira’s result is not interesting enough, so he asked his colleague how many non-negative solutions of this equation exist. This task turned out to be too difficult for Oira-Oira, so he asks you to help.</p>
<p>Input<br>Each test contains several possible values of a and your task is to find the number of equation’s solution for each of them. The first line contains an integer t (1≤t≤1000) — the number of these values.</p>
<p>The following t lines contain the values of parameter a, each value is an integer from <code>0</code> to <code>2^30−1</code> inclusive.</p>
<p>Output<br>For each value of a print exactly one integer — the number of non-negative solutions of the equation for the given value of the parameter. Print answers in the same order as values of a appear in the input.</p>
<p>One can show that the number of solutions is always finite.</p>
<p>Example<br>Input<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">0</span><br><span class="line">2</span><br><span class="line">1073741823</span><br></pre></td></tr></table></figure></p>
<p>Output<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">1073741824</span><br></pre></td></tr></table></figure></p>
<p>Note<br>Let’s define the bitwise exclusive OR (XOR) operation. Given two integers x and y, consider their binary representations (possibly with leading zeroes): xk…x2x1x0 and yk…y2y1y0. Here, xi is the i-th bit of the number x and yi is the i-th bit of the number y. Let r=x⊕y be the result of the XOR operation of x and y. Then r is defined as rk…r2r1r0 where:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ri=&#123;1, if xi≠yi；</span><br><span class="line">0, if xi=yi</span><br></pre></td></tr></table></figure>
<p>For the first value of the parameter, only x=0 is a solution of the equation.</p>
<p>For the second value of the parameter, solutions are x=0 and x=2.</p>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>转换一下公式<code>a−(a⊕x)−x=0</code> =&gt;<code>a-x=a⊕x</code>。<br>假设<strong>a</strong>的二进制表示为<code>1011011011</code>，a减去一个数x（x&gt;=0）必然会使得a减小，那么就要看a与哪些数异或会使得a会减小相同数的值。异或为不进位的加法，比如<code>1101^0001</code>，结果为<code>1100</code>；让<code>1101-0001</code>，结果为<code>1100</code>。可以发现，只要<code>x</code>的二进制串上的1与<code>a</code>的二进制串上的1有对应的（<code>x</code>的1不与<code>a</code>上的0对应），那么就满足<code>a-x=a⊕x</code>。举例子，<code>a=1011011011</code>，<code>x可为1，11，1011，11011……</code>。所以只需统计<code>a</code>的二进制串有多少位是1，又对于每一位的1选择是取还是不取，答案为2^n。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">long long fast_pow(int a,int b) &#123;</span><br><span class="line">	long long ans=1;</span><br><span class="line">	while(b) &#123;</span><br><span class="line">		if(b&amp;1)</span><br><span class="line">			ans=ans*a;</span><br><span class="line">		a*=a;</span><br><span class="line">		b&gt;&gt;=1; </span><br><span class="line">	&#125;</span><br><span class="line">	return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	</span><br><span class="line">	int t;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	while(t--) &#123;</span><br><span class="line">		long long n;</span><br><span class="line">		cin&gt;&gt;n;</span><br><span class="line">		int sum=0;</span><br><span class="line">		while(n) &#123;</span><br><span class="line">			if(n&amp;1)</span><br><span class="line">				sum++;</span><br><span class="line">			n&gt;&gt;=1;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;fast_pow(2,sum)&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C-Oh-Those-Palindromes"><a href="#C-Oh-Those-Palindromes" class="headerlink" title="C Oh Those Palindromes"></a>C Oh Those Palindromes</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>A non-empty string is called palindrome, if it reads the same from the left to the right and from the right to the left. For example, “abcba”, “a”, and “abba” are palindromes, while “abab” and “xy” are not.</p>
<p>A string is called a substring of another string, if it can be obtained from that string by dropping some (possibly zero) number of characters from the beginning and from the end of it. For example, “abc”, “ab”, and “c” are substrings of the string “abc”, while “ac” and “d” are not.</p>
<p>Let’s define a palindromic count of the string as the number of its substrings that are palindromes. For example, the palindromic count of the string “aaa” is 6 because all its substrings are palindromes, and the palindromic count of the string “abc” is 3 because only its substrings of length 1 are palindromes.</p>
<p>You are given a string s. You can arbitrarily rearrange its characters. You goal is to obtain a string with the maximum possible value of palindromic count.</p>
<p>Input<br>The first line contains an integer n (1≤n≤100000) — the length of string s.</p>
<p>The second line contains string s that consists of exactly n lowercase characters of Latin alphabet.</p>
<p>Output<br>Print string t, which consists of the same set of characters (and each characters appears exactly the same number of times) as string s. Moreover, t should have the maximum possible value of palindromic count among all such strings strings.</p>
<p>If there are multiple such strings, print any of them.</p>
<p>Examples<br>Input<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">oolol</span><br></pre></td></tr></table></figure></p>
<p>Output<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ololo</span><br></pre></td></tr></table></figure></p>
<p>Input<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">16</span><br><span class="line">gagadbcgghhchbdf</span><br></pre></td></tr></table></figure></p>
<p>Output<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abccbaghghghgdfd</span><br></pre></td></tr></table></figure></p>
<p>Note<br>In the first example, string “ololo” has 9 palindromic substrings: “o”, “l”, “o”, “l”, “o”, “olo”, “lol”, “olo”, “ololo”. Note, that even though some substrings coincide, they are counted as many times as they appear in the resulting string.</p>
<p>In the second example, the palindromic count of string “abccbaghghghgdfd” is 29.</p>
<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>给定一个字符串，求能组回文子串的最多种数。其实这个题目考思维。对于字符串<code>abccba</code>，如果能看到<code>aabbcc</code>所组成的回文子串的数量一样多的话，就简洁明了了。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAXN=100000+10;</span><br><span class="line">char str[MAXN]; </span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	cin&gt;&gt;str;</span><br><span class="line">	sort(str,str+n);</span><br><span class="line">	cout&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D-Labyrinth-CodeForces"><a href="#D-Labyrinth-CodeForces" class="headerlink" title="D Labyrinth CodeForces"></a>D Labyrinth CodeForces</h1><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h2><p>You are playing some computer game. One of its levels puts you in a maze consisting of n lines, each of which contains m cells. Each cell either is free or is occupied by an obstacle. The starting cell is in the row r and column c. In one step you can move one square up, left, down or right, if the target cell is not occupied by an obstacle. You can’t move beyond the boundaries of the labyrinth.</p>
<p>Unfortunately, your keyboard is about to break, so you can move left no more than x times and move right no more than y times. There are no restrictions on the number of moves up and down since the keys used to move up and down are in perfect condition.</p>
<p>Now you would like to determine for each cell whether there exists a sequence of moves that will put you from the starting cell to this particular one. How many cells of the board have this property?</p>
<p>Input<br>The first line contains two integers n, m (1 ≤ n, m ≤ 2000) — the number of rows and the number columns in the labyrinth respectively.</p>
<p>The second line contains two integers r, c (1 ≤ r ≤ n, 1 ≤ c ≤ m) — index of the row and index of the column that define the starting cell.</p>
<p>The third line contains two integers x, y (0 ≤ x, y ≤ 109) — the maximum allowed number of movements to the left and to the right respectively.</p>
<p>The next n lines describe the labyrinth. Each of them has length of m and consists only of symbols ‘.’ and ‘<em>“.<br>The j-th character of the i-th line corresponds to the cell of labyrinth at row i and column j. Symbol ‘.’ denotes the free cell, while symbol “</em>“ denotes the cell with an obstacle.</p>
<p>It is guaranteed, that the starting cell contains no obstacles.</p>
<p>Output<br>Print exactly one integer — the number of cells in the labyrinth, which are reachable from starting cell, including the starting cell itself.</p>
<p>Examples<br>Input<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">4 5</span><br><span class="line">3 2</span><br><span class="line">1 2</span><br><span class="line">.....</span><br><span class="line">.***.</span><br><span class="line">...**</span><br><span class="line">*....</span><br></pre></td></tr></table></figure></p>
<p>Output<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure></p>
<p>Input<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">4 4</span><br><span class="line">2 2</span><br><span class="line">0 1</span><br><span class="line">....</span><br><span class="line">..*.</span><br><span class="line">....</span><br><span class="line">....</span><br></pre></td></tr></table></figure></p>
<p>Output<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure></p>
<p>Note<br>Cells, reachable in the corresponding example, are marked with ‘+’.</p>
<p>First example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+++..</span><br><span class="line">+***.</span><br><span class="line">+++**</span><br><span class="line">*+++.</span><br></pre></td></tr></table></figure></p>
<p>Second example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.++.</span><br><span class="line">.+*.</span><br><span class="line">.++.</span><br><span class="line">.++.</span><br></pre></td></tr></table></figure></p>
<h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>由起点出发，在向左向右转有次数限制的条件下问能到达最大的位置。<br>先是用传统的BFS写了一遍，WA，后来发现某个位置可由不同的位置到达，这些位置带来的状态转变也不一定相同。<br>例如，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...*******</span><br><span class="line">.*.*******</span><br><span class="line">.*.*******</span><br><span class="line">.*.*******</span><br><span class="line">.*.*******</span><br><span class="line">.*.*......</span><br><span class="line">.*.*@*****</span><br><span class="line">.*........</span><br><span class="line">.********.</span><br><span class="line">..........</span><br></pre></td></tr></table></figure></p>
<p>在某个关键位置<code>@</code>，假如由位置1带来的状态是左右转次数都为0，就导致这个<br>点无法向左或向右转造成的结果是后面可能会有更多可达到的位置但是由于这个点<code>@</code>已经无法访问，使得就算有另外的位置达到这里的左右转次数不为零也没有用。所以需要定义一种谁先访问谁后访问的顺序来避免这种情况。</p>
<h3 id="双端队列解法"><a href="#双端队列解法" class="headerlink" title="双端队列解法"></a>双端队列解法</h3><p>由题知，上下移动不消耗次数，左右移动消耗次数，那么就可以只要能向上或向下就向上或向下移动，当无法上下移动时才左右移动。使用双端队列，将能上下移动的位置放在队头，左右移动的位置放在队尾。</p>
<h3 id="优先队列解法"><a href="#优先队列解法" class="headerlink" title="优先队列解法"></a>优先队列解法</h3><p>其实优先队列解法与双端队列解法思想是一样的，那就是能上下移动就上下移动，而上下移动不会消耗左右移动次数，也就是说左移动次数加上右移动次数大的优先访问。</p>
<h2 id="代码（deque）"><a href="#代码（deque）" class="headerlink" title="代码（deque）"></a>代码（deque）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAXN=2e3+10;</span><br><span class="line">struct node&#123;</span><br><span class="line">	int x,y,dep;</span><br><span class="line">	int left,right;</span><br><span class="line">	node(int x,int y,int dep,int left,int right):x(x),y(y),dep(dep),left(left),right(right)&#123;&#125;</span><br><span class="line">//	bool operator &lt; (const node &amp;a) const &#123;return (right)&gt;(a.right);&#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">deque&lt;node&gt; qu;</span><br><span class="line">int n,m;</span><br><span class="line">int r,c;</span><br><span class="line">int leftCount,rightCount;</span><br><span class="line">int visit[MAXN][MAXN];</span><br><span class="line">string str[MAXN]; </span><br><span class="line">int ans;</span><br><span class="line">int dx[]=&#123;1,-1,0,0&#125;;</span><br><span class="line">int dy[]=&#123;0,0,1,-1&#125;;</span><br><span class="line"></span><br><span class="line">void BFS(int x,int y,int left,int right) &#123;</span><br><span class="line">	while(!qu.empty()) qu.pop_back();</span><br><span class="line">	</span><br><span class="line">	memset(visit,0,sizeof(visit));</span><br><span class="line">	</span><br><span class="line">	qu.push_front(node(x,y,0,left,right));</span><br><span class="line">	visit[x][y]=1;</span><br><span class="line">	while(!qu.empty()) &#123;</span><br><span class="line">		</span><br><span class="line">		node t=qu.front();qu.pop_front();</span><br><span class="line">		</span><br><span class="line">		for(int i=0;i&lt;4;i++) &#123;</span><br><span class="line">			</span><br><span class="line">			int tx=t.x+dx[i];</span><br><span class="line">			int ty=t.y+dy[i];</span><br><span class="line">			</span><br><span class="line">			if(tx&gt;=0&amp;&amp;tx&lt;n&amp;&amp;ty&gt;=0&amp;&amp;ty&lt;m&amp;&amp;!visit[tx][ty]&amp;&amp;str[tx][ty]==&apos;.&apos;) &#123;</span><br><span class="line">				</span><br><span class="line">//				visit[t.x][t.y]=0;</span><br><span class="line">			</span><br><span class="line">				if(0==i||1==i) &#123;</span><br><span class="line">					qu.push_front(node(tx,ty,t.dep+1,t.left,t.right));</span><br><span class="line">					visit[tx][ty]=1;</span><br><span class="line">					ans++;</span><br><span class="line">				&#125;</span><br><span class="line">				else if(2==i) &#123;</span><br><span class="line">					if(t.right&gt;0) &#123;</span><br><span class="line">						qu.push_back(node(tx,ty,t.dep+1,t.left,t.right-1));</span><br><span class="line">						visit[tx][ty]=1;</span><br><span class="line">						ans++;</span><br><span class="line">					&#125;</span><br><span class="line">						</span><br><span class="line">					</span><br><span class="line">				&#125;</span><br><span class="line">				else if(3==i) &#123;</span><br><span class="line">					if(t.left&gt;0) &#123;</span><br><span class="line">						qu.push_back(node(tx,ty,t.dep+1,t.left-1,t.right));</span><br><span class="line">						visit[tx][ty]=1;</span><br><span class="line">						ans++;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">			&#125;</span><br><span class="line">	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	</span><br><span class="line">	ios::sync_with_stdio(false);</span><br><span class="line">	ans=1;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	cin&gt;&gt;r&gt;&gt;c;</span><br><span class="line">	cin&gt;&gt;leftCount&gt;&gt;rightCount;</span><br><span class="line">	for(int i=0;i&lt;n;i++) &#123;</span><br><span class="line">		cin&gt;&gt;str[i];</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">	BFS(r-1,c-1,leftCount,rightCount);</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="代码（priority-queue）"><a href="#代码（priority-queue）" class="headerlink" title="代码（priority_queue）"></a>代码（priority_queue）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAXN=2e3+10;</span><br><span class="line">struct node&#123;</span><br><span class="line">	int x,y,dep;</span><br><span class="line">	int left,right;</span><br><span class="line">	node(int x,int y,int dep,int left,int right):x(x),y(y),dep(dep),left(left),right(right)&#123;&#125;</span><br><span class="line">	bool operator &lt; (const node &amp;a) const &#123;return (left+right)&lt;(a.left+a.right);&#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">priority_queue&lt;node&gt; qu;</span><br><span class="line">int n,m;</span><br><span class="line">int r,c;</span><br><span class="line">int leftCount,rightCount;</span><br><span class="line">int visit[MAXN][MAXN];</span><br><span class="line">string str[MAXN]; </span><br><span class="line">int ans;</span><br><span class="line">int dx[]=&#123;1,-1,0,0&#125;;</span><br><span class="line">int dy[]=&#123;0,0,1,-1&#125;;</span><br><span class="line"></span><br><span class="line">void BFS(int x,int y,int left,int right) &#123;</span><br><span class="line">	while(!qu.empty()) qu.pop();</span><br><span class="line">	</span><br><span class="line">	memset(visit,0,sizeof(visit));</span><br><span class="line">	</span><br><span class="line">	qu.push(node(x,y,0,left,right));</span><br><span class="line">	visit[x][y]=1;</span><br><span class="line">	while(!qu.empty()) &#123;</span><br><span class="line">		</span><br><span class="line">		node t=qu.top();qu.pop();</span><br><span class="line">		</span><br><span class="line">		for(int i=0;i&lt;4;i++) &#123;</span><br><span class="line">			</span><br><span class="line">			int tx=t.x+dx[i];</span><br><span class="line">			int ty=t.y+dy[i];</span><br><span class="line">			</span><br><span class="line">			if(tx&gt;=0&amp;&amp;tx&lt;n&amp;&amp;ty&gt;=0&amp;&amp;ty&lt;m&amp;&amp;!visit[tx][ty]&amp;&amp;str[tx][ty]==&apos;.&apos;) &#123;</span><br><span class="line">				</span><br><span class="line">//				visit[t.x][t.y]=0;</span><br><span class="line">			</span><br><span class="line">				if(0==i||1==i) &#123;</span><br><span class="line">					qu.push(node(tx,ty,t.dep+1,t.left,t.right));</span><br><span class="line">					visit[tx][ty]=1;</span><br><span class="line">					ans++;</span><br><span class="line">				&#125;</span><br><span class="line">				else if(2==i) &#123;</span><br><span class="line">					if(t.right&gt;0) &#123;</span><br><span class="line">						qu.push(node(tx,ty,t.dep+1,t.left,t.right-1));</span><br><span class="line">						visit[tx][ty]=1;</span><br><span class="line">						ans++;</span><br><span class="line">					&#125;</span><br><span class="line">						</span><br><span class="line">					</span><br><span class="line">				&#125;</span><br><span class="line">				else if(3==i) &#123;</span><br><span class="line">					if(t.left&gt;0) &#123;</span><br><span class="line">						qu.push(node(tx,ty,t.dep+1,t.left-1,t.right));</span><br><span class="line">						visit[tx][ty]=1;</span><br><span class="line">						ans++;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">			&#125;</span><br><span class="line">	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	</span><br><span class="line">	ios::sync_with_stdio(false);</span><br><span class="line">	ans=1;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	cin&gt;&gt;r&gt;&gt;c;</span><br><span class="line">	cin&gt;&gt;leftCount&gt;&gt;rightCount;</span><br><span class="line">	for(int i=0;i&lt;n;i++) &#123;</span><br><span class="line">		cin&gt;&gt;str[i];</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	BFS(r-1,c-1,leftCount,rightCount);</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://shann.xyz/2019/09/21/比赛/Codeforces-516-Div. 2/" data-id="ck6luc0em0024kgv9nt46kdt0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/比赛/">比赛</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/09/21/比赛/华为杯-中矿大竞赛-G/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          中矿大-G-毕业生的纪念礼物(map+priority_queue)
        
      </div>
    </a>
  
  
    <a href="/2019/09/21/比赛/The 16th Zhejiang Provincial Collegiate Programming/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">The 16th Zhejiang Provincial Collegiate Programming</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaWeb/">JavaWeb</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/STL/">STL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/">hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/二分-三分-分治/">二分-三分-分治</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/位运算/">位运算</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/动态规划/">动态规划</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/字符串/">字符串</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/并查集/">并查集</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统/">操作系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数学/">数学</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/模板/">模板</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/比赛/">比赛</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/简单搜索/">简单搜索</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/课程设计/">课程设计</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/贪心算法/">贪心算法</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/BFS/">BFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DFS/">DFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HDU/">HDU</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OJ运维/">OJ运维</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/STL/">STL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c-c/">c/c++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gcd/">gcd</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/二分答案/">二分答案</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/优先队列/">优先队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/位运算/">位运算</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/几何/">几何</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/单调栈/">单调栈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/图/">图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/图遍历/">图遍历</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/基本操作/">基本操作</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/基础算法/">基础算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/堆优化prim/">堆优化prim</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/字符串-KMP/">字符串-KMP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/小技巧/">小技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/快速幂/">快速幂</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/思维/">思维</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最小生成树-kruskal/">最小生成树-kruskal</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/枚举/">枚举</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/概率dp/">概率dp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模拟队列/">模拟队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/比赛/">比赛</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/水题/">水题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/笔记/">笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/简单题/">简单题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/线性dp/">线性dp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/组合数/">组合数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/逆元/">逆元</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/面向对象/">面向对象</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/BFS/" style="font-size: 12.86px;">BFS</a> <a href="/tags/DFS/" style="font-size: 15.71px;">DFS</a> <a href="/tags/HDU/" style="font-size: 14.29px;">HDU</a> <a href="/tags/MySQL/" style="font-size: 11.43px;">MySQL</a> <a href="/tags/OJ运维/" style="font-size: 10px;">OJ运维</a> <a href="/tags/STL/" style="font-size: 10px;">STL</a> <a href="/tags/c-c/" style="font-size: 17.14px;">c/c++</a> <a href="/tags/gcd/" style="font-size: 10px;">gcd</a> <a href="/tags/二分答案/" style="font-size: 10px;">二分答案</a> <a href="/tags/优先队列/" style="font-size: 10px;">优先队列</a> <a href="/tags/位运算/" style="font-size: 10px;">位运算</a> <a href="/tags/几何/" style="font-size: 10px;">几何</a> <a href="/tags/单调栈/" style="font-size: 10px;">单调栈</a> <a href="/tags/图/" style="font-size: 11.43px;">图</a> <a href="/tags/图遍历/" style="font-size: 10px;">图遍历</a> <a href="/tags/基本操作/" style="font-size: 10px;">基本操作</a> <a href="/tags/基础算法/" style="font-size: 20px;">基础算法</a> <a href="/tags/堆优化prim/" style="font-size: 10px;">堆优化prim</a> <a href="/tags/字符串-KMP/" style="font-size: 10px;">字符串-KMP</a> <a href="/tags/小技巧/" style="font-size: 11.43px;">小技巧</a> <a href="/tags/快速幂/" style="font-size: 10px;">快速幂</a> <a href="/tags/思维/" style="font-size: 15.71px;">思维</a> <a href="/tags/最小生成树-kruskal/" style="font-size: 10px;">最小生成树-kruskal</a> <a href="/tags/枚举/" style="font-size: 10px;">枚举</a> <a href="/tags/概率dp/" style="font-size: 10px;">概率dp</a> <a href="/tags/模拟队列/" style="font-size: 10px;">模拟队列</a> <a href="/tags/比赛/" style="font-size: 18.57px;">比赛</a> <a href="/tags/水题/" style="font-size: 10px;">水题</a> <a href="/tags/笔记/" style="font-size: 10px;">笔记</a> <a href="/tags/简单题/" style="font-size: 10px;">简单题</a> <a href="/tags/线性dp/" style="font-size: 10px;">线性dp</a> <a href="/tags/组合数/" style="font-size: 10px;">组合数</a> <a href="/tags/逆元/" style="font-size: 10px;">逆元</a> <a href="/tags/面向对象/" style="font-size: 10px;">面向对象</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/02/25/java/Java自定义排序内容/">Java中集合自定义排序（Comparator接口）</a>
          </li>
        
          <li>
            <a href="/2020/02/18/java/Java Web基础/">Java Web基础（Servlet、Cookie、Session、Jsp回顾整理）</a>
          </li>
        
          <li>
            <a href="/2020/02/16/java/Java中类的初始化顺序/">Java中类的初始化顺序</a>
          </li>
        
          <li>
            <a href="/2020/02/09/Spring/springNote/">Spring基础学习</a>
          </li>
        
          <li>
            <a href="/2020/02/04/二分/第二讲 二分与前缀和/">第二讲 二分与前缀和</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 学号021<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>