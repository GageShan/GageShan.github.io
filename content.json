{"meta":{"title":"GageShan's blog","subtitle":null,"description":"谨言慎行，勤思能动","author":"John Doe","url":"http://yoursite.com"},"pages":[{"title":"friends","date":"2018-09-12T14:50:58.000Z","updated":"2018-09-12T15:12:40.289Z","comments":true,"path":"friends/index.html","permalink":"http://yoursite.com/friends/index.html","excerpt":"","text":""},{"title":"about","date":"2018-08-14T12:45:56.000Z","updated":"2018-08-14T13:31:09.123Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"以前不知道喜欢什么所以来到这里现在明白了想要什么未来会去哪里 ————SGZ"},{"title":"tags","date":"2018-09-09T15:47:25.000Z","updated":"2018-09-10T05:58:57.118Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-09-09T15:48:07.000Z","updated":"2018-09-10T05:59:17.344Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"NYOJ465中缀式变后缀式（套题）","slug":"中缀式变后缀式2","date":"2018-09-19T15:47:44.303Z","updated":"2018-09-19T15:47:44.313Z","comments":true,"path":"2018/09/19/中缀式变后缀式2/","link":"","permalink":"http://yoursite.com/2018/09/19/中缀式变后缀式2/","excerpt":"一、题目描述中缀式变后缀式时间限制：1000 ms | 内存限制：65535 KB难度：3描述 人们的日常习惯是把算术表达式写成中缀式，但对于机器来说更“习惯于”后缀式，关于算术表达式的中缀式和后缀式的论述一般的数据结构书都有相关内容可供参看，这里不再赘述，现在你的任务是将中缀式变为后缀式。","text":"一、题目描述中缀式变后缀式时间限制：1000 ms | 内存限制：65535 KB难度：3描述 人们的日常习惯是把算术表达式写成中缀式，但对于机器来说更“习惯于”后缀式，关于算术表达式的中缀式和后缀式的论述一般的数据结构书都有相关内容可供参看，这里不再赘述，现在你的任务是将中缀式变为后缀式。输入第一行输入一个整数n，共有n组测试数据（n&lt;10)。每组测试数据只有一行，是一个长度不超过1000的字符串，表示这个运算式的中缀式，每个运算式都是以“=”结束。这个表达式里只包含+-*/与小括号这几种符号。其中小括号可以嵌套使用。数据保证输入的操作数中不会出现负数。数据保证除数不会为0 输出 每组都输出该组中缀式相应的后缀式，要求相邻的操作数操作符用空格隔开。样例输入12321.000+2/4=((1+2)*5+1)/4= 样例输出121.000 2 4 / + =1 2 + 5 * 1 + 4 / = 二、题解模拟过程点这123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;stdio.h&gt;#include&lt;string.h&gt; #define MAXSIZE 3000struct Stack&#123; char character[MAXSIZE]; int top; int flag[MAXSIZE];&#125;;int main()&#123; int Case; scanf(&quot;%d&quot;,&amp;Case); while(Case--) &#123; char str[MAXSIZE]; char ch[MAXSIZE]; struct Stack stack; int count=0; stack.top=-1; scanf(&quot;%s&quot;,str); for(int i=0;i&lt;strlen(str)-1;i++)&#123; if((str[i]&gt;=&apos;0&apos;&amp;&amp;str[i]&lt;=&apos;9&apos;)||str[i]==&apos;.&apos;)&#123; if((str[i+1]&gt;=&apos;0&apos;&amp;&amp;str[i+1]&lt;=&apos;9&apos;)||str[i+1]==&apos;.&apos;) ch[count++]=str[i]; else&#123; ch[count++]=str[i]; ch[count++]=&apos; &apos;; &#125; &#125; else &#123; switch(str[i])&#123; case &apos;-&apos;: case &apos;+&apos;: if(stack.top==-1)&#123; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=1; &#125; else&#123; if(stack.flag[stack.top]!=3)&#123; if(stack.flag[stack.top]==2)&#123; ch[count++]=stack.character[stack.top]; ch[count++]=&apos; &apos;; stack.top--; &#125; if(stack.flag[stack.top]==1)&#123; ch[count++]=stack.character[stack.top]; ch[count++]=&apos; &apos;; stack.top--; &#125; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=1; &#125; else&#123; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=1; &#125; &#125; break; case &apos;*&apos;: case &apos;/&apos;: if(stack.top==-1)&#123; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=2; &#125; else&#123; if(stack.flag[stack.top]==1||stack.flag[stack.top]==3)&#123; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=2; &#125; else&#123; ch[count++]=stack.character[stack.top]; ch[count++]=&apos; &apos;; stack.top--; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=2; &#125; &#125; break; case &apos;(&apos;: stack.top++; stack.character[stack.top]=&apos;(&apos;; stack.flag[stack.top]=3; break; case &apos;)&apos;: while(stack.character[stack.top]!=&apos;(&apos;)&#123; ch[count++]=stack.character[stack.top]; ch[count++]=&apos; &apos;; stack.top--; &#125; stack.top--; break; &#125; &#125; &#125; while(stack.top!=-1)&#123; ch[count++]=stack.character[stack.top]; ch[count++]=&apos; &apos;; stack.top--; &#125; ch[count++]=&apos;=&apos;; ch[count]=&apos;\\0&apos;; printf(&quot;%s\\n&quot;,ch); &#125; return 0; &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"http://yoursite.com/tags/c-c/"}]},{"title":"NYOJ465中缀式变后缀式（套题）","slug":"数据结构/中缀式变后缀式2","date":"2018-09-19T15:41:38.556Z","updated":"2018-09-19T15:50:50.945Z","comments":true,"path":"2018/09/19/数据结构/中缀式变后缀式2/","link":"","permalink":"http://yoursite.com/2018/09/19/数据结构/中缀式变后缀式2/","excerpt":"一、题目描述中缀式变后缀式时间限制：1000 ms | 内存限制：65535 KB难度：3描述 人们的日常习惯是把算术表达式写成中缀式，但对于机器来说更“习惯于”后缀式，关于算术表达式的中缀式和后缀式的论述一般的数据结构书都有相关内容可供参看，这里不再赘述，现在你的任务是将中缀式变为后缀式。","text":"一、题目描述中缀式变后缀式时间限制：1000 ms | 内存限制：65535 KB难度：3描述 人们的日常习惯是把算术表达式写成中缀式，但对于机器来说更“习惯于”后缀式，关于算术表达式的中缀式和后缀式的论述一般的数据结构书都有相关内容可供参看，这里不再赘述，现在你的任务是将中缀式变为后缀式。输入第一行输入一个整数n，共有n组测试数据（n&lt;10)。每组测试数据只有一行，是一个长度不超过1000的字符串，表示这个运算式的中缀式，每个运算式都是以“=”结束。这个表达式里只包含+-*/与小括号这几种符号。其中小括号可以嵌套使用。数据保证输入的操作数中不会出现负数。数据保证除数不会为0 输出 每组都输出该组中缀式相应的后缀式，要求相邻的操作数操作符用空格隔开。样例输入12321.000+2/4=((1+2)*5+1)/4= 样例输出121.000 2 4 / + =1 2 + 5 * 1 + 4 / = 二、题解模拟过程点这123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;stdio.h&gt;#include&lt;string.h&gt; #define MAXSIZE 3000struct Stack&#123; char character[MAXSIZE]; int top; int flag[MAXSIZE];&#125;;int main()&#123; int Case; scanf(&quot;%d&quot;,&amp;Case); while(Case--) &#123; char str[MAXSIZE]; char ch[MAXSIZE]; struct Stack stack; int count=0; stack.top=-1; scanf(&quot;%s&quot;,str); for(int i=0;i&lt;strlen(str)-1;i++)&#123; if((str[i]&gt;=&apos;0&apos;&amp;&amp;str[i]&lt;=&apos;9&apos;)||str[i]==&apos;.&apos;)&#123; if((str[i+1]&gt;=&apos;0&apos;&amp;&amp;str[i+1]&lt;=&apos;9&apos;)||str[i+1]==&apos;.&apos;) ch[count++]=str[i]; else&#123; ch[count++]=str[i]; ch[count++]=&apos; &apos;; &#125; &#125; else &#123; switch(str[i])&#123; case &apos;-&apos;: case &apos;+&apos;: if(stack.top==-1)&#123; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=1; &#125; else&#123; if(stack.flag[stack.top]!=3)&#123; if(stack.flag[stack.top]==2)&#123; ch[count++]=stack.character[stack.top]; ch[count++]=&apos; &apos;; stack.top--; &#125; if(stack.flag[stack.top]==1)&#123; ch[count++]=stack.character[stack.top]; ch[count++]=&apos; &apos;; stack.top--; &#125; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=1; &#125; else&#123; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=1; &#125; &#125; break; case &apos;*&apos;: case &apos;/&apos;: if(stack.top==-1)&#123; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=2; &#125; else&#123; if(stack.flag[stack.top]==1||stack.flag[stack.top]==3)&#123; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=2; &#125; else&#123; ch[count++]=stack.character[stack.top]; ch[count++]=&apos; &apos;; stack.top--; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=2; &#125; &#125; break; case &apos;(&apos;: stack.top++; stack.character[stack.top]=&apos;(&apos;; stack.flag[stack.top]=3; break; case &apos;)&apos;: while(stack.character[stack.top]!=&apos;(&apos;)&#123; ch[count++]=stack.character[stack.top]; ch[count++]=&apos; &apos;; stack.top--; &#125; stack.top--; break; &#125; &#125; &#125; while(stack.top!=-1)&#123; ch[count++]=stack.character[stack.top]; ch[count++]=&apos; &apos;; stack.top--; &#125; ch[count++]=&apos;=&apos;; ch[count]=&apos;\\0&apos;; printf(&quot;%s\\n&quot;,ch); &#125; return 0; &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"http://yoursite.com/tags/c-c/"}]},{"title":"NYOJ257中缀式变后缀式","slug":"数据结构/中缀式变后缀式","date":"2018-09-17T06:04:47.021Z","updated":"2018-09-17T06:05:46.882Z","comments":true,"path":"2018/09/17/数据结构/中缀式变后缀式/","link":"","permalink":"http://yoursite.com/2018/09/17/数据结构/中缀式变后缀式/","excerpt":"一、题目描述郁闷的C小加（一）时间限制：1000 ms | 内存限制：65535 KB难度：3描述 我们熟悉的表达式如a+b、a+b(c+d)等都属于中缀表达式。中缀表达式就是（对于双目运算符来说）操作符在两个操作数中间：num1 operand num2。同理，后缀表达式就是操作符在两个操作数之后：num1 num2 operand。ACM队的“C小加”正在郁闷怎样把一个中缀表达式转换为后缀表达式，现在请你设计一个程序，帮助C小加把中缀表达式转换成后缀表达式。为简化问题，操作数均为个位数，操作符只有+-/ 和小括号。","text":"一、题目描述郁闷的C小加（一）时间限制：1000 ms | 内存限制：65535 KB难度：3描述 我们熟悉的表达式如a+b、a+b(c+d)等都属于中缀表达式。中缀表达式就是（对于双目运算符来说）操作符在两个操作数中间：num1 operand num2。同理，后缀表达式就是操作符在两个操作数之后：num1 num2 operand。ACM队的“C小加”正在郁闷怎样把一个中缀表达式转换为后缀表达式，现在请你设计一个程序，帮助C小加把中缀表达式转换成后缀表达式。为简化问题，操作数均为个位数，操作符只有+-/ 和小括号。输入第一行输入T，表示有T组测试数据（T&lt;10）。每组测试数据只有一行，是一个长度不超过1000的字符串，表示这个表达式。这个表达式里只包含+-*/与小括号这几种符号。其中小括号可以嵌套使用。数据保证输入的操作数中不会出现负数。并且输入数据不会出现不匹配现象。 输出 每组输出都单独成行，输出转换的后缀表达式。 样例输入12321+2(1+2)*3+4*5 样例输出1212+12+3*45*+ 二、题解本题可以用栈来解决。设置运算符的优先级，本题中令+、-的优先级为1，*、/的优先级为2，(的优先级为3。遍历字符串，若发现运算符，将其优先级与栈首元素优先级比较，（如果栈为空直接进栈），若大于则该运算符进栈，若小于且栈首不为’(‘将栈首元素出栈然后将其进栈，若栈首为’(‘，无论何运算符，进栈。若遍历到’)’，则将栈中元素出栈直到栈首为’(‘，最后把’(‘出栈。遍历完字符串，若栈不为空，将栈中元素全部出栈。代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;stdio.h&gt;#include&lt;string.h&gt; #define MAXSIZE 3000struct Stack&#123; char character[MAXSIZE]; int top; int flag[MAXSIZE];//优先级&#125;;int main()&#123; int Case; scanf(&quot;%d&quot;,&amp;Case); while(Case--) &#123; char str[MAXSIZE]; char ch[MAXSIZE]; struct Stack stack; int count=0; stack.top=-1; scanf(&quot;%s&quot;,str); for(int i=0;i&lt;strlen(str);i++)&#123; if(str[i]&gt;=&apos;0&apos;&amp;&amp;str[i]&lt;=&apos;9&apos;) ch[count++]=str[i]; else &#123; switch(str[i])&#123; case &apos;-&apos;: case &apos;+&apos;: if(stack.top==-1)&#123; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=1; &#125; else&#123; if(stack.flag[stack.top]!=3)&#123; if(stack.flag[stack.top]==2)&#123; ch[count++]=stack.character[stack.top]; stack.top--; &#125; if(stack.flag[stack.top]==1)&#123; ch[count++]=stack.character[stack.top]; stack.top--; &#125; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=1; &#125; else&#123; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=1; &#125; &#125; break; case &apos;*&apos;: case &apos;/&apos;: if(stack.top==-1)&#123; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=2; &#125; else&#123; if(stack.flag[stack.top]==1||stack.flag[stack.top]==3)&#123; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=2; &#125; else&#123; ch[count++]=stack.character[stack.top]; stack.top--; stack.top++; stack.character[stack.top]=str[i]; stack.flag[stack.top]=2; &#125; &#125; break; case &apos;(&apos;: stack.top++; stack.character[stack.top]=&apos;(&apos;; stack.flag[stack.top]=3; break; case &apos;)&apos;: while(stack.character[stack.top]!=&apos;(&apos;)&#123; ch[count++]=stack.character[stack.top]; stack.top--; &#125; stack.top--; break; &#125; &#125; &#125; while(stack.top!=-1)&#123; ch[count++]=stack.character[stack.top]; stack.top--; &#125; ch[count]=&apos;\\0&apos;; printf(&quot;%s\\n&quot;,ch); &#125; return 0; &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"http://yoursite.com/tags/c-c/"}]},{"title":"NYOJ305另类表达式求值（栈）","slug":"数据结构/另类表达式求解","date":"2018-09-15T08:35:59.739Z","updated":"2018-09-15T08:40:24.404Z","comments":true,"path":"2018/09/15/数据结构/另类表达式求解/","link":"","permalink":"http://yoursite.com/2018/09/15/数据结构/另类表达式求解/","excerpt":"一、题目描述表达式求值时间限制：3000 ms | 内存限制：65535 KB难度：3描述 Dr.Kong设计的机器人卡多掌握了加减法运算以后，最近又学会了一些简单的函数求值，比如，它知道函数min(20,23)的值是20 ，add(10,98) 的值是108等等。经过训练，Dr.Kong设计的机器人卡多甚至会计算一种嵌套的更复杂的表达式。假设表达式可以简单定义为:","text":"一、题目描述表达式求值时间限制：3000 ms | 内存限制：65535 KB难度：3描述 Dr.Kong设计的机器人卡多掌握了加减法运算以后，最近又学会了一些简单的函数求值，比如，它知道函数min(20,23)的值是20 ，add(10,98) 的值是108等等。经过训练，Dr.Kong设计的机器人卡多甚至会计算一种嵌套的更复杂的表达式。假设表达式可以简单定义为: 一个正的十进制数 x 是一个表达式。 如果 x 和 y 是 表达式，则 函数min(x,y )也是表达式,其值为x,y 中的最小数。 如果 x 和 y 是 表达式，则 函数max(x,y )也是表达式,其值为x,y 中的最大数。 如果 x 和 y 是 表达式，则 函数add(x,y )也是表达式,其值为x,y 之和。例如， 表达式 max(add(1,2),7) 的值为 7。请你编写程序，对于给定的一组表达式，帮助 Dr.Kong 算出正确答案，以便校对卡多计算的正误。 输入 第一行： N 表示要计算的表达式个数 （1≤ N ≤ 10）接下来有N行， 每行是一个字符串，表示待求值的表达式（表达式中不会有多余的空格，每行不超过300个字符，表达式中出现的十进制数都不超过1000。） 输出 输出有N行，每一行对应一个表达式的值。 样例输入123add(1,2) max(1,999) add(min(1,1000),add(100,99)) 样例输出1233999200 二、题解本题是栈应用的类型。首先定义两个栈，一个用来存放运算符（记为栈1），一个用来存放待计算的数据（记为栈2）。从字符串首开始遍历直到尾部，若发现add串（在这里我们只需要识别字符a和字符d），则表示需要求和，将其存入栈1中。若发现min串、max串继续存放。若遍历到的是数字，则存入栈2，需要注意的是，由于输入的是字符串，在识别数据就要小心了。比如识别 47，首先识别到4，这时候可以发现后面还跟着7，4是十位上的数，7是各位上的数，如果在识别是不能处理，那么4就会被单独当成一个数存入栈2中，7也如此。具体看代码。举例add(min(1,1000),add(100,99))1、字符串遍历，到add处，将其进栈1，用“加”代替，那么这时候栈1：加-&gt;null;2、遍历到min，将其精栈1，用“小”代替，栈1：加-&gt;小-&gt;null；3、遍历到1，通过处理将得到的数字进栈2，栈2：1-&gt;null;4、遍历到1000串，处理得到1000进栈2，栈2：1-&gt;1000-&gt;null;5、遍历到），说明此时需要计算数据了，查看栈1栈首的元素，发现此时为小，表明前面两个数据需要比较大小求得较小的数据，拿栈2中栈首元素与次首元素比较，就是1和1000比较得到1，栈2退栈一位，此时栈2：1-&gt;null；将比较得到的数据赋给栈首元素，那么栈2：1-&gt;null；处理完栈2，发现刚才栈1中的栈首得到了应用，将其退栈一位，栈1：加-&gt;null；6、遍历到add处，用“加”代替，进栈，栈1：加-&gt;加-&gt;null;7、接着遍历100，99，分别将他们进栈2，此时栈2：1-&gt;100-&gt;99-&gt;null；8、遍历到），计算数据，栈1中栈首元素为加，则栈2中100和99相加的199，退栈，赋值。栈2：1-&gt;199-&gt;null。栈1退栈一位；9、遍历到），计算数据，栈1中栈首元素为加，则栈2中1和199相加的199，退栈，赋值。栈2：200-&gt;null。栈1退栈一位；10、200为表达式值。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#define MAXSIZE 300+10struct Stack1&#123; int flag[MAXSIZE]; int top;&#125;;struct Stack2&#123; int number[MAXSIZE]; int top;&#125;;double calculate(char str[]);int main()&#123; int Case; scanf(&quot;%d&quot;,&amp;Case); while(Case--)&#123; char str[MAXSIZE]; scanf(&quot;%s&quot;,str); double ans=calculate(str); printf(&quot;%.0lf\\n&quot;,ans); &#125; return 0;&#125;double calculate(char str[])&#123; struct Stack1 stack1; //字符栈 struct Stack2 stack2; //数字栈 stack1.top=stack2.top=-1; int value=0; for(int i=0;i&lt;strlen(str);i++)&#123; if(str[i]==&apos;a&apos;&amp;&amp;str[i-1]!=&apos;m&apos;)&#123;//避免与求最大值的max区分开 value=0; stack1.top++; stack1.flag[stack1.top]=1; &#125; if(str[i]==&apos;m&apos;)&#123; value=0; stack1.top++; if(str[i+1]==&apos;i&apos;) stack1.flag[stack1.top]=2;//判断求最小值 else if(str[i+2]==&apos;x&apos;) stack1.flag[stack1.top]=3;//判断求最大值 &#125; if(str[i]==&apos;,&apos;) value=0; if(str[i]&gt;=&apos;0&apos;&amp;&amp;str[i]&lt;=&apos;9&apos;)&#123; if(str[i-1]&gt;=&apos;0&apos;&amp;&amp;str[i]&lt;=&apos;9&apos;)&#123; value=value*10+str[i]-48; &#125; else&#123; value=str[i]-48;//字符转数字 &#125; if(str[i+1]&lt;&apos;0&apos;||str[i+1]&gt;&apos;9&apos;)&#123; stack2.top++; stack2.number[stack2.top]=value; &#125; &#125; int temp=0; if(str[i]==&apos;)&apos;)&#123; value=0; switch(stack1.flag[stack1.top])&#123; case 1: temp=stack2.number[stack2.top]+stack2.number[stack2.top-1]; stack2.top--; stack2.number[stack2.top]=temp; break; case 2: if(stack2.number[stack2.top]&gt;=stack2.number[stack2.top-1]) stack2.top--; else&#123; temp=stack2.number[stack2.top]; stack2.top--; stack2.number[stack2.top]=temp; &#125; break; case 3: if(stack2.number[stack2.top]&lt;=stack2.number[stack2.top-1]) stack2.top--; else&#123; temp=stack2.number[stack2.top]; stack2.top--; stack2.number[stack2.top]=temp; &#125; &#125; stack1.top--; &#125; &#125; return double(stack2.number[stack2.top]); &#125; 继续补题ing…","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"http://yoursite.com/tags/c-c/"}]},{"title":"走迷宫（迷宫问题补题）","slug":"数据结构/走迷宫","date":"2018-09-14T15:22:22.908Z","updated":"2018-09-14T15:26:45.804Z","comments":true,"path":"2018/09/14/数据结构/走迷宫/","link":"","permalink":"http://yoursite.com/2018/09/14/数据结构/走迷宫/","excerpt":"一、题目描述 一个迷宫由R行C列格子组成，有的格子里有障碍物，不能走；有的格子是空地，可以走。给定一个迷宫，求从左上角走到右下角最少需要走多少步(数据保证一定能走到)。只能在水平方向或垂直方向走，不能斜着走。Input第一行是两个整数，Ｒ和Ｃ，代表迷宫的长和宽。（ 1&lt;= R，C &lt;= 40)接下来是Ｒ行，每行Ｃ个字符，代表整个迷宫。","text":"一、题目描述 一个迷宫由R行C列格子组成，有的格子里有障碍物，不能走；有的格子是空地，可以走。给定一个迷宫，求从左上角走到右下角最少需要走多少步(数据保证一定能走到)。只能在水平方向或垂直方向走，不能斜着走。Input第一行是两个整数，Ｒ和Ｃ，代表迷宫的长和宽。（ 1&lt;= R，C &lt;= 40)接下来是Ｒ行，每行Ｃ个字符，代表整个迷宫。空地格子用’.’表示，有障碍物的格子用’#’表示。迷宫左上角和右下角都是’.’。Output输出从左上角走到右下角至少要经过多少步（即至少要经过多少个空地格子）。计算步数要包括起点和终点。 样列输入1234565 5..####....#.#.##.#.##.#.. 样列输出19 二、题解本题方法跟前一篇写的《迷宫求解》队列实现方法一致，传送门需要注意的是二维字符数组的输入问题，可以单个字符的输入，但这就要考虑回车键对数组的影响；而采用字符串形式输入则不会有这个问题，具体见代码。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt;const int MAXSIZE=10000+10;struct Box&#123; int i; int j; int pre;&#125;;struct Type&#123; struct Box data[MAXSIZE]; int front,rear;&#125;;const int LEN=sizeof(struct Type);int findRoad(int a,int b,int c,int d,char mg[42][42]);int main()&#123; char mg[42][42],mgtemp[42][42]; int N,M; scanf(&quot;%d%d&quot;,&amp;N,&amp;M); for(int i=1;i&lt;=N;i++)&#123; scanf(&quot;%s&quot;,mgtemp[i]); //采用临时数组，注意列行从0开始而不是需要的从1开始 &#125; for(int i=1;i&lt;=N;i++)&#123; int t=1; for(int j=0;j&lt;M;j++) mg[i][t++]=mgtemp[i][j];//用此转换 &#125; int ans=findRoad(1,1,N,M,mg); printf(&quot;%d\\n&quot;,ans); return 0; &#125; int findRoad(int a,int b,int c,int d,char mg[42][42])&#123; Box e; struct Type *queue; queue=(struct Type *)malloc(LEN); queue-&gt;front=queue-&gt;rear=-1; int i,j; e.i=a;e.j=b;e.pre=-1; mg[a][b]=&apos;/&apos;; queue-&gt;rear++; queue-&gt;data[queue-&gt;rear]=e; while(queue-&gt;rear!=queue-&gt;front)&#123; queue-&gt;front++; e=queue-&gt;data[queue-&gt;front]; i=e.i;j=e.j; if(i==c&amp;&amp;j==d)&#123; int temp=queue-&gt;front; while(temp!=0)&#123; int num=queue-&gt;data[temp].pre; queue-&gt;data[temp].pre=-1; temp=num; &#125; temp=0; int count=0; while(temp&lt;=queue-&gt;front)&#123; if(queue-&gt;data[temp].pre==-1) count++; temp++; &#125; return count; &#125; int x,y; for(int k=0;k&lt;4;k++)&#123; switch(k)&#123; case 0: x=i-1;y=j;break; case 1: x=i;y=j+1;break; case 2: x=i+1;y=j;break; case 3: x=i;y=j-1;break; &#125; if(mg[x][y]==&apos;.&apos;)&#123; e.i=x;e.j=y;e.pre=queue-&gt;front; queue-&gt;rear++; queue-&gt;data[queue-&gt;rear]=e; mg[x][y]=&apos;/&apos;; &#125; &#125; &#125;&#125; 继续补题ing…","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"http://yoursite.com/tags/c-c/"}]},{"title":"迷宫求解","slug":"数据结构/迷宫求解","date":"2018-09-13T15:51:59.612Z","updated":"2018-09-14T15:27:38.129Z","comments":true,"path":"2018/09/13/数据结构/迷宫求解/","link":"","permalink":"http://yoursite.com/2018/09/13/数据结构/迷宫求解/","excerpt":"想不到迷宫求解还困惑我这么久久久？搞清楚了吧？做下笔记防止遗忘？去补点题？let’s go! 一、问题描述给定一个10*10的迷宫图，求一条从指定路口到指定出口的路径。在这里可以定义一个二维数组，用0来代表迷宫路径可走，用1代表路径不可走。迷宫问题可以用两种数据结构来解决（我暂时只会两种，囧rz），分别为栈、队列。栈只能简单地求出从指定路口到制定出口的路径，也就是说并不能考虑路径长短问题；而用队列来求解的话，可以求出一条最短路径。","text":"想不到迷宫求解还困惑我这么久久久？搞清楚了吧？做下笔记防止遗忘？去补点题？let’s go! 一、问题描述给定一个10*10的迷宫图，求一条从指定路口到指定出口的路径。在这里可以定义一个二维数组，用0来代表迷宫路径可走，用1代表路径不可走。迷宫问题可以用两种数据结构来解决（我暂时只会两种，囧rz），分别为栈、队列。栈只能简单地求出从指定路口到制定出口的路径，也就是说并不能考虑路径长短问题；而用队列来求解的话，可以求出一条最短路径。 二、栈实现1、解决方案说实话，不喜欢用栈来求解，耗时耗力还得不到最优解。就这样吧。从指定路口开始，将指定入口入栈。然后查找与栈头相邻且可走的路口。需要说明是首先要制定一个选择路口的方案，不然计算机怎么知道往哪走呢？我选择的是顺时针查看，即先查看上再右其次下最后左方。若找到，则将其入栈，在这里有一个非常关键的地方，就是需要记住处于栈头相对于前一个路口的方位值，所谓方位值，简单来讲，用0代表上，1代表右，2代表下，3代表左。接着再次查找相邻可走路口。为避免查找到的路口是已经走过的，在设计程序的时候，每一个路口入栈后，都将该路口的状态改变，比如，前面用0代表路径可走，那么可以设置入栈的入口状态值为-1，为区分起始条件不可走的状态值1。若没有找到，也就是说处于当前路口时，上下左右都不可走，不要怕，退一步。退一步就是退回到上一路口。那么整个栈中的元素就是从入口到出口的迷宫路径了。如此直到找到出口，若没有出口，就。。。 2、代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define MAXSIZE 10000int mg[10][10]=&#123; //迷宫数组 &#123;1,1,1,1,1,1,1,1,1,1&#125;, &#123;1,0,0,1,0,0,0,1,0,1&#125;, &#123;1,0,0,1,0,0,0,1,0,1&#125;, &#123;1,0,0,0,0,1,1,0,0,1&#125;, &#123;1,0,1,1,1,0,0,0,0,1&#125;, &#123;1,0,0,0,1,0,0,0,0,1&#125;, &#123;1,0,1,0,0,0,1,0,0,1&#125;, &#123;1,0,1,1,1,0,1,1,0,1&#125;, &#123;1,1,0,0,0,0,0,0,0,1&#125;, &#123;1,1,1,1,1,1,1,1,1,1&#125; &#125;;struct Box&#123; int i; int j; int di; //表示方位值&#125;;struct Type&#123; struct Box data[MAXSIZE]; int top;&#125;;bool findRode(int m,int n,int it,int yt);int main()&#123; if(findRode(1,1,8,8)==false) printf(&quot;failed\\n&quot;); return 0;&#125;bool findRode(int m,int n,int it,int yt)&#123; int i,j,di,k=0; Box e; struct Type *stack; stack=(struct Type *)malloc(sizeof(struct Type)); stack-&gt;top=-1; e.i=m;e.j=n;e.di=0; stack-&gt;top++; //将第一个路口入栈 stack-&gt;data[stack-&gt;top]=e; mg[e.i][e.j]=-1; while(stack-&gt;top!=-1)&#123; e=stack-&gt;data[stack-&gt;top]; i=e.i;j=e.j;k=e.di; if(i==it&amp;&amp;j==yt)&#123; while(stack-&gt;top!=-1)&#123; e=stack-&gt;data[stack-&gt;top]; printf(&quot;(%d,%d) &quot;,e.i,e.j); mg[e.i][e.j]=0; stack-&gt;top--; &#125; free(stack); return true; &#125; bool find=false; while(k&lt;4&amp;&amp;find!=true)&#123; k++; switch(k)&#123; case 0: i=e.i-1;j=e.j;break; case 1: i=e.i;j=e.j+1;break; case 2: i=e.i+1;j=e.j;break; case 3: i=e.i;j=e.j-1;break; &#125; if(mg[i][j]==0) find=true; &#125; if(k&lt;4)&#123; stack-&gt;data[stack-&gt;top].di=k; e.i=i;e.j=j;e.di=-1; stack-&gt;top++; stack-&gt;data[stack-&gt;top]=e; mg[i][j]=-1; &#125;else&#123; //如果当前路口没有相邻可走且不是出口，则退栈回到上一路口 stack-&gt;top--; mg[e.i][e.j]=0; //将该路口状态值重置，表示可走 &#125; &#125; free(stack); return false;&#125; 三、队列实现1、解决方案为什么说用队列来解可以求得最短路径呢？与栈不同的是，队列在查看相邻可走路口时，是将全部相邻可走路口进队；首先将入口进队，队列中就记录下该路口的信息了。将队首元素出队，（注意此时队伍中还记录有路口的信息），以该路口为中心查看相邻路口，使全部相邻可走路口记下该路口在队列中的位置，然后将它们进队。比如起点为A，进队。此时队列为A-&gt;NULL；此时A在队列中的位置就是0（记0是开始），出队，B、C、D是A的相邻可走路口，则B、C、D的前导值就是0，通过查询前导值，就可以清楚地知道A的位置（说明下，第一个路口的前导值记为-1）。此时队列为a-&gt;B-&gt;C-&gt;D-&gt;NULL；（A已出队，但A的信息保留着，所以用a代替）注意队首为B（B在队列中的位置是1），然后将B出队，执行与出队A类似的步骤。直到找到出口。找到出口后，那么通过出口的前导值可以知道它前面的路口（记为M）在哪（将M在队列中的状态值记为-1，后面皆是如此），通过M的前导值又可以知道M前面的路口在哪，直到与入口联系起来。从队首信息开始扫描整个队列，若队列中的元素的状态值为-1，则将该元素记录的坐标输出。求解完成。 2、代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define MAXSIZE 10000#define LEN sizeof(struct Type )int mg[10][10]=&#123; &#123;1,1,1,1,1,1,1,1,1,1&#125;, &#123;1,0,0,1,0,0,0,1,0,1&#125;, &#123;1,0,0,1,0,0,0,1,0,1&#125;, &#123;1,0,0,0,0,1,1,0,0,1&#125;, &#123;1,0,1,1,1,0,0,0,0,1&#125;, &#123;1,0,0,0,1,0,0,0,0,1&#125;, &#123;1,0,1,0,0,0,1,0,0,1&#125;, &#123;1,0,1,1,1,0,1,1,0,1&#125;, &#123;1,1,0,0,0,0,0,0,0,1&#125;, &#123;1,1,1,1,1,1,1,1,1,1&#125; &#125;;struct Box&#123; int i; int j; int pre;//记录上一路口的前导值,所谓前导值，就是可走路口在队列中的位置&#125;;struct Type&#123; struct Box data[MAXSIZE]; int front,rear;&#125;;bool findRoad(int m,int n,int it,int yt);int main()&#123; if(findRoad(1,1,8,8)==false) printf(&quot;failed\\n&quot;); return 0;&#125;bool findRoad(int m,int n,int it,int yt)&#123; int i,j; Box e; struct Type *queue; queue=(struct Type *)malloc(LEN); e.i=m;e.j=n;e.pre=-1; queue-&gt;front=queue-&gt;rear=-1; queue-&gt;rear++; queue-&gt;data[queue-&gt;rear]=e; mg[e.i][e.j]=-1; while(queue-&gt;rear!=queue-&gt;front)&#123; queue-&gt;front++; e=queue-&gt;data[queue-&gt;front]; i=e.i;j=e.j; if(i==it&amp;&amp;j==yt)&#123; int temp=queue-&gt;front; int num=0; while(temp!=0)&#123; num=queue-&gt;data[temp].pre; queue-&gt;data[temp].pre=-1; temp=num; &#125; temp=0; int count=1; while(temp&lt;=queue-&gt;rear)&#123; if(queue-&gt;data[temp].pre==-1)&#123; printf(&quot;(%d,%d)&quot;,queue-&gt;data[temp].i,queue-&gt;data[temp].j); if(count%5==0) printf(&quot;\\n&quot;); count++; &#125; temp++; &#125; return true; &#125; int x,y; int k=0; while(k&lt;4)&#123; switch(k)&#123; case 0: x=i-1;y=j;break; case 1: x=i;y=j+1;break; case 2: x=i+1;y=j;break; case 3: x=i;y=j-1;break; &#125; k++; if(mg[x][y]==0)&#123; /*只要该路口可走，就将其进队 *并且记录上一路口的前导值 */ queue-&gt;rear++; e.i=x;e.j=y;e.pre=queue-&gt;front; queue-&gt;data[queue-&gt;rear]=e; mg[i][j]=-1; &#125; &#125; &#125; return false;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"http://yoursite.com/tags/c-c/"}]},{"title":"统计磁盘文件数量（c#实现）","slug":"C#/统计磁盘文件数","date":"2018-09-11T15:34:59.406Z","updated":"2018-09-11T23:14:36.260Z","comments":true,"path":"2018/09/11/C#/统计磁盘文件数/","link":"","permalink":"http://yoursite.com/2018/09/11/C#/统计磁盘文件数/","excerpt":"一、想法想到能不能写一个小程序用来统计磁盘中有多少个文件呢？虽然系统可以统计出来，但如果自己也可以写出来会不会更舒服，而且这也可以作为c#实践的练手玩具啊啊啊啊？想到了就去做？让我造个轮子出来吧，orz。 二、原理编译环境：Visual Studio 2017页面控件： Button、Label、TextBox、ListBox应用项目：.NET Framework","text":"一、想法想到能不能写一个小程序用来统计磁盘中有多少个文件呢？虽然系统可以统计出来，但如果自己也可以写出来会不会更舒服，而且这也可以作为c#实践的练手玩具啊啊啊啊？想到了就去做？让我造个轮子出来吧，orz。 二、原理编译环境：Visual Studio 2017页面控件： Button、Label、TextBox、ListBox应用项目：.NET Framework解决方案：1、首先识别磁盘第一层（就是点开磁盘后所显示的）中有多少文件夹2、然后从上往下从第一个文件夹（记为文件夹A）开始识别，若文件夹A中还有若干个子文件夹，则又从第一个子文件夹开始识别3、接2，直到文件夹里没有其他子文件夹了，则开始统计文件的数量 4、接3，统计完当前文件夹里的文件后，返回上一层，也就是与当前文件夹处于同一层。这就是递归处理了，以前写过，递归算法不要深究，逻辑对递归一定对。注意事项：在用到GetDirectories方法时，要在命名空间添加1using System.IO; 使用截图: 三、实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657using System;using System.Collections.Generic;using System.ComponentModel;using System.Data;using System.Drawing;using System.Linq;using System.Text;using System.Threading.Tasks;using System.IO;using System.Windows.Forms;namespace 小轮子之统计文件数&#123; public partial class Form1 : Form &#123; public Form1() &#123; InitializeComponent(); &#125; private void PathName_TextChanged(object sender, EventArgs e) &#123; /*吃好睡好身体好*/ &#125; private void button1_Click(object sender, EventArgs e) &#123; MessageBox.Show(&quot;统计中，请耐心等待...&quot;); string str = PathName.Text.ToString(); long count = GetFiles(str); MessageBox.Show(count.ToString(), &quot;共有文件数&quot;); &#125; static long GetFiles(string path) &#123; long count = 0L; try &#123; var files = Directory.GetFiles(path); count += files.Length; var dirs = Directory.GetDirectories(path); foreach (var dir in dirs) &#123; count += GetFiles(dir);//递归实现深度查找 &#125; &#125; catch (Exception e) &#123; /* 欲渡黄河冰塞川 * 将登太行雪满山 * 闲来垂钓碧溪上 * 忽复乘舟梦日边 */ &#125; return count; &#125; &#125;&#125;","categories":[{"name":"c#","slug":"c","permalink":"http://yoursite.com/categories/c/"}],"tags":[{"name":"小轮子","slug":"小轮子","permalink":"http://yoursite.com/tags/小轮子/"}]},{"title":"c#中try catch finally用法","slug":"C#/C#中try catch finally用法","date":"2018-09-09T15:19:35.884Z","updated":"2018-09-11T04:30:10.584Z","comments":true,"path":"2018/09/09/C#/C#中try catch finally用法/","link":"","permalink":"http://yoursite.com/2018/09/09/C#/C#中try catch finally用法/","excerpt":"一、处理机制1、基本语法123456789101112try&#123; //语句&#125;catch&#123; //语句&#125;finally&#123; //语句&#125;","text":"一、处理机制1、基本语法123456789101112try&#123; //语句&#125;catch&#123; //语句&#125;finally&#123; //语句&#125; try：将可能产生异常的代码块放到try中，这一语句在整个异常处理中不可缺少catch：如果try中的代码出现了异常，则在这一块中需给出异常处理程序，提示使用者出现了怎样的问题。这一语句与下面的finally语句两者必须有一个，可以都有，若两者都有，finally语句在最后。当然这一语句可以有多条，用以处理不同的代码异常。这里还要指出的是catch语句抓取异常分为三种形式。 1、catch{…..代码…..} 一般形式，这样的子句将抓取任何try中出现的异常2、catch(Exception){…..代码…..} 特定形式，这样的子句抓取try中与Exception匹配的异常3、catch(Exception e){…..代码…..} 带对象的特定形式，其中e为异常变量，在这里可以该异常变量并获得与其相关得信息 如123456catch (Exception e)&#123; Console.WriteLine(&quot;Message:&#123;0&#125;&quot;, e.Message); Console.WriteLine(&quot;Source:&#123;0&#125;&quot;, e.Source); Console.WriteLine(&quot;Stack:&#123;0&#125;&quot;, e.StackTrace);&#125; finally：这一语句如果出现，则不管try语句中是否出现异常，finally包涵的代码都要执行，在这里特别要说明得是即使try语块中有return语句，finally块中得语句也要先执行完然后才能执行return语句。如：123456789101112131415try&#123; var number = 5; if (number &lt;= 10) &#123; Console.WriteLine(&quot;天生我材必有用&quot;); return; &#125; else Console.WriteLine(&quot;人生得意须尽欢&quot;);&#125;finally&#123; Console.WriteLine(&quot;千金散尽还复来&quot;);&#125; 2、异常代码示例我们都知道，被除数不能为0。那么要一个数除以0会发生什么情况呢？如没有异常处理机制，程序会直接中断，俗称的程序崩了或者说“闪退”？但如有，就不会发生这种情况了，程序会提示使用者哪里哪里出现了什么什么问题，提示之后程序继续运行。无处理机制：12345678910111213namespace 验证try_catch&#123; class Program &#123; static void Main(string[] args) &#123; var number1 = 10; var number2 = 0; number1 /= number2; //程序运行到这里会报错 Console.WriteLine(number1); &#125; &#125; &#125; 有处理机制：1234567891011121314151617181920namespace 验证try_catch&#123; class Program &#123; static void Main(string[] args) &#123; try &#123; var number1 = 10; var number2 = 0; number1 /= number2;//抛出异常 Console.WriteLine(number1); &#125; catch //抓住异常 &#123; Console.WriteLine(&quot;There has an error --Keep on running!&quot;); &#125; &#125; &#125;&#125; 3、小结12345678910111213141516try&#123; //可能出现异常得代码放入其中&#125;catch&#123; //抓取异常并提示信息&#125;catch&#123; //可以有多个catch语块用来抓取不同得异常&#125;finally&#123; //只要有该语块则一定要执行且在&#125; 二、解读try catch程序123456789101112131415161718192021222324252627282930313233343536373839404142using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace 验证try_catch&#123; class Program &#123; private static void PrintString(string str) &#123; if (str == null) throw new ArgumentException();//抛出异常 &#125; static void Main(string[] args) &#123; string str = null; try &#123; PrintString(str); &#125; catch (ArgumentException e) &#123; /*抓住来自PrintString函数抛来的异常 e为异常变量，通过打印与之相关得信息我们可以知道程序出现了什么问题 */ Console.WriteLine(&quot;Message:&#123;0&#125;&quot;,e.Message); &#125; catch(Exception) &#123; Console.WriteLine(&quot;今朝有酒今朝醉&quot;); &#125; finally &#123; Console.WriteLine(&quot;知我者谓我心忧，不知我者谓我何求&quot;); &#125; Console.ReadLine(); &#125; &#125;&#125;","categories":[{"name":"c#","slug":"c","permalink":"http://yoursite.com/categories/c/"}],"tags":[{"name":"编程实验","slug":"编程实验","permalink":"http://yoursite.com/tags/编程实验/"}]},{"title":"语言熟练之计算器（c#实现）","slug":"C#/语言熟练之计算器","date":"2018-09-08T12:59:18.479Z","updated":"2018-09-09T01:49:41.139Z","comments":true,"path":"2018/09/08/C#/语言熟练之计算器/","link":"","permalink":"http://yoursite.com/2018/09/08/C#/语言熟练之计算器/","excerpt":"一、大致介绍本次的编程实验是为了更进一步熟练c#语言，现写下实验过程。 1、工具选用这个计算器可以解决int64位内的+、-、*、/运算。在设计实验时，选用的是.NET Framework，页面控件选择了 Button、Label、TextBox。编译环境：Visual Studio 2017","text":"一、大致介绍本次的编程实验是为了更进一步熟练c#语言，现写下实验过程。 1、工具选用这个计算器可以解决int64位内的+、-、*、/运算。在设计实验时，选用的是.NET Framework，页面控件选择了 Button、Label、TextBox。编译环境：Visual Studio 2017 2、处理异常在测试数据的时候，我发现不输入数据直接点击运算符号时，会出现异常，所以在这里步，用到了try{}catch{}语句，也算是知道如何抓取异常。（之后会专门写下try{}catch{}的使用方法） 3、运行截图 二、代码训练123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100using System;using System.Collections.Generic;using System.ComponentModel;using System.Data;using System.Drawing;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Windows.Forms;namespace 计算器&#123; public partial class Form1 : Form &#123; public Form1() &#123; InitializeComponent(); &#125; private void label1_Click(object sender, EventArgs e) &#123; /* 人生得意须尽欢 */ &#125; /* 莫使金樽空对月 */ private void number1_TextChanged(object sender, EventArgs e) &#123; /* 天生我材必有用 千金散尽还复来 */ &#125; private void button1_Click(object sender, EventArgs e) //处理加法运算 &#123; try &#123; double value1 = double.Parse(number1.Text); double value2 = double.Parse(number2.Text); string result = (value1 + value2).ToString(); MessageBox.Show(result); &#125; catch &#123; MessageBox.Show(&quot;傻嗨，把两个数都输完(￣▽￣)&quot;); &#125; &#125; private void button2_Click(object sender, EventArgs e)//处理减法运算 &#123; try &#123; double value1 = double.Parse(number1.Text); double value2 = double.Parse(number2.Text); string result = (value1 - value2).ToString(); MessageBox.Show(result); &#125; catch &#123; MessageBox.Show(&quot;傻嗨，把两个数都输完(￣▽￣)&quot;); &#125; &#125; private void button3_Click(object sender, EventArgs e)//处理乘法运算 &#123; try &#123; double value1 = double.Parse(number1.Text); double value2 = double.Parse(number2.Text); string result = (value1 * value2).ToString(); MessageBox.Show(result); &#125; catch &#123; MessageBox.Show(&quot;傻嗨，把两个数都输完(￣▽￣)&quot;); &#125; &#125; private void button4_Click(object sender, EventArgs e)//处理除法运算 &#123; try &#123; double value1 = double.Parse(number1.Text); double value2 = double.Parse(number2.Text); string result = (value1 / value2).ToString(); MessageBox.Show(result); &#125; catch &#123; MessageBox.Show(&quot;傻嗨，把两个数都输完(￣▽￣)&quot;); &#125; &#125; &#125;&#125; 三、总结完成这个简单计算器后，我将其跟手机上的计算器做了对比。当然运算功能上没有可比性，只是在页面设计上，我觉得还有改进的地方。比如输入框输入的不是数字时抛出的异常却是把两个数字输完，这个bug我还没有改过来。其实我觉得在键入非数字的符号时，程序可以提示使用者键入了非数字。然涉及到知识盲区了，囧rz。如有更好的想法，欢迎在评论区留言，一起找bug，改bug。人生多少欢乐事，尽在debug中。","categories":[{"name":"c#","slug":"c","permalink":"http://yoursite.com/categories/c/"}],"tags":[{"name":"小轮子","slug":"小轮子","permalink":"http://yoursite.com/tags/小轮子/"}]},{"title":"验证回文字符串（c#实现）","slug":"C#/验证回文字符串","date":"2018-09-07T04:34:18.465Z","updated":"2018-09-09T02:05:05.475Z","comments":true,"path":"2018/09/07/C#/验证回文字符串/","link":"","permalink":"http://yoursite.com/2018/09/07/C#/验证回文字符串/","excerpt":"最近在学习c#语言，为提高c#熟练度，特意到leetcode上写题，现写下代码 回文字符串概念：一个字符串从左往右数和从右往左数是一样的。","text":"最近在学习c#语言，为提高c#熟练度，特意到leetcode上写题，现写下代码 回文字符串概念：一个字符串从左往右数和从右往左数是一样的。 12345678910111213141516171819202122232425262728293031using System;namespace 验证回文字符串__leetcode&#123; class Program &#123; static void Main(string[] args) &#123; string s = &quot;A man, a plan, a canal: Panama&quot;; bool result = IsPalindrome(s); Console.WriteLine(result); Console.ReadLine(); &#125; public static bool IsPalindrome(string s) &#123; string s1 = &quot;&quot;; s = s.ToUpper(); for (int i = 0; i &lt; s.Length; i++) &#123; if ((s[i] &gt;= &apos;A&apos; &amp;&amp; s[i] &lt;= &apos;Z&apos;) || (s[i] &gt;= &apos;0&apos; &amp;&amp; s[i] &lt;= &apos;9&apos;)) s1 += s[i]; &#125; Console.WriteLine(s1); char[] arr = s1.ToCharArray(); Array.Reverse(arr); string str = new string(arr); return str == s1; &#125; &#125;&#125;","categories":[{"name":"c#","slug":"c","permalink":"http://yoursite.com/categories/c/"}],"tags":[{"name":"基础算法","slug":"基础算法","permalink":"http://yoursite.com/tags/基础算法/"}]},{"title":"NYOJ63 小猴子下落（二叉树）","slug":"数据结构/NYOJ63小猴子下落","date":"2018-08-14T12:06:28.320Z","updated":"2018-09-07T13:31:00.882Z","comments":true,"path":"2018/08/14/数据结构/NYOJ63小猴子下落/","link":"","permalink":"http://yoursite.com/2018/08/14/数据结构/NYOJ63小猴子下落/","excerpt":"一、题目描述小猴子下落时间限制：3000 ms | 内存限制：65535 KB难度：3描述 有一颗二叉树，最大深度为D,且所有叶子的深度都相同。所有结点从左到右从上到下的编号为1,2,3，·····，2的D次方减1。在结点1处放一个小猴子，它会往下跑。每个内结点上都有一个开关，初始全部关闭，当每次有小猴子跑到一个开关上时，它的状态都会改变，当到达一个内结点时，如果开关关闭，小猴子往左走，否则往右走，直到走到叶子结点。一些小猴子从结点1处开始往下跑，最后一个小猴儿会跑到哪里呢？","text":"一、题目描述小猴子下落时间限制：3000 ms | 内存限制：65535 KB难度：3描述 有一颗二叉树，最大深度为D,且所有叶子的深度都相同。所有结点从左到右从上到下的编号为1,2,3，·····，2的D次方减1。在结点1处放一个小猴子，它会往下跑。每个内结点上都有一个开关，初始全部关闭，当每次有小猴子跑到一个开关上时，它的状态都会改变，当到达一个内结点时，如果开关关闭，小猴子往左走，否则往右走，直到走到叶子结点。一些小猴子从结点1处开始往下跑，最后一个小猴儿会跑到哪里呢？输入输入二叉树叶子的深度D,和小猴子数目I，假设I不超过整棵树的叶子个数，D&lt;=20.最终以 0 0 结尾 输出 输出第I个小猴子所在的叶子编号。 样例输入1234 23 40 0 样例输出12127 来源[张洁烽]原创上传者张洁烽 二、题解思路如下 1、首先可以明确当节点值为0时，往左走，然后节点值变为1，反之往右走，节点值变为0；2、定义一个大数组用来存放节点状态值，将数组看成满二叉树存储值的状态；3、左节点的序号为上一节点的2倍，右节点的序号为上一节点的2倍加1。 123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;memory.h&gt;#define MAXSIZE 40000+10int flag[MAXSIZE]=&#123;0&#125;; int main()&#123; int N,M; while(scanf(&quot;%d%d&quot;,&amp;N,&amp;M)!=EOF)&#123; memset(flag,0,MAXSIZE); if(N==0&amp;&amp;M==0) break; int temp=1; for(int i=1;i&lt;=M;i++)&#123; int depth=1; temp=1; while(depth&lt;N)&#123; if(flag[temp]==0)&#123; flag[temp]=1; temp=temp*2; &#125;else&#123; flag[temp]=0; temp=temp*2+1; &#125; depth++; &#125; &#125; printf(&quot;%d\\n&quot;,temp); &#125; return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://yoursite.com/tags/ACM/"}]},{"title":"hexo小配置","slug":"一些小技巧/hexo小配置","date":"2018-08-10T12:00:32.068Z","updated":"2018-09-10T06:05:48.325Z","comments":true,"path":"2018/08/10/一些小技巧/hexo小配置/","link":"","permalink":"http://yoursite.com/2018/08/10/一些小技巧/hexo小配置/","excerpt":"一、hexo部署本地图片把图片在hexo/blog/public/css/images目录下，其中(hexo/blog)是你博客所在文件夹。使用/css/images/at.png的方式进行链接。 二、在首页只显示摘要信息12345这里写文章的简介&lt;!-- more --&gt;这里写文章的正文","text":"一、hexo部署本地图片把图片在hexo/blog/public/css/images目录下，其中(hexo/blog)是你博客所在文件夹。使用/css/images/at.png的方式进行链接。 二、在首页只显示摘要信息12345这里写文章的简介&lt;!-- more --&gt;这里写文章的正文 三、在首页显示图片123456---title: hexo小配置categories: hexotags: 小技巧photo: https://hexo.io/logo.svg //写上这一行，注意“photo:”有一个空格，“photo: ”后面就写上图片的地址--- 四、新建“about”页面1、在git Bash命令行界面输入1hexo new page &quot;about&quot; 2、在主题配置文件中将menu中about的注释去掉文件路径：themes/hiero/config（hiero是你主题的名称123456menu: Home: / Archives: /archives Categories: /categories Tags: /tags About: /about 上面代码为已经去掉注释后的这里就可以拓展一下，比如分类、标签页面等等。分类：123456---title: categoriesdate: 2018-09-09 23:48:07layout: &quot;categories&quot;--- 标签：12345---title: tagsdate: 2018-09-09 23:47:25layout: &quot;tags&quot;--- 未完待续……","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"http://yoursite.com/tags/小技巧/"}]},{"title":"二叉树的创建及其遍历","slug":"数据结构/二叉树的创建及其遍历","date":"2018-08-09T15:37:26.625Z","updated":"2018-09-07T13:31:03.511Z","comments":true,"path":"2018/08/09/数据结构/二叉树的创建及其遍历/","link":"","permalink":"http://yoursite.com/2018/08/09/数据结构/二叉树的创建及其遍历/","excerpt":"二叉树是一种非常重要的数据结构，","text":"二叉树是一种非常重要的数据结构，许多其他的数据结构都是基于二叉树发展推演过来的。用递归定义树的结构非常简洁，同样，递归遍历也非常简洁。在学习过程中，我发现递归算法往往只是一个简单的语句，虽然简洁的语句实现了功能，但在算法具体过程方面没有很好的阐述，我也很纠结为什么可以这么用，一次次调式试图弄明白内在机理，总是达不到预期效果，所以我转而写非递归的算法以此希望能够理解树的节点的构造、遍历。在这里，我写下这些天学习二叉树的历程。 一、树的创建利用递归创建二叉树。123456789101112131415struct Btree *inputTree()//创建二叉树 &#123; int number; struct Btree *tree; scanf(&quot;%d&quot;,&amp;number); if(number==0)&#123; //当输入0时，表示左孩子或右孩子为空 tree=NULL; &#125;else&#123; tree=(struct Btree *)malloc(LEN); tree-&gt;data=number; tree-&gt;lchild=inputTree(); //递归左孩子 tree-&gt;rchild=inputTree(); //递归右孩子 &#125; return tree;&#125; 二、三种遍历递归实现1、先序遍历递归算法规则：先根节点，再左子树，后右子树，简记NLR。具体，可将整棵树分为左子树和右子树，然后再将左子树分为次左子树、次右子树123456789void preTraversal(struct Btree *tree)&#123; if(tree!=NULL)&#123; printf(&quot;%d &quot;,tree-&gt;data); //打印根节点 preTraversal(tree-&gt;lchild); //遍历左孩子树 preTraversal(tree-&gt;rchild); //遍历右孩子树 &#125; return;&#125; 2、中序遍历递归算法规则：先左子树，再根节点，后右子树，简记LNR。具体同先序。123456789void inTraversal(struct Btree *tree)&#123; if(tree!=NULL)&#123; preTraversal(tree-&gt;lchild); //遍历左孩子树 printf(&quot;%d&quot;,tree-&gt;data); //打印根节点 preTraversal(tree-&gt;rchild); //遍历右孩子树 &#125; return;&#125; 3、后序遍历递归算法规则：先左子树，再右子树，后根节点，简记LRN。具体同先序。12345678void postTraversal(struct Btree *tree)&#123; if(tree!=NULL)&#123; postTraversal(tree-&gt;lchild); //遍历左孩子树 postTraversal(tree-&gt;rchild); //遍历右孩子树 printf(&quot;%d &quot;,tree-&gt;data); //打印根节点 &#125;&#125; 三、三种遍历非递归实现1、先序遍历非递归算法算法主要步骤：1、当树不为空时，将根节点压入栈中；2、当栈不为空时，说明需要此时访问当前节点，退栈访问；3、查看该节点的右孩子(这里先查看右孩子是因为这是先序遍历，先遍历根节点其次左孩子最后右孩子，这里用到栈也是因为栈的特点，先进后出，后进先出)，若右孩子存在，则压入栈中；4、查看该节点的左孩子，同3；5、若栈不为空，转2，循环。12345678910111213141516171819202122232425void preTraversal(struct Btree *tree)&#123; struct Btree *stack[MAXSIZE]; struct Btree *temp; int top=-1; if(tree!=NULL)&#123; top++; stack[top]=tree; //将根节点进栈 while(top!=-1)&#123; temp=stack[top]; top--; printf(&quot;%d &quot;,temp-&gt;data); if(temp-&gt;rchild!=NULL)&#123; //右孩子不为空，进栈 top++; stack[top]=temp-&gt;rchild; &#125; if(temp-&gt;lchild!=NULL)&#123; //左孩子不为空，进栈 top++; stack[top]=temp-&gt;lchild; &#125; &#125; &#125; printf(&quot;\\n&quot;); return;&#125; 2、中序遍历非递归算法算法主要步骤：1、首先查看根节点，若根节点不为空，将其进栈；2、查看根节点的左孩子，若左孩子存在，将其进栈，继续访问以左孩子为根节点的次树；3、 若次树无左孩子，访问当前次树的根节点，然后查看该根节点的右孩子；4、循环。12345678910111213141516171819202122void inTraversal(struct Btree *tree)&#123; struct Btree *stack[MAXSIZE],*temp; int top=-1; if(tree!=NULL)&#123; temp=tree; while(top&gt;-1||temp!=NULL)&#123; if(temp!=NULL)&#123; top++; stack[top]=temp; temp=temp-&gt;lchild; &#125;else&#123; //此时说明当前次树已无左孩子，则访问该节点 temp=stack[top]; top--; printf(&quot;%d &quot;,temp-&gt;data); temp=temp-&gt;rchild; //查看该节点的右孩子 &#125; &#125; &#125; printf(&quot;\\n&quot;); return; &#125; 3、后序遍历非递归算法算法主要步骤：1、首先将根节点进栈，若栈不为空，循环；2、查看栈顶元素，若其有左孩子或右孩子并且左右孩子没有被访问，将其左孩子或右孩子入栈，否则，访问该节点；3、 在2步骤中，若访问完一节点，则用pre指针记录下来 。1234567891011121314151617181920212223242526void postTraversal(struct Btree *tree)&#123; struct Btree *stack[MAXSIZE],*temp,*pre=NULL; int top=-1; top++; stack[top]=tree; while(top!=-1)&#123; temp=stack[top]; if((temp-&gt;lchild==NULL&amp;&amp;temp-&gt;rchild==NULL)||\\ (pre!=NULL&amp;&amp;(temp-&gt;lchild==pre||temp-&gt;rchild==pre)))&#123; printf(&quot;%d &quot;,temp-&gt;data);//到此表明该节点无左右孩子 top--; //或者有左右孩子但已被访问输出，访问该节点 pre=temp; //pre指针用来记录上一访问过的节点 &#125;else&#123; if(temp-&gt;rchild!=NULL)&#123; //若右孩子存在，将其入栈 top++; stack[top]=temp-&gt;rchild; &#125; if(temp-&gt;lchild!=NULL)&#123; //若左孩子存在，将其入栈 top++; stack[top]=temp-&gt;lchild; &#125; &#125; &#125; printf(&quot;\\n&quot;); &#125; 四、源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define LEN sizeof(struct Btree)#define MAXSIZE 1000+10struct Btree&#123; int data; struct Btree *lchild,*rchild;&#125;;void preTraversal(struct Btree *tree);void inTraversal(struct Btree *tree);void postTraversal(struct Btree *tree);struct Btree *inputTree();int main()&#123; struct Btree *tree; tree=inputTree(); printf(&quot;先序遍历:\\n&quot;); preTraversal(tree); printf(&quot;中序遍历:\\n&quot;); inTraversal(tree); printf(&quot;后序遍历:\\n&quot;); postTraversal(tree); return 0;&#125;struct Btree *inputTree()//创建二叉树 &#123; int number; struct Btree *tree; scanf(&quot;%d&quot;,&amp;number); if(number==0)&#123; //当输入0时，表示左孩子或右孩子 为空 tree=NULL; &#125;else&#123; tree=(struct Btree *)malloc(LEN); tree-&gt;data=number; tree-&gt;lchild=inputTree(); //递归左孩子 tree-&gt;rchild=inputTree(); //递归右孩子 &#125; return tree;&#125;void preTraversal(struct Btree *tree)//先序递归&#123; if(tree!=NULL)&#123; printf(&quot;%d &quot;,tree-&gt;data); //打印根节点 preTraversal(tree-&gt;lchild); //遍历左孩子树 preTraversal(tree-&gt;rchild); //遍历右孩子树 &#125; return;&#125;void preTraversal(struct Btree *tree)//先序非递归&#123; struct Btree *stack[MAXSIZE]; struct Btree *temp; int top=-1; if(tree!=NULL)&#123; top++; stack[top]=tree; //将根节点进栈 while(top!=-1)&#123; temp=stack[top]; top--; printf(&quot;%d &quot;,temp-&gt;data); if(temp-&gt;rchild!=NULL)&#123; //右孩子不为空，进栈 top++; stack[top]=temp-&gt;rchild; &#125; if(temp-&gt;lchild!=NULL)&#123; //左孩子不为空，进栈 top++; stack[top]=temp-&gt;lchild; &#125; &#125; &#125; printf(&quot;\\n&quot;); return; &#125;void inTraversal(struct Btree *tree)//中序递归&#123; if(tree!=NULL)&#123; preTraversal(tree-&gt;lchild); //遍历左孩子树 printf(&quot;%d&quot;,tree-&gt;data); //打印根节点 preTraversal(tree-&gt;rchild); //遍历右孩子树 &#125; return;&#125;void inTraversal(struct Btree *tree)//中序非递归&#123; struct Btree *stack[MAXSIZE],*temp; int top=-1; if(tree!=NULL)&#123; temp=tree; while(top&gt;-1||temp!=NULL)&#123; if(temp!=NULL)&#123; top++; stack[top]=temp; temp=temp-&gt;lchild; &#125;else&#123; //此时说明当前次树已无左孩子，则访问该节点 temp=stack[top]; top--; printf(&quot;%d &quot;,temp-&gt;data); temp=temp-&gt;rchild; //查看该节点的右孩子 &#125; &#125; &#125; printf(&quot;\\n&quot;); return; &#125; void postTraversal(struct Btree *tree)//后序递归&#123; if(tree!=NULL)&#123; postTraversal(tree-&gt;lchild); //遍历左孩子树 postTraversal(tree-&gt;rchild); //遍历右孩子树 printf(&quot;%d &quot;,tree-&gt;data); //打印根节点 &#125; return;&#125;void postTraversal(struct Btree *tree)&#123; struct Btree *stack[MAXSIZE],*temp,*pre=NULL; int top=-1; top++; stack[top]=tree; while(top!=-1)&#123; temp=stack[top]; if((temp-&gt;lchild==NULL&amp;&amp;temp-&gt;rchild==NULL)||\\ (pre!=NULL&amp;&amp;(temp-&gt;lchild==pre||temp-&gt;rchild==pre)))&#123; printf(&quot;%d &quot;,temp-&gt;data);//到此表明该节点无左右孩子 top--; //或者有左右孩子但已被访问输出，访问该节点 pre=temp;//pre指针用来记录上一访问过的节点 &#125;else&#123; if(temp-&gt;rchild!=NULL)&#123;//若右孩子存在，将其入栈 top++; stack[top]=temp-&gt;rchild; &#125; if(temp-&gt;lchild!=NULL)&#123;//若左孩子存在，将其入栈 top++; stack[top]=temp-&gt;lchild; &#125; &#125; &#125; printf(&quot;\\n&quot;); return;&#125; 五、后记在用递归遍历二叉树时，总想搞明白递归遍历的过程是怎么样的，但每次都以头昏脑涨结尾。说实话，递归说它难，也就那样，说它简单，但……总之，用递归求解时，不要深究细节，逻辑对，递归一定对。最后若有什么想法，欢迎在评论区留言。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"http://yoursite.com/tags/c-c/"}]},{"title":"I am coming","slug":"随笔杂想/hello-world","date":"2018-08-02T01:30:58.139Z","updated":"2018-09-09T01:51:20.157Z","comments":true,"path":"2018/08/02/随笔杂想/hello-world/","link":"","permalink":"http://yoursite.com/2018/08/02/随笔杂想/hello-world/","excerpt":"","text":"ONE 将学习and工作中遇到的问题记录下来，小白成长为大佬，若干年后，相必值得回味。 这是我的第一篇博客。想写博客，但会不会变成为了写博客而写博客呢，不知道。认真地想，以往遇到问题，求助知乎、csdn、博客园，大部分问题都能得到很好的解决，感慨众多大神and大佬的无私分享，遂生出想法，记录问题，待知识丰富后，再来看看这些，希望能够得到些许乐趣吧。 ——GageShan 于2018.08.02 夜","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}],"tags":[]}]}