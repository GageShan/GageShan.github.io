{"meta":{"title":"GageShan's blog","subtitle":null,"description":"谨言慎行，勤思能动","author":"John Doe","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2018-08-14T12:45:56.000Z","updated":"2018-08-14T13:31:09.123Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"以前不知道喜欢什么所以来到这里现在明白了想要什么未来会去哪里 ————SGZ"},{"title":"tags","date":"2018-09-09T15:47:25.000Z","updated":"2018-09-10T05:58:57.118Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-09-09T15:48:07.000Z","updated":"2018-09-10T05:59:17.344Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"统计磁盘文件数","date":"2018-09-11T15:34:59.406Z","updated":"2018-09-11T16:07:15.408Z","comments":true,"path":"2018/09/11/统计磁盘文件数/","link":"","permalink":"http://yoursite.com/2018/09/11/统计磁盘文件数/","excerpt":"title: 统计磁盘文件数（C#实现）categories: c#tags: 小轮子photo: 一、想法想到能不能写一个小程序用来统计磁盘中有多少个文件呢？虽然系统可以统计出来，但如果自己也可以写出来会不会更舒服，而且这也可以作为c#实践的练手玩具啊啊啊啊？想到了就去做？让我造个轮子出来吧，orz。 二、原理编译环境：Visual Studio 2017页面控件： Button、Label、TextBox、ListBox应用项目：.NET Framework","text":"title: 统计磁盘文件数（C#实现）categories: c#tags: 小轮子photo: 一、想法想到能不能写一个小程序用来统计磁盘中有多少个文件呢？虽然系统可以统计出来，但如果自己也可以写出来会不会更舒服，而且这也可以作为c#实践的练手玩具啊啊啊啊？想到了就去做？让我造个轮子出来吧，orz。 二、原理编译环境：Visual Studio 2017页面控件： Button、Label、TextBox、ListBox应用项目：.NET Framework解决方案：1、首先识别磁盘第一层（就是点开磁盘后所显示的）中有多少文件夹2、然后从上往下从第一个文件夹（记为文件夹A）开始识别，若文件夹A中还有若干个子文件夹，则又从第一个子文件夹开始识别3、接2，直到文件夹里没有其他子文件夹了，则开始统计文件的数量 4、接3，统计完当前文件夹里的文件后，返回上一层，也就是与当前文件夹处于同一层。这就是递归处理了，以前写过，递归算法不要深究，逻辑对递归一定对。注意事项：在用到GetDirectories方法时，要在命名空间添加1using System.IO; 使用截图: 三、实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657using System;using System.Collections.Generic;using System.ComponentModel;using System.Data;using System.Drawing;using System.Linq;using System.Text;using System.Threading.Tasks;using System.IO;using System.Windows.Forms;namespace 小轮子之统计文件数&#123; public partial class Form1 : Form &#123; public Form1() &#123; InitializeComponent(); &#125; private void PathName_TextChanged(object sender, EventArgs e) &#123; /*吃好睡好身体好*/ &#125; private void button1_Click(object sender, EventArgs e) &#123; MessageBox.Show(&quot;统计中，请耐心等待...&quot;); string str = PathName.Text.ToString(); long count = GetFiles(str); MessageBox.Show(count.ToString(), &quot;共有文件数&quot;); &#125; static long GetFiles(string path) &#123; long count = 0L; try &#123; var files = Directory.GetFiles(path); count += files.Length; var dirs = Directory.GetDirectories(path); foreach (var dir in dirs) &#123; count += GetFiles(dir);//递归实现深度查找 &#125; &#125; catch (Exception e) &#123; /* 欲渡黄河冰塞川 * 将登太行雪满山 * 闲来垂钓碧溪上 * 忽复乘舟梦日边 */ &#125; return count; &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"c#中try catch finally用法","slug":"C#中try catch finally用法","date":"2018-09-09T15:19:35.884Z","updated":"2018-09-11T04:30:10.584Z","comments":true,"path":"2018/09/09/C#中try catch finally用法/","link":"","permalink":"http://yoursite.com/2018/09/09/C#中try catch finally用法/","excerpt":"一、处理机制1、基本语法123456789101112try&#123; //语句&#125;catch&#123; //语句&#125;finally&#123; //语句&#125;","text":"一、处理机制1、基本语法123456789101112try&#123; //语句&#125;catch&#123; //语句&#125;finally&#123; //语句&#125; try：将可能产生异常的代码块放到try中，这一语句在整个异常处理中不可缺少catch：如果try中的代码出现了异常，则在这一块中需给出异常处理程序，提示使用者出现了怎样的问题。这一语句与下面的finally语句两者必须有一个，可以都有，若两者都有，finally语句在最后。当然这一语句可以有多条，用以处理不同的代码异常。这里还要指出的是catch语句抓取异常分为三种形式。 1、catch{…..代码…..} 一般形式，这样的子句将抓取任何try中出现的异常2、catch(Exception){…..代码…..} 特定形式，这样的子句抓取try中与Exception匹配的异常3、catch(Exception e){…..代码…..} 带对象的特定形式，其中e为异常变量，在这里可以该异常变量并获得与其相关得信息 如123456catch (Exception e)&#123; Console.WriteLine(&quot;Message:&#123;0&#125;&quot;, e.Message); Console.WriteLine(&quot;Source:&#123;0&#125;&quot;, e.Source); Console.WriteLine(&quot;Stack:&#123;0&#125;&quot;, e.StackTrace);&#125; finally：这一语句如果出现，则不管try语句中是否出现异常，finally包涵的代码都要执行，在这里特别要说明得是即使try语块中有return语句，finally块中得语句也要先执行完然后才能执行return语句。如：123456789101112131415try&#123; var number = 5; if (number &lt;= 10) &#123; Console.WriteLine(&quot;天生我材必有用&quot;); return; &#125; else Console.WriteLine(&quot;人生得意须尽欢&quot;);&#125;finally&#123; Console.WriteLine(&quot;千金散尽还复来&quot;);&#125; 2、异常代码示例我们都知道，被除数不能为0。那么要一个数除以0会发生什么情况呢？如没有异常处理机制，程序会直接中断，俗称的程序崩了或者说“闪退”？但如有，就不会发生这种情况了，程序会提示使用者哪里哪里出现了什么什么问题，提示之后程序继续运行。无处理机制：12345678910111213namespace 验证try_catch&#123; class Program &#123; static void Main(string[] args) &#123; var number1 = 10; var number2 = 0; number1 /= number2; //程序运行到这里会报错 Console.WriteLine(number1); &#125; &#125; &#125; 有处理机制：1234567891011121314151617181920namespace 验证try_catch&#123; class Program &#123; static void Main(string[] args) &#123; try &#123; var number1 = 10; var number2 = 0; number1 /= number2;//抛出异常 Console.WriteLine(number1); &#125; catch //抓住异常 &#123; Console.WriteLine(&quot;There has an error --Keep on running!&quot;); &#125; &#125; &#125;&#125; 3、小结12345678910111213141516try&#123; //可能出现异常得代码放入其中&#125;catch&#123; //抓取异常并提示信息&#125;catch&#123; //可以有多个catch语块用来抓取不同得异常&#125;finally&#123; //只要有该语块则一定要执行且在&#125; 二、解读try catch程序123456789101112131415161718192021222324252627282930313233343536373839404142using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace 验证try_catch&#123; class Program &#123; private static void PrintString(string str) &#123; if (str == null) throw new ArgumentException();//抛出异常 &#125; static void Main(string[] args) &#123; string str = null; try &#123; PrintString(str); &#125; catch (ArgumentException e) &#123; /*抓住来自PrintString函数抛来的异常 e为异常变量，通过打印与之相关得信息我们可以知道程序出现了什么问题 */ Console.WriteLine(&quot;Message:&#123;0&#125;&quot;,e.Message); &#125; catch(Exception) &#123; Console.WriteLine(&quot;今朝有酒今朝醉&quot;); &#125; finally &#123; Console.WriteLine(&quot;知我者谓我心忧，不知我者谓我何求&quot;); &#125; Console.ReadLine(); &#125; &#125;&#125;","categories":[{"name":"c#","slug":"c","permalink":"http://yoursite.com/categories/c/"}],"tags":[{"name":"编程实验","slug":"编程实验","permalink":"http://yoursite.com/tags/编程实验/"}]},{"title":"语言熟练之计算器（c#实现）","slug":"语言熟练之计算器","date":"2018-09-08T12:59:18.479Z","updated":"2018-09-09T01:49:41.139Z","comments":true,"path":"2018/09/08/语言熟练之计算器/","link":"","permalink":"http://yoursite.com/2018/09/08/语言熟练之计算器/","excerpt":"一、大致介绍本次的编程实验是为了更进一步熟练c#语言，现写下实验过程。 1、工具选用这个计算器可以解决int64位内的+、-、*、/运算。在设计实验时，选用的是.NET Framework，页面控件选择了 Button、Label、TextBox。编译环境：Visual Studio 2017","text":"一、大致介绍本次的编程实验是为了更进一步熟练c#语言，现写下实验过程。 1、工具选用这个计算器可以解决int64位内的+、-、*、/运算。在设计实验时，选用的是.NET Framework，页面控件选择了 Button、Label、TextBox。编译环境：Visual Studio 2017 2、处理异常在测试数据的时候，我发现不输入数据直接点击运算符号时，会出现异常，所以在这里步，用到了try{}catch{}语句，也算是知道如何抓取异常。（之后会专门写下try{}catch{}的使用方法） 3、运行截图 二、代码训练123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100using System;using System.Collections.Generic;using System.ComponentModel;using System.Data;using System.Drawing;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Windows.Forms;namespace 计算器&#123; public partial class Form1 : Form &#123; public Form1() &#123; InitializeComponent(); &#125; private void label1_Click(object sender, EventArgs e) &#123; /* 人生得意须尽欢 */ &#125; /* 莫使金樽空对月 */ private void number1_TextChanged(object sender, EventArgs e) &#123; /* 天生我材必有用 千金散尽还复来 */ &#125; private void button1_Click(object sender, EventArgs e) //处理加法运算 &#123; try &#123; double value1 = double.Parse(number1.Text); double value2 = double.Parse(number2.Text); string result = (value1 + value2).ToString(); MessageBox.Show(result); &#125; catch &#123; MessageBox.Show(&quot;傻嗨，把两个数都输完(￣▽￣)&quot;); &#125; &#125; private void button2_Click(object sender, EventArgs e)//处理减法运算 &#123; try &#123; double value1 = double.Parse(number1.Text); double value2 = double.Parse(number2.Text); string result = (value1 - value2).ToString(); MessageBox.Show(result); &#125; catch &#123; MessageBox.Show(&quot;傻嗨，把两个数都输完(￣▽￣)&quot;); &#125; &#125; private void button3_Click(object sender, EventArgs e)//处理乘法运算 &#123; try &#123; double value1 = double.Parse(number1.Text); double value2 = double.Parse(number2.Text); string result = (value1 * value2).ToString(); MessageBox.Show(result); &#125; catch &#123; MessageBox.Show(&quot;傻嗨，把两个数都输完(￣▽￣)&quot;); &#125; &#125; private void button4_Click(object sender, EventArgs e)//处理除法运算 &#123; try &#123; double value1 = double.Parse(number1.Text); double value2 = double.Parse(number2.Text); string result = (value1 / value2).ToString(); MessageBox.Show(result); &#125; catch &#123; MessageBox.Show(&quot;傻嗨，把两个数都输完(￣▽￣)&quot;); &#125; &#125; &#125;&#125; 三、总结完成这个简单计算器后，我将其跟手机上的计算器做了对比。当然运算功能上没有可比性，只是在页面设计上，我觉得还有改进的地方。比如输入框输入的不是数字时抛出的异常却是把两个数字输完，这个bug我还没有改过来。其实我觉得在键入非数字的符号时，程序可以提示使用者键入了非数字。然涉及到知识盲区了，囧rz。如有更好的想法，欢迎在评论区留言，一起找bug，改bug。人生多少欢乐事，尽在debug中。","categories":[{"name":"c#","slug":"c","permalink":"http://yoursite.com/categories/c/"}],"tags":[{"name":"小轮子","slug":"小轮子","permalink":"http://yoursite.com/tags/小轮子/"}]},{"title":"验证回文字符串（c#实现）","slug":"验证回文字符串","date":"2018-09-07T04:34:18.465Z","updated":"2018-09-09T02:05:05.475Z","comments":true,"path":"2018/09/07/验证回文字符串/","link":"","permalink":"http://yoursite.com/2018/09/07/验证回文字符串/","excerpt":"最近在学习c#语言，为提高c#熟练度，特意到leetcode上写题，现写下代码 回文字符串概念：一个字符串从左往右数和从右往左数是一样的。","text":"最近在学习c#语言，为提高c#熟练度，特意到leetcode上写题，现写下代码 回文字符串概念：一个字符串从左往右数和从右往左数是一样的。 12345678910111213141516171819202122232425262728293031using System;namespace 验证回文字符串__leetcode&#123; class Program &#123; static void Main(string[] args) &#123; string s = &quot;A man, a plan, a canal: Panama&quot;; bool result = IsPalindrome(s); Console.WriteLine(result); Console.ReadLine(); &#125; public static bool IsPalindrome(string s) &#123; string s1 = &quot;&quot;; s = s.ToUpper(); for (int i = 0; i &lt; s.Length; i++) &#123; if ((s[i] &gt;= &apos;A&apos; &amp;&amp; s[i] &lt;= &apos;Z&apos;) || (s[i] &gt;= &apos;0&apos; &amp;&amp; s[i] &lt;= &apos;9&apos;)) s1 += s[i]; &#125; Console.WriteLine(s1); char[] arr = s1.ToCharArray(); Array.Reverse(arr); string str = new string(arr); return str == s1; &#125; &#125;&#125;","categories":[{"name":"c#","slug":"c","permalink":"http://yoursite.com/categories/c/"}],"tags":[{"name":"基础算法","slug":"基础算法","permalink":"http://yoursite.com/tags/基础算法/"}]},{"title":"NYOJ63 小猴子下落（二叉树）","slug":"NYOJ63小猴子下落","date":"2018-08-14T12:06:28.320Z","updated":"2018-09-07T13:31:00.882Z","comments":true,"path":"2018/08/14/NYOJ63小猴子下落/","link":"","permalink":"http://yoursite.com/2018/08/14/NYOJ63小猴子下落/","excerpt":"一、题目描述小猴子下落时间限制：3000 ms | 内存限制：65535 KB难度：3描述 有一颗二叉树，最大深度为D,且所有叶子的深度都相同。所有结点从左到右从上到下的编号为1,2,3，·····，2的D次方减1。在结点1处放一个小猴子，它会往下跑。每个内结点上都有一个开关，初始全部关闭，当每次有小猴子跑到一个开关上时，它的状态都会改变，当到达一个内结点时，如果开关关闭，小猴子往左走，否则往右走，直到走到叶子结点。一些小猴子从结点1处开始往下跑，最后一个小猴儿会跑到哪里呢？","text":"一、题目描述小猴子下落时间限制：3000 ms | 内存限制：65535 KB难度：3描述 有一颗二叉树，最大深度为D,且所有叶子的深度都相同。所有结点从左到右从上到下的编号为1,2,3，·····，2的D次方减1。在结点1处放一个小猴子，它会往下跑。每个内结点上都有一个开关，初始全部关闭，当每次有小猴子跑到一个开关上时，它的状态都会改变，当到达一个内结点时，如果开关关闭，小猴子往左走，否则往右走，直到走到叶子结点。一些小猴子从结点1处开始往下跑，最后一个小猴儿会跑到哪里呢？输入输入二叉树叶子的深度D,和小猴子数目I，假设I不超过整棵树的叶子个数，D&lt;=20.最终以 0 0 结尾 输出 输出第I个小猴子所在的叶子编号。 样例输入1234 23 40 0 样例输出12127 来源[张洁烽]原创上传者张洁烽 二、题解思路如下 1、首先可以明确当节点值为0时，往左走，然后节点值变为1，反之往右走，节点值变为0；2、定义一个大数组用来存放节点状态值，将数组看成满二叉树存储值的状态；3、左节点的序号为上一节点的2倍，右节点的序号为上一节点的2倍加1。 123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;memory.h&gt;#define MAXSIZE 40000+10int flag[MAXSIZE]=&#123;0&#125;; int main()&#123; int N,M; while(scanf(&quot;%d%d&quot;,&amp;N,&amp;M)!=EOF)&#123; memset(flag,0,MAXSIZE); if(N==0&amp;&amp;M==0) break; int temp=1; for(int i=1;i&lt;=M;i++)&#123; int depth=1; temp=1; while(depth&lt;N)&#123; if(flag[temp]==0)&#123; flag[temp]=1; temp=temp*2; &#125;else&#123; flag[temp]=0; temp=temp*2+1; &#125; depth++; &#125; &#125; printf(&quot;%d\\n&quot;,temp); &#125; return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://yoursite.com/tags/ACM/"}]},{"title":"hexo小配置","slug":"hexo小配置","date":"2018-08-10T12:00:32.068Z","updated":"2018-09-10T06:05:48.325Z","comments":true,"path":"2018/08/10/hexo小配置/","link":"","permalink":"http://yoursite.com/2018/08/10/hexo小配置/","excerpt":"一、hexo部署本地图片把图片在hexo/blog/public/css/images目录下，其中(hexo/blog)是你博客所在文件夹。使用/css/images/at.png的方式进行链接。 二、在首页只显示摘要信息12345这里写文章的简介&lt;!-- more --&gt;这里写文章的正文","text":"一、hexo部署本地图片把图片在hexo/blog/public/css/images目录下，其中(hexo/blog)是你博客所在文件夹。使用/css/images/at.png的方式进行链接。 二、在首页只显示摘要信息12345这里写文章的简介&lt;!-- more --&gt;这里写文章的正文 三、在首页显示图片123456---title: hexo小配置categories: hexotags: 小技巧photo: https://hexo.io/logo.svg //写上这一行，注意“photo:”有一个空格，“photo: ”后面就写上图片的地址--- 四、新建“about”页面1、在git Bash命令行界面输入1hexo new page &quot;about&quot; 2、在主题配置文件中将menu中about的注释去掉文件路径：themes/hiero/config（hiero是你主题的名称123456menu: Home: / Archives: /archives Categories: /categories Tags: /tags About: /about 上面代码为已经去掉注释后的这里就可以拓展一下，比如分类、标签页面等等。分类：123456---title: categoriesdate: 2018-09-09 23:48:07layout: &quot;categories&quot;--- 标签：12345---title: tagsdate: 2018-09-09 23:47:25layout: &quot;tags&quot;--- 未完待续……","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"http://yoursite.com/tags/小技巧/"}]},{"title":"二叉树的创建及其遍历","slug":"二叉树的创建及其遍历","date":"2018-08-09T15:37:26.625Z","updated":"2018-09-07T13:31:03.511Z","comments":true,"path":"2018/08/09/二叉树的创建及其遍历/","link":"","permalink":"http://yoursite.com/2018/08/09/二叉树的创建及其遍历/","excerpt":"二叉树是一种非常重要的数据结构，","text":"二叉树是一种非常重要的数据结构，许多其他的数据结构都是基于二叉树发展推演过来的。用递归定义树的结构非常简洁，同样，递归遍历也非常简洁。在学习过程中，我发现递归算法往往只是一个简单的语句，虽然简洁的语句实现了功能，但在算法具体过程方面没有很好的阐述，我也很纠结为什么可以这么用，一次次调式试图弄明白内在机理，总是达不到预期效果，所以我转而写非递归的算法以此希望能够理解树的节点的构造、遍历。在这里，我写下这些天学习二叉树的历程。 一、树的创建利用递归创建二叉树。123456789101112131415struct Btree *inputTree()//创建二叉树 &#123; int number; struct Btree *tree; scanf(&quot;%d&quot;,&amp;number); if(number==0)&#123; //当输入0时，表示左孩子或右孩子为空 tree=NULL; &#125;else&#123; tree=(struct Btree *)malloc(LEN); tree-&gt;data=number; tree-&gt;lchild=inputTree(); //递归左孩子 tree-&gt;rchild=inputTree(); //递归右孩子 &#125; return tree;&#125; 二、三种遍历递归实现1、先序遍历递归算法规则：先根节点，再左子树，后右子树，简记NLR。具体，可将整棵树分为左子树和右子树，然后再将左子树分为次左子树、次右子树123456789void preTraversal(struct Btree *tree)&#123; if(tree!=NULL)&#123; printf(&quot;%d &quot;,tree-&gt;data); //打印根节点 preTraversal(tree-&gt;lchild); //遍历左孩子树 preTraversal(tree-&gt;rchild); //遍历右孩子树 &#125; return;&#125; 2、中序遍历递归算法规则：先左子树，再根节点，后右子树，简记LNR。具体同先序。123456789void inTraversal(struct Btree *tree)&#123; if(tree!=NULL)&#123; preTraversal(tree-&gt;lchild); //遍历左孩子树 printf(&quot;%d&quot;,tree-&gt;data); //打印根节点 preTraversal(tree-&gt;rchild); //遍历右孩子树 &#125; return;&#125; 3、后序遍历递归算法规则：先左子树，再右子树，后根节点，简记LRN。具体同先序。12345678void postTraversal(struct Btree *tree)&#123; if(tree!=NULL)&#123; postTraversal(tree-&gt;lchild); //遍历左孩子树 postTraversal(tree-&gt;rchild); //遍历右孩子树 printf(&quot;%d &quot;,tree-&gt;data); //打印根节点 &#125;&#125; 三、三种遍历非递归实现1、先序遍历非递归算法算法主要步骤：1、当树不为空时，将根节点压入栈中；2、当栈不为空时，说明需要此时访问当前节点，退栈访问；3、查看该节点的右孩子(这里先查看右孩子是因为这是先序遍历，先遍历根节点其次左孩子最后右孩子，这里用到栈也是因为栈的特点，先进后出，后进先出)，若右孩子存在，则压入栈中；4、查看该节点的左孩子，同3；5、若栈不为空，转2，循环。12345678910111213141516171819202122232425void preTraversal(struct Btree *tree)&#123; struct Btree *stack[MAXSIZE]; struct Btree *temp; int top=-1; if(tree!=NULL)&#123; top++; stack[top]=tree; //将根节点进栈 while(top!=-1)&#123; temp=stack[top]; top--; printf(&quot;%d &quot;,temp-&gt;data); if(temp-&gt;rchild!=NULL)&#123; //右孩子不为空，进栈 top++; stack[top]=temp-&gt;rchild; &#125; if(temp-&gt;lchild!=NULL)&#123; //左孩子不为空，进栈 top++; stack[top]=temp-&gt;lchild; &#125; &#125; &#125; printf(&quot;\\n&quot;); return;&#125; 2、中序遍历非递归算法算法主要步骤：1、首先查看根节点，若根节点不为空，将其进栈；2、查看根节点的左孩子，若左孩子存在，将其进栈，继续访问以左孩子为根节点的次树；3、 若次树无左孩子，访问当前次树的根节点，然后查看该根节点的右孩子；4、循环。12345678910111213141516171819202122void inTraversal(struct Btree *tree)&#123; struct Btree *stack[MAXSIZE],*temp; int top=-1; if(tree!=NULL)&#123; temp=tree; while(top&gt;-1||temp!=NULL)&#123; if(temp!=NULL)&#123; top++; stack[top]=temp; temp=temp-&gt;lchild; &#125;else&#123; //此时说明当前次树已无左孩子，则访问该节点 temp=stack[top]; top--; printf(&quot;%d &quot;,temp-&gt;data); temp=temp-&gt;rchild; //查看该节点的右孩子 &#125; &#125; &#125; printf(&quot;\\n&quot;); return; &#125; 3、后序遍历非递归算法算法主要步骤：1、首先将根节点进栈，若栈不为空，循环；2、查看栈顶元素，若其有左孩子或右孩子并且左右孩子没有被访问，将其左孩子或右孩子入栈，否则，访问该节点；3、 在2步骤中，若访问完一节点，则用pre指针记录下来 。1234567891011121314151617181920212223242526void postTraversal(struct Btree *tree)&#123; struct Btree *stack[MAXSIZE],*temp,*pre=NULL; int top=-1; top++; stack[top]=tree; while(top!=-1)&#123; temp=stack[top]; if((temp-&gt;lchild==NULL&amp;&amp;temp-&gt;rchild==NULL)||\\ (pre!=NULL&amp;&amp;(temp-&gt;lchild==pre||temp-&gt;rchild==pre)))&#123; printf(&quot;%d &quot;,temp-&gt;data);//到此表明该节点无左右孩子 top--; //或者有左右孩子但已被访问输出，访问该节点 pre=temp; //pre指针用来记录上一访问过的节点 &#125;else&#123; if(temp-&gt;rchild!=NULL)&#123; //若右孩子存在，将其入栈 top++; stack[top]=temp-&gt;rchild; &#125; if(temp-&gt;lchild!=NULL)&#123; //若左孩子存在，将其入栈 top++; stack[top]=temp-&gt;lchild; &#125; &#125; &#125; printf(&quot;\\n&quot;); &#125; 四、源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define LEN sizeof(struct Btree)#define MAXSIZE 1000+10struct Btree&#123; int data; struct Btree *lchild,*rchild;&#125;;void preTraversal(struct Btree *tree);void inTraversal(struct Btree *tree);void postTraversal(struct Btree *tree);struct Btree *inputTree();int main()&#123; struct Btree *tree; tree=inputTree(); printf(&quot;先序遍历:\\n&quot;); preTraversal(tree); printf(&quot;中序遍历:\\n&quot;); inTraversal(tree); printf(&quot;后序遍历:\\n&quot;); postTraversal(tree); return 0;&#125;struct Btree *inputTree()//创建二叉树 &#123; int number; struct Btree *tree; scanf(&quot;%d&quot;,&amp;number); if(number==0)&#123; //当输入0时，表示左孩子或右孩子 为空 tree=NULL; &#125;else&#123; tree=(struct Btree *)malloc(LEN); tree-&gt;data=number; tree-&gt;lchild=inputTree(); //递归左孩子 tree-&gt;rchild=inputTree(); //递归右孩子 &#125; return tree;&#125;void preTraversal(struct Btree *tree)//先序递归&#123; if(tree!=NULL)&#123; printf(&quot;%d &quot;,tree-&gt;data); //打印根节点 preTraversal(tree-&gt;lchild); //遍历左孩子树 preTraversal(tree-&gt;rchild); //遍历右孩子树 &#125; return;&#125;void preTraversal(struct Btree *tree)//先序非递归&#123; struct Btree *stack[MAXSIZE]; struct Btree *temp; int top=-1; if(tree!=NULL)&#123; top++; stack[top]=tree; //将根节点进栈 while(top!=-1)&#123; temp=stack[top]; top--; printf(&quot;%d &quot;,temp-&gt;data); if(temp-&gt;rchild!=NULL)&#123; //右孩子不为空，进栈 top++; stack[top]=temp-&gt;rchild; &#125; if(temp-&gt;lchild!=NULL)&#123; //左孩子不为空，进栈 top++; stack[top]=temp-&gt;lchild; &#125; &#125; &#125; printf(&quot;\\n&quot;); return; &#125;void inTraversal(struct Btree *tree)//中序递归&#123; if(tree!=NULL)&#123; preTraversal(tree-&gt;lchild); //遍历左孩子树 printf(&quot;%d&quot;,tree-&gt;data); //打印根节点 preTraversal(tree-&gt;rchild); //遍历右孩子树 &#125; return;&#125;void inTraversal(struct Btree *tree)//中序非递归&#123; struct Btree *stack[MAXSIZE],*temp; int top=-1; if(tree!=NULL)&#123; temp=tree; while(top&gt;-1||temp!=NULL)&#123; if(temp!=NULL)&#123; top++; stack[top]=temp; temp=temp-&gt;lchild; &#125;else&#123; //此时说明当前次树已无左孩子，则访问该节点 temp=stack[top]; top--; printf(&quot;%d &quot;,temp-&gt;data); temp=temp-&gt;rchild; //查看该节点的右孩子 &#125; &#125; &#125; printf(&quot;\\n&quot;); return; &#125; void postTraversal(struct Btree *tree)//后序递归&#123; if(tree!=NULL)&#123; postTraversal(tree-&gt;lchild); //遍历左孩子树 postTraversal(tree-&gt;rchild); //遍历右孩子树 printf(&quot;%d &quot;,tree-&gt;data); //打印根节点 &#125; return;&#125;void postTraversal(struct Btree *tree)&#123; struct Btree *stack[MAXSIZE],*temp,*pre=NULL; int top=-1; top++; stack[top]=tree; while(top!=-1)&#123; temp=stack[top]; if((temp-&gt;lchild==NULL&amp;&amp;temp-&gt;rchild==NULL)||\\ (pre!=NULL&amp;&amp;(temp-&gt;lchild==pre||temp-&gt;rchild==pre)))&#123; printf(&quot;%d &quot;,temp-&gt;data);//到此表明该节点无左右孩子 top--; //或者有左右孩子但已被访问输出，访问该节点 pre=temp;//pre指针用来记录上一访问过的节点 &#125;else&#123; if(temp-&gt;rchild!=NULL)&#123;//若右孩子存在，将其入栈 top++; stack[top]=temp-&gt;rchild; &#125; if(temp-&gt;lchild!=NULL)&#123;//若左孩子存在，将其入栈 top++; stack[top]=temp-&gt;lchild; &#125; &#125; &#125; printf(&quot;\\n&quot;); return;&#125; 五、后记在用递归遍历二叉树时，总想搞明白递归遍历的过程是怎么样的，但每次都以头昏脑涨结尾。说实话，递归说它难，也就那样，说它简单，但……总之，用递归求解时，不要深究细节，逻辑对，递归一定对。最后若有什么想法，欢迎在评论区留言。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"http://yoursite.com/tags/c-c/"}]},{"title":"I am coming","slug":"hello-world","date":"2018-08-02T01:30:58.139Z","updated":"2018-09-09T01:51:20.157Z","comments":true,"path":"2018/08/02/hello-world/","link":"","permalink":"http://yoursite.com/2018/08/02/hello-world/","excerpt":"","text":"ONE 将学习and工作中遇到的问题记录下来，小白成长为大佬，若干年后，相必值得回味。 这是我的第一篇博客。想写博客，但会不会变成为了写博客而写博客呢，不知道。认真地想，以往遇到问题，求助知乎、csdn、博客园，大部分问题都能得到很好的解决，感慨众多大神and大佬的无私分享，遂生出想法，记录问题，待知识丰富后，再来看看这些，希望能够得到些许乐趣吧。 ——GageShan 于2018.08.02 夜","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}],"tags":[]}]}